
/* ********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2016 by Vctr Informatik GmbH.                                                  All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vctr Informatik GmbH.
 *                Vctr Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vctr Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -------------------------------------------------------------------------------------------------------------------
 *         File:  Dem.c
 *      Project:  MICROSAR Diagnostic Event Manager (Dem)
 *       Module:  -
 *    Generator:  -
 *
 *  Description:  Implementation file for the MICROSAR Dem
 *
 *********************************************************************************************************************/

/* ********************************************************************************************************************
 *  AUTHOR IDENTITY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Name                          Initials      Company
 *  -------------------------------------------------------------------------------------------------------------------
 *  Stefan Huebner                vishrs        Vctr Informatik GmbH
 *  Alexander Ditte               visade        Vctr Informatik GmbH
 *  Matthias Heil                 vismhe        Vctr Informatik GmbH
 *  Thomas Dedler                 visdth        Vctr Informatik GmbH
 *  Anna Bosch                    visanh        Vctr Informatik GmbH
 *  -------------------------------------------------------------------------------------------------------------------
 *  REVISION HISTORY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Version   Date        Author  Change Id     Description
 *  -------------------------------------------------------------------------------------------------------------------
 *  04.00.00  2012-06-29  vismhe  ESCAN00057159 AR4-82: DEM 4.x
 *                        visade  ESCAN00057159 AR4-82: DEM 4.x
 *  04.01.00  2012-09-07  vismhe  ESCAN00061254 VersionInfo API returns wrong version number
 *            2012-09-14  vismhe  ESCAN00061429 Autostart cycle has no effect
 *            2012-09-20  vismhe  ESCAN00061565 Wrong snapshot record number reported for 19 03
 *            2012-10-26  vismhe  ESCAN00062489 Compiler warning: Condition is always true
 *            2012-10-26  vismhe  ESCAN00062490 Compiler warning: Condition is always true
 *            2012-10-26  vismhe  ESCAN00062483 Unexpected ClearAllowed callback
 *  04.02.00  2012-11-05  vismhe  ESCAN00062646 Compiler warning: Function "Dem_Queue_CancelOperation" was declared but never referenced
 *            2012-11-05  vismhe  ESCAN00062647 Compiler warning: Variable "Dem_Mem_PrimaryInfo" was declared but never referenced
 *            2012-11-05  vismhe  ESCAN00062644 Compiler warning: Variable "lResult" was set but never used
 *            2012-11-06  vismhe  ESCAN00062645 Compiler warning: Variable "lOldEventStatus" was set but never used
 *            2012-11-06  visade  ESCAN00062771 Memory corruption after call of Dem_SetDTCFilter()
 *            2012-12-07  vismhe  ESCAN00061769 AR4-207: Support VCC Diagnostic specification and required Diagnostic RFCs
 *  04.03.00  2013-02-04  visdth  ESCAN00061747 OBDII Support: IUMPR handling added
 *            2013-03-05  vismhe  ESCAN00065600 DET error DEM_E_UNINIT in Dem_Mainfunction
 *            2013-03-08  visade  ESCAN00061747 AR4-55: DEM - OBDII Support
 *            2013-03-13  visdth  ESCAN00063590 OBD IUMPR Counting Misbehavior
 *            2013-03-13  visdth  ESCAN00065851 Support User Controlled Warning Indicator Request
 *            2013-03-13  visdth  ESCAN00065853 Support suppression of permanent DTC storage
 *            2013-03-13  visdth  ESCAN00065854 Support MIL Groups
 *            2013-03-13  vismhe  ESCAN00065867 Allow PendingDTC independent from event storage
 *            2013-03-13  vismhe  ESCAN00065868 Support different DTC aging protocols
 *  04.04.00  2013-04-02  visade  ESCAN00066314 Compiler warning: multiple dead assignments within Dem.c
 *            2013-04-03  vismhe  ESCAN00065209 AR4-375: Add Support of "Suppress DTC" in Dem
 *            2013-04-10  visdth  ESCAN00066201 Extension of Interface to read IUMPR data
 *            2013-04-26  vismhe  ESCAN00067007 Secondary Memory DTCs do not report Severity and FunctionalUnit information
 *  04.04.01  2013-05-15  visade  ESCAN00067368 Compiler error: OdometerAtClear is not a member of Dem_Cfg_AdminDataType_s
 *            2013-05-15  visade  ESCAN00067372 Compiler error: Dem_Cfg_ObdGetGlobalDenominator() not a modifiable lvalue
 *            2013-05-15  visade  ESCAN00067155 Missing type definitions if Dem is used without Rte
 *            2013-05-15  visade  ESCAN00067025 Include FiM.h only if IUMPR or FiM notification is enabled
 *            2013-05-22  vismhe  ESCAN00067180 Compiler warning: uninitialized local variable 'lDtcStatusNew' used
 *            2013-05-22  vismhe  ESCAN00067354 Compilation error: Undefined symbol
 *            2013-05-22  vismhe  ESCAN00067345 Compilation error: Undefined symbol
 *            2013-05-22  vismhe  ESCAN00067459 Compiler warning: dead assignment to "lReturnValue" eliminated
 *  04.05.00  2013-06-03  visade  ESCAN00067673 Change Permanent Activation Distance from absolute to relative distance calculation
 *            2013-06-10  visade  ESCAN00067618 Out-parameter not initialized in Dem_GetIUMPRGeneralData
 *            2013-06-19  visdth  ESCAN00068159 MIL Group trip counter not reset on ClearDTC
 *            2013-06-19  vismhe  ESCAN00067715 AR4-418: Support Event Combination Type 1
 *            2013-06-19  vismhe  ESCAN00068164 Immediately persist event status on ClearDTC
 *            2013-06-19  vismhe  ESCAN00068389 Extended use of Dem_GetSeverityOfDTC and Dem_GetFunctionalUnitOfDTC
 *            2013-06-27  vismhe  ESCAN00068390 OperationCycles not stopped during Shutdown
 *            2013-09-18  vismhe  ESCAN00070478 Unexpected value for EventStatusChanged and DTCStatusChanged callbacks
 *  04.05.01  2013-07-03  vismhe  ESCAN00068511 Compiler error: Dem.c: 'Dem_Cbk_InitMonitor' undefined
 *  04.05.02  2013-07-03  vismhe  ESCAN00068562 Mode 0x02 does not return data
 *            2013-07-04  vismhe  ESCAN00068508 IUMPR: Numerator is incremented without qualified test result
 *            2013-07-04  vismhe  ESCAN00068569 Suppression or UserControlled WIR has no effect
 *  04.05.03  2013-07-10  visade  ESCAN00068885 Provide OBD FreezeFrame in 0x1904 although Snapshots Records are disabled
 *            2013-07-18  visade  ESCAN00069154 Missing cast truncates OBD DTC number
 *            2013-07-22  vismhe  ESCAN00069132 Mixed internal and external data records are stored misaligned
 *            2013-07-22  vismhe  ESCAN00069237 Allow to override static / inline specific to Dem module
 *            2013-07-23  vismhe  ESCAN00069270 Too many increments of occurrence counter
 *            2013-07-23  vismhe  ESCAN00069271 DTC starts aging although it is still pending
 *            2013-07-23  visdth  ESCAN00068577 IUMPR Counters may be incremented more than once per DCY
 *  04.06.00  2013-07-24  visade  ESCAN00069311 Missing DID/PID validation check in Dem_GetEventFreezeFrameData()
 *            2013-07-24  visade  ESCAN00068636 AR4-419: Support Multiple OBD Freeze Frames
 *            2013-08-02  visade  ESCAN00069587 The code shall compile if NVM support is disabled and OBD support is enabled
 *            2013-08-06  visade  ESCAN00069626 OBD DTC Status does not qualify
 *            2013-08-07  visade  ESCAN00069423 OBD relevant data is not reset on configuration change
 *            2013-08-08  visade  ESCAN00069683 Erroneous indicator decrement during Mode 0x04
 *            2013-08-14  vismhe  ESCAN00069801 BSW error reporting after PreInit and before Init not possible
 *  05.00.00  2013-09-03  vismhe  ESCAN00068165 Compiler warning: Condition is always constant
 *            2013-09-03  vismhe  ESCAN00068395 AR4-292: Reporting of DET and DEM errors via DLT
 *            2013-09-03  vismhe  ESCAN00068416 AR4-420: Postbuild Loadable Support
 *            2013-09-03  vismhe  ESCAN00068465 AR4-371: Support signal interface
 *            2013-09-03  vismhe  ESCAN00068526 AR4-409: Support of OEM Volvo AB
 *            2013-09-03  vismhe  ESCAN00068530 AR4-542: Support of OEM Ford
 *            2013-09-03  vismhe  ESCAN00069882 Internal event is not cleared
 *            2013-09-03  vismhe  ESCAN00069989 Compiler warning: variable "lEntry" was set but never used
 *            2013-09-03  vismhe  ESCAN00069805 Add verification of EventKind to ReportErrorStatus and SetEventStatus
 *            2013-09-04  visdth  ESCAN00070048 OBD IUMPR: reading the same ratio several times is not possible
 *            2013-09-11  vismhe  ESCAN00070346 AgingCounter is reported with incorrect value
 *            2013-09-16  vismhe  ESCAN00069943 Delay WarmUpCycle until restart of Driving Cycle
 *            2013-09-16  vismhe  ESCAN00070219 Reset PID 0x21 if no OBD DTC requests the MIL for 40 warm-up cycles
 *            2013-09-19  vismhe  ESCAN00070500 Remove DET for consecutive qualified DCY reports
 *            2013-09-26  vismhe  ESCAN00070686 ConfirmedDTC is reset on initialization
 *            2013-10-02  vismhe  ESCAN00070834 Incorrect event displaced on overflow
 *            2013-11-27  vismhe  ESCAN00072203 Memory overwritten during initialization
 *  05.00.01  2013-11-13  vismhe  ESCAN00071873 DTCs do not age
 *            2013-11-14  vismhe  ESCAN00071948 Compiler warning: Definition different from declaration
 *  05.01.00  2013-10-17  visade  ESCAN00071182 Incorrect MIL group behavior after ClearAllDTCs
 *            2013-10-22  visade  ESCAN00071161 Change initialization of PID 0x31
 *            2013-10-22  visade  ESCAN00071162 Support ClearSingleDtc for OBD ECUs
 *            2013-10-25  visade  ESCAN00071244 Provide Dem internal EventId in Environmental Data
 *            2013-10-25  visade  ESCAN00071425 Provide OBD DTC in Environmental Data
 *            2013-10-30  visade  ESCAN00071346 Support application interface providing the permanent DTC activation state
 *            2013-11-20  vismhe  ESCAN00072084 Incorrect value for maximum FDC in current cycle
 *            2013-11-20  vismhe  ESCAN00071550 Incorrect status report handling for BSW errors
 *            2013-11-21  visade  ESCAN00072122 Stored UDS DTC does not have Confirmed and WarningIndicator bit set
 *            2013-11-28  vismhe  ESCAN00072310 Incorrect PID21 handling
 *  06.00.00  2014-02-04  visade  ESCAN00072994 Admin data is not persisted during shutdown if no Operation Cycle was started
 *            2014-02-04  vismhe  ESCAN00073575 Compile/Validation error: Incompatible prototypes
 *            2014-02-04  vismhe  ESCAN00073578 Rework NV MemoryAbstraction
 *            2014-02-04  vismhe  ESCAN00070873 AR4-402: Support of OEM Ford
 *            2014-02-04  visade  ESCAN00071380 AR4-465: Support for J1939 Diagnostics - API to DCM according AR 4.1.2
 *            2014-02-04  visade  ESCAN00071379 AR4-465: Support for J1939 Diagnostics
 *            2014-02-14  visade  ESCAN00073721 Driving cycle remains qualified after automatic end
 *            2014-02-18  vismhe  ESCAN00073792 Diagnostics locked when clearing DTCs
 *            2014-02-18  vismhe  ESCAN00079177 Compiler warning: Name Dem_DTCGroupType has already been declared
 *  06.01.00  2014-03-10  visdth  ESCAN00073613 Numerator is only incremented with fulfilled General Denominator conditions
 *            2014-03-12  vismhe  ESCAN00074193 NRC "conditions not correct" for services 19 04, 19 06
 *            2014-03-12  vismhe  ESCAN00074203 AR4-673: Diag_Asr4J1939Dcm + Diag_Asr4Dem shall work without Diag_Asr4Dcm
 *            2014-03-13  vismhe  ESCAN00074248 Compiler error: Missing type definition Dem_J1939DcmDiagnosticReadinessNType
 *            2014-03-12  visade  ESCAN00073876 Lock Numerator increment during active tester communication
 *            2014-03-13  visade  ESCAN00074253 Compile error if Aging is configured to start at passed
 *            2014-03-21  vismhe  ESCAN00074493 DTC does not re-enable after suppression
 *            2014-03-21  vismhe  ESCAN00074494 DTCs do not respect multiple trips
 *            2014-03-25  vismhe  ESCAN00074541 Hide Dependent OBD DTCs in UDS diagnostic services
 *            2014-03-25  vismhe  ESCAN00074410 Incorrect old DTC status in DtcStatusChangeCbk
 *            2014-03-26  vismhe  ESCAN00074566 Event does not debounce correctly
 *            2014-03-27  vismhe  ESCAN00074598 Significance value reported incorrectly in extended records
 *            2014-03-28  vismhe  ESCAN00074644 Time debounced events report wrong maximum debounce value
 *            2014-03-28  vismhe  ESCAN00074647 Occurrence Counter reported incorrectly
 *            2014-03-28  vismhe  ESCAN00073289 Add Operating Hours to Standardized Environmental Data
 *            2014-04-02  visade  ESCAN00074740 Possible out of bound access for variable Dem_Cfg_ObdIumprData.Status
 *            2014-04-02  vismhe  ESCAN00074743 Wrong result when reporting invalid event status
 *  06.02.00  2014-04-23  vismhe  ESCAN00074202 AR4-670: Support DTC Pre-storage
 *            2014-04-23  vismhe  ESCAN00075221 Support 16 Operation Cycles
 *            2014-04-23  vismhe  ESCAN00075100 Usage of OSEK OS symbol can cause errors during preprocessing
 *            2014-04-24  vismhe  ESCAN00075205 Provide API Dem_SetEventAvailable
 *            2014-04-24  vismhe  ESCAN00075207 Suppressed Events do not confirm
 *            2014-04-28  visade  ESCAN00073569 Do not track the ratio for suppressed DTCs/Events
 *            2014-05-05  vismhe  ESCAN00075368 Incorrect new DTC status reported in DTC status changed callback
 *            2014-05-07  visade  ESCAN00075400 PID 0x21 is not cleared if MIL is not triggered
 *            2014-05-08  visade  ESCAN00074965 Loop underrun in function Dem_EnablePermanentStorage()
 *            2014-06-04  vismhe  ESCAN00075786 Dem does not compile if PID 0x21 is not enabled
 *            2014-05-21  vismhe  ESCAN00075810 OBD Freeze Frame is not cleared correctly
 *            2014-06-04  vismhe  ESCAN00076016 Compile Error: Multiple errors for OBD DEM with feature OBD disabled
 *            2014-06-04  vismhe  ESCAN00076021 Compiler error: Undefined preprocessor identifier in Dem_Dcm.h
 *  07.00.00  2014-06-25  vismhe  ESCAN00076615 AR4-732: Application Trigger for NV Synchronization
 *            2014-06-25  vismhe  ESCAN00076615 AR4-732: Extend aging behavior to not require TFTOC==false
 *            2014-06-30  vismhe  ESCAN00076615 AR4-732: Added support for Clear DTC Limitation
 *            2014-07-02  vismhe  ESCAN00076615 AR4-732: Added support FDC trip / once per cycle
 *            2014-06-25  vismhe  ESCAN00076450 Compiler error: inline function's body is not declared previously
 *            2014-06-30  vismhe  ESCAN00077724 AR4-698: Move InitPointer to Dem_Init
 *            2014-07-02  visade  ESCAN00076529 AR4-607: Option to store the Fault Detection Counter in NVRAM
 *            2014-07-02  vismhe  ESCAN00076664 Improve DTC status recovery after power loss
 *            2014-07-02  visade  ESCAN00076667 Remove support of DEM_DTC_FORMAT_OBD from DTC suppression
 *            2014-07-10  vismhe  ESCAN00076878 Improve robustness against Shutdown
 *            2014-07-11  vismhe  ESCAN00076920 Wrong result when extended record is not stored
 *            2014-07-11  vismhe  ESCAN00076982 Implausible value for extended data records mapped to aging counter
 *            2014-07-23  visade  ESCAN00076612 AR4-741: Support multiple J1939 nodes in DEM and J1939DCM
 *            2014-08-07  vismhe  ESCAN00077685 Improve robustness of disable DTC record update
 *            2014-08-07  visade  ESCAN00077680 Do not report previously OBD relevant DTCs in Mode 0x0A
 *            2014-08-08  vismhe  ESCAN00077722 Compiler warning: 'EventId' : unreferenced formal parameter
 *            2014-08-12  vismhe  ESCAN00074759 Feature J1939 and EventCombination does not work together
 *            2014-08-25  vismhe  ESCAN00074190 Restore ConfirmedBit when StorageTrigger == Confirmed
 *            2014-08-25  vismhe  ESCAN00077999 Service 19 02 does not report all DTCs
 *            2014-09-12  vismhe  ESCAN00078381 Dem_GetIUMPRGeneralData returns an incorrect value for 'NumberOfRatios'
 *            2014-09-30  vismhe  ESCAN00078498 Recover external visible OBD Freeze Frame if event in memory is not OBD relevant by configuration (anymore)
 *            2014-10-01  visade  ESCAN00078639 Add NVRAM Recovery for Permanent Memesry
 *            2014-10-10  vismhe  ESCAN00078806 Wrong event displaced from event memory
 *            2014-10-13  vismhe  ESCAN00078902 Event availability not working with combined events
 *            2014-10-13  vismhe  ESCAN00068635 Compiler warning: expression always constant
 *            2014-10-13  vismhe  ESCAN00070124 Compiler warning: conditional expression is constant
 *            2014-10-13  vismhe  ESCAN00076527 AR4-572: Ford/Mazda Feature Complete - Ford in AR environment
 *            2014-10-13  vismhe  ESCAN00076605 AR4-669: Support for J1939 Diagnostics
 *            2014-10-13  vismhe  ESCAN00080571 Memory corruption when aging DTCs
 *            2015-01-14  vismhe  ESCAN00081016 Out of bound memory read access for Dem_Cfg_ObdIumprData.Status
 *  08.00.00  2014-11-24  vismhe  ESCAN00079766 Remove API Dem_GetNextIUMPRRatioData
 *            2014-11-24  vismhe  ESCAN00079776 Combined events not correctly unavailable in postbuild configuration
 *            2014-11-24  vismhe  ESCAN00079653 Change return value for API Dem_SetOperationCycleState()
 *            2014-11-24  visade  ESCAN00079787 Compiler warning: Dead assignment in function Dem_Data_PermanentEntryFind()
 *            2014-12-04  visade  ESCAN00079994 1-Trip DTC without the need for a qualified driving cycle
 *            2014-12-04  vismhe  ESCAN00079778 A Monitor Report is lost
 *            2014-12-05  vismhe  ESCAN00080187 FEAT-412 Support latching TestFailed of confirmed DTCs
 *            2014-12-11  vismhe  ESCAN00080187 FEAT-412 Support Freezing/Resetting the debouncing state by API
 *            2014-12-11  vismhe  ESCAN00080187 FEAT-412 Support init monitor notification when debouncing is reenabled
 *            2014-12-11  vismhe  ESCAN00080187 FEAT-412 Transport NvM error result to ClearDTC Api
 *            2014-12-17  visade  ESCAN00080224 Support of 3 Byte OBD DTC for DEM internal data element
 *            2015-01-12  vismhe  ESCAN00079539 FEAT-1200: Support of length information in Snapshot
 *            2015-01-12  vismhe  ESCAN00079539 FEAT-1200: Option to rest TF bit on operation cycle start
 *            2015-01-14  vismhe  ESCAN00080283 FEAT-427: Refactoring of large functions, rework function headers
 *            2015-01-21  visade  ESCAN00080705 Permanent DTC without permanent memory activation
 *            2015-01-21  visade  ESCAN00080718 Remove DCY wait state for permanent DTCs after CodeClear
 *            2015-01-21  visade  ESCAN00080178 Add DCY qualification as permanent DTC erase condition
 *            2015-01-28  vismhe  ESCAN00080898 Out of bounds memory read access
 *            2015-02-06  visade  ESCAN00081089 Improve NVRAM recovery for combined events in permanent memory
 *            2015-02-06  visade  ESCAN00081024 IUMPR - erroneous numerator increment
 *            2015-02-12  vismhe  ESCAN00081038 Event reports are not processed correctly before Dem_Init()
 *            2015-02-12  vismhe  ESCAN00081188 Keep auto-start cycles active after shutdown
 *            2015-02-15  vismhe  ESCAN00080245 FEAT-473: Support default initialization for event available state
 *            2015-02-18  vismhe  ESCAN00081328 Critical section is kept in lock state
 *            2015-02-20  vismhe  ESCAN00080555 Compiler warning: 'FreezeFrameIndex' : unreferenced formal parameter
 *            2015-02-23  visade  ESCAN00081400 Make active DTC immediately visible after permanent memory activation
 *            2015-02-25  visade  ESCAN00079859 FEAT-643: Support WWH OBD (Beta)
 *            2015-02-27  vismhe  ESCAN00081529 Blocking of ClearDTC while processing ClearSingleDTC
 *            2015-03-10  vismhe  ESCAN00081708 DTC aging starts too early
 *            2015-03-19  vismhe  ESCAN00079199 Compiler warning: 'FreezeFrameIndex' : unreferenced formal parameter
 *            2015-03-19  vismhe  ESCAN00079200 Compiler warning: 'SRecIndex' : unreferenced formal parameter
 *  09.00.00  2015-03-24  visade  ESCAN00082399 FEAT-1446: Make OBD II Freeze Frame optional in Service 0x1904
 *            2015-03-31  visade  ESCAN00082399 FEAT-1446: Optionally restart DCY on ClearAllDTCs
 *            2015-04-01  vismhe  ESCAN00082199 Compiler warning: Unitialized variable lReturnValue
 *            2015-04-08  visade  ESCAN00082399 FEAT-1446: Add option to displace Pending OBD Freeze Frame
 *            2015-04-09  vismhe  ESCAN00082289 Displacement of wrong DTC
 *            2015-04-09  vismhe  ESCAN00082319 Compiler error: Missing 'else' block
 *            2015-04-20  vismhe  ESCAN00082534 Compiler error or warning:  initializer type incompatible with object type
 *            2015-04-20  vismhe  ESCAN00082346 FEAT-56: Support data callbacks with EventId parameter
 *            2015-04-23  vismhe  ESCAN00082348 FEAT-285: Support healing for events without indicator
 *            2015-04-23  vismhe  ESCAN00082348 FEAT-285: Support debouncing while enable conditions are locked
 *            2015-05-05  visade  ESCAN00082811 Environmental data is missing for confirmed DTC
 *            2015-05-22  vismhe  ESCAN00082348 FEAT-285: Support entry retry
 *            2015-06-03  vismhe  ESCAN00082346 FEAT-56: Support data callbacks without NV storage
 *            2015-06-03  vismhe  ESCAN00082346 FEAT-56: Support JLR specific snapshot trigger
 *            2015-06-09  vismhe  ESCAN00082346 FEAT-56: Support aging at passed trigger for aging target == 0
 *            2015-06-26  vismhe  ESCAN00079889 Status change callback called without change of status
 *            2015-06-29  visade  ESCAN00083654 1-Trip DTC not available in Mode 0x0A
 *            2015-07-02  vismhe  ESCAN00083400 Compiler warning:  narrowing or signed-to-unsigned type conversion found
 *            2015-07-06  vismhe  ESCAN00083803 Combined events age without completed test
 *            2015-07-08  vismhe  ESCAN00082762 Compiler error: E0516: Zero sized structure 'DebounceInfo', E0823: Too long macro expansion 'VStdMemSet'
 *            2015-07-21  vismhe  ESCAN00084110 DID length is not included in snapshot record
 *            2015-07-21  visade  ESCAN00082355 FEAT-397: Support of WWH-OBD in Dcm and Dem [AR4-749] incl. Variant Handling for WWH-OBD use case
 *  10.00.00  2015-08-28  vismhe  ESCAN00084816 Compiler error: struct has no member SnapshotData
 *            2015-08-28  vismhe  ESCAN00084822 Compiler error: struct has no member MaxDebounceValue, missing symbols DEM_ESM_TEST/SET_FDC_MAX
 *            2015-08-28  vismhe  ESCAN00084823 Compiler error: undefined symbol Dem_Mem_SetOdometerMilOn
 *            2015-08-28  vismhe  ESCAN00084837 Compiler error: undefined symbol Dem_Cfg_GlobalSpecialIndicatorStates
 *            2015-08-28  vismhe  ESCAN00084839 Compiler error: undefined symbol Dem_Data_CollectDid
 *            2015-08-31  vismhe  ESCAN00084885 Compiler error: undefined symbol lEventId
 *            2015-09-02  vismhe  ESCAN00084948 Compiler error: syntax error in Dem_J1939Dcm_GetNextDTCwithLampStatus
 *            2015-09-03  vismhe  ESCAN00084954 Compiler error: undefined symbol 'Dem_Esm_TestEventHealed'
 *            2015-09-03  vismhe  ESCAN00084615 ClearDTC for secondary memory deletes wrong DTCs
 *            2015-09-10  vismhe  ESCAN00085138 DTCs not stored on FaultDetectionCounter Threshold
 *            2015-09-11  vismhe  ESCAN00085160 Compiler error: undefined symbol 'lNewEventStatus'
 *            2015-09-11  vismhe  ESCAN00085162 Compiler error: undefined symbol 'Dem_Queue_CalculatePid4E'
 *            2015-09-14  vismhe  ESCAN00084044 Indicator is reported active without requesting DTC
 *            2015-09-14  vismhe  ESCAN00085009 Support non-volatile availability setting
 *            2015-11-10  vismhe  ESCAN00085612 Out of bounds memory write access
 *            2015-11-10  vismhe  ESCAN00085604 Statistic values 'Failed Cycles counter', 'Consecutive Failed Cycles Counter' do not update correctly
 *            2015-11-10  vismhe  ESCAN00085552 Missing Data after DTC re-occurrence
 *            2015-11-20  vismhe  ESCAN00086554 Remove initailaziation check from API Dem_NvM_InitObdPermanentData
 *            2015-11-26  vismhe  ESCAN00086756 Code depends on undefined behavior
 *            2015-11-26  vismhe  ESCAN00086757 Dem calls FiM_DemTriggerOnEventStatus before initialization
 *            2015-11-26  vismhe  ESCAN00086808 Cycles since last failed not updated correctly
 *            2015-11-26  vismhe  ESCAN00086603 Compiler warning: variable "lOldStatus/lNewStatus" was set but never used
 *            2015-11-26  vismhe  ESCAN00086539 Compiler warning: variable 'lSRecId'/'lCfgSRecIndex' was set but never used
 *            2015-11-26  vismhe  ESCAN00086537 Compiler warning: variable 'lSRecId' was set but never used
 *            2015-11-26  visanh  ESCAN00085828 FEAT-1334: Support Time-series Snapshot Data Records
 *            2015-11-26  visanh  ESCAN00085143 FEAT-1527: SafeBSW Step 3
 *            2015-11-26  vismhe  ESCAN00085143 FEAT-1527: SafeBSW Step 3
 *            2015-11-30  vismhe  ESCAN00086885 Dcm cannot lock DTCs (unexpected NRC22)
 *            2015-12-14  vismhe  ESCAN00086336 Aging behavior for AgingTarget==0 is incorrect
 *            2015-12-14  vismhe  ESCAN00086887 Allow Dem_SetWIRStatus during ControlDTCSetting
 *  11.00.00  2016-01-14  vismhe  ESCAN00087477 Cannot report event status
 *            2016-01-14  vismhe  ESCAN00087481 Compiler error: Undefined symbol Dem_Esm_TestEventHealed
 *            2016-01-20  visanh  ESCAN00087429 Memory overwritten when using internal data elements in time series snapshot records
 *            2016-01-20  visanh  ESCAN00087534 Time Series Snapshot Records cannot be used without time based debouncing
 *            2016-02-03  vismhe  ESCAN00087637 FEAT-1472: Implement RoE for VAG
 *            2016-02-29  vismhe  ESCAN00088591 Permanent memory initialization pattern is overwritten
 *            2016-02-29  visanh  ESCAN00087794 FEAT-1688: SafeBSW Step 4
 *            2016-02-29  vismhe  ESCAN00087794 FEAT-1688: SafeBSW Step 4
 *            2016-03-07  vismhe  ESCAN00087325 Incorrect behavior for disablement of numerators and denominators after Clear DTC
 *            2016-03-11  vismhe  ESCAN00087868 FEAT-1605: Support DM5/27/53/54/55 in J1939Dcm
 *            2016-03-15  vismhe  ESCAN00088915 Fault data updated too often
 *            2016-03-23  vismhe  ESCAN00089043 Combined DTC incorrectly sets Pending and Confirmed bit
 *            2016-03-23  vismhe  ESCAN00089057 WarmUp cycle not restarted automatically
 *  11.01.00  2016-05-12  vismhe  ESCAN00087975 OCC7 incorrect after reoccurrence of an aged DTC
 *            2016-05-12  vismhe  ESCAN00089288 Incorrect Maximum FDC Since Last Clear
 *            2016-05-12  vismhe  ESCAN00089446 Monitor results are not processed
 *            2016-05-12  vismhe  ESCAN00089453 Compiler error: l-value specifies const object
 *            2016-05-12  vismhe  ESCAN00089619 Compiler warning: last line of file ends without a newline
 *            2016-07-08  vismhe  ESCAN00090874 Compiler warning: DEM_CFG_SUPPORT_NVM_POLLING undefined
 *            2016-07-08  vismhe  ESCAN00090369 Add support for DM35
 *            2016-07-08  visade  ESCAN00089767 Reset ratio status before call of init monitor function
 *            2016-07-08  visanh  ESCAN00089775 SI30.5 is not set as expected
 *            2016-07-08  vismhe  ESCAN00090431 DTC is not stored during memory overflow
 *            2016-07-08  vismhe  ESCAN00090622 Aging counter incremented without test result
 *            2016-07-08  vismhe  ESCAN00089386 FEAT-1734: SafeBSW Step 5
 *            2016-07-08  vismhe  ESCAN00089435 Incorrect J1939 lamp status in DM01
 *            2016-07-08  vismhe  ESCAN00091087 Wrong response reading WWH-OBD freeze frame
 *            2016-08-23  vismhe  ESCAN00091568 Support OperationCycle automatic end
 *            2016-08-24  vismhe  ESCAN00091611 Wrong negative response code for ControlDTCSetting
 *********************************************************************************************************************/
#define DEM_SOURCE

/* ********************************************************************************************************************
 *  GLOBAL MISRA VIOLATIONS
 *********************************************************************************************************************/

/* PRQA S 0828 EOF */ /* MD_MSR_1.1_828 */
/* PRQA S 0857 EOF */ /* MD_MSR_1.1_857 */

/* ********************************************************************************************************************
 *  INCLUDES
 *********************************************************************************************************************/

                                                       /* Dem module headers */
/* ------------------------------------------------------------------------- */

#include "Dem.h"
#include "Dem_Cbk.h"

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
# include "Dem_Dcm.h"
#endif

                            /* Development error tracer, for Det_ReportError */
/* ------------------------------------------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
# include "Det.h"
#endif
/* ------------------------------------------------------------------------- */

                   /* Diagnostic Logger and Tracer, for callback declaration */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_NOTIFY_DLT == STD_ON)
# include "Dlt.h"
#endif
/* ------------------------------------------------------------------------- */

      /* Fault inhibition manager, for callbacks and IUMPR inhibition matrix */
/* ------------------------------------------------------------------------- */
#if (((DEM_CFG_SUPPORT_OBDII == STD_ON) || (DEM_CFG_SUPPORT_WWHOBD == STD_ON)) \
   && (DEM_CFG_SUPPORT_IUMPR == STD_ON)) || (DEM_CFG_NOTIFY_FIM == STD_ON)                                                       /* COV_MSR_UNSUPPORTED TF xf xf xf tf */
# include "FiM.h"
#endif
/* ------------------------------------------------------------------------- */

                                  /* Schedule Manager, for critical sections */
/* ------------------------------------------------------------------------- */
#include "SchM_Dem.h"
/* ------------------------------------------------------------------------- */

                               /* Rte for forward global callback prototypes */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_USE_RTE == STD_ON)
# include "Rte_Dem.h"
#endif
/* ------------------------------------------------------------------------- */

                                            /* Dcm for notification callback */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_NOTIFY_DCM == STD_ON)
# include "Dcm.h"
#endif
/* ------------------------------------------------------------------------- */

                                       /* J1939Dcm for notification callback */
/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */

                                                          /* NvM for its API */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_USE_NVM == STD_ON)
# include "NvM.h"
#endif
/* ------------------------------------------------------------------------- */

                                                       /* EcuM for ErrorHook */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_VARIANT_POSTBUILD_LOADABLE == STD_ON)
# include "EcuM_Error.h"
#endif

                                      /* vstdlib for optimized copy routines */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_USE_MEMCOPY_MACROS != STD_ON)
# include "vstdlib.h"
#endif
/* ------------------------------------------------------------------------- */

                                                            /* subcomponents */
/* ------------------------------------------------------------------------- */
#include "Dem_Cfg_Declarations.h"

#include "Dem_Cfg_Definitions.h"

/* ********************************************************************************************************************
 *  VERSION CHECK
 *********************************************************************************************************************/

/* vendor specific version information is decimal coded */
#if ( (DEM_SW_MAJOR_VERSION != 11) \
   || (DEM_SW_MINOR_VERSION !=  1) \
   || (DEM_SW_PATCH_VERSION !=  0) )
# error "Vendor specific version numbers of Dem.c and Dem.h are inconsistent"
#endif

/* versions of all included configuration header files shall be checked */
#if ( (DEM_CFG_SW_MAJOR_VERSION != 11) \
   || (DEM_CFG_SW_MINOR_VERSION !=  1) )
# error "Version numbers of Dem.c and Dem_Cfg.h are inconsistent!"
#endif

#if (DEM_CFG_GEN_MAJOR_VERSION != 8)
# error "Incompatible configuration file version used!"
#endif

/* ********************************************************************************************************************
 *  LOCAL CONSTANT MACROS
 *********************************************************************************************************************/

#if !defined (__LINE__)
/*! substitute a number if the preprocessor does not support __LINE__ */
# define __LINE__                                0xffffu
#endif

/*!
 * \defgroup  Dem_Bitmask_Macros  Macros to define bitmask values by preprocessor
 * Macros to define bitmask values by preprocessor
 * \{
 */

/*! bitfield length of one byte width (8bit) */
#define DEM_1BYTE                                1
/*! bitfield length of two byte width (16bit) */
#define DEM_2BYTE                                2

/*! bitmask of one byte width (8bit) */
#define DEM_MASK_1                               0xffU
/*! bitmask of two byte width (16bit) */
#define DEM_MASK_2                               0xffffU
/*! bitmask builder for mask of 'size' byte width */
#define DEM_MASK(size)                           DEM_MASK_##size                                                                 /* PRQA S 0342, 3453 */ /* MD_DEM_19.13, MD_MSR_19.7 */

/*! bitmask with bit 'pos' set */
#define DEM_BIT(pos)                             (0x01U << (pos))                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! bitmask of 'size' byte width, with all bits but 'pos' set */
#define DEM_BIT_MASK(pos, size)                  (DEM_MASK(size) ^ DEM_BIT(pos))                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! bitmask with n bits set, starting at 'pos' */
#define DEM_NBIT(n, pos)                         ((DEM_MASK(1) >> (8U-(n))) << (pos))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! bitmask of 'size' byte width, with all bits set, but n bits starting at 'pos' */
#define DEM_NBIT_MASK(n, pos, size)              (DEM_MASK(size) ^ DEM_NBIT(n, pos))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*!
 * \}
 */

                                                                    /* Admin */
/* ------------------------------------------------------------------------- */

/*!
 * \defgroup  Dem_Initialization_State  Macros encoding the initialization states
 * Macros encoding the initialization states
 * \{
 */
#define DEM_INIT_UNINITIALIZED                   (0U)                /*!< Initialization state directly after system startup */
#define DEM_INIT_HALTED_AFTER_ERROR              (1U)                /*!< Initialization state after a failed runtime check has disabled the module */
#define DEM_INIT_PREINITIALIZED                  (2U)                /*!< Initialization state after Dem_PreInit */
#define DEM_INIT_SHUTDOWN                        (3U)                /*!< Initialization state after Dem_Shutdown */
#define DEM_INIT_INITIALIZED                     (4U)                /*!< Initialization state after Dem_Init */
/*!
 * \}
 */

                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/*!
 * \defgroup  Dem_Queue_State  Macros encoding queued states
 * Macros encoding different states set when queueing actions
 * \{
 */
#define DEM_QUEUE_CYCLE_STOPPED                  (1U)     /*!< Cycle state change to stopped */
#define DEM_QUEUE_CYCLE_STARTED                  (2U)     /*!< Cycle state change to started */
#define DEM_QUEUE_CYCLE_RESTARTED                (3U)     /*!< Cycle state change, stop then start */

#define DEM_QUEUE_EVENT_NONE                     (0x00U)  /*!< Event has no pending state change */
#define DEM_QUEUE_EVENT_QUEUED                   (0x40U)  /*!< Event has a pending state change, queued in bsw error queue */
#define DEM_QUEUE_EVENT_PENDING                  (0x80U)  /*!< Event has a pending state change, not queued in bsw error queue */
#define DEM_QUEUE_EVENT_CLEARMASK                (0xc0U)  /*!< Mask to reset pending state change */

#define DEM_QUEUE_CLEARSTATE_IDLE                (0x00U)  /*!< No clear operation in progress */
/*!
 * \}
 */

                                                                 /* Callback */
/* ------------------------------------------------------------------------- */

/*!
 * \defgroup  Dem_Callback_Reasons  Macros encoding reasons for calling notifications
 * Macros encoding reasons for calling notifications
 * \{
 */
#define DEM_CBK_DTC_CLEAR                        (0U)  /*!< DTC was cleared */
#define DEM_CBK_DTC_UPDATED                      (1U)  /*!< DTC was updated */
#define DEM_CBK_DTC_AGED                         (2U)  /*!< DTC was aged */
#define DEM_CBK_DTC_HEALED                       (3U)  /*!< DTC was healed */
#define DEM_CBK_DTC_DISPLACED                    (4U)  /*!< DTC was displaced */
#define DEM_CBK_DTC_REINIT                       (5U)  /*!< DTC operating cycle was restarted */
#define DEM_CBK_CYCLE_QUALIFIED                  (6U)  /*!< DTC operating cycle was qualified */
#define DEM_CBK_USER_WIR                         (7U)  /*!< DTC WIR bit was set by application API */
/*!
 * \}
 */

                                                           /* Data Provision */
/* ------------------------------------------------------------------------- */

/*! Data byte value substituted when callbacks fail to retrieve data */
#define DEM_DATA_INVALID_DATA_PATTERN            (0xffU)

#if (DEM_CFG_PROCESS_OCCTR_CONFIRMED == STD_ON)
/*! Start value for occurrence counter */
# define DEM_DATA_OCCURRENCE_INIT                (1U)
#else
/*! Start value for occurrence counter */
# define DEM_DATA_OCCURRENCE_INIT                (0U)
#endif

#if (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
/*! Maximum value for occurrence counter */
# define DEM_DATA_OCCURRENCE_MAX                 (0xffffU)
#else
/*! Maximum value for occurrence counter */
# define DEM_DATA_OCCURRENCE_MAX                 (0xffU)
#endif

/*!
 * \defgroup  Dem_Data_ChangeState  Macros encoding changed data while updating DTCs
 * Macros encoding changed data while updating DTCs
 * \{
 */
#define DEM_DATA_NO_CHANGES                      (0x00U)  /*!< No data changed */
#define DEM_DATA_USERDATA_CHANGED                (0x01U)  /*!< User data changed, update NV ram and call data change notification */
#define DEM_DATA_STATISTICS_CHANGED              (0x02U)  /*!< Internal data changed, update NV ram but no data change notification */
/*!
 * \}
 */

/*!
 * \}
 */

/*! Number of bytes per DID added to response in UDS protocol */
# define DEM_DATA_ADDITIONAL_BYTES_PER_DID       (2)

                                                     /* Memory Manager [MEM] */
/* ------------------------------------------------------------------------- */

/*! Invalid memory index used for 'no index available' */
#define DEM_MEM_INVALID_MEMORY_INDEX             Dem_Cfg_GlobalNvBlockCount()

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/*! Invalid prestore memory index used for 'no index available' */
# define DEM_MEM_INVALID_PRESTORAGE_INDEX        Dem_Cfg_GlobalPrestorageMaxCount()
/*! Invalid prestore memory reference used for 'no such reference' */
# define DEM_MEM_INVALID_PRESTORAGE_REF          Dem_Cfg_GlobalPrestorageEventCount()
#endif
/*! Aging counter threshold for PID aging */
#define DEM_MEM_PID_AGING_COUNTER_THRESHOLD      0x28U

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */
/*! Handle for enable condition 'ControlDTCSetting' */
#define DEM_ENABLECONDITION_CONTROLDTCSETTING    0
/*! Number of supported debounce algorithms */
#define DEM_ESM_DEBOUNCE_ALGORITHM_COUNT         3

/*! UDS status after re-initialization */
#define DEM_UDS_STATUS_INITIALIZE                (0x50U)
/*! Preconfirmed DTC status after re-initialization */
#define DEM_PC_STATUS_INITIALIZE                 (0x00U)

/*!
 * \defgroup  Dem_UdsStatusClearMask  Macros encoding status masks to reset UDS status bits
 * Macros encoding status masks to reset UDS status bits
 * \{
 */
#define DEM_UDS_STATUS_TF_MASK                   DEM_BIT_MASK(0, DEM_1BYTE)  /*!< Byte mask to reset test failed */
#define DEM_UDS_STATUS_TFTOC_MASK                DEM_BIT_MASK(1, DEM_1BYTE)  /*!< Byte mask to reset test failed this operating cycle*/
#define DEM_UDS_STATUS_PDTC_MASK                 DEM_BIT_MASK(2, DEM_1BYTE)  /*!< Byte mask to reset pending dtc */
#define DEM_UDS_STATUS_CDTC_MASK                 DEM_BIT_MASK(3, DEM_1BYTE)  /*!< Byte mask to reset confirmed dtc */
#define DEM_UDS_STATUS_TNCSLC_MASK               DEM_BIT_MASK(4, DEM_1BYTE)  /*!< Byte mask to reset test not completed since last clear */
#define DEM_UDS_STATUS_TFSLC_MASK                DEM_BIT_MASK(5, DEM_1BYTE)  /*!< Byte mask to reset test failed since last clear */
#define DEM_UDS_STATUS_TNCTOC_MASK               DEM_BIT_MASK(6, DEM_1BYTE)  /*!< Byte mask to reset test not completed this operating cycle */
#define DEM_UDS_STATUS_WIR_MASK                  DEM_BIT_MASK(7, DEM_1BYTE)  /*!< Byte mask to reset warning indicator requested */
/*!
 * \}
 */

/*!
 * \defgroup  Dem_InternalStatusBitSizes  Macros encoding bit sizes for internal status
 * Macros encoding bit sizes for internal status
 * \{
 */
#define DEM_ESM_DEBOUNCE_STATUS_SIZE             4  /*!< bit size of debounce status */
#define DEM_ESM_STORED_STATUS_SIZE               2  /*!< bit size of stored status */
#define DEM_ESM_SUPPRESSED_EVENT_SIZE            1  /*!< bit size of event suppressed */
#define DEM_ESM_SUPPRESSED_DTC_SIZE              1  /*!< bit size of DTC suppressed */
#define DEM_ESM_DISCONNECTED_EVENT_SIZE          1  /*!< bit size of event disconnected */
#define DEM_ESM_FDC_TRIP_SIZE                    1  /*!< bit size of fault detection counter threshold exceeded */
#define DEM_ESM_FDC_MAX_SIZE                     1  /*!< bit size of fault detection counter threshold new maximum */
#define DEM_ESM_FDC_TOC_SIZE                     1  /*!< bit size of fault detection counter threshold this cycle */
#define DEM_ESM_AVAILABLEINVARIANT_SIZE          1  /*!< bit size of event available in active variant */
/*!
 * \}
 */

/*!
 * \defgroup  Dem_InternalStatusBitPosition  Macros encoding bit position for internal status
 * Macros encoding bit position for internal status
 * \{
 */
#define DEM_ESM_USER_CONTROLLED_WIR_POS          7  /*!< bit position of user controlled warning indicator request */

#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
# define DEM_ESM_DEBOUNCE_STATUS_POS             0  /*!< bit start position of debounce status */
# define DEM_ESM_DEBOUNCE_STATUS_END             (DEM_ESM_DEBOUNCE_STATUS_POS + DEM_ESM_DEBOUNCE_STATUS_SIZE)  /*!< bit end position of debounce status */
#else
# define DEM_ESM_DEBOUNCE_STATUS_POS             0  /*!< bit start position of debounce status */
# define DEM_ESM_DEBOUNCE_STATUS_END             0  /*!< bit end position of debounce status */
#endif

#define DEM_ESM_STORED_STATUS_POS                DEM_ESM_DEBOUNCE_STATUS_END  /*!< bit start position of stored status */
#define DEM_ESM_STORED_STATUS_END                (DEM_ESM_STORED_STATUS_POS + DEM_ESM_STORED_STATUS_SIZE)  /*!< bit end position of stored status */

#if (DEM_FEATURE_NEED_SUPPRESSION == STD_ON)
# define DEM_ESM_SUPPRESSED_EVENT_POS            DEM_ESM_STORED_STATUS_END  /*!< bit start position of event suppressed */
# define DEM_ESM_SUPPRESSED_EVENT_END            (DEM_ESM_SUPPRESSED_EVENT_POS + DEM_ESM_SUPPRESSED_EVENT_SIZE)  /*!< bit end position of event suppressed */
#else
# define DEM_ESM_SUPPRESSED_EVENT_POS            DEM_ESM_STORED_STATUS_POS  /*!< bit start position of event suppressed */
# define DEM_ESM_SUPPRESSED_EVENT_END            DEM_ESM_STORED_STATUS_END  /*!< bit end position of event suppressed */
#endif

#if (DEM_FEATURE_NEED_SUPPRESSION == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_SUPPRESSED_EVENT_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )                                                       /* COV_DEM_BITCALCULATION TF tf xx */
#  define DEM_ESM_SUPPRESSED_DTC_POS             (DEM_ESM_SUPPRESSED_EVENT_END + 1)  /*!< bit start position of DTC suppressed */
# else
#  define DEM_ESM_SUPPRESSED_DTC_POS             DEM_ESM_SUPPRESSED_EVENT_END  /*!< bit start position of DTC suppressed */
# endif
# define DEM_ESM_SUPPRESSED_DTC_END              (DEM_ESM_SUPPRESSED_DTC_POS + DEM_ESM_SUPPRESSED_DTC_SIZE)  /*!< bit end position of DTC suppressed */
#else
# define DEM_ESM_SUPPRESSED_DTC_POS              DEM_ESM_SUPPRESSED_EVENT_POS  /*!< bit start position of DTC suppressed */
# define DEM_ESM_SUPPRESSED_DTC_END              DEM_ESM_SUPPRESSED_EVENT_END  /*!< bit end position of DTC suppressed */
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_SUPPRESSED_DTC_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )                                                         /* COV_DEM_BITCALCULATION TF tf xx */
#  define DEM_ESM_DISCONNECTED_EVENT_POS         (DEM_ESM_SUPPRESSED_DTC_END + 1)  /*!< bit start position of event disconnected */
# else
#  define DEM_ESM_DISCONNECTED_EVENT_POS         DEM_ESM_SUPPRESSED_DTC_END  /*!< bit start position of event disconnected */
# endif
# define DEM_ESM_DISCONNECTED_EVENT_END          (DEM_ESM_DISCONNECTED_EVENT_POS + DEM_ESM_DISCONNECTED_EVENT_SIZE)  /*!< bit end position of event disconnected */
#else
# define DEM_ESM_DISCONNECTED_EVENT_POS          DEM_ESM_SUPPRESSED_DTC_POS  /*!< bit start position of event disconnected */
# define DEM_ESM_DISCONNECTED_EVENT_END          DEM_ESM_SUPPRESSED_DTC_END  /*!< bit end position of event disconnected */
#endif

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_DISCONNECTED_EVENT_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )                                                     /* COV_DEM_BITCALCULATION TF tf xx */
#  define DEM_ESM_FDC_TRIP_POS                   (DEM_ESM_DISCONNECTED_EVENT_END + 1)  /*!< bit start position of fault detection counter threshold exceeded */
# else
#  define DEM_ESM_FDC_TRIP_POS                   DEM_ESM_DISCONNECTED_EVENT_END  /*!< bit start position of fault detection counter threshold exceeded */
# endif
# define DEM_ESM_FDC_TRIP_END                    (DEM_ESM_FDC_TRIP_POS + DEM_ESM_FDC_TRIP_SIZE)  /*!< bit end position of fault detection counter threshold exceeded */
#else
# define DEM_ESM_FDC_TRIP_POS                    DEM_ESM_DISCONNECTED_EVENT_POS  /*!< bit start position of fault detection counter threshold exceeded */
# define DEM_ESM_FDC_TRIP_END                    DEM_ESM_DISCONNECTED_EVENT_END  /*!< bit end position of fault detection counter threshold exceeded */
#endif

#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_FDC_TRIP_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )                                                               /* COV_DEM_BITCALCULATION TF tf xx */
#  define DEM_ESM_FDC_MAX_POS                    (DEM_ESM_FDC_TRIP_END + 1)  /*!< bit start position of fault detection counter threshold new maximum */
# else
#  define DEM_ESM_FDC_MAX_POS                    DEM_ESM_FDC_TRIP_END  /*!< bit start position of fault detection counter threshold new maximum */
# endif
# define DEM_ESM_FDC_MAX_END                     (DEM_ESM_FDC_MAX_POS + DEM_ESM_FDC_MAX_SIZE)  /*!< bit end position of fault detection counter threshold new maximum */
#else
# define DEM_ESM_FDC_MAX_POS                     DEM_ESM_FDC_TRIP_POS  /*!< bit start position of fault detection counter threshold new maximum */
# define DEM_ESM_FDC_MAX_END                     DEM_ESM_FDC_TRIP_END  /*!< bit end position of fault detection counter threshold new maximum */
#endif

#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_FDC_MAX_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )                                                                /* COV_DEM_BITCALCULATION TF tf xx */
#  define DEM_ESM_FDC_TOC_POS                    (DEM_ESM_FDC_MAX_END + 1)  /*!< bit start position of fault detection counter threshold this cycle */
# else
#  define DEM_ESM_FDC_TOC_POS                    DEM_ESM_FDC_MAX_END  /*!< bit start position of fault detection counter threshold this cycle */
# endif
# define DEM_ESM_FDC_TOC_END                     (DEM_ESM_FDC_TOC_POS + DEM_ESM_FDC_TOC_SIZE)  /*!< bit end position of fault detection counter threshold this cycle */
#else
# define DEM_ESM_FDC_TOC_POS                     DEM_ESM_FDC_MAX_POS  /*!< bit start position of fault detection counter threshold this cycle */
# define DEM_ESM_FDC_TOC_END                     DEM_ESM_FDC_MAX_END  /*!< bit end position of fault detection counter threshold this cycle */
#endif

#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON) && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_FDC_TOC_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )                                                                /* COV_DEM_BITCALCULATION TF tf xx */
#  define DEM_ESM_AVAILABLEINVARIANT_POS         (DEM_ESM_FDC_TOC_END + 1)  /*!< bit start position of event available in active variant */
# else
#  define DEM_ESM_AVAILABLEINVARIANT_POS         DEM_ESM_FDC_TOC_END  /*!< bit start position of event available in active variant */
# endif
# define DEM_ESM_AVAILABLEINVARIANT_END          (DEM_ESM_AVAILABLEINVARIANT_POS + DEM_ESM_AVAILABLEINVARIANT_SIZE)  /*!< bit end position of event available in active variant */
#else
# define DEM_ESM_AVAILABLEINVARIANT_POS          DEM_ESM_FDC_TOC_POS  /*!< bit start position of event available in active variant */
# define DEM_ESM_AVAILABLEINVARIANT_END          DEM_ESM_FDC_TOC_END  /*!< bit end position of event available in active variant */
#endif
/*!
 * \}
 */

#if (DEM_ESM_AVAILABLEINVARIANT_POS < 8)
/*! Required byte size of event internal status */
# define DEM_ESM_INTERNAL_STATUS_BYTESIZE        DEM_1BYTE
#else
/*! Required byte size of event internal status */
# define DEM_ESM_INTERNAL_STATUS_BYTESIZE        DEM_2BYTE
#endif

/*!
 * \defgroup  Dem_InternalStatusBitMasks  Macros encoding bit masks for internal status
 * Macros encoding bit masks for internal status
 * \{
 */
#define DEM_ESM_DEBOUNCE_STATUS                  DEM_NBIT(DEM_ESM_DEBOUNCE_STATUS_SIZE, DEM_ESM_DEBOUNCE_STATUS_POS)  /*!< Bit mask for debounce status bit(s) */
#define DEM_ESM_DEBOUNCE_STATUS_MASK             DEM_NBIT_MASK(DEM_ESM_DEBOUNCE_STATUS_SIZE, DEM_ESM_DEBOUNCE_STATUS_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for debounce status bit(s) */

#define DEM_ESM_STORED_STATUS                    DEM_NBIT(DEM_ESM_STORED_STATUS_SIZE, DEM_ESM_STORED_STATUS_POS)  /*!< Bit mask for stored status bit(s) */
#define DEM_ESM_STORED_STATUS_MASK               DEM_NBIT_MASK(DEM_ESM_STORED_STATUS_SIZE, DEM_ESM_STORED_STATUS_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for stored status bit(s) */

#define DEM_ESM_SUPPRESSED_EVENT                 DEM_BIT(DEM_ESM_SUPPRESSED_EVENT_POS)  /*!< Bit mask for event suppressed bit(s) */
#define DEM_ESM_SUPPRESSED_EVENT_MASK            DEM_BIT_MASK(DEM_ESM_SUPPRESSED_EVENT_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for event suppressed bit(s) */

#define DEM_ESM_SUPPRESSED_DTC                   DEM_BIT(DEM_ESM_SUPPRESSED_DTC_POS)  /*!< Bit mask for DTC suppressed bit(s) */
#define DEM_ESM_SUPPRESSED_DTC_MASK              DEM_BIT_MASK(DEM_ESM_SUPPRESSED_DTC_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for DTC suppressed bit(s) */

#define DEM_ESM_USER_CONTROLLED_WIR              DEM_BIT(DEM_ESM_USER_CONTROLLED_WIR_POS)  /*!< Bit mask for user controlled warning indicator request bit(s) */
#define DEM_ESM_USER_CONTROLLED_WIR_MASK         DEM_BIT_MASK(DEM_ESM_USER_CONTROLLED_WIR_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for user controlled warning indicator request bit(s) */

#define DEM_ESM_DISCONNECTED_EVENT               DEM_BIT(DEM_ESM_DISCONNECTED_EVENT_POS)  /*!< Bit mask for event disconnected bit(s) */
#define DEM_ESM_DISCONNECTED_EVENT_MASK          DEM_BIT_MASK(DEM_ESM_DISCONNECTED_EVENT_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for event disconnected bit(s) */

#define DEM_ESM_FDC_TRIP                         DEM_BIT(DEM_ESM_FDC_TRIP_POS)  /*!< Bit mask for fault detection counter threshold exceeded bit(s) */
#define DEM_ESM_FDC_TRIP_MASK                    DEM_BIT_MASK(DEM_ESM_FDC_TRIP_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for fault detection counter threshold exceeded bit(s) */

#define DEM_ESM_FDC_MAX                          DEM_BIT(DEM_ESM_FDC_MAX_POS)  /*!< Bit mask for fault detection counter threshold new maximum bit(s) */
#define DEM_ESM_FDC_MAX_MASK                     DEM_BIT_MASK(DEM_ESM_FDC_MAX_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for fault detection counter threshold new maximum bit(s) */

#define DEM_ESM_FDC_TOC                          DEM_BIT(DEM_ESM_FDC_TOC_POS)  /*!< Bit mask for fault detection counter threshold this cycle bit(s) */
#define DEM_ESM_FDC_TOC_MASK                     DEM_BIT_MASK(DEM_ESM_FDC_TOC_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for fault detection counter threshold this cycle bit(s) */

#define DEM_ESM_AVAILABLEINVARIANT               DEM_BIT(DEM_ESM_AVAILABLEINVARIANT_POS)  /*!< Bit mask for event available in active variant bit(s) */
#define DEM_ESM_AVAILABLEINVARIANT_MASK          DEM_BIT_MASK(DEM_ESM_AVAILABLEINVARIANT_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)  /*!< Negated bit mask for event available in active variant bit(s) */
/*!
 * \}
 */

#if (DEM_DEV_ERROR_DETECT == STD_ON)
struct DemInternalStatusSizeCheck_s
{
  unsigned int Dem_Verify_SizeOfInternalStatus : (DEM_ESM_INTERNAL_STATUS_BYTESIZE == sizeof(Dem_Cfg_EventInternalStatusType) ? 1 : -1);
};
# if (DEM_ESM_USER_CONTROLLED_WIR != 0x80U)
#  error "Bit definition is no longer working for Dem_Util_DtcApplyUserControlledWIR"
# endif
#endif

/*!
 * \defgroup  Dem_Esm_MonitorStatus  Macros encoding qualified monitor status reports
 * Macros encoding qualified monitor status reports
 * \{
 */
#define DEM_ESM_MONITOR_STATUS_NONE              (0)   /*! < No result */
#define DEM_ESM_MONITOR_STATUS_FAILED            (1)   /*! < Failed result */
#define DEM_ESM_MONITOR_STATUS_PASSED            (-1)  /*! < Passed result */
/*!
 * \}
 */

/*!
 * \defgroup  Dem_Esm_DebounceStatus  Macros encoding debounce status states
 * Macros encoding debounce status states
 * \{
 */
#define DEM_ESM_DEBOUNCE_STATUS_NONE             ((0x00U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing inactive */
#define DEM_ESM_DEBOUNCE_RESET_FAILED            ((0x01U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing started, counter initialized towards failed threshold */
#define DEM_ESM_DEBOUNCE_RESET_PASSED            ((0x02U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing started, counter initialized towards passed threshold */
#define DEM_ESM_DEBOUNCE_COUNT_FAILED            ((0x03U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing in progress, counting towards failed threshold */
#define DEM_ESM_DEBOUNCE_COUNT_PASSED            ((0x04U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing in progress, counting towards passed threshold */
#define DEM_ESM_DEBOUNCE_FREEZE_FAILED           ((0x05U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing paused while counting towards failed threshold */
#define DEM_ESM_DEBOUNCE_FREEZE_PASSED           ((0x06U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing paused while counting towards passed threshold */
#define DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC        ((0x07U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing in progress, counting towards failed threshold, fdc trip already processed */
#define DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC       ((0x09U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing paused while counting towards failed threshold, fdc trip already processed */
#define DEM_ESM_DEBOUNCE_DONE_PASSED             ((0x0aU) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing completed, passed threshold reached */
#define DEM_ESM_DEBOUNCE_DONE_FAILED             ((0x0bU) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing completed, failed threshold reached */

#define DEM_ESM_DEBOUNCE_DIR_PASSED              ((0x00U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*!< De-bouncing super state: De-bouncing in direction 'passed' */
/*!
 * \}
 */

/*!
 * \defgroup  Dem_Esm_StoredStatus  Macros encoding stored status states
 * Macros encoding stored status states
 * \{
 */
#define DEM_ESM_STORED_STATUS_NONE               (0U << DEM_ESM_STORED_STATUS_POS)  /*!< Not stored */
#define DEM_ESM_STORED_STATUS_ACTIVE             (1U << DEM_ESM_STORED_STATUS_POS)  /*!< Active memory entry exists */
#define DEM_ESM_STORED_STATUS_AGING              (2U << DEM_ESM_STORED_STATUS_POS)  /*!< Aging memory entry exists */
#define DEM_ESM_STORED_STATUS_AGED               (3U << DEM_ESM_STORED_STATUS_POS)  /*!< Aged memory entry exists */
/*!
 * \}
 */

/*!
 * \defgroup  Dem_Esm_PrestoredStatus  Macros encoding prestored status states
 * Macros encoding prestored status states
 * \{
 */
#define DEM_ESM_PRESTORED_STATUS_FREE            (0x00U)  /*!< Prestored entry is free */
#define DEM_ESM_PRESTORED_STATUS_READY           (0x01U)  /*!< Prestored entry contains valid data */
#define DEM_ESM_PRESTORED_STATUS_UPDATING        (0x02U)  /*!< Prestored entry is updating data */
#define DEM_ESM_PRESTORED_STATUS_LOCKED          (0x03U)  /*!< Prestored entry is locked */
#define DEM_ESM_PRESTORED_STATUS_DISCARDED       (0x04U)  /*!< Prestored entry needs to be reclaimed */
/*!
 * \}
 */

/*!
 * \defgroup  Dem_Esm_CycleCountValues  Macros encoding magic cycle counter values
 * Macros encoding magic cycle counter values
 * \{
 */
#define DEM_ESM_CYCLECOUNT_MAX                   (0xeeeeU)  /*!< maximum cycle counter */
#define DEM_ESM_CYCLECOUNT_LATCHED               (0xeeffU)  /*!< latched cycle counter */
#define DEM_ESM_CYCLECOUNT_EVENT_AGED            (0xffeeU)  /*!< event is aged */
#define DEM_ESM_CYCLECOUNT_INVALID               (0xffffU)  /*!< no cycle counter available */
/*!
 * \}
 */

#if (DEM_CFG_STORAGE_AT_CONFIRMED == STD_ON)
/*! Trigger mask for creation of an event memory entry */
# define DEM_ESM_EVENT_STORAGE_TRIGGER           DEM_CFG_TRIGGER_CONFIRMED
#elif (DEM_CFG_STORAGE_AT_FAILED == STD_ON)
/*! Trigger mask for creation of an event memory entry */
# define DEM_ESM_EVENT_STORAGE_TRIGGER           (DEM_CFG_TRIGGER_TESTFAILED|DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE)
#elif (DEM_CFG_STORAGE_AT_FDC == STD_ON)                                                                                         /* COV_MSR_CONFIG TX */
/*! Trigger mask for creation of an event memory entry */
# define DEM_ESM_EVENT_STORAGE_TRIGGER           (DEM_CFG_TRIGGER_FDC|DEM_CFG_TRIGGER_TESTFAILED)
#else
# error "No event storage trigger defined"
#endif

#if ( (DEM_CFG_PROCESS_CDTC_STOREDONLY == STD_ON)   \
   || (DEM_CFG_PROCESS_PDTC_STOREDONLY == STD_ON)   \
   || (DEM_CFG_PROCESS_WIR_STOREDONLY == STD_ON)    \
   || (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON) )
/*! Option setting if status bits depend on creation of an event memory entry */
# define DEM_FEATURE_NEED_STOREDONLY_BITS        STD_ON
#else
/*! Option setting if status bits depend on creation of an event memory entry */
# define DEM_FEATURE_NEED_STOREDONLY_BITS        STD_OFF
#endif

#if (DEM_CFG_PROCESS_PDTC_STOREDONLY == STD_ON)
/*! Mask for stored only Pending DTC bit */
# define DEM_ESM_STOREDONLY_PDTC                 DEM_UDS_STATUS_PDTC
/*! Mask for stored only Pending DTC trigger */
# define DEM_ESM_EVENT_NO_TRIGGER_PENDING        DEM_CFG_TRIGGER_PENDING
#else
/*! Mask for stored only Pending DTC bit */
# define DEM_ESM_STOREDONLY_PDTC                 0x00U
/*! Mask for stored only Pending DTC trigger */
# define DEM_ESM_EVENT_NO_TRIGGER_PENDING        0x00U
#endif
#if (DEM_CFG_PROCESS_CDTC_STOREDONLY == STD_ON)
/*! Mask for stored only Confirmed DTC bit */
# define DEM_ESM_STOREDONLY_CDTC                 DEM_UDS_STATUS_CDTC
/*! Mask for stored only Confirmed DTC trigger */
# define DEM_ESM_EVENT_NO_TRIGGER_CONFIRMED      DEM_CFG_TRIGGER_CONFIRMED
#else
/*! Mask for stored only Confirmed DTC bit */
# define DEM_ESM_STOREDONLY_CDTC                 0x00U
/*! Mask for stored only Confirmed DTC trigger */
# define DEM_ESM_EVENT_NO_TRIGGER_CONFIRMED      0x00U
#endif
#if (DEM_CFG_PROCESS_WIR_STOREDONLY == STD_ON)
/*! Mask for stored only Warning Indicator Requested bit */
# define DEM_ESM_STOREDONLY_WIR                  DEM_UDS_STATUS_WIR
/*! Mask for stored only Warning Indicator Requested trigger */
# define DEM_ESM_EVENT_NO_TRIGGER_INDICATOR      DEM_CFG_TRIGGER_INDICATOR
#else
/*! Mask for stored only Warning Indicator Requested bit */
# define DEM_ESM_STOREDONLY_WIR                  0x00U
/*! Mask for stored only Warning Indicator Requested trigger */
# define DEM_ESM_EVENT_NO_TRIGGER_INDICATOR      0x00U
#endif
#if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON)
/*! Mask for stored only Test Failed This Operating Cycle bit */
# define DEM_ESM_STOREDONLY_TFSLC                DEM_UDS_STATUS_TFSLC
#else
/*! Mask for stored only Test Failed This Operating Cycle bit */
# define DEM_ESM_STOREDONLY_TFSLC                0x00U
#endif

/*! Mask for all stored only bits */
#define DEM_ESM_STOREDONLY_BITS                  (DEM_ESM_STOREDONLY_CDTC|DEM_ESM_STOREDONLY_PDTC|\
                                                 DEM_ESM_STOREDONLY_TFSLC|DEM_ESM_STOREDONLY_WIR)

/*! Trigger Mask for event updates */
#define DEM_ESM_EVENT_UPDATE_TRIGGER             DEM_CFG_TRIGGER_TESTFAILED

/*! Reset Mask for stored only triggers */
#define DEM_ESM_EVENT_RESET_TRIGGER_MASK         ((uint8)(0xffU ^ (DEM_ESM_EVENT_NO_TRIGGER_PENDING   \
                                                                 | DEM_ESM_EVENT_NO_TRIGGER_CONFIRMED \
                                                                 | DEM_ESM_EVENT_NO_TRIGGER_INDICATOR)))

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

/*!
 * \defgroup  Dem_NvM_StatusChangedMask Macros encoding status changes relevant for NV update
 * Macros encoding status changes relevant for NV update
 * \{
 */
#if (DEM_CFG_SUPPORT_TESTFAILED_STORAGE == STD_ON)
# define DEM_NVM_TF_MASK                         (0x01U)  /*!< Bit Mask for test failed update in NV */
#else
# define DEM_NVM_TF_MASK                         (0x00U)  /*!< Bit Mask for test failed update in NV */
#endif

#define DEM_NVM_TFTOC_MASK                       (0x02U)  /*!< Bit Mask for test failed this operating cycle update in NV */
#define DEM_NVM_PDTC_MASK                        (0x04U)  /*!< Bit Mask for pending DTC update in NV */
#define DEM_NVM_CDTC_MASK                        (0x08U)  /*!< Bit Mask for confirmed DTC update in NV */
#define DEM_NVM_NTSLC_MASK                       (0x10U)  /*!< Bit Mask for not tested since last clear update in NV */
#define DEM_NVM_TFSLC_MASK                       (0x20U)  /*!< Bit Mask for test failed since last clear update in NV */
#define DEM_NVM_NTTOC_MASK                       (0x40U)  /*!< Bit Mask for not tested this operating cycle update in NV */
#define DEM_NVM_WIR_MASK                         (0x80U)  /*!< Bit Mask for warning indicator requested update in NV */

/*! Combined bit mask for status update in NV */
#define DEM_NVM_STATUS_MASK                      (DEM_NVM_TF_MASK|DEM_NVM_TFTOC_MASK|DEM_NVM_PDTC_MASK|    \
                                                  DEM_NVM_CDTC_MASK|DEM_NVM_NTSLC_MASK|DEM_NVM_TFSLC_MASK| \
                                                  DEM_NVM_NTTOC_MASK|DEM_NVM_WIR_MASK)
/*!
 * \}
 */

/*!
 * \defgroup  Dem_NvM_CommitState Macros encoding NV immediate data commit state
 * Macros encoding NV immediate data commit state
 * \{
 */
#define DEM_NVM_COMMIT_IDLE                      (0x00U)  /*!< No data commit in progress */
#define DEM_NVM_COMMIT_WRITING                   (0x01U)  /*!< Data commit in progress */
#define DEM_NVM_COMMIT_FINISHED                  (0x02U)  /*!< Data commit completed */
#define DEM_NVM_COMMIT_FAILED                    (0x03U)  /*!< Data commit finished, but failed */
/*!
 * \}
 */

/*!
 * \defgroup  Dem_NvM_BlockState Macros encoding NV block state
 * Macros encoding NV block state
 * \{
 */
#define DEM_NVM_BLOCKSTATE_UNMODIFIED            (0x00U)  /*!< Data is unmodified */
#define DEM_NVM_BLOCKSTATE_DIRTY                 (0x01U)  /*!< Data modified, commit at shutdown */
#define DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE        (0x03U)  /*!< Data modified, commit immediately */
#define DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE  (0x07U)  /*!< Data cleared, commit immediately */

#define DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG         (0x02U)  /*!< Block status bit 'commit immediately' */
#define DEM_NVM_BLOCKSTATE_CLEARFLAG             (0x04U)  /*!< Block status bit 'date cleared' */
/*!
 * \}
 */

                                                              /* Dcm filters */
/* ------------------------------------------------------------------------- */

/*!
 * \defgroup  Dem_Dcm_Clients Macros encoding data access clients
 * Macros encoding data access clients
 * \{
 */
#define DEM_DCM_CLIENT_DCM                       (0x00U)  /*!< Data access by Dcm */
#define DEM_DCM_CLIENT_APPLICATION               (0x01U)  /*!< Data access by application API */

#define DEM_DCM_CLIENT_COUNT                     (2U)  /*!< Number of concurrent clients */
/*!
 * \}
 */

/*!
 * \defgroup  Dem_Dcm_FilterStates Macros encoding state for DTC data access
 * Macros encoding state for DTC data access
 * \{
 */
#define DEM_DCM_FILTERDATA_IDLE                  (0xFFU)  /*!< No data filter in progress */
#define DEM_DCM_FILTERDATA_PENDING               (DEM_DISABLE_DTCRECUP_PENDING)  /*!< Data filter in progress */
#define DEM_DCM_FILTERDATA_READY                 (DEM_DISABLE_DTCRECUP_OK)  /*!< Data filter completed, ready for access */
/*!
 * \}
 */

                                                              /* Service API */
/* ------------------------------------------------------------------------- */

/*!
 * \defgroup  Dem_Api_InvalidValues Macros encoding invalid values for API parameter verification
 * Macros encoding invalid values for API parameter verification
 * \{
 */
#define DEM_EVENT_STATUS_INVALID                 ((Dem_EventStatusType)(0x04U))  /*!< First out of range value of Dem_EventStatusType */
#define DEM_DEBOUNCE_STATUS_INVALID              ((Dem_DebounceResetStatusType)(0x02U))  /*!< First out of range value of Dem_DebounceResetStatusType */
#define DEM_CYCLE_STATE_INVALID                  ((Dem_OperationCycleStateType)(0x02U))  /*!< First out of range value of Dem_OperationCycleStateType */
#define DEM_DTC_FORMAT_INVALID                   ((Dem_DTCFormatType)(0x03U))  /*!< First out of range value of Dem_DTCFormatType */
#define DEM_DTC_ORIGIN_INVALID                   ((Dem_DTCOriginType)(0x05U))  /*!< First out of range value of Dem_DTCOriginType */
#define DEM_DTC_KIND_INVALID                     ((Dem_DTCKindType)(0x03U))  /*!< First out of range value of Dem_DTCKindType */
#define DEM_FILTER_FOR_FDC_INVALID               ((Dem_FilterForFDCType)(0x02U))  /*!< First out of range value of Dem_FilterForFDCType */
#define DEM_FILTER_WITH_SEVERITY_INVALID         ((Dem_FilterWithSeverityType)(0x02U))  /*!< First out of range value of Dem_FilterWithSeverityType */
/*!
 * \}
 */

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

/* ********************************************************************************************************************
 *  LOCAL FUNCTION MACROS
 *********************************************************************************************************************/

                                                               /* Assertions */
/* ------------------------------------------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
/*! Wrapper to call Det_ReportError */
# define Dem_Det_ReportError(ApiId, ErrorCode)   (void)Det_ReportError(DEM_MODULE_ID, 0, (ApiId), (ErrorCode));                  /* PRQA S 3412, 3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
#else
/*! Wrapper to call Det_ReportError */
# define Dem_Det_ReportError(ApiId, ErrorCode)
#endif

#if (DEM_DEV_ERROR_REPORT == STD_ON)
/*! Define local variable for DET error code */
# define Dem_Det_ErrorRegisterDefine()           uint8 lErrorId;                                                                 /* PRQA S 3412, 3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
/*! Set error register with DET error code */
# define Dem_Det_ErrorRegisterSet(value)         lErrorId = (value);                                                             /* PRQA S 3412, 3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
/*! Get error register with DET error code */
# define Dem_Det_ErrorRegisterGet()              lErrorId                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
/*! Define local variable for DET error code  */
# define Dem_Det_ErrorRegisterDefine()                                                                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set error register with DET error code */
# define Dem_Det_ErrorRegisterSet(value)                                                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get error register with DET error code */
# define Dem_Det_ErrorRegisterGet()                                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Internal Development Assertion Macros */
/*! Unconditional assertion, also calls DET if enabled */
#define Dem_Internal_AssertAlways(ErrorCode)
/*! Conditional assertion, also calls DET if enabled. Returns in case the assertion fails */
#define Dem_Internal_AssertReturnVoid(Condition, ErrorCode)
/*! Conditional assertion, also calls DET if enabled. Returns 'ReturnValue' in case the assertion fails */
#define Dem_Internal_AssertReturnValue(Condition, ErrorCode, ReturnValue)
/*! Conditional assertion, also calls DET if enabled. Continues with execution in case the assertion fails */
#define Dem_Internal_AssertContinue(Condition, ErrorCode)

                                                        /* Critical Sections */
/* ------------------------------------------------------------------------- */

/*! Enter critical section 'DiagMonitor' */
#define Dem_EnterCritical_DiagMonitor()          SchM_Enter_Dem_DEM_EXCLUSIVE_AREA_0()                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Leave critical section 'DiagMonitor' */
#define Dem_LeaveCritical_DiagMonitor()          SchM_Exit_Dem_DEM_EXCLUSIVE_AREA_0()                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Enter critical section 'StateManager' */
#define Dem_EnterCritical_StateManager()         SchM_Enter_Dem_DEM_EXCLUSIVE_AREA_1()                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Leave critical section 'StateManager' */
#define Dem_LeaveCritical_StateManager()         SchM_Exit_Dem_DEM_EXCLUSIVE_AREA_1()                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Enter critical section 'DcmAPI' */
#define Dem_EnterCritical_DcmApi()               SchM_Enter_Dem_DEM_EXCLUSIVE_AREA_2()                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Leave critical section 'DcmAPI' */
#define Dem_LeaveCritical_DcmApi()               SchM_Exit_Dem_DEM_EXCLUSIVE_AREA_2()                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

/*! Rotate 'b' left one bit. b may only contain one set bit */
#define Dem_LROT1_Byte(b)                        { (b) = (uint8)(((b) == 0x80U)?(0x01U):((b) << 1)); }                           /* PRQA S 3412, 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7, MD_MSR_19.7 */
/*! Rotate 'b' left one bit. b may only contain one set bit. Increment 'acc' on each full turn */
#define Dem_LROT1_ADD_Byte(acc, b)               { if ((b) == 0x80U) { ++(acc); (b) = 0x01; } else { (b) = (uint8)((b) << 1); }} /* PRQA S 3412, 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7, MD_MSR_19.7 */
/*! Rotate 'b' left one bit. b may only contain one set bit. Increment 'acc' and do 'act' on each full turn */
#define Dem_LROT1_ADD_ACTION_Byte(acc, act, b)   { if ((b) == 0x80U) { ++(acc); (act); (b) = 0x01; } else { (b) = (uint8)((b) << 1); }} /* PRQA S 3412, 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7, MD_MSR_19.7 */
/*! Increment 'value', wrap around when reaching 'Max' */
#define Dem_WrappingIncrement(Value, Max)        { ++(Value); if ((Value) >= (Max)) { (Value) = 0U; } }                          /* PRQA S 3412, 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7, MD_MSR_19.7 */

/*! Get the high byte of a 16 bit value. Used to serialize data */
#define Dem_GetHiByte(value)                     ((uint8)((uint16)(value)>>8))                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get the low byte of a 16 bit value. Used to serialize data */
#define Dem_GetLoByte(value)                     ((uint8)((value)))                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get the high word, high byte of a 32 bit value. Used to serialize data */
#define Dem_GetHiHiByte(value)                   ((uint8)((uint32)(value)>>24))                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get the high word, low byte of a 32 bit value. Used to serialize data */
#define Dem_GetHiLoByte(value)                   ((uint8)((uint32)(value)>>16))                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get the low word, high byte of a 32 bit value. Used to serialize data */
#define Dem_GetLoHiByte(value)                   ((uint8)((uint32)(value)>>8))                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get the low word, low byte of a 32 bit value. Used to serialize data */
#define Dem_GetLoLoByte(value)                   ((uint8)(value))                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Build a 16 bit value from high byte and low byte. Used to de-serialize data */
#define Dem_Make16Bit(hiByte,loByte)             ((uint16)((((uint16)(hiByte))<<8)| \
                                                 ((uint16)(loByte))))                                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Build a 32 bit value from high word high byte, high word low byte, low word high byte and low word low byte. Used to de-serialize data */
#define Dem_Make32Bit(hiHiByte, hiLoByte, loHiByte, loLoByte)   ((uint32)(((uint32)(hiHiByte)<<24)| \
                                                                ((uint32)(hiLoByte)<<16)| \
                                                                ((uint32)(loHiByte)<<8) | \
                                                                ((uint32)(loLoByte))))                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_CFG_USE_MEMCOPY_MACROS == STD_ON)                                                                                       /* COV_MSR_UNSUPPORTED XF */
# if !defined(Dem_MemCpy_Macro)
/*! Default Macro implementation of memcopy. Can be used instead of external function call */
#  define Dem_MemCpy_Macro(dst, src, len)        { uint16_least lMemCopyIndex; \
                                                   for ( lMemCopyIndex = 0x00u; lMemCopyIndex < (len); ++lMemCopyIndex) \
                                                   { (dst)[lMemCopyIndex] = (src)[lMemCopyIndex]; \
                                                 } }                                                                             /* PRQA S 3453, 3458 */ /* MD_MSR_19.7, MD_MSR_19.7 */
# endif

# if !defined(Dem_MemSet_Macro)
/*! Macro implementation of memset. Can be used instead of external function call */
#  define Dem_MemSet_Macro(dst, val, len)        { uint16_least lMemCopyIndex; \
                                                   for ( lMemCopyIndex = 0x00u; lMemCopyIndex < (len); ++lMemCopyIndex) \
                                                   { (dst)[lMemCopyIndex] = (val); \
                                                 } }                                                                             /* PRQA S 3453, 3458 */ /* MD_MSR_19.7, MD_MSR_19.7 */
# endif

/*! Wrapper macro for memcopy */
# define Dem_MemCpy(dst, src, len)               Dem_MemCpy_Macro((dst), (src), (len))                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Wrapper macro for memset */
# define Dem_MemSet(dst, val, len)               Dem_MemSet_Macro((dst), (val), (len))                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
/*! Wrapper macro for memcopy */
# define Dem_MemCpy(dst, src, len)               VStdMemCpy((Dem_DataPtrType)(dst), (Dem_DataPtrType)(src), (len))               /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Wrapper macro for memset */
# define Dem_MemSet(dst, val, len)               VStdMemSet((Dem_DataPtrType)(dst), (val), (len))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/*! Test if cycle change is pending for 'CycleId' */
#define Dem_Queue_IsPendingCycle(CycleId)        ((Dem_Queue_CycleFlag & ((uint8)(1U << (CycleId)))) != 0)                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get memory Id of the current clear request */
#define Dem_Queue_GetClearMemory()               (Dem_Queue_ClearRequest.ClearMemoryId)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set memory Id of the current clear request */
#define Dem_Queue_SetClearMemory(MemoryId)       (Dem_Queue_ClearRequest.ClearMemoryId = (MemoryId))                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get clear format of the current clear request */
#define Dem_Queue_GetClearFormat()               (Dem_Queue_ClearRequest.ClearFormat)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear format of the current clear request */
#define Dem_Queue_SetClearFormat(Format)         (Dem_Queue_ClearRequest.ClearFormat = (Format))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get clear group of the current clear request */
#define Dem_Queue_GetClearGroup()                (Dem_Queue_ClearRequest.ClearGroup)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear group of the current clear request */
#define Dem_Queue_SetClearGroup(Group)           (Dem_Queue_ClearRequest.ClearGroup = (Group))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get clear event of the current clear request */
#define Dem_Queue_GetClearEvent()                (Dem_Queue_ClearRequest.ClearEventId)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear event of the current clear request */
#define Dem_Queue_SetClearEvent(Event)           (Dem_Queue_ClearRequest.ClearEventId = (Event))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get clear client of the current clear request */
#define Dem_Queue_GetClearClient()               (Dem_Queue_ClearRequest.ClearClient)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear client of the current clear request */
#define Dem_Queue_SetClearClient(Client)         (Dem_Queue_ClearRequest.ClearClient = (Client))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get clear state of the current clear request */
#define Dem_Queue_GetClearState()                (Dem_Queue_ClearState)                                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear state of the current clear request */
#define Dem_Queue_SetClearState(State)           (Dem_Queue_ClearState = (State))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test if clear state is pending */
#define DEM_QUEUE_TESTCLEARSTATE_PENDING(State)  ((uint8)((State) & 0x01U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear state pending */
#define DEM_QUEUE_SETCLEARSTATE_PENDING(State)   ((uint8)((State) | 0x01U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset clear state pending */
#define DEM_QUEUE_RESETCLEARSTATE_PENDING(State) ((uint8)((State) & 0xfeU))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test if clear state is done */
#define DEM_QUEUE_TESTCLEARSTATE_DONE(State)     ((uint8)((State) & 0x02U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear state done */
#define DEM_QUEUE_SETCLEARSTATE_DONE(State)      ((uint8)((State) | 0x02U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset clear state done */
#define DEM_QUEUE_RESETCLEARSTATE_DONE(State)    ((uint8)((State) & 0xfdU))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test if clear state is cancel */
#define DEM_QUEUE_TESTCLEARSTATE_CANCEL(State)   ((uint8)((State) & 0x04U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear state cancel */
#define DEM_QUEUE_SETCLEARSTATE_CANCEL(State)    ((uint8)((State) | 0x04U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset clear state cancel */
#define DEM_QUEUE_RESETCLEARSTATE_CANCEL(State)  ((uint8)((State) & 0xfbU))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test if clear state is failed */
#define DEM_QUEUE_TESTCLEARSTATE_FAILED(State)   ((uint8)((State) & 0x08U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear state failed */
#define DEM_QUEUE_SETCLEARSTATE_FAILED(State)    ((uint8)((State) | 0x08U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset clear state failed */
#define DEM_QUEUE_RESETCLEARSTATE_FAILED(State)  ((uint8)((State) & 0xf7U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test if clear state is NV failed */
#define DEM_QUEUE_TESTCLEARSTATE_NVFAILED(State) ((uint8)((State) & 0x10U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set clear state NV failed */
#define DEM_QUEUE_SETCLEARSTATE_NVFAILED(State)  ((uint8)((State) | 0x10U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset clear state NV failed */
#define DEM_QUEUE_RESETCLEARSTATE_NVFAILED(State) ((uint8)((State) & 0xefU))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Internal queuing status 'nothing - queued/pending - non-queued/pending' - */
/*! Get queue state part of an event's queue state */
#define DEM_QUEUE_GET_QUEUESTATE(Action)         ((Action) & 0xc0U)                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set queue state part of an event's queue state */
#define DEM_QUEUE_SET_QUEUESTATE(Action, s)      ((uint8)(((uint8)((Action) & 0x3fU)) | ((uint8)((s) & 0xc0U))))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get queue action part of an event's queue state */
#define DEM_QUEUE_GET_QUEUEACTION(Action)        ((Action) & 0x1fU)                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set queue action part of an event's queue state */
#define DEM_QUEUE_SET_QUEUEACTION(Action, s)     ((uint8)(((uint8)((Action) & 0xe0U)) | ((uint8)((s) & 0x1fU))))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Internal queuing status 'fdc processing required' ----------------------- */
/*! Test FDC threshold flag of an event's queue state */
#define DEM_QUEUE_TEST_FDCPROCESSING(Action)     ((boolean)(((Action) & 0x20U) != 0))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set FDC threshold flag of an event's queue state */
#define DEM_QUEUE_SET_FDCPROCESSING(Action)      ((uint8)((Action) | 0x20U))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset FDC threshold flag of an event's queue state */
#define DEM_QUEUE_RESET_FDCPROCESSING(Action)    ((uint8)((Action) & 0xdfU))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

                                                           /* Data Provision */
/* ------------------------------------------------------------------------- */
/*! Test userdata changed flag of data changed state */
#define DEM_DATA_TEST_USERDATA_CHANGED(Status)   (((Status) & DEM_DATA_USERDATA_CHANGED) != 0)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set userdata changed flag of data changed state */
#define DEM_DATA_SET_USERDATA_CHANGED(Status)    ((uint8)((Status) | DEM_DATA_USERDATA_CHANGED))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test statistics changed flag of data changed state */
#define DEM_DATA_TEST_STATISTICS_CHANGED(Status)  (((Status) & DEM_DATA_STATISTICS_CHANGED) != 0)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set statistics changed flag of data changed state */
#define DEM_DATA_SET_STATISTICS_CHANGED(Status)  ((uint8)((Status) | DEM_DATA_STATISTICS_CHANGED))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test normal sample update flag of time series update state */
#define DEM_DATA_TEST_NORMAL_SAMPLE_UPDATE(Status)  (((Status) & DEM_DATA_NORMAL_SAMPLE_UPDATE) != 0)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set normal sample update flag of time series update state */
#define DEM_DATA_SET_NORMAL_SAMPLE_UPDATE(Status)  ((uint8)((Status) | DEM_DATA_NORMAL_SAMPLE_UPDATE))                           /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test fast sample update flag of time series update state */
#define DEM_DATA_TEST_FAST_SAMPLE_UPDATE(Status)   (((Status) & DEM_DATA_FAST_SAMPLE_UPDATE) != 0)                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set fast sample update flag of time series update state */
#define DEM_DATA_SET_FAST_SAMPLE_UPDATE(Status)    ((uint8)((Status) | DEM_DATA_FAST_SAMPLE_UPDATE))                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/* Status bit 'testFailed' ------------------------------------------------- */
/*! Test test failed state of UDS status byte */
#define DEM_ESM_TEST_UDS_STATUS_TF(Status)       (((Status) & DEM_UDS_STATUS_TF) != 0)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set test failed state of UDS status byte */
#define DEM_ESM_SET_UDS_STATUS_TF(Status)        ((uint8)((Status) | DEM_UDS_STATUS_TF))                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset test failed state of UDS status byte */
#define DEM_ESM_RESET_UDS_STATUS_TF(Status)      ((uint8)((Status) & DEM_UDS_STATUS_TF_MASK))                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'testFailedThisOperationCycle' ------------------------------- */
/*! Test test failed this operating cycle state of UDS status byte */
#define DEM_ESM_TEST_UDS_STATUS_TFTOC(Status)    (((Status) & DEM_UDS_STATUS_TFTOC) != 0)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set test failed this operating cycle state of UDS status byte */
#define DEM_ESM_SET_UDS_STATUS_TFTOC(Status)     ((uint8)((Status) | DEM_UDS_STATUS_TFTOC))                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset test failed this operating cycle state of UDS status byte */
#define DEM_ESM_RESET_UDS_STATUS_TFTOC(Status)   ((uint8)((Status) & DEM_UDS_STATUS_TFTOC_MASK))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'pendingDTC' ------------------------------------------------- */
/*! Test pending DTC state of UDS status byte */
#define DEM_ESM_TEST_UDS_STATUS_PDTC(Status)     (((Status) & DEM_UDS_STATUS_PDTC) != 0)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set pending DTC state of UDS status byte */
#define DEM_ESM_SET_UDS_STATUS_PDTC(Status)      ((uint8)((Status) | DEM_UDS_STATUS_PDTC))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset pending DTC state of UDS status byte */
#define DEM_ESM_RESET_UDS_STATUS_PDTC(Status)    ((uint8)((Status) & DEM_UDS_STATUS_PDTC_MASK))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'confirmedDTC' ----------------------------------------------- */
/*! Test confirmed DTC state of UDS status byte */
#define DEM_ESM_TEST_UDS_STATUS_CDTC(Status)     (((Status) & DEM_UDS_STATUS_CDTC) != 0)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set confirmed DTC state of UDS status byte */
#define DEM_ESM_SET_UDS_STATUS_CDTC(Status)      ((uint8)((Status) | DEM_UDS_STATUS_CDTC))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset confirmed DTC state of UDS status byte */
#define DEM_ESM_RESET_UDS_STATUS_CDTC(Status)    ((uint8)((Status) & DEM_UDS_STATUS_CDTC_MASK))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'testNotCompletedSinceLastClear' ----------------------------- */
/*! Test test not completed since last clear state of UDS status byte */
#define DEM_ESM_TEST_UDS_STATUS_TNCSLC(Status)   (((Status) & DEM_UDS_STATUS_TNCSLC) != 0)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set test not completed since last clear state of UDS status byte */
#define DEM_ESM_SET_UDS_STATUS_TNCSLC(Status)    ((uint8)((Status) | DEM_UDS_STATUS_TNCSLC))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset test not completed since last clear state of UDS status byte */
#define DEM_ESM_RESET_UDS_STATUS_TNCSLC(Status)  ((uint8)((Status) & DEM_UDS_STATUS_TNCSLC_MASK))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'testFailedSinceLastClear' ----------------------------------- */
/*! Test test failed since last clear state of UDS status byte */
#define DEM_ESM_TEST_UDS_STATUS_TFSLC(Status)    (((Status) & DEM_UDS_STATUS_TFSLC) != 0)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set test failed since last clear state of UDS status byte */
#define DEM_ESM_SET_UDS_STATUS_TFSLC(Status)     ((uint8)((Status) | DEM_UDS_STATUS_TFSLC))                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset test failed since last clear state of UDS status byte */
#define DEM_ESM_RESET_UDS_STATUS_TFSLC(Status)   ((uint8)((Status) & DEM_UDS_STATUS_TFSLC_MASK))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'testNotCompletedThisOperationCycle' ------------------------- */
/*! Test test not completed this operating cycle state of UDS status byte */
#define DEM_ESM_TEST_UDS_STATUS_TNCTOC(Status)   (((Status) & DEM_UDS_STATUS_TNCTOC) != 0)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set test not completed this operating cycle state of UDS status byte */
#define DEM_ESM_SET_UDS_STATUS_TNCTOC(Status)    ((uint8)((Status) | DEM_UDS_STATUS_TNCTOC))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset test not completed this operating cycle state of UDS status byte */
#define DEM_ESM_RESET_UDS_STATUS_TNCTOC(Status)  ((uint8)((Status) & DEM_UDS_STATUS_TNCTOC_MASK))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'warningIndicatorRequested' ---------------------------------- */
/*! Test warning indicator requested state of UDS status byte */
#define DEM_ESM_TEST_UDS_STATUS_WIR(Status)      (((Status) & DEM_UDS_STATUS_WIR) != 0)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set warning indicator requested state of UDS status byte */
#define DEM_ESM_SET_UDS_STATUS_WIR(Status)       ((uint8)((Status) | DEM_UDS_STATUS_WIR))                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset warning indicator requested state of UDS status byte */
#define DEM_ESM_RESET_UDS_STATUS_WIR(Status)     ((uint8)((Status) & DEM_UDS_STATUS_WIR_MASK))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Bitfield for enable condition states ------------------------------------ */
/*! Set enable condition state in enable conditions state bitfield */
#define DEM_ESM_SET_ENABLECONDITION(Reg, Idx)    ((Reg) | (uint32)(((uint32)1u) << (Idx)))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset enable condition state in enable conditions state bitfield */
#define DEM_ESM_RESET_ENABLECONDITION(Reg, Idx)  ((Reg) & ((uint32)(~((uint32)(((uint32)1u) << (Idx))))))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Test enable condition state in enable conditions state bitfield */
#define DEM_ESM_TEST_ENABLECONDITION(Reg, Idx)   ((Reg) & ((uint32)(((uint32)1u) << (Idx))))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/*! Selector expression to distinguish between combined and non-combined setups */
# define Dem_Esm_SelectStorageEffects(EventContext) (EventContext)->DtcEffects                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
/*! Selector expression to distinguish between combined and non-combined setups */
# define Dem_Esm_SelectStorageEffects(EventContext) (EventContext)->EventEffects                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

/* Entry->State currently used bits: 0x89 */
/*! Get qualified DTC states of memory entry status byte */
#define DEM_MEM_GET_QUALIFIED_MASK(Reg)          ((uint8)((Reg) | 0x77U)) /* Returns a mask, hence the | operator */             /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set qualified DTC states of memory entry status byte */
#define DEM_MEM_SET_QUALIFIED_MASK(Reg, Mask)    ((uint8)(((Reg) & 0x77U) | ((Mask) & 0x88U)))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test aging only state of memory entry status byte */
#define DEM_MEM_TEST_AGING_ONLY(State)           ((uint8)((State) & 0x01U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set aging only state of memory entry status byte */
#define DEM_MEM_SET_AGING_ONLY(State)            ((uint8)((State) | 0x01U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset aging only state of memory entry status byte */
#define DEM_MEM_RESET_AGING_ONLY(State)          ((uint8)((State) & 0xfeU))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Initial transaction number of NV transaction state  */
#define DEM_MEM_INIT_COMMIT_NUMBER               (0x00U)
/*! Test commit started state of NV transaction state */
#define DEM_MEM_TEST_COMMIT_STARTED(State)       ((uint8)((State) & 0x80U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set commit started state of NV transaction state */
#define DEM_MEM_SET_COMMIT_STARTED(State)        ((uint8)((State) | 0x80U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set commit finished state of NV transaction state */
#define DEM_MEM_SET_COMMIT_FINISHED(State)       ((uint8)(((State) + 1) & 0x7fU))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/*! Get memory overflow state */
# define Dem_Mem_GetMemoryOverflow()             (Dem_Cfg_AdminData.MemoryOverflow)                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set memory overflow state */
# define Dem_Mem_SetMemoryOverflow(Value)        (Dem_Cfg_AdminData.MemoryOverflow = (Value))                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Prestorage */
#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/*! Get EventId of a prestored entry */
# define Dem_Mem_PrestoredEntryGetEventId(Entry)  ((Entry)->EventId)                                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set EventId of a prestored entry */
# define Dem_Mem_PrestoredEntrySetEventId(Entry, Id)  (Entry)->EventId = (Id)                                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get index of next prestored entry */
# define Dem_Mem_PrestoredEntryGetNext(Entry)    ((Dem_Cfg_PrestorageIndexType)((Entry)->EventId))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set index of next prestored entry */
# define Dem_Mem_PrestoredEntrySetNext(Entry, Idx)  (Entry)->EventId = (Dem_EventIdType)(Idx)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get state of a prestored entry */
# define Dem_Mem_PrestoredEntryGetState(Entry)   ((Entry)->State)                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set state of a prestored entry */
# define Dem_Mem_PrestoredEntrySetState(Entry, Status)  (Entry)->State = (Status)                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get data buffer for UDS snapshot record data of a prestored entry */
# define Dem_Mem_PrestoredEntryGetSRecDataPtr(Entry)  (&((Entry)->SnapshotData[0]))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get data buffer for OBD freeze frame data of a prestored entry */
# define Dem_Mem_PrestoredEntryGetObdIIFFDataPtr(Entry)  (&((Entry)->ObdFreezeFrame[0]))                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get data buffer for WWH-OBD freeze frame data of a prestored entry */
# define Dem_Mem_PrestoredEntryGetWwhObdFFDataPtr(Entry)  (&((Entry)->ObdFreezeFrameData[0]))                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get data buffer for J1939 freeze frame data of a prestored entry */
# define Dem_Mem_PrestoredEntryGetJ1939FFDataPtr(Entry)  (&((Entry)->J1939FreezeFrame[0]))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Event Memory */
/*! Get EventId of a memory entry */
#define Dem_Mem_EntryGetEventId(Entry)           ((Entry)->EventId)                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set EventId of a memory entry */
#define Dem_Mem_EntrySetEventId(Entry, Id)       (Entry)->EventId = (Id)                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get TimeStamp of a memory entry */
#define Dem_Mem_EntryGetTimestamp(Entry)         ((Entry)->Timestamp)                                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set TimeStamp of a memory entry */
#define Dem_Mem_EntrySetTimestamp(Entry, Time)   (Entry)->Timestamp = (Time)                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get max debounce value of a memory entry */
#define Dem_Mem_EntryGetDebounceValueMax(Entry)  ((Entry)->MaxDebounceValue)                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set max debounce value of a memory entry */
#define Dem_Mem_EntrySetDebounceValueMax(Entry, Cnt)  (Entry)->MaxDebounceValue = (Cnt)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get state of a memory entry */
#define Dem_Mem_EntryGetState(Entry)             ((Entry)->State)                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set state of a memory entry */
#define Dem_Mem_EntrySetState(Entry, Status)     (Entry)->State = (Status)                                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Macros are optional to ease identifying coding errors */
/*! Get aging count of a memory entry */
#define Dem_Mem_EntryGetAgingCount(Entry)        ((Entry)->AgingCounter)                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set aging count of a memory entry */
#define Dem_Mem_EntrySetAgingCount(Entry, Cnt)   (Entry)->AgingCounter = (Cnt)                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Macros are optional to ease identifying coding errors */
#if (DEM_FEATURE_NEED_OCC_COUNTER == STD_ON)
/*! Get occurrence count of a memory entry */
# define Dem_Mem_EntryGetOccurrenceCount(Entry)  ((Entry)->OccurrenceCounter)                                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set occurrence count of a memory entry */
# define Dem_Mem_EntrySetOccurrenceCount(Entry, Cnt)  (Entry)->OccurrenceCounter = (Cnt)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Macros are optional to ease identifying coding errors */
#if (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
/*! Get failed cycle count of a memory entry */
# define Dem_Mem_EntryGetFailedCycleCount(Entry)  ((Entry)->FailedCycleCounter)                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set failed cycle count of a memory entry */
# define Dem_Mem_EntrySetFailedCycleCount(Entry, Cnt)  (Entry)->FailedCycleCounter = (Cnt)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
/*! Get consecutive failed cycle count of a memory entry */
# define Dem_Mem_EntryGetConsecutiveFailedCycleCount(Entry)  ((Entry)->ConsecutiveFailedCycleCounter)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set consecutive failed cycle count of a memory entry */
# define Dem_Mem_EntrySetConsecutiveFailedCycleCount(Entry, Cnt)  (Entry)->ConsecutiveFailedCycleCounter = (Cnt)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
/*! Get first failed cycle count of a memory entry */
# define Dem_Mem_EntryGetFirstFailedCycleCount(Entry)  ((Entry)->CyclesSinceFirstFailed)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set first failed cycle count of a memory entry */
# define Dem_Mem_EntrySetFirstFailedCycleCount(Entry, Cnt)  (Entry)->CyclesSinceFirstFailed = (Cnt)                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
/*! Get tested since first failed cycle count of a memory entry */
# define Dem_Mem_EntryGetTestedSinceFirstFailedCycleCount(Entry)  ((Entry)->TestedCyclesSinceFirstFailed)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set tested since first failed cycle count of a memory entry */
# define Dem_Mem_EntrySetTestedSinceFirstFailedCycleCount(Entry, Cnt)  (Entry)->TestedCyclesSinceFirstFailed = (Cnt)             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
/*! Get last failed cycle count of a memory entry */
# define Dem_Mem_EntryGetLastFailedCycleCount(Entry)  ((Entry)->CyclesSinceLastFailed)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set last failed cycle count of a memory entry */
# define Dem_Mem_EntrySetLastFailedCycleCount(Entry, Cnt)  (Entry)->CyclesSinceLastFailed = (Cnt)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/*! Get data buffer for WWH-OBD freeze frame data of a memory entry */
#define Dem_Mem_EntryGetWwhObdFFDataPtr(Entry)   (&((Entry)->ObdFreezeFrameData[0]))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get first failed event */
#define Dem_Mem_GetFirstFailedEvent()            (Dem_Cfg_StatusData.FirstFailedEvent)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set first failed event */
#define Dem_Mem_SetFirstFailedEvent(EventId)     (Dem_Cfg_StatusData.FirstFailedEvent = (EventId))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get first confirmed event */
#define Dem_Mem_GetFirstConfirmedEvent()         (Dem_Cfg_StatusData.FirstConfirmedEvent)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set first confirmed event */
#define Dem_Mem_SetFirstConfirmedEvent(EventId)  (Dem_Cfg_StatusData.FirstConfirmedEvent = (EventId))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get most recent failed event */
#define Dem_Mem_GetMostRecentFailedEvent()       (Dem_Cfg_StatusData.MostRecentFailedEvent)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set most recent failed event */
#define Dem_Mem_SetMostRecentFailedEvent(EventId)  (Dem_Cfg_StatusData.MostRecentFailedEvent = (EventId))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get most recent confirmed event */
#define Dem_Mem_GetMostRecentConfmdEvent()       (Dem_Cfg_StatusData.MostRecentConfmdEvent)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set most recent confirmed event */
#define Dem_Mem_SetMostRecentConfmdEvent(EventId)  (Dem_Cfg_StatusData.MostRecentConfmdEvent = (EventId))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test if an update is in progress in a memory state */
#define Dem_Mem_UpdateTestInProgress(State)      (DEM_MEM_TEST_COMMIT_STARTED(State) == TRUE)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get the first valid event memory index */
#define Dem_Mem_MemoryIndexAll_Begin()           (Dem_Cfg_MemoryPrimaryIndex())                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get the first invalid event memory index */
#define Dem_Mem_MemoryIndexAll_End()             (Dem_Mem_MemoryIndexAll_Begin() + Dem_Cfg_GlobalPrimaryMaxCount() + Dem_Cfg_GlobalSecondaryMaxCount()) /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Test if a memory index is used for an event memory block  */
#define Dem_Mem_IsMemoryEntryIndex(Index)        (((Index) >= Dem_Mem_MemoryIndexAll_Begin()) && ((Index) < Dem_Mem_MemoryIndexAll_End())) /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/*! Set permanent DTC block modification state */
# define Dem_Mem_PermanentSetBlockState(State)   Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryPermanentIndex(), State)           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set OBD freeze frame block modification state */
# define Dem_Mem_FreezeFrameSetBlockState(State) Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryFreezeFrameIndex(), State)         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set OBD IUMPR block modification state */
# define Dem_Mem_IumprSetBlockState(State)       Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryIumprIndex(), State)               /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set Admin block modification state */
# define Dem_Mem_AdminSetBlockState(State)       Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryAdminIndex(), State)               /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set EventStatus block modification state */
# define Dem_Mem_StatusSetBlockState(State)      Dem_Nvm_PendingStatusBlockState = (State)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set Event Availability block modification state */
# define Dem_Mem_EventAvailableSetBlockState(State)  Dem_Nvm_PendingEventAvailabilityBlockState = (State)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set modification state of a memory block by index */
# define Dem_Mem_SetBlockState(Index, State)     Dem_Nvm_SetBlockStateImmediate(Index, State)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set modification state of a memory block used for event memory by index */
# define Dem_Mem_MemorySetBlockState(Index, State)   Dem_Nvm_MemorySetBlockStateImmediate(Index, State)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set DebounceData block modification state */
# define Dem_Mem_DebounceSetBlockState(State)    Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryDebounceIndex(), State)            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
/*! Set Admin block modification state */
# define Dem_Mem_AdminSetBlockState(State)       Dem_Nvm_AdminSetBlockState(State)                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set EventStatus block modification state */
# define Dem_Mem_StatusSetBlockState(State)      Dem_Nvm_StatusSetBlockState(State)                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set Event Availability block modification state */
# define Dem_Mem_EventAvailableSetBlockState(State)  Dem_Nvm_EventAvailableSetBlockState(State)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set modification state of a memory index */
# define Dem_Mem_SetBlockState(Index, State)     Dem_Nvm_SetBlockState(Index, State)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set modification state of a memory block used for event memory by index */
# define Dem_Mem_MemorySetBlockState(Index, State)   Dem_Nvm_SetBlockState(Index, State)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set DebounceData block modification state */
# define Dem_Mem_DebounceSetBlockState(State)    Dem_Nvm_SetBlockState(Dem_Cfg_MemoryDebounceIndex(), State)                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_USE_NVM == STD_ON)
/*! Set block state of admin block (unchecked) */
# define Dem_Nvm_AdminSetBlockState(State)       (Dem_Nvm_SetBlockState(Dem_Cfg_MemoryAdminIndex(), State))                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get block state of status block */
# define Dem_Nvm_StatusGetBlockState()           (Dem_Nvm_GetBlockState(Dem_Cfg_MemoryStatusIndex()))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set block state of status block (unchecked) */
# define Dem_Nvm_StatusSetBlockState(State)      (Dem_Nvm_SetBlockState(Dem_Cfg_MemoryStatusIndex(), State))                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get block state of event available block */
# define Dem_Nvm_EventAvailableGetBlockState()   (Dem_Nvm_GetBlockState(Dem_Cfg_MemoryEventAvailableIndex()))                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set block state of event available block (unchecked) */
# define Dem_Nvm_EventAvailableSetBlockState(State) (Dem_Nvm_SetBlockState(Dem_Cfg_MemoryEventAvailableIndex(), State))          /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get block state of OBD freeze frame block */
# define Dem_Nvm_FreezeFrameGetBlockState()      (Dem_Nvm_GetBlockState(Dem_Cfg_MemoryFreezeFrameIndex()))                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get block state of permanent DTC block */
# define Dem_Nvm_PermanentGetBlockState()        (Dem_Nvm_GetBlockState(Dem_Cfg_MemoryPermanentIndex()))                         /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test if memory commits for a clear operation are pending */
# define Dem_Nvm_GetPendingClear()               (0 != Dem_Nvm_CommitData.PendingClearCount)                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Set event status memory block to changed if the status change is relevant */
# define DEM_NVM_CHECK_DIRTY_STATUS(oldStatus, newStatus) \
                                                 if (0 != (((oldStatus) ^ (newStatus)) & DEM_NVM_STATUS_MASK)) \
                                                 { Dem_Mem_StatusSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY); }                      /* PRQA S 3412,3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
#else /* DEM_CFG_USE_NVM == STD_OFF) */
/*! Set block state of admin block (unchecked) */
# define Dem_Nvm_AdminSetBlockState(state)                                                                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set block state of status block (unchecked) */
# define Dem_Nvm_StatusSetBlockState(state)                                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set block state of event available block (unchecked) */
# define Dem_Nvm_EventAvailableSetBlockState(state)                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Remove call to non-existing function */
# define Dem_Nvm_SetBlockState(Index, state)                                                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Remove call to non-existing function */
# define Dem_Nvm_SetBlockStateImmediate(Index, state)                                                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Set event status memory block to changed if the status change is relevant */
# define DEM_NVM_CHECK_DIRTY_STATUS(oldStatus, newStatus)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

/*! Map a DTC origin to a memory ID */
#define Dem_Dcm_MemoryIdFromOrigin(Origin)       (Dem_Dcm_MemoryIdMapping[Origin])                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_CFG_NOTIFY_DCM == STD_ON)
/*! Test if Dcm DTC status changed state is enabled */
# define Dem_Dcm_TestNotificationState()         (Dem_Dcm_NotificationState != FALSE)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set Dcm DTC status changed state */
# define Dem_Dcm_SetNotificationState(state)     (Dem_Dcm_NotificationState = (state))                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/*! Get filter criteria of Dcm filter info */
#define Dem_Dcm_FilterGetCriteria()              (Dem_Dcm_FilterInfo.FilterFlags)                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter criteria of Dcm filter info */
#define Dem_Dcm_FilterSetCriteria(Criteria)      (Dem_Dcm_FilterInfo.FilterFlags = (Criteria))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter status mask of Dcm filter info */
#define Dem_Dcm_FilterDtcGetStatusMask()         (Dem_Dcm_FilterInfo.Filter.Dtc.StatusMask)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter status mask of Dcm filter info */
#define Dem_Dcm_FilterDtcSetStatusMask(Mask)     (Dem_Dcm_FilterInfo.Filter.Dtc.StatusMask = (Mask))                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter memory id of Dcm filter info */
#define Dem_Dcm_FilterDtcGetMemoryId()           (Dem_Dcm_FilterInfo.Filter.Dtc.MemoryId)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter memory id of Dcm filter info */
#define Dem_Dcm_FilterDtcSetMemoryId(Id)         (Dem_Dcm_FilterInfo.Filter.Dtc.MemoryId = (Id))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
/*! Get filter severity mask of Dcm filter info */
# define Dem_Dcm_FilterDtcGetSeverityMask()      (Dem_Dcm_FilterInfo.Filter.Dtc.SeverityMask)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter severity mask of Dcm filter info */
# define Dem_Dcm_FilterDtcSetSeverityMask(Mask)  (Dem_Dcm_FilterInfo.Filter.Dtc.SeverityMask = (Dem_DTCSeverityType)(Mask))      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/*! Get event iterator position of Dcm filter info */
#define Dem_Dcm_FilterDtcGetEventIndex()         (Dem_Dcm_FilterInfo.Filter.Dtc.Iterator.EventIndex)                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set event iterator position of Dcm filter info */
#define Dem_Dcm_FilterDtcSetEventIndex(Index)    (Dem_Dcm_FilterInfo.Filter.Dtc.Iterator.EventIndex = (Index))                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get chronological iterator position of Dcm filter info */
#define Dem_Dcm_FilterDtcGetChronoIndex()        (Dem_Dcm_FilterInfo.Filter.Dtc.Iterator.ChronoIndex)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set chronological iterator position of Dcm filter info */
#define Dem_Dcm_FilterDtcSetChronoIndex(Index)   (Dem_Dcm_FilterInfo.Filter.Dtc.Iterator.ChronoIndex = (Index))                  /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter function pointer of Dcm filter info */
#define Dem_Dcm_FilterDtcGetFunctionPtr()        (Dem_Dcm_FilterInfo.pFilterDtcFunction)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter function pointer of Dcm filter info */
#define Dem_Dcm_FilterDtcSetFunctionPtr(FuncPtr) (Dem_Dcm_FilterInfo.pFilterDtcFunction = (FuncPtr))                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter fault detection counter of Dcm filter info */
#define Dem_Dcm_FilterDtcGetFdc()                (Dem_Dcm_FilterInfo.Filter.Dtc.FaultDetectionCounter)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter fault detection counter of Dcm filter info */
#define Dem_Dcm_FilterDtcSetFdc(Fdc)             (Dem_Dcm_FilterInfo.Filter.Dtc.FaultDetectionCounter = (Fdc))                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter snapshot records memory iterator position of Dcm filter info */
#define Dem_Dcm_FilterRecordGetMemIndex()        (Dem_Dcm_FilterInfo.Filter.Record.MemoryIndex)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter snapshot records memory iterator position of Dcm filter info */
#define Dem_Dcm_FilterRecordSetMemIndex(Index)   (Dem_Dcm_FilterInfo.Filter.Record.MemoryIndex = (Index))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter snapshot records snapshot iterator position of Dcm filter info */
#define Dem_Dcm_FilterRecordGetSRecIndex()       (Dem_Dcm_FilterInfo.Filter.Record.SnapshotIndex)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter snapshot records snapshot iterator position of Dcm filter info */
#define Dem_Dcm_FilterRecordSetSRecIndex(Index)  (Dem_Dcm_FilterInfo.Filter.Record.SnapshotIndex = (Index))                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter snapshot records iterator variable of Dcm filter info */
#define Dem_Dcm_FilterRecordGetIterator()        (&Dem_Dcm_FilterInfo.Filter.Record.Iterator)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter data state of Dcm filter info */
#define Dem_Dcm_FilterDataGetState()             (Dem_Dcm_FilterInfo.FilterDataState)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter data state of Dcm filter info */
#define Dem_Dcm_FilterDataSetState(State)        (Dem_Dcm_FilterInfo.FilterDataState = (State))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test operation cancelled state of Dcm filter info */
#define Dem_Dcm_FilterTestCancelled()            (Dem_Dcm_FilterInfo.FilterCancelled)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set operation cancelled state of Dcm filter info */
#define Dem_Dcm_FilterSetCancelled()             (Dem_Dcm_FilterInfo.FilterCancelled = TRUE)                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset operation cancelled state of Dcm filter info */
#define Dem_Dcm_FilterResetCancelled()           (Dem_Dcm_FilterInfo.FilterCancelled = FALSE)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter data eventId of Dcm filter info */
#define Dem_Dcm_FilterDataGetEventId()           (Dem_Dcm_FilterInfo.Filter.Data.EventId)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter data eventId of Dcm filter info */
#define Dem_Dcm_FilterDataSetEventId(Id)         (Dem_Dcm_FilterInfo.Filter.Data.EventId = (Id))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get filter data memory Id of Dcm filter info */
#define Dem_Dcm_FilterDataGetMemoryId()          (Dem_Dcm_FilterInfo.Filter.Data.MemoryId)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter data memory Id of Dcm filter info */
#define Dem_Dcm_FilterDataSetMemoryId(Id)        (Dem_Dcm_FilterInfo.Filter.Data.MemoryId = (Id))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* DTC Filter Criteria ------------ */
/*! Test filter criterion status mask */
#define DEM_DCM_TEST_FILTER_USESTATUSMASK(Criteria)     ((uint8)((Criteria) & 0x01U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter criterion status mask */
#define DEM_DCM_SET_FILTER_USESTATUSMASK(Criteria)      ((uint8)((Criteria) | 0x01U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset filter criterion status mask */
#define DEM_DCM_RESET_FILTER_USESTATUSMASK(Criteria)    ((uint8)((Criteria) & 0xfeU))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test filter criterion fault detection counter */
#define DEM_DCM_TEST_FILTER_USEFDC(Criteria)            ((uint8)((Criteria) & 0x02U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter criterion fault detection counter */
#define DEM_DCM_SET_FILTER_USEFDC(Criteria)             ((uint8)((Criteria) | 0x02U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset filter criterion fault detection counter */
#define DEM_DCM_RESET_FILTER_USEFDC(Criteria)           ((uint8)((Criteria) & 0xfdU))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test filter criterion severity mask */
#define DEM_DCM_TEST_FILTER_USESEVERITY(Criteria)       ((uint8)((Criteria) & 0x04U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter criterion severity mask */
#define DEM_DCM_SET_FILTER_USESEVERITY(Criteria)        ((uint8)((Criteria) | 0x04U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get filter criterion severity mask */
#define DEM_DCM_RESET_FILTER_USESEVERITY(Criteria)      ((uint8)((Criteria) & 0xfbU))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test filter criterion OBD format */
#define DEM_DCM_TEST_FILTER_DTCFORMAT_OBD(Criteria)     ((uint8)((Criteria) & 0x08U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter criterion OBD format */
#define DEM_DCM_SET_FILTER_DTCFORMAT_OBD(Criteria)      ((uint8)((Criteria) | 0x08U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset filter criterion OBD format */
#define DEM_DCM_RESET_FILTER_DTCFORMAT_OBD(Criteria)    ((uint8)((Criteria) & 0xf7U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Test filter criterion emission related */
#define DEM_DCM_TEST_FILTER_DTCKIND_EMISSION(Criteria)  ((uint8)((Criteria) & 0x10U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set filter criterion emission related */
#define DEM_DCM_SET_FILTER_DTCKIND_EMISSION(Criteria)   ((uint8)((Criteria) | 0x10U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset filter criterion emission related */
#define DEM_DCM_RESET_FILTER_DTCKIND_EMISSION(Criteria) ((uint8)((Criteria) & 0xefU))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* DTC Filter Event Reported Marker ------------ */
/*! Size of filtered event marker bitfield */
#define DEM_DCM_FILTER_CALC_MARKER_SIZE(NumEvents)      (uint16)(((NumEvents)+7)/8)                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Index of filtered event marker bitfield */
#define DEM_DCM_FILTER_CALC_MARKER_INDEX(EventId)       (uint16)((EventId)/8)                                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Bitmask of filtered event marker bitfield */
#define DEM_DCM_FILTER_CALC_MARKER_MASK(EventId)        (uint8)(0x01u << ((uint8)((EventId) % 8)))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Get event filtered bit in filtered event bitfield */
#define DEM_DCM_GET_FILTER_EVENT_MARKER(Value, Mask)    (uint8)((Value) & (Mask))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Set event filtered bit in filtered event bitfield */
#define DEM_DCM_SET_FILTER_EVENT_MARKER(Value, Mask)    (uint8)((Value) | (Mask))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Reset event filtered bit in filtered event bitfield */
#define DEM_DCM_RESET_FILTER_EVENT_MARKER(Value, Mask)  (uint8)((Value) & ~(Mask))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! NodeId value for J1939 */
# define DEM_J1939_NODE_ID            0x00U

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */
#if (DEM_FEATURE_NEED_SPECIAL_INDICATORS == STD_ON)                                                                              /* COV_MSR_UNSUPPORTED XF */
/*! Get global special indicator state */
#  define Dem_Util_GlobalSpecialIndicatorState(indicatorId)   Dem_Cfg_GlobalSpecialIndicatorStates[indicatorId][0]               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* ********************************************************************************************************************
 *  LOCAL DATA TYPES AND STRUCTURES
 *********************************************************************************************************************/

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

/*! Structure used as argument type for Dem_Util_ForEachCombinedEvent functions */
struct Dem_Util_ForEachCombinedArgType_s
{
  /*! Function arguments common to all functions */
  struct
  {
    uint8 OldDtcStatus;  /*!< [in] DtcStatus before the call */
    uint8 NewDtcStatus;  /*!< [out] DtcStatus after the call */
  } Common;
  /*! Function arguments specific to the called function */
  union
  {                                                                                                                              /* PRQA S 0750 */ /* MD_DEM_18.4 */
    /*! Function arguments specific to Dem_Esm_EventClearState */
    struct
    {
      uint8 unused;  /*!< no specific arguments, dummy only */
    } EventClearState;
    /*! Function arguments specific to Dem_Esm_EventDisplaced_Internal */
    struct
    {
      uint8 unused;  /*!< no specific arguments, dummy only */
    } EventDisplaced_Internal;
    /*! Function arguments specific to Dem_Esm_EventOpCycle_Internal */
    struct
    {
      uint8 CycleStatus;  /*!< [in] CycleStatus to set */
    } EventOpCycle_Internal;
    /*! Function arguments specific to Dem_Esm_EventAgingCycle_Internal */
    struct
    {
      uint8 unused;  /*!< no specific arguments, dummy only */
    } EventAgingCycle_Internal;
  } Specific;
};

/*! Argument type used for Dem_Util_ForEachCombinedEvent functions */
typedef struct Dem_Util_ForEachCombinedArgType_s Dem_Util_ForEachCombinedArgType;

/*! Reference to argument struct used for Dem_Util_ForEachCombinedEvent functions */
typedef P2VAR(Dem_Util_ForEachCombinedArgType, TYPEDEF, DEM_VAR_NOINIT) Dem_Util_ForEachCombinedArgPtrType;

/*! Function pointer type for Dem_Util_ForEachCombinedEvent functions */
typedef P2FUNC(void, DEM_CODE, Dem_Util_ForEachCombinedFuncType)(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr
  );

                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/*! Clear DTC request structure definition */
struct Dem_Queue_ClearRequestType_s
{
  Dem_EventIdType ClearEventId;  /*!< Specific EventId to clear */
  uint8  ClearMemoryId;  /*!< MemoryId to clear */
  uint8  ClearFormat;  /*!< DTC format of the clear request */
  uint8  ClearGroup;  /*!< DTC group to clear */
  uint8  ClearClient;  /*!< Client requesting the clear */
};

/*! Type to store a clear DTC request */
typedef struct Dem_Queue_ClearRequestType_s Dem_Queue_ClearRequestType;

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_OCC_COUNTER == STD_ON)
# if (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
/*! Type for DTC occurrence counter */
typedef uint16 Dem_Data_OccurrenceCounterType;
# else
/*! Type for DTC occurrence counter */
typedef uint8 Dem_Data_OccurrenceCounterType;
# endif
#endif

/*! Structure for DID data collection */
struct Dem_Data_CollectDidInfoType_s
{
  Dem_SharedDataPtrType  DestinationBuffer;  /*!< destination buffer receiving the DID data */
  Dem_EventIdType        EventId;  /*!< EventId for which data is collected */
  uint16                 BufferSize;  /*!< Buffer size of the destination buffer */
  uint16                 WriteIndex;  /*!< Current write index in the destination buffer */
};

/*! Type for DID collection information */
typedef struct Dem_Data_CollectDidInfoType_s Dem_Data_CollectDidInfoType;
/*! Pointer to type for DID collection information */
typedef P2VAR(Dem_Data_CollectDidInfoType, TYPEDEF, AUTOMATIC) Dem_Data_CollectDidInfoPtrType;

/*! Structure for DID data readout */
struct Dem_Data_CopyDidInfoType_s
{
  Dem_ConstSharedDataPtrType        SourceBuffer;  /*!< source buffer providing the DID data */
  Dem_SharedDataPtrType             DestinationBuffer;  /*!< destination buffer receiving the DID data */
  Dem_ConstSharedMemoryEntryPtrType Entry;  /*< memory entry holding the DTC data */
  Dem_EventIdType                   EventId;  /*!< EventId for which data is collected */
  uint16                            BufferSize;  /*!< Buffer size of the destination buffer */
  uint16                            ReadIndex;  /*!< Current read index from the source buffer */
  uint16                            WriteIndex;  /*!< Current write index in the destination buffer */
};

/*! Type for DID data readout */
typedef struct Dem_Data_CopyDidInfoType_s Dem_Data_CopyDidInfoType;
/*! Pointer to type for DID data readout */
typedef P2VAR(Dem_Data_CopyDidInfoType, TYPEDEF, AUTOMATIC) Dem_Data_CopyDidInfoPtrType;
/*! Non-writable pointer to type for DID data readout */
typedef P2CONST(Dem_Data_CopyDidInfoType, TYPEDEF, AUTOMATIC) Dem_Data_ConstCopyDidInfoPtrType;

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/*! Pointer to a prestorage entry */
typedef P2VAR(Dem_Cfg_PrestorageEntryType, TYPEDEF, DEM_VAR_NOINIT)  Dem_Mem_PrestoredEntryPtrType;
#endif

/*! Pointer to a event memory entry */
typedef P2VAR(Dem_Cfg_PrimaryEntryType, TYPEDEF, DEM_NVM_DATA)       Dem_Mem_EntryPtrType;
/*! Non-writeable pointer to a event memory entry */
typedef P2CONST(Dem_Cfg_PrimaryEntryType, TYPEDEF, DEM_NVM_DATA)     Dem_Mem_ConstEntryPtrType;

/*! Pointer to a chronology list */
typedef CONSTP2VAR(Dem_Cfg_MemoryIndexType, TYPEDEF, DEM_VAR_NOINIT) Dem_Mem_ChronoStackPtrType;
/*! Pointer to memory size variable */
typedef CONSTP2VAR(uint8, TYPEDEF, DEM_VAR_NOINIT)                   Dem_Mem_CurrentSizePtrType;

/*! Event Memory management data */
struct Dem_Mem_MemoryInfoType_s
{
  Dem_Mem_ChronoStackPtrType    ChronoPtr;  /*!< Pointer to the chronology list of the event memory */
  Dem_Mem_CurrentSizePtrType    SizePtr;  /*!< Pointer to the current size variable */
  Dem_Cfg_MemoryIndexType       FirstMemoryIndex;  /*!< First memory block index belonging to the memory */
  Dem_EventIdType               FirstEvent;  /*!< First event id belonging to the memory */
  Dem_EventIdType               LastEvent;  /*!< Last event Id belonging to the memory */
  uint8                         MaxSize;  /*!< Maximum number of memory entries for the memory */
  uint8                         MemoryId;  /*!< Handle to identify the event memory */
};

/*! Event Memory management data type */
typedef struct Dem_Mem_MemoryInfoType_s                              Dem_Mem_MemoryInfoType;
/*! Pointer to Event Memory management data */
typedef P2CONST(Dem_Mem_MemoryInfoType, TYPEDEF, DEM_CONST)          Dem_Mem_MemoryInfoPtrType;

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

/*! Function pointer type for event filter functions */
typedef P2FUNC(Dem_EventIdType, DEM_CODE, Dem_Dcm_FilterFuncPtrType) (
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)
  );
/*! Function pointer type for DTC number evaluation in clear requests */
typedef P2FUNC(Dem_ReturnClearDTCType, DEM_CODE, Dem_Dcm_ClearDtc_TestFuncPtrType)(
  CONST(uint32, AUTOMATIC),
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)
  );
/*! Pointer to list of DTC number evaluation function pointers */
typedef P2CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, TYPEDEF, DEM_CONST) Dem_Dcm_ClearDtc_TestPtrType;

/*! Iterator data for iterating over list of DTC number evaluation function pointers */
struct Dem_Dcm_ClearDtc_TestIterType_s
{
  Dem_Dcm_ClearDtc_TestPtrType TestFuncPtr;  /*!< List of DTC number evaluation function pointers iterated */
  uint8                        Index;  /*!< Current iteration index */
};

/*! Iterator data type for iterating over list of DTC number evaluation function pointers */
typedef struct Dem_Dcm_ClearDtc_TestIterType_s Dem_Dcm_ClearDtc_TestIterType;

/*! Cache data to speed up DTC lookup */
struct Dem_Dcm_CacheType_s
{
  uint32                     Dtc;  /*!< DTC number (external ID) */
  Dem_EventIdType            EventId;  /*!< EventId using that DTC number */
  uint8                      MemoryId;  /*!< MemoryId the event belongs to */
};

/*! Cache data type for DTC lookup */
typedef struct Dem_Dcm_CacheType_s Dem_Dcm_CacheType;
/*! Pointer to cache data for DTC lookup */
typedef P2VAR(Dem_Dcm_CacheType, TYPEDEF, DEM_VAR_NOINIT)  Dem_Dcm_DtcCachePtrType;
/*! Non-writeable pointer tor cache data for DTC lookup */
typedef P2CONST(Dem_Dcm_CacheType, TYPEDEF, DEM_VAR_NOINIT)  Dem_Dcm_ConstDtcCachePtrType;

/*! Filter data for Dcm 'filter DTC' requests */
struct Dem_Dcm_FilterDtcInfoType_s
{
  /*! Iterator data */
  union
  {                                                                                                                              /* PRQA S 0750 */ /* MD_DEM_18.4 */
    Dem_EventIdType          EventIndex;  /*!< Event iterator for linar order filtering */
    uint8                    ChronoIndex;  /*!< chronology iterator for chronological order filtering */
  }                          Iterator;
  uint8                      StatusMask;  /*!< Status mask filter */
  sint8                      FaultDetectionCounter;  /*!< FaultDetectionCounter for FDC filter */
  uint8                      MemoryId;  /*!< Filtered event memory */
#if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
  Dem_DTCSeverityType        SeverityMask;  /*!< Severity mask filter */
#endif
};

/*! Filter data for Dcm 'filter Record' requests */
struct Dem_Dcm_FilterRecordInfoType_s
{
  uint8                      MemoryIndex;  /*!< memory entry iterator position */
  uint8                      SnapshotIndex;  /*!< snapshot record iterator position */
  Dem_Cfg_EventSRecIterType  Iterator;  /*!< snapshot record configuration iterator position */
};

/*! Filter data for Dcm 'filter event data' requests */
struct Dem_Dcm_FilterDataInfoType_s
{
  Dem_EventIdType            EventId;  /*!< Filtered event Id */
  uint8                      MemoryId;  /*!< Filtered event memory */
};

/*! Filter data for Dcm requests */
struct Dem_Dcm_FilterInfoType_s
{
  union
  {                                                                                                                              /* PRQA S 0750 */ /* MD_DEM_18.4 */
    struct Dem_Dcm_FilterDtcInfoType_s    Dtc;  /*!< Filter data for Dcm 'filter DTC' requests */
    struct Dem_Dcm_FilterRecordInfoType_s Record;  /*!< Filter data for Dcm 'filter Record' requests */
    struct Dem_Dcm_FilterDataInfoType_s   Data;  /*!< Filter data for Dcm 'filter event data' requests */
  }                          Filter;
  uint8                      FilterFlags;  /*!< Filter flags */
  uint8                      FilterDataState;  /*!< Event data lock state */
  boolean                    FilterCancelled;  /*!< Cancellation state */
  Dem_Dcm_FilterFuncPtrType  pFilterDtcFunction;  /*!< Active filter function */
};

/*! Filter data type for Dcm requests */
typedef struct Dem_Dcm_FilterInfoType_s Dem_Dcm_FilterInfoType;

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/*! De-bounce algorithm management data type */
typedef struct Dem_DebounceInfoType_s Dem_DebounceInfoType;

/*! De-bouncing function pointer for functions without return value */
typedef P2FUNC(void, DEM_CODE, DebounceVoidFunctionPtr)(
  CONSTP2VAR(Dem_DebounceInfoType, AUTOMATIC, AUTOMATIC)
  );
/*! De-bouncing function pointer for functions with boolean return value */
typedef P2FUNC(boolean, DEM_CODE, DebounceBoolFunctionPtr)(
  CONSTP2VAR(Dem_DebounceInfoType, AUTOMATIC, AUTOMATIC)
  );

/*! De-bouncing function pointer table  */
struct Dem_DebounceFunctionTable_s
{
  DebounceBoolFunctionPtr Calculate;  /*!< de-bouncing calculation function */
  DebounceBoolFunctionPtr Validate;  /*!< de-bouncing validation function */
  DebounceVoidFunctionPtr Commit;  /*!< de-bouncing state commit function */
  DebounceVoidFunctionPtr Freeze;  /*!< freeze de-bouncing function */
  DebounceVoidFunctionPtr Reset;  /*!< reset de-bouncing function */
};

/*! De-bouncing function pointer table type */
typedef struct Dem_DebounceFunctionTable_s Dem_DebounceFunctionTableType;
/*! Non-writeable pointer to debouncing function pointer table */
typedef P2CONST(Dem_DebounceFunctionTableType, TYPEDEF, DEM_CONST) Dem_DebounceFunctionTablePtrType;

/*! De-bounce algorithm management data */
struct Dem_DebounceInfoType_s
{
  /*! Data common to all de-bounce algorithms */
  struct
  {
    Dem_DebounceFunctionTablePtrType FunctionTable;  /*!< [in] Function pointer table for the de-bouncing type */
    Dem_EventIdType EventId;  /*!< [in] De-bounced event id */
    Dem_EventStatusType MonitorStatus;  /*!< [in,out] Reported/Effective monitor status */
    boolean DebouncingChanged;  /*!< Status change indication */
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
    boolean RequestProcessing;  /*!< FDC Status change indication */
#endif
  } Common;
  /*! Data for specific de-bounce algorithms */
  union
  {                                                                                                                              /* PRQA S 0750 */ /* MD_DEM_18.4 */
    /*! Data for counter-based debouncing */
    struct
    {
      sint16 OldDebounceValue;  /*!< [in] de-bounce counter before processing */
      sint16 NewDebounceValue;  /*!< [out] de-bounce counter after processing */
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
      Dem_Cfg_EventInternalStatusType OldInternalStatus;  /*!< [in] internal event status before processing */
      Dem_Cfg_EventInternalStatusType NewInternalStatus;  /*!< [out] internal event status after processing */
#endif
    } CounterBased;
    struct
    {
      Dem_Cfg_EventInternalStatusType OldInternalStatus;  /*!< [in] internal event status before processing */
      Dem_Cfg_EventInternalStatusType NewInternalStatus;  /*!< [out] internal event status after processing */
    } TimeBased;
    struct
    {
      sint16 OldMonitorStatus;  /*!< [in] Last monitor result before processing */
      sint16 NewMonitorStatus;  /*!< [out] Last monitor result after processing */
    } MonitorInternal;
  } Specific;
};

/*! Pointer to de-bounce algorithm management data */
typedef P2VAR(Dem_DebounceInfoType, TYPEDEF, AUTOMATIC) Dem_DebounceInfoPtrType;
/*! Non-writeable pointer to de-bounce algorithm management data */
typedef P2CONST(Dem_DebounceInfoType, TYPEDEF, AUTOMATIC) Dem_ConstDebounceInfoPtrType;

/*! Event status processing data */
struct Dem_Esm_EventContext_s
{
  Dem_EventIdType EventId;  /*!< [in] processed Event */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType GroupId;  /*!< [in] combination group of the event */
  uint8 OldDtcStatus;  /*!< [in] DTC status before processing */
  uint8 NewDtcStatus;  /*!< [in,out] DTC status after processing */
  uint8 DtcEffects;  /*!< [in,out] status change triggers resulting from DTC status changes */
#endif
  uint8 OldEventStatus;  /*!< [in] event status before processing */
  uint8 NewEventStatus;  /*!< [in,out] event status after processing */
  uint8 EventEffects;  /*!< [in,out] status change triggers resulting from event status changes */
};

/*! Event status processing data type */
typedef struct Dem_Esm_EventContext_s Dem_Esm_EventContextType;

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/*! NV commit management data */
struct Dem_Nvm_CommitDataType_s
{
  Dem_Cfg_MemoryIndexType MemoryIndex;  /*!< Currently processed memory block */
  uint8 PendingCount;  /*!< Number of pending commits */
  uint8 WriteState;  /*!<State of current commit */
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
  uint8 PendingClearCount;  /*!< Number of pending cleared block commits */
  boolean BlockIsCleared;  /*!< Indication if the currently processed block was cleared */
# endif
};
/*! NV commit management data type*/
typedef struct Dem_Nvm_CommitDataType_s Dem_Nvm_CommitDataType;
#endif

/* ********************************************************************************************************************
 *  LOCAL DATA
 *********************************************************************************************************************/

                                                            /* Administrator */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_INIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! Initialization state of the Dem */
DEM_LOCAL VAR(uint8, DEM_VAR_INIT)               Dem_InitState = DEM_INIT_UNINITIALIZED;

#define DEM_STOP_SEC_VAR_INIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! Current state of enable conditions */
DEM_LOCAL volatile VAR(uint32, DEM_VAR_NOINIT)   Dem_CurrentEnableConditionStates;
#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/*! Pending enable condition state changes */
DEM_LOCAL volatile VAR(uint32, DEM_VAR_NOINIT)   Dem_NextEnableConditionStates;
#endif

#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
/*! Current state of storage conditions */
DEM_LOCAL volatile VAR(uint32, DEM_VAR_NOINIT)   Dem_StorageConditionStates;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                                    /* Timer */
/* ------------------------------------------------------------------------- */
#define DEM_START_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_STOP_SEC_VAR_NOINIT_16BIT                                                                                            /* PRQA S 5087 */ /* MD_MSR_19.1 */
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */
                                                                   /* Queues */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
/*! Read index of chronological BSW queue */
DEM_LOCAL volatile VAR(uint8, DEM_VAR_NOINIT)    Dem_Queue_EventReadIndex;
/*! Write index of chronological BSW queue */
DEM_LOCAL volatile VAR(uint8, DEM_VAR_NOINIT)    Dem_Queue_EventWriteIndex;
#endif

/*! State of clear requests */
DEM_LOCAL volatile VAR(uint8, DEM_VAR_NOINIT)    Dem_Queue_ClearState;

#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! Pending operating cycle states */
DEM_LOCAL VAR(uint16, DEM_VAR_NOINIT)            Dem_Queue_CycleState;
/*! Operating cycle states update flags */
DEM_LOCAL volatile VAR(uint16, DEM_VAR_NOINIT)   Dem_Queue_CycleFlag;
/*! Number of events with pending update */
DEM_LOCAL volatile VAR(uint16, DEM_VAR_NOINIT)   Dem_Queue_EventCount;
#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT == STD_ON)
/*! ClearEvent run-time limitation state */
DEM_LOCAL VAR(uint16, DEM_VAR_NOINIT)            Dem_Queue_ClearEventIterator;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/*! Enable condition state after the last update on the task */
DEM_LOCAL VAR(uint32, DEM_VAR_NOINIT)            Dem_Queue_EnableConditionStates;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! ClearRequest data */
DEM_LOCAL volatile VAR(Dem_Queue_ClearRequestType, DEM_VAR_NOINIT)  Dem_Queue_ClearRequest;

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! Number of stored entries in primary memory */
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Mem_PrimaryCurrentCount;
#if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
/*! Number of stored entries in secondary memory */
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Mem_SecondaryCurrentCount;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! Current operating cycle states */
DEM_LOCAL VAR(uint16, DEM_VAR_NOINIT)            Dem_Mem_CurrentCycleState;
#define DEM_STOP_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! Current time stamp, used to establish a chronological ordering */
DEM_LOCAL VAR(uint32, DEM_VAR_NOINIT)            Dem_Mem_CurrentTimestamp;

#define DEM_STOP_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/*! Start of prestorage entry free list */
DEM_LOCAL VAR(Dem_Cfg_PrestorageIndexType, DEM_VAR_NOINIT)  Dem_Mem_PrestorageHeadIndex;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME_LR == STD_ON)
/*! Low resolution de-bouncing poll timer */
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Esm_DebounceLoResTimer;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/*! Prestorage entry locked for status processing */
DEM_LOCAL VAR(Dem_Cfg_PrestorageIndexType, DEM_VAR_NOINIT)  Dem_Esm_PrestorageLockedIndex;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/*! Pending status update for the event status NV block */
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Nvm_PendingStatusBlockState;
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) && (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
/*! Pending status update for the event availability NV block */
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Nvm_PendingEventAvailabilityBlockState;
#endif

#if (DEM_CFG_SUPPORT_NVM_APPL_SYNCHRONIZE == STD_ON)
/*! Pending request for NV synchronization */
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Nvm_SynchronizationRequest;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/*! Management data needed for immediate NV updates */
DEM_LOCAL VAR(Dem_Nvm_CommitDataType, DEM_VAR_NOINIT)  Dem_Nvm_CommitData;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                          /* ASR Service API */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_NOTIFY_DCM == STD_ON)
/*! Enable state of Dcm notifications */
DEM_LOCAL VAR(boolean, DEM_VAR_NOINIT)           Dem_Dcm_NotificationState;
#endif
#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/*! Filter data for Dcm filter requests */
DEM_LOCAL VAR(Dem_Dcm_FilterInfoType, DEM_VAR_NOINIT)  Dem_Dcm_FilterInfo;
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/*! DTC lookup caches */
DEM_LOCAL VAR(Dem_Dcm_CacheType, DEM_VAR_NOINIT)  Dem_Dcm_Cache[DEM_DCM_CLIENT_COUNT];                                           /* PRQA S 3218 */ /* MD_DEM_8.7 */
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  GLOBAL DATA
 *********************************************************************************************************************/

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_USE_INIT_POINTER == STD_ON)
/*! Currently active module configuration */
P2CONST(Dem_ConfigType, DEM_VAR_NOINIT, DEM_INIT_DATA)  Dem_GlobalConfigPtr;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
/*! Stores the code line where a run-time error has occurred */
uint16 Dem_LineOfRuntimeError;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  LOCAL INLINE FUNCTION DECLARATIONS
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

/* Internal Event status 'current de-bounce direction and action' (time)     */
#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
# if ( ((DEM_ESM_DEBOUNCE_COUNT_FAILED & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_COUNT_PASSED & 0x01) != 0) \
    || ((DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_FREEZE_FAILED & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_FREEZE_PASSED & 0x01) != 0) \
    || ((DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_RESET_FAILED & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_RESET_PASSED & 0x01) != 0) \
    || ((DEM_ESM_DEBOUNCE_DONE_FAILED & 0x01) == 0)  \
    || ((DEM_ESM_DEBOUNCE_DONE_PASSED & 0x01) != 0) )
#  error "Inconsistent state definition for timebased debouncing"
# endif
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetDebounceStatus
 *****************************************************************************/
/*!
 * \brief         Get the debounce status from internal status byte
 *
 * \details       Get the debounce status from internal status byte.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        The debounce status.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_GetDebounceStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* ****************************************************************************
 * Dem_Mem_SetDebounceStatus
 *****************************************************************************/
/*!
 * \brief         Set the debounce status in the internal status byte
 *
 * \details       Set the debounce status in the internal status byte. Only has
 *                effect if time-based de-bouncing is supported
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 * \param[in]     Status
 *                Debounce Status to set
 *
 * \return        Internal status byte with modified debounce status.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetDebounceStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) Status
  );

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Mem_TestDebounceDirection
 *****************************************************************************/
/*!
 * \brief         Get the debouncing direction from the internal status byte
 *
 * \details       Get the debouncing direction from the internal status byte
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        The debouncing direction.
 *
 * \config        DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_TestDebounceDirection(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* Internal event status 'storage' ----------------------------------------- */

/* ****************************************************************************
 * Dem_Mem_GetStoredStatus
 *****************************************************************************/
/*!
 * \brief         Get the stored status from internal status byte
 *
 * \details       Get the stored status from internal status byte.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        The stored status (Dem_Esm_StoredStatus)
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_GetStoredStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

/* ****************************************************************************
 * Dem_Mem_SetStoredStatus
 *****************************************************************************/
/*!
 * \brief         Set the stored status in the internal status byte
 *
 * \details       Set the stored status in the internal status byte.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        Internal status byte with modified stored status.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetStoredStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) Status
  );

/* Internal status bit 'event suppressed' ---------------------------------- */

/* ****************************************************************************
 * Dem_Mem_TestEventSuppressedStatus
 *****************************************************************************/
/*!
 * \brief         Test if event suppressed is set in the internal status
 *
 * \details       Test if event suppressed is set in the internal status
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        TRUE
 *                Flag is set
 * \return        FALSE
 *                Flag is not set
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestEventSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetEventSuppressedStatus
 *****************************************************************************/
/*!
 * \brief         Set event suppressed in the internal status.
 *
 * \details       Set event suppressed in the internal status.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag set.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetEventSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_ResetEventSuppressedStatus
 *****************************************************************************/
/*!
 * \brief         Reset event suppressed in the internal status
 *
 * \details       Reset event suppressed in the internal status.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag reset.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetEventSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* Internal status bit 'DTC suppressed' ------------------------------------ */

/* ****************************************************************************
 * Dem_Mem_TestDtcSuppressedStatus
 *****************************************************************************/
/*!
 * \brief         Test if DTC suppressed is set in the internal status
 *
 * \details       Test if DTC suppressed is set in the internal status
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        TRUE
 *                Flag is set
 * \return        FALSE
 *                Flag is not set
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestDtcSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetDtcSuppressedStatus
 *****************************************************************************/
/*!
 * \brief         Set DTC suppressed in the internal status
 *
 * \details       Set DTC suppressed in the internal status.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag set.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetDtcSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_ResetDtcSuppressedStatus
 *****************************************************************************/
/*!
 * \brief         Reset DTC suppressed in the internal status
 *
 * \details       Reset DTC suppressed in the internal status.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag reset.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetDtcSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* Internal status bit 'event available' ----------------------------------- */

/* ****************************************************************************
 * Dem_Mem_TestEventDisconnectedStatus
 *****************************************************************************/
/*!
 * \brief         Test if event disconnected is set in the internal status
 *
 * \details       Test if event disconnected is set in the internal status
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        TRUE
 *                Flag is set
 * \return        FALSE
 *                Flag is not set
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestEventDisconnectedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

/* ****************************************************************************
 * Dem_Mem_SetEventDisconnectedStatus
 *****************************************************************************/
/*!
 * \brief         Set event disconnected in the internal status
 *
 * \details       Set event disconnected in the internal status. Only has an
 *                effect if event availability is supported
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag set.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetEventDisconnectedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) || (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 * Dem_Mem_ResetEventDisconnectedStatus
 *****************************************************************************/
/*!
 * \brief         Reset event disconnected in the internal status
 *
 * \details       Reset event disconnected in the internal status. Only has an
 *                effect if event availability is supported
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag reset.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *             || DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetEventDisconnectedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* Internal status bit 'event crossed FDC threshold in this cycle' --------- */

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
/* ****************************************************************************
 * Dem_Mem_TestFdcTripStatus
 *****************************************************************************/
/*!
 * \brief         Test if event fdc trip is set in the internal status
 *
 * \details       Test if event fdc trip is set in the internal status
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        TRUE
 *                Flag is set
 * \return        FALSE
 *                Flag is not set
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_FDC_TRIP == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestFdcTripStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON) && (DEM_CFG_STORAGE_AT_FDC == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetFdcTripStatus
 *****************************************************************************/
/*!
 * \brief         Set event fdc trip in the internal status
 *
 * \details       Set event fdc trip in the internal status.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag set.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_DEBOUNCE == STD_ON && DEM_CFG_STORAGE_AT_FDC == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetFdcTripStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* ****************************************************************************
 * Dem_Mem_ResetFdcTripStatus
 *****************************************************************************/
/*!
 * \brief         Reset event fdc trip in the internal status
 *
 * \details       Reset event fdc trip in the internal status. Only has an
 *                effect if fdc trip is supported
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag reset.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetFdcTripStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

/* Internal status bit 'event maximum FDC updated since last clear' -------- */

#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_TestFdcMaxStatus
 *****************************************************************************/
/*!
 * \brief         Test if 'event fdc maximum exceeded' is set in the internal status
 *
 * \details       Test if 'event fdc maximum exceeded' is set in the internal status
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        TRUE
 *                Flag is set
 * \return        FALSE
 *                Flag is not set
 *
 * \pre           -
 * \config        DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestFdcMaxStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON) && (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetFdcMaxStatus
 *****************************************************************************/
/*!
 * \brief         Set 'event fdc maximum exceeded' in the internal status
 *
 * \details       Set flag 'event fdc maximum exceeded' in the internal status.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag set.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_DEBOUNCE == STD_ON
 *             && DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetFdcMaxStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* ****************************************************************************
 * Dem_Mem_ResetFdcMaxStatus
 *****************************************************************************/
/*!
 * \brief         Reset 'event fdc maximum exceeded' in the internal status
 *
 * \details       Reset'event fdc maximum exceeded' in the internal status. Only
 *                has an effect if maximum fdc is supported
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag reset.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetFdcMaxStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

/* Internal status bit 'event already crossed FDC threshold in this cycle' - */

#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) || (DEM_CFG_STORAGE_AT_FDC == STD_ON)
/* ****************************************************************************
 * Dem_Mem_TestFdcTocStatus
 *****************************************************************************/
/*!
 * \brief         Test if event fdc max this cycle is set in the internal status
 *
 * \details       Test if event fdc max this cycle is set in the internal status
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        TRUE
 *                Flag is set
 * \return        FALSE
 *                Flag is not set
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON
 *             || DEM_CFG_STORAGE_AT_FDC == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestFdcTocStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* ****************************************************************************
 * Dem_Mem_SetFdcTocStatus
 *****************************************************************************/
/*!
 * \brief         Set event fdc max this cycle in the internal status
 *
 * \details       Set event fdc max this cycle in the internal status. Only
 *                has an effect if maximum fdc calculation is supported
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag set.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetFdcTocStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

/* ****************************************************************************
 * Dem_Mem_ResetFdcTocStatus
 *****************************************************************************/
/*!
 * \brief         Reset event fdc max this cycle in the internal status
 *
 * \details       Reset event fdc max this cycle in the internal status. Only
 *                has an effect if maximum fdc calculation is supported
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag reset.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetFdcTocStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

/* Internal status bit 'DTC disabled by PB selectable' --------------------- */

/* ****************************************************************************
 * Dem_Mem_TestAvailableInVariantStatus
 *****************************************************************************/
/*!
 * \brief         Test if event available in variant is set in the internal status
 *
 * \details       Test if event available in variant is set in the internal status
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        TRUE
 *                Flag is set
 * \return        FALSE
 *                Flag is not set
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestAvailableInVariantStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetAvailableInVariantStatus
 *****************************************************************************/
/*!
 * \brief         Set event available in variant in the internal status
 *
 * \details       Set event available in variant in the internal status
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag set.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetAvailableInVariantStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* Internal status bit 'user controlled warning indicator' ----------------- */

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) || (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_TestUserControlledWirStatus
 *****************************************************************************/
/*!
 * \brief         Test if user controlled WIR is set in the internal status
 *
 * \details       Test if user controlled WIR is set in the internal status
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        TRUE
 *                Flag is set
 * \return        FALSE
 *                Flag is not set
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON
 *             || DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestUserControlledWirStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetUserControlledWirStatus
 *****************************************************************************/
/*!
 * \brief         Set user controlled WIR in the internal status
 *
 * \details       Set user controlled WIR in the internal status.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag set
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetUserControlledWirStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_ResetUserControlledWirStatus
 *****************************************************************************/
/*!
 * \brief         Reset user controlled WIR in the internal status
 *
 * \details       Reset user controlled WIR in the internal status.
 *
 * \param[in]     InternalStatus
 *                Internal status byte
 *
 * \return        InternalStatus with flag reset
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetUserControlledWirStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus
  );
#endif

/* ****************************************************************************
 * Dem_Mem_CycleGetCounter
 *****************************************************************************/
/*!
 * \brief         Get current counter of the cycle
 *
 * \details       Get current counter of the cycle
 *
 * \param[in]     CycleId
 *                Unique handle of the cycle
 *
 * \return        Current counter of the cycle
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_CycleGetCounter(
  CONST(uint8, AUTOMATIC) CycleId
  );

/* ****************************************************************************
 * Dem_Mem_CycleSetCounter
 *****************************************************************************/
/*!
 * \brief         Set current counter value of the cycle
 *
 * \details       Set current counter value of the cycle
 *
 * \param[in]     CycleId
 *                Unique handle of the cycle
 * \param[in]     CycleCounter
 *                New counter value of the cycle
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CycleSetCounter(
  CONST(uint8, AUTOMATIC) CycleId,
  CONST(uint16, AUTOMATIC) CycleCounter
  );

/* ****************************************************************************
 * Dem_Mem_EventGetStatus
 *****************************************************************************/
/*!
 * \brief         Get current status of the event
 *
 * \details       Get current status of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 *
 * \return        Current status of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_EventGetStatus(
  CONST(Dem_EventIdType, AUTOMATIC) EventId
  );

/* ****************************************************************************
 * Dem_Mem_EventSetStatus
 *****************************************************************************/
/*!
 * \brief         Set current status value of the event
 *
 * \details       Set current status value of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     Status
 *                New status of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetStatus(
  CONST(Dem_EventIdType, AUTOMATIC) EventId,
  CONST(uint8, AUTOMATIC) Status
  );

#if (DEM_FEATURE_NEED_TRIPCOUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EventGetTripCount
 *****************************************************************************/
/*!
 * \brief         Get current trip count of the event
 *
 * \details       Get current trip count of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 *
 * \return        Current trip count of the event
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_TRIPCOUNTER == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_EventGetTripCount(
  CONST(Dem_EventIdType, AUTOMATIC) EventId
  );
#endif

#if (DEM_FEATURE_NEED_TRIPCOUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EventSetStatus
 *****************************************************************************/
/*!
 * \brief         Set current trip count of the event
 *
 * \details       Set current trip count of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     TripCount
 *                New trip count of the event
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_TRIPCOUNTER == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetTripCount(
  CONST(Dem_EventIdType, AUTOMATIC) EventId,
  CONST(uint8, AUTOMATIC) TripCount
  );
#endif

/* ****************************************************************************
 * Dem_Mem_EventGetInternalStatus
 *****************************************************************************/
/*!
 * \brief         Get current internal status of the event
 *
 * \details       Get current internal status of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 *
 * \return        Current internal status of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_EventGetInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC) EventId
  );

/* ****************************************************************************
 * Dem_Mem_EventSetInternalStatus
 *****************************************************************************/
/*!
 * \brief         Set current internal status value of the event
 *
 * \details       Set current internal status value of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     Status
 *                New internal status of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC) EventId,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) Status
  );

/* ****************************************************************************
 * Dem_Mem_EventGetDebounceValue
 *****************************************************************************/
/*!
 * \brief         Get current debounce counter of the event
 *
 * \details       Get current debounce counter of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 *
 * \return        Current debounce counter of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(sint16, DEM_CODE)
Dem_Mem_EventGetDebounceValue(
  CONST(Dem_EventIdType, AUTOMATIC) EventId
  );

/* ****************************************************************************
 * Dem_Mem_EventSetDebounceValue
 *****************************************************************************/
/*!
 * \brief         Set current debounce value of the event
 *
 * \details       Set current debounce value of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     DebounceValue
 *                New debounce value of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetDebounceValue(
  CONST(Dem_EventIdType, AUTOMATIC) EventId,
  CONST(sint16, AUTOMATIC) DebounceValue
  );

#if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON) && (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EventGetDebounceValueMax
 *****************************************************************************/
/*!
 * \brief         Get current maximum debounce value of the event
 *
 * \details       Get current maximum debounce value of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 *
 * \return        Current maximum debounce value of the event
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON && DEM_FEATURE_NEED_DEBOUNCE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(sint16, DEM_CODE)
Dem_Mem_EventGetDebounceValueMax(
  CONST(Dem_EventIdType, AUTOMATIC) EventId
  );
#endif

/* ****************************************************************************
 * Dem_Mem_EventSetDebounceValueMax
 *****************************************************************************/
/*!
 * \brief         Set current maximum debounce value of the event
 *
 * \details       Set current maximum debounce value of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     DebounceValue
 *                New maximum debounce value of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetDebounceValueMax(
  CONST(Dem_EventIdType, AUTOMATIC) EventId,
  CONST(sint16, AUTOMATIC) DebounceValue
  );

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_CombinedGroupGetStatus
 *****************************************************************************/
/*!
 * \brief         Get current status of the combined group
 *
 * \details       Get current status of the combined group
 *
 * \param[in]     GroupId
 *                Unique handle of the combined group
 *
 * \return        Current status of the combined group
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_CombinedGroupGetStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC) GroupId
  );
#endif

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_CombinedGroupSetStatus
 *****************************************************************************/
/*!
 * \brief         Set current status of the combined group
 *
 * \details       Set current status of the combined group
 *
 * \param[in]     GroupId
 *                Unique handle of the combined group
 * \param[in]     Status
 *                New status of the combined group
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CombinedGroupSetStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC) GroupId,
  CONST(uint8, AUTOMATIC) Status
  );
#endif

/* ****************************************************************************
 * Dem_Mem_CombinedGroupGetInternalStatus
 *****************************************************************************/
/*!
 * \brief         Get current internal status of the combined group
 *
 * \details       Get current internal status of the combined group
 *
 * \param[in]     GroupId
 *                Unique handle of the combined group
 *
 * \return        Current internal status of the combined group
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_CombinedGroupGetInternalStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC) GroupId
  );

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_CombinedGroupSetInternalStatus
 *****************************************************************************/
/*!
 * \brief         Set current internal status of the combined group
 *
 * \details       Set current internal status of the combined group
 *
 * \param[in]     GroupId
 *                Unique handle of the combined group
 * \param[in]     Status
 *                New internal status the combined group
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CombinedGroupSetInternalStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC) GroupId,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) Status
  );
#endif

#if (DEM_FEATURE_NEED_OBD == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EventGetQualifyStatus
 *****************************************************************************/
/*!
 * \brief         Get current qualification status of the event
 *
 * \details       Get current qualification status of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 *
 * \return        Current qualification status of the event
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_OBD == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_EventGetQualifyStatus(
  CONST(Dem_EventIdType, AUTOMATIC) EventId
  );
#endif

#if (DEM_FEATURE_NEED_OBD == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EventSetQualifyStatus
 *****************************************************************************/
/*!
 * \brief         Set current qualification status of the event
 *
 * \details       Set current qualification status of the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     Status
 *                New qualification status of the event
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_OBD == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetQualifyStatus(
  CONST(Dem_EventIdType, AUTOMATIC) EventId,
  CONST(uint8, AUTOMATIC) Status
  );
# endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 * Dem_Mem_DebounceGetStoredValue
 *****************************************************************************/
/*!
 * \brief         Get the stored debounce value at position 'index'
 *
 * \details       Get the stored debounce value at position 'index'.
 *
 * \param[in]     Index
 *                Index of the debounce value
 *
 * \return        The stored debounce value
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(sint16, DEM_CODE)
Dem_Mem_DebounceGetStoredValue(
  CONST(uint16, AUTOMATIC) Index
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 * Dem_Mem_DebounceSetStoredValue
 *****************************************************************************/
/*!
 * \brief         Set the stored debounce value at position 'index'
 *
 * \details       Set the stored debounce value at position 'index'.
 *
 * \param[in]     Index
 *                Index of the debounce value
 * \param[in]     DebounceValue
 *                New stored debounce value at position 'index'
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_DebounceSetStoredValue(
  CONST(uint16, AUTOMATIC) Index,
  CONST(sint16, AUTOMATIC) DebounceValue
  );
#endif

#if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EventGetAvailableMask
 *****************************************************************************/
/*!
 * \brief         Get the event available mask at position 'index'
 *
 * \details       Get the event available mask at position 'index'.
 *
 * \param[in]     Index
 *                Index of the available mask
 *
 * \return        The event available mask at position 'index'
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_EventGetAvailableMask(
  CONST(uint16, AUTOMATIC) Index
  );
#endif

#if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EventSetAvailableMask
 *****************************************************************************/
/*!
 * \brief         Set the event available mask at position 'index'.
 *
 * \details       Set the event available mask at position 'index'.
 *
 * \param[in]     Index
 *                Index of the event available mask
 * \param[in]     Mask
 *                New event available mask at position 'index'
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetAvailableMask(
  CONST(uint16, AUTOMATIC) Index,
  CONST(uint8, AUTOMATIC) Mask
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageGetEntry
 *****************************************************************************/
/*!
 * \brief         Get the prestorage entry at position 'PrestorageIndex'
 *
 * \details       Get the prestorage entry at position 'PrestorageIndex'.
 *
 * \param[in]     PrestorageIndex
 *                Index of the prestorage entry
 *
 * \return        The prestorage entry at position 'PrestorageIndex'.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Mem_PrestoredEntryPtrType, DEM_CODE)
Dem_Mem_PrestorageGetEntry(
  CONST(Dem_Cfg_PrestorageIndexType, AUTOMATIC) PrestorageIndex
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageGetRef
 *****************************************************************************/
/*!
 * \brief         Get the prestorage index allocated to the event
 *
 * \details       Get the prestorage index allocated to the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 *
 * \return        Prestorage index allocated to the event
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageGetRef(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageSetRef
 *****************************************************************************/
/*!
 * \brief         Set the prestorage index allocated to the event
 *
 * \details       Set the prestorage index allocated to the event
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     PrestorageIndex
 *                Prestorage Index allocated to the event
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageSetRef(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Cfg_PrestorageIndexType, AUTOMATIC)  PrestorageIndex
  );
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryUpdateInit
 *****************************************************************************/
/*!
 * \brief         Init the update state of the memory block
 *
 * \details       Init the update state of the memory block
 *
 * \param[in]     MemoryIndex
 *                NV Block handle of the memory block
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateInit(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );

/* ****************************************************************************
 * Dem_Mem_MemoryUpdateStart
 *****************************************************************************/
/*!
 * \brief         Mark update started for the memory block
 *
 * \details       Mark update started for the memory block
 *
 * \param[in]     MemoryIndex
 *                NV Block handle of the memory block
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateStart(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );

/* ****************************************************************************
 * Dem_Mem_MemoryUpdateFinish
 *****************************************************************************/
/*!
 * \brief         Mark update finished for the memory block
 *
 * \details       Mark update finished for the memory block
 *
 * \param[in]     MemoryIndex
 *                NV Block handle of the memory block
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateFinish(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );

#if ( (DEM_CFG_SUPPORT_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
/* ****************************************************************************
 * Dem_Mem_MemoryUpdateGetState
 *****************************************************************************/
/*!
 * \brief         Get the update state of the memory block
 *
 * \details       Get the update state of the memory blockk
 *
 * \param[in]     MemoryIndex
 *                NV Block handle of the memory block
 *
 * \return        The update state of the memory block
 *
 * \pre           -
 * \config        ( (DEM_CFG_SUPPORT_ERECS == STD_ON)
 *               || (DEM_CFG_SUPPORT_SRECS == STD_ON)
 *               || (DEM_CFG_SUPPORT_OBDII == STD_ON)
 *               || (DEM_CFG_SUPPORT_WWHOBD == STD_ON)
 *               || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON)
 *               || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryUpdateGetState(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryGetEntry
 *****************************************************************************/
/*!
 * \brief         Get the Nth memory entry
 *
 * \details       Get the Nth memory entry
 *
 * \param[in]     MemoryIndex
 *                NV Block handle of the memory block
 *
 * \return        Pointer to the Nth memory entry
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Mem_EntryPtrType, DEM_CODE)
Dem_Mem_MemoryGetEntry(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );

/* ****************************************************************************
 * Dem_Mem_MemoryInfoInit
 *****************************************************************************/
/*!
 * \brief         Get the memory descriptor for the event memory
 *
 * \details       Get the memory descriptor for the event memory
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \return        Pointer to the memory descriptor for the event memory
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Mem_MemoryInfoPtrType, DEM_CODE)
Dem_Mem_MemoryInfoInit(
  CONST(uint8, AUTOMATIC)  MemoryId
  );

/* ****************************************************************************
 * Dem_Mem_MemoryGetId
 *****************************************************************************/
/*!
 * \brief         Get the identifier of the event memory
 *
 * \details       Get the identifier of the event memory
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 *
 * \return        Unique identifier of the event memory
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryGetId(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );

/* ****************************************************************************
 * Dem_Mem_MemoryGetChronology
 *****************************************************************************/
/*!
 * \brief         Get the Nth oldest memory index
 *
 * \details       Get the Nth oldest memory index. 0 Is the oldest index.
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 * \param[in]     ChronoIndex
 *                Index into chronology
 *
 * \return        NV Block handle of the memory entry
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryGetChronology(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  ChronoIndex
  );

/* ****************************************************************************
 * Dem_Mem_MemorySetChronology
 *****************************************************************************/
/*!
 * \brief         Set the Nth oldest memory index
 *
 * \details       Set the Nth oldest memory index. 0 Is the oldest index.
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 * \param[in]     ChronoIndex
 *                Index into chronology
 * \param[in]     MemoryIndex
 *                NV Block handle of the memory entry
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemorySetChronology(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  ChronoIndex,
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );

/* ****************************************************************************
 * Dem_Mem_MemoryIter_Begin
 *****************************************************************************/
/*!
 * \brief         Get the start memory index of the event memory
 *
 * \details       Get the start memory index of the event memory
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 *
 * \return        Memory index of the first memory entry belonging to the range
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryIter_Begin(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );

/* ****************************************************************************
 * Dem_Mem_MemoryIter_End
 *****************************************************************************/
/*!
 * \brief         Get the end memory index of the event memory
 *
 * \details       Get the end memory index of the event memory. The index
 *                returned does not belong to the event memory.
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 *
 * \return        Memory index of the first memory entry not belonging to the range
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryIter_End(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );

/* ****************************************************************************
 * Dem_Mem_MemoryGetMaxSize
 *****************************************************************************/
/*!
 * \brief         Get the size of the event memory
 *
 * \details       Get the size of the event memory
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 *
 * \return        The size of the event memory
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryGetMaxSize(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );

/* ****************************************************************************
 * Dem_Mem_MemoryGetCurrentSize
 *****************************************************************************/
/*!
 * \brief         Get the number of occupied entries in the event memory
 *
 * \details       Get the number of occupied entries in the event memory
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 *
 * \return        The number of occupied entries in the event memory
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryGetCurrentSize(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );

/* ****************************************************************************
 * Dem_Mem_MemorySetCurrentSize
 *****************************************************************************/
/*!
 * \brief         Set the number of occupied entries in the event memory
 *
 * \details       Set the number of occupied entries in the event memory
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 * \param[in]     Size
 *                New number of occupied entries in the event memory
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemorySetCurrentSize(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  Size
  );

/* ****************************************************************************
 * Dem_Mem_MemoryGetFirstEvent
 *****************************************************************************/
/*!
 * \brief         Get first event belonging to the event memory
 *
 * \details       Get first event belonging to the event memory
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 *
 * \return        Unique handle of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Mem_MemoryGetFirstEvent(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );

/* ****************************************************************************
 * Dem_Mem_MemoryGetLastEvent
 *****************************************************************************/
/*!
 * \brief         Get last event belonging to the event memory
 *
 * \details       Get last event belonging to the event memory. The event
 *                returned also belongs to the event memory
 *
 * \param[in]     MemoryInfo
 *                Pointer to the memory descriptor for the event memory
 *
 * \return        Unique handle of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Mem_MemoryGetLastEvent(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EntryGetERecDataPtr
 *****************************************************************************/
/*!
 * \brief         Get the Nth extended data buffer of the memory entry
 *
 * \details       Get the Nth extended data buffer of the memory entry
 *
 * \param[in]     MemoryEntry
 *                Pointer to the memory entry
 * \param[in]     ERecIndex
 *                Index of the extended data record
 *
 * \return        Pointer to the Nth extended data buffer
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_USER_ERECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_SharedDataPtrType, DEM_CODE)
Dem_Mem_EntryGetERecDataPtr(
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  ERecIndex
  );
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EntryGetERecConstDataPtr
 *****************************************************************************/
/*!
 * \brief         Get the indexed extended data buffer of the memory entry
 *
 * \details       Get the indexed extended data buffer of the memory entry
 *
 * \param[in]     MemoryEntry
 *                Pointer to the memory entry
 * \param[in]     ERecIndex
 *                Index of the extended data record
 *
 * \return        Const Pointer to the indexed extended data buffer
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_USER_ERECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ConstSharedDataPtrType, DEM_CODE)
Dem_Mem_EntryGetERecConstDataPtr(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  ERecIndex
  );
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EntryGetSRecDataPtr
 *****************************************************************************/
/*!
 * \brief         Get the indexed snapshot data buffer of the memory entry
 *
 * \details       Get the indexed snapshot data buffer of the memory entry
 *
 * \param[in]     MemoryEntry
 *                Pointer to the memory entry
 * \param[in]     SRecIndex
 *                Index of the snapshot data record
 *
 * \return        Pointer to the indexed snapshot data buffer
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_SharedDataPtrType, DEM_CODE)
Dem_Mem_EntryGetSRecDataPtr(
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  SRecIndex
  );
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Mem_EntryGetSRecConstDataPtr
 *****************************************************************************/
/*!
 * \brief         Get the indexed snapshot data buffer of the memory entry
 *
 * \details       Get the indexed snapshot data buffer of the memory entry
 *
 * \param[in]     MemoryEntry
 *                Pointer to the memory entry
 * \param[in]     SRecIndex
 *                Index of the snapshot data record
 *
 * \return        Const Pointer to the indexed snapshot data buffer
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ConstSharedDataPtrType, DEM_CODE)
Dem_Mem_EntryGetSRecConstDataPtr(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  SRecIndex
  );
#endif

/* ****************************************************************************
 * Dem_Mem_IndicatorGetEventCountContinuous
 *****************************************************************************/
/*!
 * \brief         Get the number of events requesting the indicator in continuous
 *                mode, relative to the J1939 node
 *
 * \details       Get the number of events requesting the indicator in continuous
 *                mode, relative to the J1939 node
 *
 * \param[in]     IndicatorId
 *                Unique handle of indicator
 * \param[in]     J1939NodeId
 *                Unique handle of the J1939 node
 *
 * \return        The number of events requesting the indicator
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_IndicatorGetEventCountContinuous(
  CONST(uint8, AUTOMATIC)  IndicatorId,
  CONST(uint8, AUTOMATIC)  J1939NodeId
);

#if (DEM_CFG_SUPPORT_INDICATORS == STD_ON)
/* ****************************************************************************
 * Dem_Mem_IndicatorSetEventCountContinuous
 *****************************************************************************/
/*!
 * \brief         Set the number of events requesting the indicator in continuous
 *                mode, relative to the J1939 node
 *
 * \details       Set the number of events requesting the indicator in continuous
 *                mode, relative to the J1939 node
 *
 * \param[in]     IndicatorId
 *                Unique handle of indicator
 * \param[in]     J1939NodeId
 *                Unique handle of the J1939 node
 * \param[in]     ActiveEventCount
 *                New number of events
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_INDICATORS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_IndicatorSetEventCountContinuous(
  CONST(uint8, AUTOMATIC)  IndicatorId,
  CONST(uint8, AUTOMATIC)  J1939NodeId,
  CONST(uint16, AUTOMATIC)  ActiveEventCount
  );
#endif

/* ****************************************************************************
 * Dem_Mem_IndicatorGetEventCountBlinking
 *****************************************************************************/
/*!
 * \brief         Get the number of events requesting the indicator in blinking
 *                mode, relative to the J1939 node
 *
 * \details       Get the number of events requesting the indicator in blinking
 *                mode, relative to the J1939 node
 *
 * \param[in]     IndicatorId
 *                Unique handle of indicator
 * \param[in]     J1939NodeId
 *                Unique handle of the J1939 node
 *
 * \return        The number of events requesting the indicator
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_IndicatorGetEventCountBlinking(
  CONST(uint8, AUTOMATIC)  IndicatorId,
  CONST(uint8, AUTOMATIC)  J1939NodeId
  );

/* ****************************************************************************
 * Dem_Mem_IndicatorSetEventCountBlinking
 *****************************************************************************/
/*!
 * \brief         Set the number of events requesting the indicator in blinking
 *                mode, relative to the J1939 node
 *
 * \details       Set the number of events requesting the indicator in blinking
 *                mode, relative to the J1939 node
 *
 * \param[in]     IndicatorId
 *                Unique handle of indicator
 * \param[in]     J1939NodeId
 *                Unique handle of the J1939 node
 * \param[in]     ActiveEventCount
 *                New number of events
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_IndicatorSetEventCountBlinking(
  CONST(uint8, AUTOMATIC)  IndicatorId,
  CONST(uint8, AUTOMATIC)  J1939NodeId,
  CONST(uint16, AUTOMATIC)  ActiveEventCount
  );

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_IumprGetUpdatePending
 *****************************************************************************/
/*!
 * \brief         Get the update state of the ratio
 *
 * \details       Get the update state of the ratio
 *
 * \param[in]     RatioIndex
 *                Unique handle of the ratio
 *
 * \return        The update state
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_ObdIumprUpdatePendingType, DEM_CODE)
Dem_Mem_IumprGetUpdatePending(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_IumprSetUpdatePending
 *****************************************************************************/
/*!
 * \brief         Set the update state of the ratio
 *
 * \details       Set the update state of the ratio
 *
 * \param[in]     RatioIndex
 *                Unique handle of the ratio
 * \param[in]     Value
 *                New update state
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_IumprSetUpdatePending(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex,
  CONST(Dem_Cfg_ObdIumprUpdatePendingType, AUTOMATIC)  Value
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetDenominator
 *****************************************************************************/
/*!
 * \brief         Get the denominator of the ratio
 *
 * \details       Get the denominator of the ratio
 *
 * \param[in]     RatioIndex
 *                Unique handle of the ratio
 *
 * \return        The denominator
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_GetDenominator(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetDenominator
 *****************************************************************************/
/*!
 * \brief         Set the denominator of the ratio
 *
 * \details       Set the denominator of the ratio
 *
 * \param[in]     RatioIndex
 *                Unique handle of the ratio
 * \param[in]     Value
 *                New denominator
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetDenominator(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex,
  CONST(uint16, AUTOMATIC)  Value
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetGeneralDenominator
 *****************************************************************************/
/*!
 * \brief         Get the general denominator
 *
 * \details       Get the general denominator
 *
 * \return        The general denominator
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_GetGeneralDenominator(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetGeneralDenominator
 *****************************************************************************/
/*!
 * \brief         Set the general denominator
 *
 * \details       Set the general denominator
 *
 * \param[in]     Value
 *                The new general denominator
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetGeneralDenominator(
  CONST(uint16, AUTOMATIC)  Value
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetGeneralDenominatorStatus
 *****************************************************************************/
/*!
 * \brief         Get the general denominator status
 *
 * \details       Get the general denominator status
 *
 * \return        The general denominator status
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetGeneralDenominatorStatus(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetGeneralDenominatorStatus
 *****************************************************************************/
/*!
 * \brief         Set the general denominator status
 *
 * \details       Set the general denominator status
 *
 * \param[in]     Value
 *                The new general denominator status
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetGeneralDenominatorStatus(
  CONST(uint8, AUTOMATIC) Value
  );
#endif

# if (DEM_FEATURE_NEED_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetGlobalIumprHybridStatus
 *****************************************************************************/
/*!
 * \brief         Get the hybrid ignition cycle status
 *
 * \details       Get the hybrid ignition cycle status
 *
 * \return        The hybrid ignition cycle status
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetGlobalIumprHybridStatus(
  void
  );
#endif

# if (DEM_FEATURE_NEED_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetGlobalIumprHybridStatus
 *****************************************************************************/
/*!
 * \brief         Set the hybrid ignition cycle status
 *
 * \details       Set the hybrid ignition cycle status
 *
 * \param[in]     Value
 *                The new hybrid ignition cycle status
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetGlobalIumprHybridStatus(
  CONST(uint8, AUTOMATIC)  Value
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetGlobalNumeratorsLocked
 *****************************************************************************/
/*!
 * \brief         Get the global numerator lock status
 *
 * \details       Get the global numerator lock status
 *
 * \return        The global numerator lock status
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetGlobalNumeratorsLocked(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetGlobalNumeratorsLocked
 *****************************************************************************/
/*!
 * \brief         Set the global numerator lock status
 *
 * \details       Set the global numerator lock status
 *
 * \param[in]     Value
 *                The new global numerator lock status
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetGlobalNumeratorsLocked(
  CONST(uint8, AUTOMATIC)  Value
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetIumprStatus
 *****************************************************************************/
/*!
 * \brief         Get the status of the ratio
 *
 * \details       Get the status of the ratio
 *
 * \param[in]     RatioIndex
 *                Unique handle of the ratio
 *
 * \return        The status of the ratio
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetIumprStatus(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetIumprStatus
 *****************************************************************************/
/*!
 * \brief         Set the status of the ratio
 *
 * \details       Set the status of the ratio
 *
 * \param[in]     RatioIndex
 *                Unique handle of the ratio
 * \param[in]     Value
 *                New status of the ratio
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetIumprStatus(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex,
  CONST(uint8, AUTOMATIC)  Value
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetNumerator
 *****************************************************************************/
/*!
 * \brief         Get the numerator of the ratio
 *
 * \details       Get the numerator of the ratio
 *
 * \param[in]     RatioIndex
 *                Unique handle of the ratio
 *
 * \return        The numerator
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_GetNumerator(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex
  );
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetNumerator
 *****************************************************************************/
/*!
 * \brief         Set the numerator of the ratio
 *
 * \details       Set the numerator of the ratio
 *
 * \param[in]     RatioIndex
 *                Unique handle of the ratio
 * \param[in]     Value
 *                New numerator
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_IUMPR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetNumerator(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex,
  CONST(uint16, AUTOMATIC)  Value
  );
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryFindIndex_Checked
 *****************************************************************************/
/*!
 * \brief         Finds the event memory allocated to an event
 *
 * \details       Finds the event memory allocated to an event. If the event
 *                does not have a valid memory index, any valid index is
 *                returned instead.
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The memory index used by the event.
 *                In error cases, a valid index is returned to avoid out of
 *                bounds memory access.
 *
 * \pre           The event must have a memory entry, i.e it is marked as
 *                'stored'
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryFindIndex_Checked(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_GetBlockState
 *****************************************************************************/
/*!
 * \brief         Get the status of the memory block
 *
 * \details       Get the status of the memory block
 *
 * \param[in]     MemoryIndex
 *                Handle of the memory block
 *
 * \return        The status of the memory block
 *
 * \pre           -
 * \config        DEM_CFG_USE_NVM == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Nvm_GetBlockState(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );
#endif

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_SetBlockState
 *****************************************************************************/
/*!
 * \brief         Set the status of the memory block
 *
 * \details       Set the status of the memory block
 *
 * \param[in]     MemoryIndex
 *                Handle of the memory block
 * \param[in]     Status
 *                New status of the memory block
 *
 * \pre           -
 * \config        DEM_CFG_USE_NVM == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_SetBlockState(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex,
  CONST(uint8, AUTOMATIC)  Status
  );
#endif

/* ****************************************************************************
 * Dem_Cal_TestGroupAvailable
 *****************************************************************************/
/*!
 * \brief         Tests if a combined event group is available based on runtime
 *                calibration
 *
 * \details       Tests if a combined event group is available based on runtime
 *                calibration
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 *
 * \return        TRUE
 *                The group is available
 * \return        FALSE
 *                The group is not available
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestGroupAvailable(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId
  );

/* ****************************************************************************
 * Dem_Cal_TestDtcAvailable
 *****************************************************************************/
/*!
 * \brief         Tests if a event or combined event group is available based
 *                on runtime calibration
 *
 * \details       Tests if a event or combined event group is available based
 *                on runtime calibration. Any event of a combined group can be
 *                passed to this function.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event or combined event group is available
 * \return        FALSE
 *                The event or combined event group is not available
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestDtcAvailable(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Cal_TestEventAvailable
 *****************************************************************************/
/*!
 * \brief         Tests if an Event is available based on runtime calibration
 *
 * \details       Tests if an Event is available based on runtime calibration
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event is available
 * \return        FALSE
 *                The event is not available
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestEventAvailable(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Cal_TestGroupAvailableInVariant
 *****************************************************************************/
/*!
 * \brief         Tests if a combined event group is available based on the PB-S
 *                variant
 *
 * \details       Tests if a combined event group is available based on the PB-S
 *                variant
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 *
 * \return        TRUE
 *                The group is available in the selected variant
 * \return        FALSE
 *                The group is not available in the selected variant
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestGroupAvailableInVariant(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId
  );

/* ****************************************************************************
 * Dem_Cal_TestDtcAvailableInVariant
 *****************************************************************************/
/*!
 * \brief         Tests if an event or combined event group is available based
 *                on the PB-S variant
 *
 * \details       For normal events, this function simply looks up the event
 *                configuration. A combined event group is available only if at
 *                least one sub-event is available in the active variant.
 *                Any event of a combined group can be passed to this function.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event or combined event group is available in the selected
 *                variant
 * \return        FALSE
 *                The event or combined event group is not available in the
 *                selected variant
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestDtcAvailableInVariant(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Cal_TestGroupSuppression
 *****************************************************************************/
/*!
 * \brief         Tests if a combined event group is suppressed for reporting API
 *
 * \details       Tests if a combined event group is suppressed for reporting API
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 *
 * \return        TRUE
 *                The group is suppressed
 * \return        FALSE
 *                The group is not suppressed
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestGroupSuppression(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId
  );

/* ****************************************************************************
 * Dem_Cal_TestEventSuppression
 *****************************************************************************/
/*!
 * \brief         Tests if an event is suppressed for reporting API
 *
 * \details       Tests if an event is suppressed for reporting API
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event is suppressed
 * \return        FALSE
 *                The event is not suppressed
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestEventSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Cal_TestDtcSuppression
 *****************************************************************************/
/*!
 * \brief         Tests if an event or combined event group is suppressed for
 *                reporting API
 *
 * \details       Tests if an event or combined event group is suppressed for
 *                reporting API. Any event of a combined group can be passed
 *                to this function.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event or combined event group is suppressed
 * \return        FALSE
 *                The event or comined event group is not suppressed
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestDtcSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 * Dem_Cal_TestEventSuppressed
 *****************************************************************************/
/*!
 * \brief         Tests if an event can be considered for reporting API
 *
 * \details       Tests all options due to which an event has to be excluded
 *                from reporting API, based on an individual event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event is currently suppressed
 * \return        FALSE
 *                The event is currently not suppressed
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_IUMPR == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestEventSuppressed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Cal_TestDtcSuppressed
 *****************************************************************************/
/*!
 * \brief         Tests an event or event group can be considered for reporting API
 *
 * \details       Tests all options due to which an event or combined event group has to be
 *                has to be excluded from reporting API, based on the combined event group
 *                for combined events. Any event of a combined group can be passed
 *                to this function.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event or combined event group is currently suppressed
 * \return        FALSE
 *                The event or combined event group is currently not suppressed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestDtcSuppressed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Util_TestEventValid
 *****************************************************************************/
/*!
 * \brief         Test whether a handle is a valid event ID
 *
 * \details       This function tests whether a handle is in the valid range
 *                of EventIds. This function does not consider calibration or
 *                runtime-availability.
 *
 * \param[in]     EventId
 *                Handle to test against range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                EventId is valid
 * \return        FALSE
 *                EventId is not valid
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Util_TestEventValid(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
/* ****************************************************************************
 * Dem_Util_CallClearEventAllowed
 *****************************************************************************/
/*!
 * \brief         Wrap call to user defined clear filter
 *
 * \details       This function calls a user defined clear allowed callback
 *                and handles the related error conditions.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event may be cleared
 * \return        FALSE
 *                The application does not allow clearing
 *
 * \pre           RTE is started
 * \config        DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Util_CallClearEventAllowed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Util_DtcApplyUserControlledWIR
 *****************************************************************************/
/*!
 * \brief         Apply the user controlled WIR bit to the DTC's status
 *
 * \details       This function applies a user controlled WIR bit from the
 *                given internal status to the given DTC status byte.
 *
 *                The resulting WIR status cannot be reset by this function.
 *
 * \param[in]     DtcStatus
 *                Unmodified DTC status byte
 *
 * \param[in]     InternalStatus
 *                Internal event status information
 *
 * \return        The resulting DTC status
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyUserControlledWIR(
  CONST(uint8, AUTOMATIC)  DtcStatus,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  );

#if ( (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) \
   || (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON) \
   || (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) \
   || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON) )
/* ****************************************************************************
 * Dem_Util_DtcApplyCombinedStatus
 *****************************************************************************/
/*!
 * \brief         Apply interdependent status bits on a combined status
 *
 * \details       This function corrects the status byte inconsistencies
 *                resulting from event combination, according to the Autosar
 *                specification.
 *
 * \param[in]     DtcStatus
 *                Unmodified DTC status byte
 *
 * \return        The resulting DTC status
 *
 * \pre           -
 * \config        (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) ||
 *                (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON) ||
 *                (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) ||
 *                (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyCombinedStatus(
  CONST(uint8, AUTOMATIC)  DtcStatus
  );
#endif

/* ****************************************************************************
 * Dem_Util_DtcApplyExternalOnlyStatus
 *****************************************************************************/
/*!
 * \brief         Apply correction term for DTC status modification
 *
 * \details       This function applies a filter to the DTC status byte to set
 *                bits that are forced to true by different mechanisms than
 *                event status modification.
 *                Also, status bits not contained in the status availability
 *                mask are masked out.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     DtcStatus
 *                Unmodified DTC status byte
 *
 * \return        The resulting DTC status
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyExternalOnlyStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  DtcStatus
  );

/* ****************************************************************************
 * Dem_Util_DtcGetInternalStatus
 *****************************************************************************/
/*!
 * \brief         Get the internal status byte with consideration of event
 *                combination
 *
 * \details       This function retrieves the event's internal status byte for
 *                normal events, and the group's internal status byte for
 *                combined events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The internal status byte relevant for the event or group.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Util_DtcGetInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Util_DtcSetInternalStatus
 *****************************************************************************/
/*!
 * \brief         Set the internal status byte with consideration of event
 *                combination
 *
 * \details       This function stores the event's internal status byte for
 *                normal events, and the group's internal status byte for
 *                combined events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     InternalStatus
 *                New internal status to set
 *
 * \pre           Must be called within critical section DiagMonitor
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Util_DtcSetInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  );

/* ****************************************************************************
 * Dem_Util_DtcGetStatus
 *****************************************************************************/
/*!
 * \brief         Gets the UDS status byte of an event or combined event group
 *
 * \details       This function retrieves the event's status byte for normal
 *                events, and the combined event group's status byte for
 *                combined events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The status byte relevant for the event or group
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcGetStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

#if ( (DEM_CFG_SUPPORT_DCM == STD_ON) \
  || (DEM_CFG_DATA_CURRENT_FDC == STD_ON) )
/* ****************************************************************************
 * Dem_Util_DtcGetFaultDetectionCounter
 *****************************************************************************/
/*!
 * \brief         Gets the FaultDetectionCounter (FDC) of an event or combined
 *                event group
 *
 * \details       This function retrieves the event's FDC for normal events,
 *                and the maximum FDC of the combined event group's sub-events
 *                for combined events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The current FDC of the event or group.
 *
 * \pre           RTE must be started
 * \config        (DEM_CFG_SUPPORT_DCM == STD_ON) ||
 *                (DEM_CFG_DATA_CURRENT_FDC == STD_ON)
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Util_DtcGetFaultDetectionCounter(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONSTP2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter
  );
#endif

/* ****************************************************************************
 * Dem_Util_CombinedGroupGetEvent
 *****************************************************************************/
/*!
 * \brief         Looks up the master event for a combined event
 *
 * \details       This function finds the master event based on any sub-event
 *                of an event combination group.
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 *
 * \return        The EventId representing the combined event group.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Util_CombinedGroupGetEvent(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId
  );

/* ****************************************************************************
 * Dem_Util_DtcGetMasterEvent
 *****************************************************************************/
/*!
 * \brief         Gets the master event of a combined event group
 *
 * \details       Selects the representing event (master event) of an event
 *                combination group, or the event itself if it is not combined.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The EventId representing the event or combined event group.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Util_DtcGetMasterEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Util_ForEachCombinedEvent
 *****************************************************************************/
/*!
 * \brief         Executes a combined operation.
 *
 * \details       Due to excessive code duplication it was necessary to fall
 *                back to higher order functions. This function takes a
 *                function pointer to an operation to be executed for all
 *                sub-events of a combined event.
 *                For normal events, the operation is executed for that event
 *                only, so the caller does not need to distinguish between
 *                combined and non-combined events too much.
 *
 *                The caller is still reponsible to call this function only
 *                once per combined event, e.g. by calling it only for the
 *                master event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     FuncPtr
 *                Operation to perform on all subevents
 * \param[in]     ArgPtr
 *                Arguments passed to the operation.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Util_ForEachCombinedEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedFuncType, AUTOMATIC)  FuncPtr,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr
  );

                                                            /* Main Function */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_SPLIT_TASKS != STD_ON)                                                                                      /* COV_MSR_UNSUPPORTED TX */
/* ****************************************************************************
 * Dem_MainFunctionWorker
 *****************************************************************************/
/*!
 * \brief         Cyclic Dem worker task
 *
 * \details       This function processes the asynchronous status changes, e.g.
 *                storing event data into the event memory, clearing the event
 *                memory and processing operation cycle changes.
 *
 *                The run-time of this function can be high depending on the
 *                configuration, and the API calls that happen to coincide.
 *
 *                If the Dem module is not initialized, calling this function
 *                has no effect.
 *
 * \pre           Dem has been pre-initialized
 * \config        private if DEM_CFG_SUPPORT_SPLIT_TASKS != STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_MAINFUNC_LINKAGE FUNC(void, DEM_CODE)
Dem_MainFunctionWorker(
  void
);

# if (DEM_FEATURE_NEED_ENGINE_RUN_TIME == STD_ON) \
  || (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) \
  || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON)
/* ****************************************************************************
 * Dem_MainFunctionTimer
 *****************************************************************************/
/*!
 * \brief         Cyclic Dem timer task
 *
 * \details       This function creates the time base for the Dem module.
 *
 *                Call this function in a cyclic manner, with the configured
 *                cycle time. The run-time of this function is as minimal as
 *                possible, so it can be called on a higher priority task with
 *                minimal impact.
 *
 *                If the Dem module is not initialized, calling this function
 *                has no effect.
 *
 * \pre           Dem has been pre-initialized
 * \config        private if DEM_CFG_SUPPORT_SPLIT_TASKS != STD_ON
 *                   DEM_FEATURE_NEED_ENGINE_RUN_TIME == STD_ON
 *                || DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 *                || DEM_FEATURE_NEED_TIME_SERIES == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_MAINFUNC_LINKAGE FUNC(void, DEM_CODE)
Dem_MainFunctionTimer(
  void
);
# endif
#endif

                                                      /* Queue Setter/Getter */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ChronologyGetEvent
 *****************************************************************************/
/*!
 * \brief         Get the Nth event in order of occurrence
 *
 * \details       Get the Nth event of the list sorted in chronological order.
 *
 * \param[in]     QueueIndex
 *                Index in the ordered list
 *
 * \return        Unique handle of the event
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Queue_ChronologyGetEvent(
  CONST(uint8, AUTOMATIC)  QueueIndex
  );
#endif

#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ChronologySetEvent
 *****************************************************************************/
/*!
 * \brief         Set the Nth event in the list
 *
 * \details       This function only sets the element. The caller must establish
 *                the chronological order and set the list items accordingly.
 *
 * \param[in]     QueueIndex
 *                Index in the ordered list
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ChronologySetEvent(
  CONST(uint8, AUTOMATIC)  QueueIndex,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Queue_GetEventStatus
 *****************************************************************************/
/*!
 * \brief         Get the queue status of the event
 *
 * \details       Get the queue status of the event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The queue status of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Queue_GetEventStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Queue_SetEventStatus
 *****************************************************************************/
/*!
 * \brief         Set the queue status of the event
 *
 * \details       Set the queue status of the event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     Status
 *                New queue status of the event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_SetEventStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  Status
  );

/* ****************************************************************************
 * Dem_Queue_GetPendingCycle
 *****************************************************************************/
/*!
 * \brief         Looks up a pending cycle state change
 *
 * \details       This function looks up a pending cycle state change.
 *                The value returned is only meaningful if the modification
 *                flag is also set for this cycle (see Dem_Queue_CycleFlag)
 *
 * \param[in]     CycleId
 *                Unique handle of the Cycle.
 *
 * \return        TRUE
 *                The cycle shall be in state started
 * \return        FALSE
 *                The cycle shall be in state stopped
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Queue_GetPendingCycle(
  CONST(uint8, AUTOMATIC)  CycleId
  );

/* ****************************************************************************
 * Dem_Queue_SetPendingCycle
 *****************************************************************************/
/*!
 * \brief         Stores a pending cycle state change
 *
 * \details       This function stores a pending cycle state change to be
 *                processed later on task context.
 *
 *                The queue can encode one STOP, one START or one STOP->START
 *                action. The modification flag (see Dem_Queue_CycleFlag) is
 *                set always.
 *
 * \param[in]     CycleId
 *                Unique handle of the Cycle.
 * \param[in]     Status
 *                DEM_QUEUE_CYCLE_STARTED  To start a cycle
 *                DEM_QUEUE_CYCLE_STOPPED  To stop a cycle
 *
 * \pre           Must be called within critical section 'StateManager'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_SetPendingCycle(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(boolean, AUTOMATIC)  Status
  );

/* ****************************************************************************
 * Dem_Queue_SetPendingEvent_Enqueue
 *****************************************************************************/
/*!
 * \brief         Initializes an event queue entry
 *
 * \details       Up to Dem_Cfg_GlobalQueueMaxCount() events are queued in order of
 *                first action. Other events still maintain their queued
 *                actions, but not in order of arrival.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        Queue state of the event
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Queue_SetPendingEvent_Enqueue(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Queue_SetPendingEvent_Queued
 *****************************************************************************/
/*!
 * \brief         Stores a pending event qualification to be processed later
 *
 * \details       The queue state can be stored for every event, and will be
 *                further processed on task level of the Dem. This function
 *                queues qualified actions without interpreting the current
 *                status byte. This means that reporting a Failed result which
 *                has no effect on the event status will still cause event
 *                processing on the main function.
 *                The reports can be queued even before the current event
 *                status is restored during initalization.
 *
 *                If the queuing action limit is exceeded this function will
 *                return E_NOT_OK.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     MonitorStatus
 *                DEM_EVENT_STATUS_PASSED    To add a qualification to 'PASSED'
 *                DEM_EVENT_STATUS_FAILED    To add a qualification to 'FAILED'
 *                DEM_EVENT_STATUS_PREFAILED Queue, but do not add qualification (FDC)
 *                DEM_EVENT_STATUS_PREPASSED Queue, but do not add qualification (FDC)
 *
 * \return        E_OK
 *                The event could be queued
 * \return        E_NOT_OK
 *                The event could not be queued.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Queue_SetPendingEvent_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  MonitorStatus
  );

/* ****************************************************************************
 * Dem_Queue_SetPendingEvent_Immediate
 *****************************************************************************/
/*!
 * \brief         Stores a pending event qualification to be processed later
 *
 * \details       The queue state can be stored for every event, and will be
 *                further processed on task level of the Dem. This function
 *                queues qualified actions by interpreting the current status
 *                byte. This means that status changes are encoded in the queue
 *                state, so the current status can be changed without losing
 *                the triggers. On the other hand, the status byte is not
 *                available before initialization, so this function cannot
 *                queue events before initalization.
 *
 *                If the queuing action limit is exceeded this function will
 *                return E_NOT_OK.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     MonitorResult
 *                DEM_EVENT_STATUS_PASSED    To add a qualification to 'PASSED'
 *                DEM_EVENT_STATUS_FAILED    To add a qualification to 'FAILED'
 *                DEM_EVENT_STATUS_PREFAILED Queue, but do not add qualification (FDC)
 *                DEM_EVENT_STATUS_PREPASSED Queue, but do not add qualification (FDC)
 * \param[in]     EventStatus
 *                The current event status.
 *
 * \return        E_OK
 *                The event could be queued
 * \return        E_NOT_OK
 *                The event could not be queued.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Queue_SetPendingEvent_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  MonitorResult,
  CONST(uint8, AUTOMATIC)  EventStatus
  );

/* ****************************************************************************
 * Dem_Queue_ResetPendingEvent
 *****************************************************************************/
/*!
 * \brief         Clears queued event actions
 *
 * \details       Reset the queued action state of the event. The queue itself
 *                is not modified.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ResetPendingEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Data_EventFailed
 *****************************************************************************/
/*!
 * \brief         Hook function to handle data updates on TestFailed transition
 *
 * \details       This function updates global failure statistics, like first
 *                failed event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     Effects
 *                Trigger flags
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_EventFailed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  Effects
  );

                                                            /* Notifications */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Cbk_DtcStatusChanged
 *****************************************************************************/
/*!
 * \brief         Calls all configured DTC status notification functions
 *
 * \details       This function is a wrapper of
 *                Dem_Cbk_DtcStatusChanged_Internal. The Dtc status is modified
 *                before passing it over, so the calls to
 *                Dem_Util_DtcApplyExternalOnlyStatus are not distributed
 *                across the code.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     EventStatusOld
 *                Old UDS status of the event
 * \param[in]     EventStatusNew
 *                New UDS status of the event
 * \param[in]     NotificationReason
 *                Reason for notification
 *
 * \pre           RTE must be started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_DtcStatusChanged(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  EventStatusOld,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  EventStatusNew,
  CONST(uint8, AUTOMATIC)  NotificationReason
  );

/* ****************************************************************************
 * Dem_Cbk_EventDataChanged
 *****************************************************************************/
/*!
 * \brief         Calls all configured event data notification functions
 *
 * \details       If configured, event specific and general data changed
 *                callbacks are invoked, unconditionally.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           RTE must be started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_EventDataChanged(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Cbk_InitMonitorForEvent
 *****************************************************************************/
/*!
 * \brief         Calls all configured 'init monitor for event' callbacks.
 *
 * \details       Calls all configured 'init monitor for event' callbacks.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     InitReason
 *                The reason why the init callback is called
 *
 * \pre           RTE must be started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_InitMonitorForEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_InitMonitorReasonType, AUTOMATIC)  InitReason
  );

/* ****************************************************************************
 * Dem_Cbk_InitMonitorForFunction
 *****************************************************************************/
/*!
 * \brief         Calls all configured 'init monitor for function' callbacks.
 *
 * \details       Calls all configured 'init monitor for function' callbacks.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           RTE must be started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_InitMonitorForFunction(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Mem_Init_RestoreMemory
 *****************************************************************************/
/*!
 * \brief         Initializes primary/secondary memory
 *
 * \details       This function verifies the integrity of memory entries and
 *                links them up into the runtime control structures.
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 *
 * \pre           NvM must have restored NV mirrors
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_Init_RestoreMemory(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );

/* ****************************************************************************
 * Dem_Mem_GetCycleStatus
 *****************************************************************************/
/*!
 * \brief         Gets the current state of a cycle.
 *
 * \details       Gets the current state of a cycle.
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 *
 * \return        DEM_QUEUE_CYCLE_STARTED
 *                The cycle is currently started
 * \return        DEM_QUEUE_CYCLE_STOPPED
 *                The cycle is currently stopped
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetCycleStatus(
  CONST(uint8, AUTOMATIC)  CycleId
  );

/* ****************************************************************************
 * Dem_Mem_SetCycleStatus
 *****************************************************************************/
/*!
 * \brief         Set current state of a cycle.
 *
 * \details       Set current state of a cycle.
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 * \param[in]     Status
 *                The state of the cycle
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetCycleStatus(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint8, AUTOMATIC)  Status
  );

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetOverflow
 *****************************************************************************/
/*!
 * \brief         Get the 'overflown' state for an event memory.
 *
 * \details       Get the 'overflown' state for an event memory.
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \return        TRUE
 *                The event memory has overflown
 * \return        FALSE
 *                The event memory has not overflown
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_OVFLIND == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_GetOverflow(
  CONST(uint8, AUTOMATIC)  MemoryId
  );
#endif

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetOverflow
 *****************************************************************************/
/*!
 * \brief         Set the 'overflown' state for an event memory.
 *
 * \details       Set the 'overflown' state for an event memory.
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_OVFLIND == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetOverflow(
  CONST(uint8, AUTOMATIC)  MemoryId
  );
#endif

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 * Dem_Mem_ResetOverflow
 *****************************************************************************/
/*!
 * \brief         Clear the 'overflown' state for an event memory.
 *
 * \details       Clear the 'overflown' state for an event memory.
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_OVFLIND == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_ResetOverflow(
  CONST(uint8, AUTOMATIC)  MemoryId
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 * Dem_Mem_CopyDataDebounceNv
 *****************************************************************************/
/*!
 * \brief         Copies debounce values from debounce array to NVRAM mirror
 *
 * \details       This function copies all debounce counters and timer values
 *                that need to be stored in NV memory into the NV data buffer.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CopyDataDebounceNv(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageInit
 *****************************************************************************/
/*!
 * \brief         Initializes the prestorage free list.
 *
 * \details       Initializes the prestorage free list.
 *
 * \pre           Can only be called during Dem initialization
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageInit(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageFindEntry
 *****************************************************************************/
/*!
 * \brief         Locates the prestored data entry of an event.
 *
 * \details       This function looks up if a prestorage entry exists for the
 *                given event, and returns its handle if found.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        Index into Prestorage area, if one was found.
 *                DEM_MEM_INVALID_PRESTORAGE_INDEX otherwise.
 *
 * \pre           The event must support prestorage
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageFindEntry(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageAllocateEntry
 *****************************************************************************/
/*!
 * \brief         Allocates a new prestored entry for an event
 *
 * \details       This function consumes the next free prestorage entry (if
 *                available) and allocates it to the given event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        Index into Prestorage area, if one was found.
 *                DEM_MEM_INVALID_PRESTORAGE_INDEX otherwise.
 *
 * \pre           The event must support prestorage
 * \pre           The event must not have a prestored entry
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageAllocateEntry(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageFreeEntry
 *****************************************************************************/
/*!
 * \brief         Free a prestored entry
 *
 * \details       This function removes the ownership of the prestored entry
 *                and returns it to the free list.
 *
 * \param[in]     PrestorageIndex
 *                Prestored entry to free
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageFreeEntry(
  CONST(Dem_Cfg_PrestorageIndexType, AUTOMATIC)  PrestorageIndex
  );
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryUpdateIndex
 *****************************************************************************/
/*!
 * \brief         Update the chronology of one entry in the event memory
 *
 * \details       Moves the passed entry up to most current in the chronology
 *                list.
 *                Do not call this function directly, use
 *                Dem_Esm_EventUpdateMemory
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  MemoryIndex
  );

/* ****************************************************************************
 * Dem_Mem_PreInit
 *****************************************************************************/
/*!
 * \brief         Pre-initializes backing memory
 *
 * \details       This function performs basic initialization to allow later
 *                full initialization.
 *
 * \pre           May only be called during pre-initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PreInit(
  void
  );

/* ****************************************************************************
 * Dem_Mem_Init
 *****************************************************************************/
/*!
 * \brief         Initializes backing memory
 *
 * \details       This function controls initialization of the memory
 *                subcomponent. After the function completes, event memories
 *                are available.
 *
 * \pre           May only be called during initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_Init(
  void
  );

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Esm_AddCycleCount
 *****************************************************************************/
/*!
 * \brief         Calculates wrapped cycle counter
 *
 * \details       This function increments and wraps a cycle count avoiding
 *                overflow and 'magic numbers'.
 *
 * \param[in]     CurrentCounter
 *                Current value of the cycle counter
 * \param[in]     DeltaValue
 *                Value by which CurrentCounter is incremented.
 *
 * \return        Value of (CurrentCounter + DeltaValue) mod X
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Esm_AddCycleCount(
  CONST(uint16, AUTOMATIC)  CurrentCounter,
  CONST(uint8, AUTOMATIC)  DeltaValue
  );

/* ****************************************************************************
 * Dem_Esm_DebounceInfoInit
 *****************************************************************************/
/*!
 * \brief         Initializes a debounce descriptor
 *
 * \details       This function initializes the basic common fields of a
 *                debounce descriptor. State information remains uninitialized
 *                as it is not known without context.
 *                The common fields that will be set here are 'EventId' and
 *                'FunctionTable'
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[out]    DebounceInfo
 *                The debouncing info to initialize.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_DebounceInfoInit(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONSTP2VAR(Dem_DebounceInfoType, AUTOMATIC, AUTOMATIC)  DebounceInfo
  );

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_PrestorageDiscard
 *****************************************************************************/
/*!
 * \brief         Marks a prestored entry as used up
 *
 * \details       Prestored data (if available) is valid throughout the whole
 *                event processing step. This function marks the current data
 *                to be discarded after event processing completes.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PrestorageDiscard(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventPrestorageLock
 *****************************************************************************/
/*!
 * \brief         Locks a ready prestored entry to use its data
 *
 * \details       This function prepares the prestored data of the given event
 *                (if available) for consumption during the event processing
 *                step.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPrestorageLock(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventPrestorageRelease
 *****************************************************************************/
/*!
 * \brief         Unlock the previously locked prestored entry
 *
 * \details       This function releases the prestored data locked by
 *                Dem_Esm_EventPrestorageLock, if such data exists.
 *
 *                If the data was consumed during the event processing step,
 *                the data is discarded.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPrestorageRelease(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventPrestorageUpdate
 *****************************************************************************/
/*!
 * \brief         Store prestored data for an event
 *
 * \details       This function tries to find a prestorage entry for the given
 *                event, allocating a new one if needed.
 *                If a prestorage entry is found, it is updated with sample
 *                data.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        E_OK
 *                Prestored data was successfully collected
 * \return        E_NOT_OK
 *                No data was collected
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventPrestorageUpdate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventCreateMemory
 *****************************************************************************/
/*!
 * \brief         Allocate an event memory entry
 *
 * \details       This function tries to allocate an event memory entry for
 *                the given event. This can displace existing memory entries
 *                if the memory is already full.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        MemoryIndex of the allocated memory entry. If no entry was
 *                allocated, DEM_MEM_INVALID_MEMORY_INDEX is returned.
 *
 * \pre           The event may not be stored already
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventCreateMemory(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Esm_EventUpdateMemory
 *****************************************************************************/
/*!
 * \brief         Report an event entry as updated
 *
 * \details       This function updates an event memory after failure.
 *                An aged entry is reinitialized, and an active entry updates
 *                the time stamp when an occurrence was reported.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     Occurrence
 *                TRUE if the TF bit has transitioned FALSE->TRUE
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \return        Block modification bitmask:
 *                DEM_DATA_NO_CHANGES          nothing has changed
 *                DEM_DATA_USERDATA_CHANGED    user provided data was updated
 *                DEM_DATA_STATISTICS_CHANGED  internal data was updated
 *
 * \pre           The event must be stored
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventUpdateMemory(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  MemoryIndex,
  CONST(boolean, AUTOMATIC)  Occurrence
  );

#if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)
/* ****************************************************************************
 * Dem_Esm_UserIndicatorEnable
 *****************************************************************************/
/*!
 * \brief         Updates user-defined indicator counters
 *
 * \details       Adds the event's contribution to the indicator states.
 *                Basically this adds 1 to each indicators continuous or
 *                blinking count, if the indicator is enabled by the given
 *                event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           Must be called inside of critical section 'DiagMonitor'
 * \config        DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_UserIndicatorEnable(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)
/* ****************************************************************************
 * Dem_Esm_UserIndicatorDisable
 *****************************************************************************/
/*!
 * \brief         Update user-defined indicator counters
 *
 * \details       Removes the event's contribution to the indicator states.
 *                Basically this subtracts 1 from each indicators continuous or
 *                blinking count, if the indicator is enabled by the given
 *                event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           Must be called inside of critical section 'DiagMonitor'
 * \config        DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_UserIndicatorDisable(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_TestLatchedTestFailed
 *****************************************************************************/
/*!
 * \brief         Tests whether an event's latched failed restriction applies
 *
 * \details       Tests whether an event's latched failed restriction applies
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event is latched at TestFailed
 * \return        FALSE
 *                The event is not latched, process it normally
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestLatchedTestFailed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

#if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TestEventHealed
 *****************************************************************************/
/*!
 * \brief         Tests whether an event is healed
 *
 * \details       Tests whether an event is healed
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     EventStatus
 *                Current event status of the event
 *
 * \return        TRUE
 *                The event is healed
 * \return        FALSE
 *                The event is not healed
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_HEALING == STD_ON &&
 *                DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestEventHealed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventStatus
  );
#endif

#if ( (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON) \
   && ( (DEM_CFG_AGING_START_TRIGGER_PASSED == STD_ON) || (DEM_CFG_AGING_00_START_TRIGGER_PASSED == STD_ON) \
     || ( (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) && ((DEM_CFG_AGING_00_START_TRIGGER_PASSED == STD_OFF) || (DEM_CFG_AGING_START_TRIGGER_PASSED == STD_OFF)) ) ) )
/* ****************************************************************************
 % Dem_Esm_TestDtcHealed
 *****************************************************************************/
/*!
 * \brief         Tests whether an event or combined event is healed
 *
 * \details       Tests whether an event or combined event is healed
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event is healed
 * \return        FALSE
 *                The event is not healed
 *
 * \pre           -
 * \config        ( (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
 *             && ( (DEM_CFG_AGING_START_TRIGGER_PASSED == STD_ON) || (DEM_CFG_AGING_00_START_TRIGGER_PASSED == STD_ON)
 *             || ( (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) && ((DEM_CFG_AGING_00_START_TRIGGER_PASSED == STD_OFF)
 *             || (DEM_CFG_AGING_START_TRIGGER_PASSED == STD_OFF)) ) ) )
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestDtcHealed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventResetDebounceState
 *****************************************************************************/
/*!
 * \brief         Reset an event's debouncing state
 *
 * \details       This function is used to reset or freeze the debouncing
 *                process for events that are debounced by the Dem.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     Status
 *                Kind of reset
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDebounceState(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_DebounceResetStatusType, AUTOMATIC)  Status
  );

/* ****************************************************************************
 * Dem_Esm_EventResetDebounceValues
 *****************************************************************************/
/*!
 * \brief         Reset an event's debouncing counters/timers
 *
 * \details       This function sets the debouncing values (for events that are
 *                debounced by the Dem) back to initial values. This means the
 *                event's FDC is 0 after this function completes.
 *
 *                Any 'max FDC' statistics are reset as well.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDebounceValues(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 % Dem_Esm_EventSetDisconnectedBit
 *****************************************************************************/
/*!
 * \brief         Set an event's disconnected bit
 *
 * \details       Set an event's disconnected bit
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     IsDisconnected
 *                TRUE: Set disconnected bit to TRUE
 *                FALSE: Set disconnected bit to FALSE
 *
 * \pre           Must be called within critical section DiagMonitor
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetDisconnectedBit(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(boolean, AUTOMATIC)  IsDisconnected
  );

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventMayDisconnect
 *****************************************************************************/
/*!
 * \brief         Tests precondition for event disconnect
 *
 * \details       Tests precondition for event disconnect
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           Must be called within critical section DiagMonitor
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventMayDisconnect(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventDisconnect_Combined
 *****************************************************************************/
/*!
 * \brief         Marks a combined event unavailable
 *
 * \details       This function sets a sub-event unavailable and re-calculates
 *                the availability and suppression states for the combined
 *                DTC.
 *
 *                A stored DTC may not be set to unavailable, so this function
 *                performes no actions on stored DTCs.
 *
 *                Do not call directly, use Dem_Esm_EventDisconnect instead.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON &&
 *                DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisconnect_Combined(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventDisconnect_Normal
 *****************************************************************************/
/*!
 * \brief         Marks a normal event unavailable
 *
 * \details       This function sets the event unavailable if it is not stored.
 *
 *                Do not call directly, use Dem_Esm_EventDisconnect instead.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisconnect_Normal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventDisconnect
 *****************************************************************************/
/*!
 * \brief         Marks an event unavailable
 *
 * \details       This function sets an event unavailable, if its state allows
 *                to do so.
 *
 *                In case the event is set unavailable, its event status byte
 *                is changed to 0x00 and the FiM is informed.
 *
 *                Otherwise, this function returns E_NOT_OK.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        E_OK
 *                The event was set to unavailable
 * \return        E_NOT_OK
 *                The event was not set to unavailable
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventDisconnect(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventReconnect_Combined
 *****************************************************************************/
/*!
 * \brief         Marks a combined event available
 *
 * \details       This function sets a sub-event available and re-calculates
 *                the availability and suppression states for the combined
 *                DTC.
 *
 *                Do not call directly, use Dem_Esm_EventReconnect instead.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON &&
 *                DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect_Combined(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventReconnect_Normal
 *****************************************************************************/
/*!
 * \brief         Marks a normal event available
 *
 * \details       This function sets the event available.
 *
 *                Do not call directly, use Dem_Esm_EventReconnect instead.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect_Normal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventReconnect
 *****************************************************************************/
/*!
 * \brief         Marks an event available
 *
 * \details       This function sets an event available.
 *
 *                In case the event is set available, its event status byte is
 *                changed to 0x50 and the FiM is informed.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventSetSuppression
 *****************************************************************************/
/*!
 * \brief         Marks an event suppressed
 *
 * \details       This function sets an event suppressed. For combined events,
 *                this also marks the combined event suppressed if all
 *                (available) sub-events are suppressed.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventResetSuppression
 *****************************************************************************/
/*!
 * \brief         Marks an event unsuppressed
 *
 * \details       This function sets an event unsuppressed. For combined
 *                events, this also marks the combined event unsuppressed.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventSetDtcSuppression
 *****************************************************************************/
/*!
 * \brief         Marks an event's DTC suppressed
 *
 * \details       This function sets an event's DTC suppressed.
 *                For combined events, it does not matter which sub-event is
 *                passed to this function.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetDtcSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventResetDtcSuppression
 *****************************************************************************/
/*!
 * \brief         Marks an event's DTC un-suppressed
 *
 * \details       This function sets an event's DTC un-suppressed.
 *                For combined events, it does not matter which sub-event is
 *                passed to this function.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDtcSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif
/* ****************************************************************************
 * Dem_Esm_EventAged
 *****************************************************************************/
/*!
 * \brief         Completes aging of an event.
 *
 * \details       Depending on configuration this will clear the event's memory
 *                entry, or simply mark it as 'aged'.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAged(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );

/* ****************************************************************************
 * Dem_Esm_EventAgingStartZeroTarget
 *****************************************************************************/
 /*!
 * \brief         Starts aging of an event with aging target 0
 *
 * \details       This function processes aging for events with aging target
 *                0. I.e. the event will age immediately. This function has
 *                no effect if the event in question is already aged or does
 *                not support aging.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
  */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingStartZeroTarget(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Esm_EventAgingStartMultiTarget
 *****************************************************************************/
/*!
 * \brief         Starts aging of an event.
 *
 * \details       This function sets up an event for aging. In case the event
 *                already ages (or does not support aging), this function has
 *                no effect.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingStartMultiTarget(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) || (DEM_CFG_STORAGE_AT_FDC == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventFdcTrip
 *****************************************************************************/
/*!
 * \brief         Updates event data due to exceeding a FDC threshold
 *
 * \details       Updates event data due to exceeding a FDC threshold
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     FirstThisCycle
 *                Flag to mark if FDC did already trip this cycle
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON ||
 *                DEM_CFG_STORAGE_AT_FDC == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFdcTrip(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(boolean, AUTOMATIC)  FirstThisCycle
  );
#endif

#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventFdcMax
 *****************************************************************************/
/*!
 * \brief         Update event data 'maximum FDC since last clear'
 *
 * \details       Update event data 'maximum FDC since last clear'
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFdcMax(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
/* ****************************************************************************
 * Dem_Esm_ProcessFdc
 *****************************************************************************/
/*!
 * \brief         Process the event's FDC trip actions
 *
 * \details       This function processes the stored triggers from debounce
 *                values passing the FDC trip threshold.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_FDC_TRIP == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_ProcessFdc(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_FEATURE_NEED_IMMEDIATEHEAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventPassed_ProcessHealing
 *****************************************************************************/
/*!
 * \brief         Process event healing for events with healing target 0.
 *
 * \details       Tests if an event has healed with healing target 0 and
 *                processes the actions resulting from healing. This function
 *                has no effect when called for events with healing target != 0.
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_IMMEDIATEHEAL == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_ProcessHealing(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  );
#endif
/* ****************************************************************************
 * Dem_Esm_EventPassed_Queued
 *****************************************************************************/
/*!
 * \brief         Process the event's queued qualified passed result
 *
 * \details       This function processes a passed result stored on the
 *                event queue, for events using the QUEUED mechanism. The
 *                triggers resulting from the status bit changes are calculated
 *                within this function, based on the current event status.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Esm_EventPassed_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes the event's queued qualified passed result
 *
 * \details       This function processes a passed result stored on the
 *                event queue, for events using the IMMEDIATE mechanism. The
 *                triggers are stored on the queue, and need to be passed to
 *                this function, the event status is assumed to have already
 *                changed according to those triggers.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     Effects
 *                Trigger flags
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  Effects
  );

/* ****************************************************************************
 * Dem_Esm_EventTestConfirmed
 *****************************************************************************/
/*!
 * \brief         Tests if an event has confirmed (completed tripping)
 *
 * \details       Tests if an event has confirmed (completed tripping)
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventTestConfirmed(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC)  EventContext
  );

/* ****************************************************************************
 * Dem_Esm_EventFailed_ProcessPending
 *****************************************************************************/
/*!
 * \brief         Processes the pendingDtc status change
 *
 * \details       Processes the pendingDtc status change
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessPending(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC)  EventContext
  );

/* ****************************************************************************
 * Dem_Esm_EventFailed_ProcessConfirmed
 *****************************************************************************/
/*!
 * \brief         Processes the confirmedDtc status change
 *
 * \details       Processes the confirmedDtc status change
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessConfirmed(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC)  EventContext
  );

/* ****************************************************************************
 * Dem_Esm_EventFailed_ProcessStorage
 *****************************************************************************/
/*!
 * \brief         Process event storage into event memory
 *
 * \details       Processes event storage into event memory and updates the stored
 *                data.
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \return        TRUE
 *                Event data was modified
 * \return        FALSE
 *                Event data was not modified
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventFailed_ProcessStorage(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC)  EventContext
  );

/* ****************************************************************************
 * Dem_Esm_EventFailed_CommitToMemory
 *****************************************************************************/
/*!
 * \brief         Commits the event status changes into active memory
 *
 * \details       Commits the event status changes performed on the event
 *                context to the global memory.
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_CommitToMemory(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC)  EventContext
  );

/* ****************************************************************************
 * Dem_Esm_EventFailed_ProcessNotifications
 *****************************************************************************/
/*!
 * \brief         Notifies all changes to observers
 *
 * \details       Notifies all changes to observers.
 *
 * \param[in]     EventContext
 *                Event processing context
 * \param[in]     DataModified
 *                Flags if event user data has changed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessNotifications(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC)  EventContext,
  CONST(boolean, AUTOMATIC)  DataModified
  );

/* ****************************************************************************
 * Dem_Esm_EventOpCycleStart
 *****************************************************************************/
/*!
 * \brief         Processes the start of the event's operation cycle
 *
 * \details       Processes the start of the event's operation cycle: Reset
 *                status bits and de-bouncing.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleStart(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Esm_EventHealed
 *****************************************************************************/
/*!
 * \brief         Heals an event
 *
 * \details       Resets all warning indicator requests from the given event.
 *                This can modify the global indicator state if the indicator
 *                is no longer requested at all.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     EventStatus
 *                Current event status of the event
 *
 * \return        Modified event status based on the status passed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventHealed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventStatus
  );

/* ****************************************************************************
 * Dem_Esm_EventProcessHealing
 *****************************************************************************/
/*!
 * \brief         Processes an event's healing conditions
 *
 * \details       Processes the healing counter. If the healing conditions
 *                configured for the event are fulfilled, the event is healed.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     EventStatus
 *                Current event status of the event
 *
 * \return        Modified event status based on the status passed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventProcessHealing(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventStatus
  );

/* ****************************************************************************
 * Dem_Esm_EventOpCycleEnd_Healing
 *****************************************************************************/
/*!
 * \brief         Processes healing at the end of the event's operation cycle
 *
 * \details       Processes healing at the end of the event's operation cycle.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     EventStatus
 *                Current event status
 *
 * \return        TRUE if the event has fulfilled the preconditions to start aging
 *                FALSE if the event is blocked from aging
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventOpCycleEnd_Healing(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventStatus
  );

#if (DEM_FEATURE_NEED_AGING_TRIGGER_CYCLE == STD_ON) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventOpCycleEnd_Aging
 *****************************************************************************/
/*!
 * \brief         Processes aging at the end of the event's operation cycle
 *
 * \details       Processes aging at the end of the event's operation cycle.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     EventStatus
 *                Current event status
 * \param[in]     OldDtcStatus
 *                Dtc status before cycle restart
 *
 * \pre           -
 * \config        (DEM_FEATURE_NEED_AGING_TRIGGER_CYCLE == STD_ON) ||
 *                (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleEnd_Aging(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventStatus,
  CONST(uint8, AUTOMATIC)  OldDtcStatus
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventOpCycleEnd
 *****************************************************************************/
/*!
 * \brief         Processes the end of the event's operation cycle
 *
 * \details       Processes actions performed at the end of the event's operation
 *                cycle, i.e. healing, aging start condition.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     OldDtcStatus
 *                Dtc status before cycle restart
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleEnd(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  OldDtcStatus
  );

#if ((DEM_CFG_AGING_NEXT_TESTS_TNCTOC == STD_ON) || (DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON))
/* ****************************************************************************
 * Dem_Esm_TestStatusForAgingCycle
 *****************************************************************************/
/*!
 * \brief         Tests whether the current cycle fulfills the conditions for
 *                aging
 *
 * \details       Tests whether the current cycle fulfills the conditions for
 *                aging
 *
 * \param[in]     EventStatus
 *                UDS event status to test
 *
 * \return        TRUE
 *                The aging conditions are fulfilled for this cycle
 * \return        FALSE
 *                the aging conditions are not fulfilled for this cycle
 *
 * \pre           -
 * \config        DEM_CFG_AGING_NEXT_TESTS_TNCTOC == STD_ON ||
 *                DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestStatusForAgingCycle(
  CONST(uint8, AUTOMATIC)  EventStatus
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventAgingCycle
 *****************************************************************************/
/*!
 * \brief         Processes the aging cycle for an event
 *
 * \details       Processes the aging cycle for an event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     CycleCounter
 *                Current cycle count
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingCycle(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint16, AUTOMATIC)  CycleCounter,
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventCleared_Optional
 *****************************************************************************/
/*!
 * \brief         Clears an event from the given origin memory, if allowed
 *
 * \details       This function clears an event based on the return value of
 *                its 'clear event allowed' callback.
 *                InitMonitor notifications are called also when the event is
 *                not allowed to be cleared.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        TRUE
 *                The event was cleared
 * \return        FALSE
 *                The event was not cleared
 *
 * \pre           RTE must be started
 * \config        DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventCleared_Optional(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED != STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventCleared_Always
 *****************************************************************************/
/*!
 * \brief         Clears an event from the given origin memory
 *
 * \details       Clears an event from the given origin memory
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_NOTIFY_CLEAR_ALLOWED != STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventCleared_Always(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_RESTART_DCY_ON_CLEAR_DTC == STD_ON)                                     /* COV_MSR_UNSUPPORTED XF xf xf */
/* ****************************************************************************
 * Dem_Esm_PreOnClear_AllDtc
 *****************************************************************************/
/*!
 * \brief         Restarts the DCY before Clear DTC is processed
 *
 * \details       This function is called before ClearAllDTC is processed.
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_OBD == STD_ON &&
 *                DEM_CFG_SUPPORT_RESTART_DCY_ON_CLEAR_DTC == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PreOnClear_AllDtc(
  CONST(uint8, AUTOMATIC)  MemoryId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_PostOnClear_AllDtc
 *****************************************************************************/
/*!
 * \brief         Clears global statistics after Clear DTC was processed
 *
 * \details       This function is called when ClearAllDTC was finished.
 *                It clears all global statistic data which is cleared only
 *                on ClearAllDTC requests.
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PostOnClear_AllDtc(
  CONST(uint8, AUTOMATIC)  MemoryId
  );

/* ****************************************************************************
 * Dem_Esm_PostOnClear_Always
 *****************************************************************************/
/*!
 * \brief         Clears global OBD statistics after Clear DTC was processed
 *
 * \details       This function is called after a ClearDTC request was processed.
 *                It clears all global statistic data which is cleared with
 *                all clear requests.
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PostOnClear_Always(
  CONST(uint8, AUTOMATIC)  MemoryId
  );

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventDisplaced
 *****************************************************************************/
/*!
 * \brief         Updates the status of a displaced event
 *
 * \details       Updates the status of a displaced event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisplaced(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_CycleUpdateStored
 *****************************************************************************/
/*!
 * \brief         Processes cycle update for stored entries
 *
 * \details       This function processes the aging cycle updates for all
 *                events currently stored in the event memory. This has effect
 *                only on events using the given aging cycle, when their aging
 *                condition is fulfilled for this cycle.
 *                This function also processes data updates on operation cycle
 *                change.
 *
 *                This function expects that the cycle counter has already been
 *                incremented for the cycle.
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 * \param[in]     CycleCounter
 *                Current cycle count
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdateStored(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint16, AUTOMATIC)  CycleCounter
  );

/* ****************************************************************************
 * Dem_Esm_CycleUpdateReadiness
 *****************************************************************************/
/*!
 * \brief         Processes operation cycle updates
 *
 * \details       This function processes the operation cycle updates for all
 *                events using that cycle as operation cycle.
 *
 *                Since operation cycles can restart or only stop/start, the
 *                cycle status can be one of DEM_QUEUE_CYCLE_STARTED,
 *                DEM_QUEUE_CYCLE_STOPPED or DEM_QUEUE_CYCLE_RESTARTED (most
 *                other APIs only accept the first two states).
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 * \param[in]     CycleStatus
 *                Cycle status changes
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdateReadiness(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint8, AUTOMATIC)  CycleStatus
  );

                                                                    /* Timer */
/* ------------------------------------------------------------------------- */
                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Queue_PreInit
 *****************************************************************************/
/*!
 * \brief         Pre-Initializes Dem queue states
 *
 * \details       This function initializes all global variables encoding queue
 *                states. Queued elements are qualification of events, e.g.
 *                FDCTRIP and PASSED<->FAILED toggles, as well as changes to a
 *                cycle state.
 *
 * \pre           May be called only during pre-initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_PreInit(
  void
  );

/* ****************************************************************************
 * Dem_Queue_Init
 *****************************************************************************/
/*!
 * \brief         Initializes the Dem queue states
 *
 * \details       This function initializes all global variables required to
 *                defer asynchronous requests to be processed on the Dem task
 *                function.
 *
 * \pre           May be called only during initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_Init(
  void
  );

/* ****************************************************************************
 * Dem_Queue_Shutdown
 *****************************************************************************/
/*!
 * \brief         Clears the Dem queue states
 *
 * \details       This function clears all global variables used to defer
 *                asynchronous requests to be processed on the Dem task
 *                function.
 *
 * \pre           May be called only during module shutdown
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_Shutdown(
  void
  );

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ProcessFilterEventData
 *****************************************************************************/
/*!
 * \brief         Prepares event data for diagnostic output
 *
 * \details       The function creates a copy of an event's stored environment
 *                data. The reading Dcm functions access this copy instead of
 *                the live data to guarantee a consistent output.
 *
 * \pre           The Dcm read buffer is currently not in use
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessFilterEventData(
  void
  );
#endif

#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ProcessClearSingleDtc
 *****************************************************************************/
/*!
 * \brief         Clears a single dtc
 *
 * \details       This function clears a single DTC and manages the related
 *                API state transitions.
 *
 * \return        TRUE
 *                The event was cleared
 * \return        FALSE
 *                The event was not cleared, clearing was forbidden by the
 *                application
 *
 * \pre           -
 * \config        DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Queue_ProcessClearSingleDtc(
  void
  );
#endif

/* ****************************************************************************
 ! Dem_Queue_ProcessClearDtc
 *****************************************************************************/
/*!
 * \brief         Processes clear dtc requests
 *
 * \details       This function processes clear DTC requests. Group clear is
 *                optionally distributed across multiple tasks, single clear
 *                is processed immediately.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessClearDtc(
  void
  );

/* ****************************************************************************
 * Dem_Queue_ProcessEvent_Queued
 *****************************************************************************/
/*!
 * \brief         Processes events queued with the QUEUED mechanism
 *
 * \details       This function decodes the sequence of event reports stored
 *                for the given event, and calls the respective event processor
 *                functions, selecting the QUEUED processor variant to also
 *                handle transitions of asynchronous bit.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     QueueStatus
 *                Queued state of the event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  QueueStatus
  );

/* ****************************************************************************
 * Dem_Queue_ProcessEvent_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes events queued with the IMMEDIATE mechanism
 *
 * \details       This function decodes the sequence of event reports and
 *                asynchronous bit transitions stored for the given event, and
 *                calls the respective event processor functions, selecting the
 *                IMMEDIATE processor variant.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     QueueStatus
 *                Queued state of the event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  QueueStatus
  );

/* ****************************************************************************
 * Dem_Queue_ProcessEvent
 *****************************************************************************/
/*!
 * \brief         Processes the queued actions of an event
 *
 * \details       This function unqueues an event and selects the appropriate
 *                processor for either QUEUED or IMMEDIATE queued events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Queue_ProcessSetEventStatus
 *****************************************************************************/
/*!
 * \brief         Processes all queued events
 *
 * \details       This function processes queued event status changes for all
 *                events
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessSetEventStatus(
  void
  );

/* ****************************************************************************
 * Dem_Queue_ProcessCycles
 *****************************************************************************/
/*!
 * \brief         Process all queued operation cycles
 *
 * \details       The function processes cycle management for aging and
 *                operation cycle management (readiness bits etc)
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessCycles(
  void
  );

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ProcessEventEnableConditions
 *****************************************************************************/
/*!
 * \brief         Processes changes of enable condition states
 *
 * \details       This function resets or freezes debouncing of an event, based
 *                on the changes of the enable condition states since this
 *                function was called last. When the event is re-enabled, this
 *                function also calls the init monitor notifications.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     OldConditionStates
 *                Previous enable condition states
 * \param[in]     NewConditionStates
 *                Updated enable condition states
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEventEnableConditions(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint32, AUTOMATIC)  OldConditionStates,
  CONST(uint32, AUTOMATIC)  NewConditionStates
  );
#endif

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ProcessEnableConditions
 *****************************************************************************/
/*!
 * \brief         Process enable condition changes
 *
 * \details       This function processes changes of the enable conditions for
 *                all events.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEnableConditions(
  void
  );
#endif

/* ****************************************************************************
 * Dem_Queue_MainFunction
 *****************************************************************************/
/*!
 * \brief         Process all queued actions
 *
 * \details       Process all queued actions
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_MainFunction(
  void
  );

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Data_EntryInit
 *****************************************************************************/
/*!
 * \brief         Initializes an event memory entry
 *
 * \details       Initializes an event memory entry
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_EntryInit(
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry
  );

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_CollectSnapshot
 *****************************************************************************/
/*!
 * \brief         Samples a snapshot for an event
 *
 * \details       Samples a snapshot for an event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in,out] DestinationBuffer
 *                Pointer to the buffer to store the data
 * \param[in]     BufferSize
 *                Size of the destination buffer
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectSnapshot(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_SharedDataPtrType, AUTOMATIC)  DestinationBuffer,
  CONST(uint16, AUTOMATIC)  BufferSize
  );
#endif
#if (DEM_CFG_SUPPORT_SRECS == STD_ON) && (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Data_PrestorageApplySRec
 *****************************************************************************/
/*!
 * \brief         Copies a prestored snapshot for an event
 *
 * \details       This function copies the prestored data only if a prestored
 *                entry has been locked for the event. Otherwise, this function
 *                does not modify the destination buffer.
 *
 * \param[out]    DestinationBuffer
 *                Pointer to the buffer to store the data
 * \param[in]     BufferSize
 *                Size of the destination buffer
 *
 * \return        TRUE
 *                Data has been copied
 * \return        FALSE
 *                No data has been copied
 *
 * \pre           A Prestorage entry has been locked
 * \config        DEM_CFG_SUPPORT_SRECS == STD_ON &&
 *                DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_PrestorageApplySRec(
  CONST(Dem_SharedDataPtrType, AUTOMATIC)  DestinationBuffer,
  CONST(uint16, AUTOMATIC)  BufferSize
  );
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_EntryUpdate_UserERecs
 *****************************************************************************/
/*!
 * \brief         Collects the user provided extended data records stored for
 *                an event entry.
 *
 * \details       Collects the user provided extended data records stored for
 *                an event entry.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 *
 * \return        Block modification bitmask:
 *                DEM_DATA_NO_CHANGES          nothing has changed
 *                DEM_DATA_USERDATA_CHANGED    user provided data was updated
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_USER_ERECS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_EntryUpdate_UserERecs(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry
  );
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_EntryUpdate_SRecs
 *****************************************************************************/
/*!
 * \brief         Collect all user snapshot records for an event
 *
 * \details       This function will look for every snapshot record of the
 *                event that needs updating due to the status changes encoded
 *                by the trigger flags.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 * \param[in]     UpdateFlags
 *                Trigger flags
 *
 * \return        Block modification bitmask:
 *                DEM_DATA_NO_CHANGES          nothing has changed
 *                DEM_DATA_USERDATA_CHANGED    user provided data was updated
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_EntryUpdate_SRecs(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  UpdateFlags
  );
#endif

/* ****************************************************************************
 * Dem_Data_EntryUpdate
 *****************************************************************************/
/*!
 * \brief         Updates all data stored for an event.
 *
 * \details       Depending on configuration of the event data, collect the
 *                data to be updated due to the update trigger(s) in UpdateFlags.
 *                This includes statistical data (e.g. occurrence counter) as
 *                well as environment data collected from callback routines.
 *
 *                Statistical data is stored separately in the MemoryEntry and
 *                is mapped into snapshot and extended records when reading the
 *                data.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     UpdateFlags
 *                Trigger flags
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \return        Block modification bitmask:
 *                DEM_DATA_NO_CHANGES, or some of
 *                DEM_DATA_USERDATA_CHANGED
 *                DEM_DATA_STATISTICS_CHANGED
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_EntryUpdate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  UpdateFlags,
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  );

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Data_CalculateFDC_CounterBased
 *****************************************************************************/
/*!
 * \brief         Calculates the current fault detection counter of an event.
 *
 * \details       Calculates the current fault detection counter of an event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     DebounceValue
 *                Debounce counter value
 *
 * \return        The FaultDetectionCounter based on DebounceValue
 *
 * \pre           The event must use counter based debouncing
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_CalculateFDC_CounterBased(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(sint16, AUTOMATIC)  DebounceValue
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Data_CalculateFDC_TimeBased
 *****************************************************************************/
/*!
 * \brief         Calculates the current fault detection counter of an event.
 *
 * \details       Calculates the current fault detection counter of an event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     DebounceValue
 *                Debounce time value
 * \param[in]     DebounceStatus
 *                Debouncing state
 *
 * \return        The FaultDetectionCounter based on the given time and state
 *
 * \pre           The event must use time based debouncing
 * \config        DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_CalculateFDC_TimeBased(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(sint16, AUTOMATIC)  DebounceValue,
  CONST(uint8, AUTOMATIC)  DebounceStatus
  );
#endif

#if ((DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)) \
 || ((DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON))
/* ****************************************************************************
 * Dem_Data_EventGetFDCMax
 *****************************************************************************/
/*!
 * \brief         Gets the maximum fault detection counter of an event
 *
 * \details       This function retrieves the maximum value of the FDC in
 *                the current operation cycle. In case of monitor internal
 *                debouncing, this function returns an estimate based on the
 *                event's UDS status byte.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The maximum FDC this operation cycle
 *
 * \pre           -
 * \config        (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
 *             || (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON && DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_EventGetFDCMax(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_ERecIsStored
 *****************************************************************************/
/*!
 * \brief         Tests whether an extended record is currently stored
 *
 * \details       Tests whether an extended record is currently stored
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 * \param[in]     ERecStoredIndex
 *                Index of the extended record
 *
 * \return        TRUE
 *                The record is stored
 * \return        FALSE
 *                The record is not stored
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_USER_ERECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_ERecIsStored(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  ERecStoredIndex
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_SRecCount
 *****************************************************************************/
/*!
 * \brief         Counts the number of snapshot records stored in a memory
 *                entry
 *
 * \details       Counts the number of snapshot records stored in a memory
 *                entry
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 *
 * \result        Number of stored snapshot records
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON &&
 *                DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_SRecCount(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry
  );
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_SRecIsStored
 *****************************************************************************/
/*!
 * \brief         Tests whether a snapshot record is currently stored
 *
 * \details       Tests whether a snapshot record is currently stored
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 * \param[in]     SRecStoredIndex
 *                Index of the snapshot record
 *
 * \return        TRUE
 *                The record is stored
 * \return        FALSE
 *                The record is not stored
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_SRecIsStored(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  SRecStoredIndex
  );
#endif

#if ( (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
/* ****************************************************************************
 * Dem_Data_SkipDid
 *****************************************************************************/
/*!
 * \brief         Skip data elements
 *
 * \details       Moves the read (source) pointer in the copy context to skip
 *                the stored data for the given DID. This function has no
 *                effect if the DID does not have persisted data, e.g. if the
 *                DID is composed of statistical values.
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 * \param[in]     DidIndex
 *                Unique handle of the DID
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_SRECS == STD_ON ||
 *                DEM_CFG_SUPPORT_OBDII == STD_ON ||
 *                DEM_CFG_SUPPORT_WWHOBD == STD_ON ||
 *                DEM_FEATURE_NEED_TIME_SERIES == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_SkipDid(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DidIndexType, AUTOMATIC)  DidIndex
  );
#endif

#if ( (DEM_CFG_SUPPORT_DCM == STD_ON) \
   && ((DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON)) )
/* ****************************************************************************
 * Dem_Data_SRecCopyData
 *****************************************************************************/
/*!
 * \brief         Copies the contents of a stored snapshot record
 *
 * \details       This function formats the snapshot data stored in the source
 *                according to the UDS specification and copies the result into
 *                the given destination buffer.
 *                The function will abort copying data if the destination is
 *                too small.
 *
 * \param[out]    DestBuffer
 *                Pointer to the destination buffer
 * \param[in]     SourceBuffer
 *                Pointer to the source buffer
 * \param[in]     BufferSize
 *                Size of the destination buffer
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           A memory entry must have been copied to the intermediate
 *                buffer (see Dem_DcmDisableDTCRecordUpdate)
 * \pre           Existence of the record must be verified before calling this
 *                function, otherwise random data will be copied.
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON &&
 *                (DEM_CFG_SUPPORT_SRECS == STD_ON ||
 *                DEM_FEATURE_NEED_TIME_SERIES == STD_ON)
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_SRecCopyData(
  CONST(Dem_SharedDataPtrType, AUTOMATIC)  DestBuffer,
  CONST(Dem_ConstSharedDataPtrType, AUTOMATIC)  SourceBuffer,
  CONST(uint16, AUTOMATIC)  BufferSize,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_FEATURE_NEED_CYCLE_COUNTERS == STD_ON)
/* ****************************************************************************
 * Dem_Data_EntryOpCycleStart
 *****************************************************************************/
/*!
 * \brief         Latches overflowing operation cycle counters
 *
 * \details       Latches overflowing operation cycle counters
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 * \param[in]     CycleCount
 *                The new cycle counter
 *
 * \return        TRUE
 *                The memory entry has been modified
 * \return        FALSE
 *                The memory entry has not been modified
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_CYCLE_COUNTERS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryOpCycleStart(
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint16, AUTOMATIC)  CycleCount
  );
#endif

#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 * Dem_Data_DtcOpCycleUpdate
 *****************************************************************************/
/*!
 * \brief         Updates operation cycle counters, if necessary
 *
 * \details       Updates operation cycle counters, if necessary
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     DtcStatus
 *                DTC status byte
 * \param[in]     CycleStatus
 *                Cycle status changes
 *
 * \pre           The passed event must be a master event
 * \config        DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON ||
 *                DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_DtcOpCycleUpdate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  DtcStatus,
  CONST(uint8, AUTOMATIC)  CycleStatus
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Data_PrestorageEntryUpdate
 *****************************************************************************/
/*!
 * \brief         Samples all event related data into a prestorage entry
 *
 * \details       Samples all event related data into a prestorage entry
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     PrestoredEntry
 *                Pointer to the prestorage entry
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_PrestorageEntryUpdate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Mem_PrestoredEntryPtrType, AUTOMATIC)  PrestoredEntry
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_AGINGCTR == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyUpwardsAgingCounter
 *****************************************************************************/
/*!
 * \brief         Retrieves the aging counter of the event holding the event
 *                memory entry as upward counting data element
 *
 * \details       Retrieves the aging counter of the event holding the event
 *                memory entry as upward counting data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_AGINGCTR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyUpwardsAgingCounter(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyDownwardsAgingCounter
 *****************************************************************************/
/*!
 * \brief         Retrieves the aging counter of the event holding the event
 *                memory entry as downward counting data element
 *
 * \details       Retrieves the aging counter of the event holding the event
 *                memory entry as downward counting data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyDownwardsAgingCounter(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OCCCTR == STD_ON)
/* ****************************************************************************
 * Dem_Data_Copy1ByteOccurrenceCounter
 *****************************************************************************/
/*!
 * \brief         Retrieves the occurrence counter of the event holding the
 *                event memory entry as 1 byte data element
 *
 * \details       An occurrence counter that will not fit 1 byte is written as
 *                255.
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_OCCCTR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_Copy1ByteOccurrenceCounter(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
/* ****************************************************************************
 * Dem_Data_Copy2ByteOccurrenceCounter
 *****************************************************************************/
/*!
 * \brief         Retrieves the occurrence counter of the event holding the
 *                event memory entry as 2 byte data element
 *
 * \details       Retrieves the occurrence counter of the event holding the
 *                event memory entry as 2 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_Copy2ByteOccurrenceCounter(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OVFLIND == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyOverflowIndication
 *****************************************************************************/
/*!
 * \brief         Retrieves the event memory overflow state as 1 byte data
 *                element
 *
 * \details       Retrieves the event memory overflow state as 1 byte data
 *                element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_OVFLIND == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyOverflowIndication(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_SIGNIFICANCE == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyEventSignificance
 *****************************************************************************/
/*!
 * \brief         Retrieves the significance configuration of the event holding
 *                the event memory entry as 1 byte data element
 *
 * \details       Retrieves the significance configuration of the event holding
 *                the event memory entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_SIGNIFICANCE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventSignificance(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_PRIORITY == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyEventPriority
 *****************************************************************************/
/*!
 * \brief         Retrieves the priority configuration of the event holding
 *                the event memory entry as 1 byte data element
 *
 * \details       Retrieves the priority configuration of the event holding
 *                the event memory entry as 1 byte data element.
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_PRIORITY == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventPriority(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyMaxFdcSinceLastClear
 *****************************************************************************/
/*!
 * \brief         Retrieves the maximum fault detection counter since last
 *                clear of the event holding the event memory entry as 1 byte
 *                data element
 *
 * \details       Retrieves the maximum fault detection counter since last
 *                clear of the event holding the event memory entry as 1 byte
 *                data element.
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyMaxFdcSinceLastClear(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyMaxFdcThisCycle
 *****************************************************************************/
/*!
 * \brief         Retrieves the maximum fault detection counter this cycle
 *                of the event holding the event memory entry as 1 byte data
 *                element
 *
 * \details       Retrieves the maximum fault detection counter this cycle
 *                of the event holding the event memory entry as 1 byte data
 *                element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyMaxFdcThisCycle(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCyclesSinceLastFailed
 *****************************************************************************/
/*!
 * \brief         Retrieves the cycle count since last failed of the event
 *                holding the event memory entry as 1 byte data element
 *
 * \details       Retrieves the cycle count since last failed of the event
 *                holding the event memory entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesSinceLastFailed(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCyclesSinceFirstFailed
 *****************************************************************************/
/*!
 * \brief         Retrieves the cycle count since first failed of the event
 *                holding the event memory entry as 1 byte data element
 *
 * \details       Retrieves the cycle count since first failed of the event
 *                holding the event memory entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesSinceFirstFailed(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyFailedCycles
 *****************************************************************************/
/*!
 * \brief         Retrieves the number of cycles tested failed of the event
 *                holding the event memory entry as 1 byte data element
 *
 * \details       Retrieves the number of cycles tested failed of the event
 *                holding the event memory entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_FAILED_CYCLES == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyFailedCycles(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyConsecutiveFailedCycles
 *****************************************************************************/
/*!
 * \brief         Retrieves the number of consecutive cycles tested failed of
 *                the event holding the event memory entry as 1 byte data element
 *
 * \details       Retrieves the number of consecutive cycles tested failed of
 *                the event holding the event memory entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyConsecutiveFailedCycles(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCyclesTestedSinceFirstFailed
 *****************************************************************************/
/*!
 * \brief         Retrieves the number of cycles tested since first failed of
 *                the event holding the event memory entry as 1 byte data element
 *
 * \details       Retrieves the number of cycles tested since first failed of
 *                the event holding the event memory entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesTestedSinceFirstFailed(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyRootCauseEventId
 *****************************************************************************/
/*!
 * \brief         Retrieves the event that caused event memory storage as
 *                2 byte data element
 *
 * \details       Retrieves the event that caused event memory storage as
 *                2 byte data element. For combined events, this is the exact
 *                sub-event.
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyRootCauseEventId(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OBDDTC == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyEventObdDtc
 *****************************************************************************/
/*!
 * \brief         Retrieves the OBD DTC number of the event that stored the
 *                event memory entry as 2 byte data element
 *
 * \details       Retrieves the OBD DTC number of the event that stored the
 *                event memory entry as 2 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_OBDDTC == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventObdDtc(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OBDDTC_3BYTE == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyEventObdDtc_3Byte
 *****************************************************************************/
/*!
 * \brief         Retrieves the OBD DTC number of the event that stored the
 *                event memory entry as 3 byte data element with trailing 0
 *
 * \details       Retrieves the OBD DTC number of the event that stored the
 *                event memory entry as 3 byte data element with trailing 0
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_OBDDTC_3BYTE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventObdDtc_3Byte(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CURRENT_FDC == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCurrentFdc
 *****************************************************************************/
/*!
 * \brief         Retrieves the current fault detection counter of the event
 *                holding the event memory entry as 1 byte data element
 *
 * \details       Retrieves the current fault detection counter of the event
 *                holding the event memory entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON &&
 *                DEM_CFG_DATA_CURRENT_FDC == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCurrentFdc(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyStoredUserData
 *****************************************************************************/
/*!
 * \brief         Retrieves the user data stored in the event memory entry or
 *                time series entry
 *
 * \details       Retrieves the user data stored in the event memory entry or
 *                time series entry
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 * \param[in]     DataIndex
 *                Index of requested data element
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyStoredUserData(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCurrentUserData
 *****************************************************************************/
/*!
 * \brief         Retrieves current user data for an event that holds an event
 *                memory or time series entry
 *
 * \details       Retrieves current user data for an event that holds an event
 *                memory or time series entry
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 * \param[in]     DataIndex
 *                Index of requested data element
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCurrentUserData(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
  );
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCurrentUserDataWithEventId
 *****************************************************************************/
/*!
 * \brief         Retrieves current user data with event Id for an event that
 *                holds an event memory or time series entry
 *
 * \details       Retrieves current user data with event Id for an event that
 *                holds an event memory or time series entry
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 * \param[in]     DataIndex
 *                Index of requested data element
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCurrentUserDataWithEventId(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
  );
#endif

#if ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
/* ****************************************************************************
 * Dem_Data_CollectStoredUserData
 *****************************************************************************/
/*!
 * \brief         Store user data for an event
 *
 * \details       Retrieves user data from the application and stores it into
 *                the passed buffer.
 *
 * \param[in]     CollectDidInfoPtr
 *                CollectDid context
 * \param[in]     DataIndex
 *                Index of requested data element
 *
 * \pre           -
 * \config        ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
 *               || (DEM_CFG_SUPPORT_SRECS == STD_ON)
 *               || (DEM_CFG_SUPPORT_OBDII == STD_ON)
 *               || (DEM_CFG_SUPPORT_WWHOBD == STD_ON)
 *               || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON)
 *               || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectStoredUserData(
  CONST(Dem_Data_CollectDidInfoPtrType, AUTOMATIC)  CollectDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
  );
#endif

#if ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
/* ****************************************************************************
 * Dem_Data_CollectStoredUserDataWithEventId
 *****************************************************************************/
/*!
 * \brief         Store user data for an event
 *
 * \details       Retrieves user data from the application and stores it into
 *                the passed buffer. The callback also passes the EventId to
 *                the application.
 *
 * \param[in]     CollectDidInfoPtr
 *                CollectDid context
 * \param[in]     DataIndex
 *                Index of requested data element
 *
 * \pre           -
 * \config        ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
 *               || (DEM_CFG_SUPPORT_SRECS == STD_ON)
 *               || (DEM_CFG_SUPPORT_OBDII == STD_ON)
 *               || (DEM_CFG_SUPPORT_WWHOBD == STD_ON)
 *               || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON)
 *               || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectStoredUserDataWithEventId(
  CONST(Dem_Data_CollectDidInfoPtrType, AUTOMATIC)  CollectDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
  );
#endif

#if ( ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON) \
     || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
     || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
     || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
     || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
     || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) ) \
   && (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON) )
/* ****************************************************************************
 * Dem_Data_CollectRootCauseEventId
 *****************************************************************************/
/*!
 * \brief         Store the event that caused event memory storage
 *
 * \details       Stores the EventId of the event which caused event memory
 *                storage. For combined events this stores the exact sub-event.
 *
 * \param[in]     CollectDidInfoPtr
 *                CollectDid context
 *
 * \pre           -
 * \config        ( ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
 *                 || (DEM_CFG_SUPPORT_SRECS == STD_ON)
 *                 || (DEM_CFG_SUPPORT_OBDII == STD_ON)
 *                 || (DEM_CFG_SUPPORT_WWHOBD == STD_ON)
 *                 || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON)
 *                 || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
 *               && (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON) )
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectRootCauseEventId(
  CONST(Dem_Data_CollectDidInfoPtrType, AUTOMATIC)  CollectDidInfoPtr
  );
#endif

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_CommitBlock
 *****************************************************************************/
/*!
 * \brief         Processes NvM synchronization
 *
 * \details       This function writes the memory block marked for immediate
 *                synchronization into the NV storage.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_CommitBlock(
  void
  );
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_ProcessQueue
 *****************************************************************************/
/*!
 * \brief         Process updates of deferred dirty markers
 *
 * \details       To avoid critical sections some NV block status updates are
 *                deferred. This function processes those updates.
 *                This function also processes the application request for
 *                complete NV-Ram synchronization.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_ProcessQueue(
  void
  );
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) && (DEM_CFG_SUPPORT_NVM_POLLING == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_GetNvMResult
 *****************************************************************************/
/*!
 * \brief         Poll the result of an ongoing write job
 *
 * \details       Poll the result of an ongoing write job
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON &&
 *                DEM_CFG_SUPPORT_NVM_POLLING == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_GetNvMResult(
  void
  );
#endif

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_Init
 *****************************************************************************/
/*!
 * \brief         Initializes the NvM management
 *
 * \details       Initializes the NvM management
 *
 * \pre           May be called only during module initialization
 * \config        DEM_CFG_USE_NVM == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_Init(
  void
  );
#endif

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_Shutdown
 *****************************************************************************/
/*!
 * \brief         Finalize NvM block status
 *
 * \details       All pending Nv updates are reported as modified block for the
 *                NvM. (NvM_SetRamBlockStatus). The Dem assumes that all such
 *                marked blocks are persisted in NV-Ram using NvM_WriteAll
 *                following the Dem shutdown. This is not in scope of the Dem
 *                module however.
 *                If Dem_Shutdown is ever called without a following
 *                NvM_WriteAll, data will be lost.
 *
 * \pre           May be called only during module shutdown
 * \config        DEM_CFG_USE_NVM == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_Shutdown(
  void
  );
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_MainFunction
 *****************************************************************************/
/*!
 * \brief         Processes NvM synchronization
 *
 * \details       The function controls NvM commits. Modified blocks are passed
 *                to the NvM to write back, and once the write operation has
 *                finished the next modified block is processed.
 *                In case of polling, NvM job results are updated here as well.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_MainFunction(
  void
  );
#endif

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterGetReportedEvents
 *****************************************************************************/
/*!
 * \brief         Get the reported event mask
 *
 * \details       Get the reported event mask
 *
 * \param[in]     FilterIndex
 *                Index of the mask
 *
 * \return        The reported event mask
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Dcm_FilterGetReportedEvents(
  CONST(uint16, AUTOMATIC)  FilterIndex
  );
#endif

#if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterSetReportedEvents
 *****************************************************************************/
/*!
 * \brief         Set the reported event mask
 *
 * \details       Set the reported event mask
 *
 * \param[in]     FilterIndex
 *                Index of the mask
 * \param[in]     FilterValue
 *                New reported event mask
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_FilterSetReportedEvents(
  CONST(uint16, AUTOMATIC)  FilterIndex,
  CONST(uint8, AUTOMATIC)  FilterValue
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_GetDtcCache
 *****************************************************************************/
/*!
 * \brief         Get the DTC cache for a client
 *
 * \details       Get the DTC cache for a client
 *
 * \param[in]     ClientId
 *                Id of the client
 *
 * \return        Pointer to the DTC cache
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON || DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Dcm_DtcCachePtrType, DEM_CODE)
Dem_Dcm_GetDtcCache(
  CONST(uint8, AUTOMATIC)  ClientId
  );
#endif

/* ****************************************************************************
 * Dem_Dcm_Init
 *****************************************************************************/
/*!
 * \brief         Initializes DCM state variables
 *
 * \details       Initializes DCM state variables
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_Init(
  void
  );

#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ***************************************************************************
 * Dem_Dcm_FindEventFromUdsDtc
 *****************************************************************************/
/*!
 * \brief         Looks up the EventId corresponding to a DTC number.
 *
 * \details       This function searches for an event using the given UdsDtc
 *                number in the requested event memory. In contrast to
 *                Dem_Cfg_FindEventFromUdsDtc, the DTC number and EventId are
 *                cached in case the same DTC is requested again - which happens
 *                frequently for Dcm access.
 *
 * \param[in]     UdsDtc
 *                The UDS DTC number
 * \param[in]     MemoryId
 *                The memory Id
 * \param[in]     ClientId
 *                Id of the client
 *
 * \return        The EventId using the given DTC number in the requested event
 *                memory. DEM_EVENT_INVALID if no matching event is found.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON ||
 *                DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FindEventFromUdsDtc(
  CONST(uint32, AUTOMATIC)  UdsDtc,
  CONST(uint8, AUTOMATIC)  MemoryId,
  CONST(uint8, AUTOMATIC)  ClientId
  );
#endif

/* ****************************************************************************
 * Dem_Dcm_ClearDtcTestIterInit
 *****************************************************************************/
/*!
 * \brief         Init the DTC test function iterator
 *
 * \details       Initializes the iterator to enumerate all DTC test functions
 *                for the given memory and DTC format.
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 * \param[in]     DTCFormat
 *                Format of the DTC (UDS, OBD, J1939)
 * \param[in]     IterPtr
 *                Pointer to the iterator
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_ClearDtcTestIterInit(
  CONST(uint8, AUTOMATIC) MemoryId,
  CONST(uint8, AUTOMATIC) DTCFormat,
  CONSTP2VAR(Dem_Dcm_ClearDtc_TestIterType, AUTOMATIC, AUTOMATIC) IterPtr
  );

/* ****************************************************************************
 * Dem_Dcm_ClearDtcTestIterExists
 *****************************************************************************/
/*!
 * \brief         Test if the iterator points to a valid element
 *
 * \details       Test if the iterator points to a valid element
 *
 * \param[in]     IterPtr
 *                Pointer to the iterator
 *
 * \return        TRUE
 *                Dem_Dcm_ClearDtcTestIterGet() will return a valid element
 *                on this iterator
 * \return        FALSE
 *                Dem_Dcm_ClearDtcTestIterGet() will return a fallback element
 *                on this iterator
 *
 * \pre           IterPtr has been initialized
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Dcm_ClearDtcTestIterExists(
  CONSTP2CONST(Dem_Dcm_ClearDtc_TestIterType, AUTOMATIC, AUTOMATIC) IterPtr
  );

/* ****************************************************************************
 * Dem_Dcm_ClearDtcTestIterGet
 *****************************************************************************/
/*!
 * \brief         Get the element pointed to by the iterator
 *
 * \details       If the iterator is still valid (Dem_Dcm_ClearDtcTestIterExists)
 *                get the current DTC test function.
 *                Otherwise, the function returns a fallback function that is
 *                safe to call.
 *
 * \param[in]     IterPtr
 *                Pointer to the iterator
 *
 * \return        A DTC test function to test if a DTC number requests a valid
 *                clear operation. If so, it will also initialize the ClearDTC
 *                filter appropriately.
 *
 * \pre           IterPtr has been initialized
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CODE)
Dem_Dcm_ClearDtcTestIterGet(
  CONSTP2CONST(Dem_Dcm_ClearDtc_TestIterType, AUTOMATIC, AUTOMATIC) IterPtr
  );

/* ****************************************************************************
 * Dem_Dcm_ClearDtcTestIterNext
 *****************************************************************************/
/*!
 * \brief         Move the iterator to the next element
 *
 * \details       Move the iterator to the next element. Has no effect if the
 *                iterator already is at its end.
 *
 * \param[in]     IterPtr
 *                Pointer to the iterator
 *
 * \pre           IterPtr has been initialized
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_ClearDtcTestIterNext(
  CONSTP2VAR(Dem_Dcm_ClearDtc_TestIterType, AUTOMATIC, AUTOMATIC) IterPtr
  );

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_CopyDidFromSRec
 *****************************************************************************/
/*!
 * \brief         Extracts a snapshot record, or a single DID from it
 *
 * \details       The stored snapshot data of the event is written to
 *                DestBuffer in no particular format. This means in case of
 *                ReportTotalRecord == TRUE all data is simply concatenated.
 *                The record number 0xff (in this case: most recent snapshot)
 *                is supported only in configurations using calculated record
 *                numbers.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     RecordNumber
 *                Snapshot record number
 * \param[in]     ReportTotalRecord
 *                TRUE:  Return the data of all stored DIDs (unformatted)
 *                FALSE: Return only the data of the DID 'DataId'
 * \param[in]     DataId
 *                Return only the data of this DID. Only evaluated if also
 *                ReportTotalRecord == FALSE.
 * \param[out]    DestBuffer
 *                Pointer to the destination buffer
 *
 * \return        E_OK
 *                The requested data was copied to the destination buffer
 * \return        E_NOT_OK
 *                The requested data was not copied due to an error. E.g. when
 *                called with invalid arguments, or the data is concurrently
 *                updated.
 * \return        DEM_E_NODATAAVAILABLE
 *                The data is not currently stored for the requested event.
 * \return        DEM_E_WRONG_RECORDNUMBER
 *                The requested data was not copied due to an undefined
 *                RecordNumber for the given event.
 * \return        DEM_E_WRONG_DIDNUMBER
 *                The requested data was not copied due to an undefined
 *                data identifier (in case ReportTotalRecord == FALSE)
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyDidFromSRec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONST(boolean, AUTOMATIC)  ReportTotalRecord,
  CONST(uint16, AUTOMATIC)  DataId,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
  );
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_CopyDidSRec_Internal
 *****************************************************************************/
/*!
 * \brief         Extracts a snapshot record, or a single DID from it
 *
 * \details       The stored snapshot data of an event memory entry is written
 *                to DestBuffer in no particular format. This means in case of
 *                ReportTotalRecord == TRUE all data is simply concatenated.
 *                The record number 0xff (in this case: most recent snapshot)
 *                is supported only in configurations using calculated record
 *                numbers.
 *
 * \param[in]     Entry
 *                Primary Entry
 * \param[in]     SRecIndex
 *                Index of the snapshot record in the event memory entry
 * \param[in]     ReportTotalRecord
 *                TRUE:  Return the data of all stored DIDs (unformatted)
 *                FALSE: Return only the data of the DID 'DataId'
 * \param[in]     DataId
 *                Return only the data of this DID. Only evaluated if also
 *                ReportTotalRecord == FALSE.
 * \param[out]    DestBuffer
 *                Pointer to the destination buffer
 *
 * \return        E_OK
 *                The requested data was copied to the destination buffer
 * \return        DEM_E_WRONG_DIDNUMBER
 *                The requested data was not copied due to an undefined
 *                data indentifier within the requested record (in case
 *                ReportTotalRecord == FALSE)
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyDidSRec_Internal(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  Entry,
  CONST(uint8, AUTOMATIC)  SRecIndex,
  CONST(boolean, AUTOMATIC)  ReportTotalRecord,
  CONST(uint16, AUTOMATIC)  DataId,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
  );
#endif

#if (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_CopyERecs
 *****************************************************************************/
/*!
 * \brief         Extract an extended data record for an event
 *
 * \details       Read and copy the stored extended data record of an event. The
 *                data is written to DestBuffer in no particular format.
 *                The record numbers 0xfe and 0xff are not supported.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     RecordNumber
 *                Extended record number
 * \param[out]    DestBuffer
 *                Pointer to the destination buffer
 *
 * \return        E_OK
 *                The requested data was copied to the destination buffer
 * \return        E_NOT_OK
 *                The requested data was not copied due to an error. E.g. when
 *                called with invalid arguments, or the data is concurrently
 *                updated.
 * \return        DEM_E_NODATAAVAILABLE
 *                The data is not currently stored for the requested event.
 * \return        DEM_E_WRONG_RECORDNUMBER
 *                The requested data was not copied due to an undefined
 *                RecordNumber for the given event.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_ERECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyERecs(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_CopySRec
 *****************************************************************************/
/*!
 * \brief         Validates the request to get a snapshot record in UDS
 *                Format, and copies the data.
 *
 * \details       This function does the necessary validations and eventually
 *                calls Dem_Data_SRecCopyData to copy a snapshot record.
 *                If errors are detected, the appropriate negative response is
 *                returned.
 *                The record number 0xFF is not allowed with this function,
 *                to get all records the caller must iterate through all the
 *                numbers.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     RecordNumber
 *                Snapshot record number
 * \param[out]    DestBuffer
 *                Pointer to the destination buffer
 * \param[in,out] BufSize
 *                In: Available space in the receiving buffer
 *                Out: Number of written bytes.
 *
 * \return        DEM_GET_FFDATABYDTC_OK
 *                Data was found and returned
 * \return        DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER
 *                The requested record is not available for EventId
 * \return        DEM_GET_FFDATABYDTC_WRONG_BUFFERSIZE
 *                The destination buffer is too small
 *
 * \pre           A memory entry has to be locked for Dcm readout
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON &&
 *                DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetFreezeFrameDataByDTCType, DEM_CODE)
Dem_Dcm_CopySRec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  CONSTP2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  BufSize
  );
#endif

#if ( (DEM_CFG_SUPPORT_DCM == STD_ON) \
   && ( (DEM_CFG_SUPPORT_SRECS == STD_ON) \
     || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) \
     || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
     || (DEM_CFG_SUPPORT_WWHOBD == STD_ON)) )                                                                                    /* COV_MSR_UNSUPPORTED TF tf tf xf xf */
/* ****************************************************************************
 * Dem_Dcm_GetSizeOfSRec
 *****************************************************************************/
/*!
 * \brief         Calculates the total size of one or all snapshot record(s) of
 *                an event, formatted as UDS snapshot record (19 04)
 *
 * \details       Calculates the total size of one or all snapshot record(s) of
 *                an event, formatted as UDS snapshot record (19 04)
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     RecordNumber
 *                Snapshot record number
 * \param[out]    SizeOfFreezeFrame
 *                Number of bytes.
 *
 * \return        DEM_GETSIZEBYDTC_OK
 *                Data was found and returned
 * \return        DEM_GETSIZEBYDTC_WRONG_RECNUM
 *                The requested record is not available
 *
 * \pre           A memory entry has to be locked for Dcm readout
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON &&
 *                ( DEM_CFG_SUPPORT_SRECS == STD_ON ||
 *                  DEM_FEATURE_NEED_TIME_SERIES == STD_ON ||
 *                  DEM_CFG_SUPPORT_OBDII == STD_ON ||
 *                  DEM_CFG_SUPPORT_WWHOBD == STD_ON )
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_Dcm_GetSizeOfSRec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  SizeOfFreezeFrame
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_CopyERec
 *****************************************************************************/
/*!
 * \brief         Validates the request to get an extended data record in UDS
 *                format, and copies the data.
 *
 * \details       This function does the necessary validations and eventually
 *                calls Dem_Data_CopyDid to copy the data.
 *                If errors are detected, the appropriate negative response is
 *                returned.
 *                The record number 0xFF is not allowed with this function,
 *                to get all records the caller must iterate through all the
 *                numbers.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     RecordNumber
 *                Extended data record number
 * \param[out]    DestBuffer
 *                Pointer to the destination buffer
 * \param[in,out] BufSize
 *                In: Available space in the receiving buffer
 *                Out: Number of written bytes.
 *
 * \return        DEM_RECORD_OK
 *                Data was found and returned
 * \return        DEM_RECORD_WRONG_NUMBER
 *                The requested record is not available for EventId
 * \return        DEM_RECORD_WRONG_BUFFERSIZE
 *                The destination buffer is too small
 *
 * \pre           A memory entry has to be locked for Dcm readout
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON &&
 *                DEM_CFG_SUPPORT_ERECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetExtendedDataRecordByDTCType, DEM_CODE)
Dem_Dcm_CopyERec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  CONSTP2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  BufSize
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_GetSizeOfERec
 *****************************************************************************/
/*!
 * \brief         Calculates the total of the event's snapshot records, when
 *                formatted as UDS snapshot record (19 04)
 *
 * \details       Calculates the total of the event's snapshot records, when
 *                formatted as UDS snapshot record (19 04)
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     RecordNumber
 *                Extended data record number
 * \param[out]    SizeOfExtendedDataRecord
 *                Number of bytes.
 *
 * \return        DEM_GETSIZEBYDTC_OK
 *                Data was found and returned
 * \return        DEM_GETSIZEBYDTC_WRONG_RECNUM
 *                The requested record is not available
 *
 * \pre           A memory entry has to be locked for Dcm readout
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON &&
 *                DEM_CFG_SUPPORT_ERECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_Dcm_GetSizeOfERec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  SizeOfExtendedDataRecord
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_GetNumberOfSRec
 *****************************************************************************/
/*!
 * \brief         Gets the number of stored snapshot records
 *
 * \details       Gets the number of stored snapshot records
 *
 * \return        number of stored records
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON &&
 *                DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Dcm_GetNumberOfSRec(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterSRec
 *****************************************************************************/
/*!
 * \brief         Filters the snapshot records of events stored in primary memory
 *
 * \details       Filters the snapshot records of events stored in primary memory
 *
 * \param[out]    DTC
 *                Pointer to receive the UDS DTC number
 * \param[out]    RecordNumber
 *                Pointer to receive the snapshot record number
 *
 * \return        TRUE
 *                Next record was found
 *                FALSE
 *                No more record found
 *
 * \pre           The record filter has been initialized by
 *                Dem_DcmSetFreezeFrameRecordFilter
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON &&
 *                DEM_CFG_SUPPORT_SRECS == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Dcm_FilterSRec(
  CONSTP2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  RecordNumber
  );
#endif

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Esm_EventQueueAsync_Queued
 *****************************************************************************/
/*!
 * \brief         Processes queueing of event reports
 *
 * \details       This functions evaluates which results need queuing for
 *                events reported on the QUEUED path, i.e. without evaluating
 *                the current event status byte.
 *                Qualified results (PASSED/FAILED) are evaluated for IUMPR
 *                processing.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     DebounceInfo
 *                Monitor result after debouncing
 *
 * \return        E_OK
 *                The monitor result was queued
 * \return        E_NOT_OK
 *                The monitor result was discarded.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventQueueAsync_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_ConstDebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );

/* ****************************************************************************
 * Dem_Esm_EventQueueAsync_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes queueing of event reports
 *
 * \details       This functions evaluates which results need queuing for
 *                events reported on the IMMEDIATE path, i.e. it uses the
 *                current event status byte.
 *                Qualified results (PASSED/FAILED) are evaluated for IUMPR
 *                processing.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     DebounceInfo
 *                Monitor result after debouncing
 *
 * \return        E_OK
 *                The monitor result was queued
 * \return        E_NOT_OK
 *                The monitor result was discarded.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventQueueAsync_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_ConstDebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_ProcessTimeDebounce
 *****************************************************************************/
/*!
 * \brief         Processes the timer based debouncing of an event
 *
 * \details       Updates the debouncing state and timers of the debounced
 *                event. Any resulting event processing is deferred to the
 *                context of the Dem task.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_ProcessTimeDebounce(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_PreInit
 *****************************************************************************/
/*!
 * \brief         Pre-Initializes the state of operation cycles and Dem events
 *
 * \details       Pre-Initializes the state of operation cycles and Dem events
 *
 * \pre           May be called only during module pre-initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PreInit(
  void
  );

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_PrestorageInit
 *****************************************************************************/
/*!
 * \brief         Initializes the prestorage handling
 *
 * \details       Initializes the prestorage handling
 *
 * \pre           May be called only during module initialization
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PrestorageInit(
  void
  );
#endif

/* ****************************************************************************
 * Dem_Esm_InitEventAvailableNV
 *****************************************************************************/
/*!
 * \brief         Initializes the event availability from NV Ram
 *
 * \details       Initializes the event availability from NV Ram
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventAvailableNV(
  void
  );

/* ****************************************************************************
 * Dem_Esm_InitEventInternalStatus
 *****************************************************************************/
/*!
 * \brief         Initializes the internal event status of a given event
 *
 * \details       Initializes the internal event status of a given event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_InitGroupInternalStatus
 *****************************************************************************/
/*!
 * \brief         Initializes the internal event status of a given combined
 *                event group
 *
 * \details       Initializes the internal event status of a given combined
 *                event group
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 *
 * \pre           May be called only during module initialization
 * \config        DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitGroupInternalStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_InitEventStatus
 *****************************************************************************/
/*!
 * \brief         Initializes the event status of a given event
 *
 * \details       Initializes the event status of a given event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventStatus(
  CONST(Dem_EventIdType, AUTOMATIC) EventId
  );

/* ****************************************************************************
 * Dem_Esm_Init
 *****************************************************************************/
/*!
 * \brief         Initializes the event status processing sub-component
 *
 * \details       Initializes the event status processing sub-component
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_Init(
  void
  );

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_OFF) || (DEM_CFG_SUPPORT_OPCYCLE_AUTOMATIC_END == STD_ON)
/* ****************************************************************************
 * Dem_Esm_Shutdown
 *****************************************************************************/
/*!
 * \brief         Finalizes event status processing
 *
 * \details       Depending on configurataion, this function stops all running
 *                cycles, with all consequences this has on event status.
 *
 * \pre           May be called only during module shutdown
 * \config        DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_OFF ||
 *                DEM_CFG_SUPPORT_OPCYCLE_AUTOMATIC_END == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_Shutdown(
  void
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_MainFunction
 *****************************************************************************/
/*!
 * \brief         Processes all deferred operations
 *
 * \details       This function is the task function of the Dem module.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_MainFunction(
  void
  );
#endif

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  LOCAL FUNCTION DECLARATIONS
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                            /* Notifications */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Cbk_DtcStatusChanged_Internal
 *****************************************************************************/
/*!
 * \brief         Call all configured DTC status notification functions
 *
 * \details       The following callbacks are called here:
 *                - DtcStatusChanged(1...*)
 *                - DcmDtcStatusChanged(1)
 *                - J1939DcmDtcStatusChanged(1)
 *
 *                Before the callbacks are processed, the passed event status
 *                is masked with the status availability mask
 *
 *                Although the callback processing is technically not possible
 *                reentrantly, the Autosar design forces this behavior. The
 *                resulting inconsistencies are documented in RfC 48668
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     DtcStatusOld
 *                The old DTC status
 * \param[in]     DtcStatusNew
 *                The new DTC status
 * \param[in]     NotificationReason
 *                Reason for notification
 *
 * \pre           EventStatusOld must be different from EventStatusNew.
 * \pre           The external only status modifications must have been applied
 *                to the passed status bytes
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Cbk_DtcStatusChanged_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  DtcStatusOld,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  DtcStatusNew,
  CONST(uint8, AUTOMATIC)  NotificationReason
  );

/* ****************************************************************************
 * Dem_Cbk_StatusChanged
 *****************************************************************************/
/*!
 * \brief         Call all configured event status notification functions
 *
 * \details       The following callbacks are called here:
 *                - EventStatusChanged(1...*)
 *                - GeneralEventStatusChanged(1)
 *                - FimEventStatusChanged(1)
 *                - DltEventStatusChanged(1)
 *
 *                Although the callback processing is technically not possible
 *                reentrantly, the Autosar design forces this behavior. The
 *                resulting inconsistencies are documented in RfC 48668
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     DtcStatusOld
 *                The old DTC status
 * \param[in]     DtcStatusNew
 *                The new DTC status
 *
 * \pre           EventStatusOld must be different from EventStatusNew.
 * \pre           The external only status modifications must have been applied
 *                to the passed status bytes
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Cbk_StatusChanged(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  EventStatusOld,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  EventStatusNew
  );

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SelectDisplacedIndex
 *****************************************************************************/
/*!
 * \brief         Selects an event to displace in a filled memory
 *
 * \details       Selects an event to displace in a filled memory
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 * \param[in]     DisplacingEventId
 *                Unique handle of the Event to be entered into the memory
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The memory index of the displaced memory entry if one could
 *                be identified. DEM_MEM_INVALID_MEMORY_INDEX if displacement
 *                was not possible.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_SelectDisplacedIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  DisplacingEventId
  );
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryAllocateIndex
 *****************************************************************************/
/*!
 * \brief         Selects a memory entry for an event
 *
 * \details       This function manages the event memory storage. If a free
 *                slot is available, it is returned directly. In case no free
 *                slot is available, the configured displacement algorithm is
 *                applied to free a slot.
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The memory index of the allocated event memory entry if one
 *                could be identified. DEM_MEM_INVALID_MEMORY_INDEX if no entry
 *                was allocated.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryAllocateIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

#if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
/* ****************************************************************************
 * Dem_Mem_MemoryAllocateAging
 *****************************************************************************/
/*!
 * \brief         Selects a memory entry for an event's aging counter
 *
 * \details       If a free memory slot is available, it is returned directly.
 *                There is no fallback in case of a filled up event memory.
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The memory index of the allocated event memory entry if one
 *                could be identified. DEM_MEM_INVALID_MEMORY_INDEX if no entry
 *                was allocated.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryAllocateAging(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryFreeIndex
 *****************************************************************************/
/*!
 * \brief         Frees an event memory entry
 *
 * \details       This function frees an event memory entry.
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Mem_MemoryFreeIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  MemoryIndex
  );

/* ****************************************************************************
 * Dem_Mem_MemoryFindIndex
 *****************************************************************************/
/*!
 * \brief         Finds the event memory allocated to an event
 *
 * \details       Finds the event memory allocated to an event.
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        The memory index used by the event if one was found.
 *                Otherwise, DEM_MEM_INVALID_MEMORY_INDEX is returned.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryFindIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedCalculate
 *****************************************************************************/
/*!
 * \brief         Process the counter based debouncing of an event
 *
 * \details       Process the counter based debouncing of an event
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \return        TRUE
 *                De-bouncing was processed
 * \return        FALSE
 *                De-bouncing failed due to enable conditions
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_CounterBasedCalculate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedValidate
 *****************************************************************************/
/*!
 * \brief         Validate debouncing result
 *
 * \details       Validate debouncing result
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \return        TRUE
 *                The calculated debouncing result is still valid
 * \return        FALSE
 *                A concurrent modification has invalidated the calculation
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_CounterBasedValidate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedCommit
 *****************************************************************************/
/*!
 * \brief         Commit modified debouncing values to memory
 *
 * \details       Commit modified debouncing values to memory
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedCommit(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedFreeze
 *****************************************************************************/
/*!
 * \brief         Pauses counter based de-bouncing for an event (noop)
 *
 * \details       Pauses counter based de-bouncing for an event (noop)
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedFreeze(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedReset
 *****************************************************************************/
/*!
 * \brief         Resets counter based de-bouncing for an event
 *
 * \details       Resets counter based de-bouncing for an event
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedReset(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedCalculate
 *****************************************************************************/
/*!
 * \brief         Process the time based debouncing of an event
 *
 * \details       Process the time based debouncing of an event
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \return        TRUE
 *                De-bouncing was processed
 * \return        FALSE
 *                De-bouncing failed due to enable conditions
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_TimeBasedCalculate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedValidate
 *****************************************************************************/
/*!
 * \brief         Validate debouncing result
 *
 * \details       Validate debouncing result
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \return        TRUE
 *                The calculated debouncing result is still valid
 * \return        FALSE
 *                A concurrent modification has invalidated the calculation
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 * \config        DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_TimeBasedValidate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedCommit
 *****************************************************************************/
/*!
 * \brief         Commit modified debouncing values to memory
 *
 * \details       Commit modified debouncing values to memory
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 * \config        DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedCommit(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedFreeze
 *****************************************************************************/
/*!
 * \brief         Pauses time based de-bouncing for an event
 *
 * \details       Pauses time based de-bouncing for an event
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedFreeze(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedReset
 *****************************************************************************/
/*!
 * \brief         Resets time based de-bouncing for an event
 *
 * \details       Resets time based de-bouncing for an event
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedReset(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_MonitorInternalCalculate
 *****************************************************************************/
/*!
 * \brief         Process monitor internal debouncing
 *
 * \details       Monitor internal debouncing is handled inside the monitor,
 *                this function only validates the arguments.
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.MonitorInternal specialisation.
 *
 * \return        TRUE
 *                The monitor result was valid
 * \return        FALSE
 *                The monitor result was invalid
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_MonitorInternalCalculate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_MonitorInternalValidate
 *****************************************************************************/
/*!
 * \brief         Validate debouncing result
 *
 * \details       Validate debouncing result
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.MonitorInternal specialisation.
 *
 * \return        TRUE
 *                The calculated debouncing result is still valid
 * \return        FALSE
 *                A concurrent modification has invalidated the calculation
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_MonitorInternalValidate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_MonitorInternalCommit
 *****************************************************************************/
/*!
 * \brief         Commit modified debouncing values to memory
 *
 * \details       Commit modified debouncing values to memory
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.MonitorInternal specialisation.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_MonitorInternalCommit(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_MonitorInternalFreeze
 *****************************************************************************/
/*!
 * \brief         Pauses monitor internal de-bouncing for an event
 *
 * \details       Pauses monitor internal de-bouncing for an event. Due to
 *                monitor internal de-bouncing, this function has no effect.
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.MonitorInternal specialisation.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_MonitorInternalFreeze(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_MonitorInternalReset
 *****************************************************************************/
/*!
 * \brief         Reset monitor internal de-bouncing for an event
 *
 * \details       Reset monitor internal de-bouncing for an event
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.MonitorInternal specialisation.
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_MonitorInternalReset(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );
#endif

/* ****************************************************************************
 * Dem_Esm_DebounceInvalidCalculate
 *****************************************************************************/
/*!
 * \brief         Fallback implementation, instead of NULL_PTR
 *
 * \details       This function will always assert.
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses no specialisation.
 *
 * \return        FALSE
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceInvalidCalculate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );

/* ****************************************************************************
 * Dem_Esm_DebounceInvalidBoolean
 *****************************************************************************/
/*!
 * \brief         Fallback implementation, instead of NULL_PTR
 *
 * \details       This function will always assert.
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses no specialisation.
 *
 * \return        TRUE
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceInvalidBoolean(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );

/* ****************************************************************************
 * Dem_Esm_DebounceInvalidVoid
 *****************************************************************************/
/*!
 * \brief         Fallback implementation, instead of NULL_PTR
 *
 * \details       This function will always assert.
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses no specialisation.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_DebounceInvalidVoid(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  );

/* ****************************************************************************
 * Dem_Esm_EventFailed_Queued
 *****************************************************************************/
/*!
 * \brief         Process the event's queued qualified failed result
 *
 * \details       This function processes a failed result stored on the
 *                event queue, for events using the QUEUED mechanism. The
 *                triggers resulting from the status bit changes are calculated
 *                within this function, based on the current event status.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Esm_EventFailed_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes the event's queued qualified failed result
 *
 * \details       This function processes a failed result stored on the
 *                event queue, for events using the IMMEDIATE mechanism. The
 *                triggers are stored on the queue, and need to be passed to
 *                this function, the event status is assumed to have already
 *                changed according to those triggers.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     EventEffects
 *                Trigger flags for the event status
 * \param[in]     DTCEffects
 *                Trigger flags for the DTC status
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventEffects,
  CONST(uint8, AUTOMATIC)  DtcEffects
  );

/* ****************************************************************************
 * Dem_Esm_CycleUpdate
 *****************************************************************************/
/*!
 * \brief         Updates cycle state
 *
 * \details       Updates cycle state
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 * \param[in]     CycleStatus
 *                Cycle status changes
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdate(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint8, AUTOMATIC)  CycleStatus
  );

#if (DEM_FEATURE_NEED_AGING_CYCLE_DISTANCE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CycleCountDistance
 *****************************************************************************/
/*!
 * \brief         Calculates the distance between cycle counter values
 *
 * \details       Calculates the distance between cycle counter values
 *
 * \param[in]     CurrentCounter
 *                Current value of the cycle counter
 * \param[in]     TargetCounter
 *                Target counter value to find the distance to
 *
 * \return        Number of increments until current counter reaches target
 *                counter
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_AGING_CYCLE_DISTANCE == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(uint16, DEM_CODE)
Dem_Esm_CycleCountDistance(
  CONST(uint16, AUTOMATIC)  CurrentCounter,
  CONST(uint16, AUTOMATIC)  TargetCounter
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventOpCycle_Internal
 *****************************************************************************/
/*!
 * \brief         Updates an event's state due to operation cycle change
 *
 * \details       Updates an event's state due to operation cycle change
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in,out] ArgPtr
 *                Arguments: CycleStatus - encoding of cycle modification
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycle_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr
  );

/* ****************************************************************************
 * Dem_Esm_EventUpdateAsync_Queued
 *****************************************************************************/
/*!
 * \brief         Processes asynchronous monitor reports
 *
 * \details       This function processes event de-bouncing and queues
 *                qualified test results. This function implements the QUEUED
 *                processing, so the event status byte is not updated within
 *                this function, and the queue states are independent of its
 *                current value.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     EventStatus
 *                The monitor result
 *
 * \return        E_OK
 *                The monitor result was processed
 * \return        E_NOT_OK
 *                The monitor result was discarded.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventUpdateAsync_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusType, AUTOMATIC)  EventStatus
  );

/* ****************************************************************************
 * Dem_Esm_EventUpdateAsync_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes asynchronous monitor reports
 *
 * \details       This function processes event de-bouncing and queues
 *                qualified test results. This function implements the
 *                IMMEDIATE processing, so the asynchronously updated event
 *                status bits are modified within this function. The queued
 *                state also encodes those transitions.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in]     EventStatus
 *                The monitor result
 *
 * \return        E_OK
 *                The monitor result was processed
 * \return        E_NOT_OK
 *                The monitor result was discarded.
 *
 * \pre           The Dem must be fully initialized
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventUpdateAsync_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusType, AUTOMATIC)  EventStatus
  );

/* ****************************************************************************
 * Dem_Esm_EventReset_Async
 *****************************************************************************/
/*!
 * \brief         Resets the 'TestFailed' bit
 *
 * \details       Resets the 'TestFailed' bit
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        E_OK
 *                The TestFailed bit was reset
 * \return        E_NOT_OK
 *                The TestFailed bit was not modified.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventReset_Async(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

/* ****************************************************************************
 * Dem_Esm_EventAged_Internal
 *****************************************************************************/
/*!
 * \brief         Updates an event due to aging
 *
 * \details       Updates an event due to aging
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in,out] ArgPtr
 *                Arguments: none
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventAged_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr
  );

/* ****************************************************************************
 * Dem_Esm_EventClearState
 *****************************************************************************/
/*!
 * \brief         Clears an event's state in volatile RAM
 *
 * \details       Do not call this function directly, it is part of
 *                Dem_Esm_EventCleared_Internal
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in,out] ArgPtr
 *                Arguments: none
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventClearState(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr
  );

/* ****************************************************************************
 * Dem_Esm_EventCleared_Internal
 *****************************************************************************/
/*!
 * \brief         Clears an event
 *
 * \details       Clears an event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventCleared_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventDisplaced_Internal
 *****************************************************************************/
/*!
 * \brief         Updates an event's status due to displacement
 *
 * \details       Do not call this function directly, it is part of
 *                Dem_Esm_EventDisplaced
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 * \param[in,out] ArgPtr
 *                Arguments: none
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventDisplaced_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventPrestorageClear
 *****************************************************************************/
/*!
 * \brief         Clears the prestorage entry of an event
 *
 * \details       Clears the prestorage entry of an event
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        E_OK
 *                The data was cleared successfully
 * \return        E_NOT_OK
 *                The data was not cleared, e.g. no data was available
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 * \config        DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventPrestorageClear(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif
                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Queue_ProcessClearDtcGroup
 *****************************************************************************/
/*!
 * \brief         Process UDS clear dtc group requests
 *
 * \details       The function processes clearing for the events in range
 *                [FirstEventId, LastEventId] (inclusive interval) that match
 *                the ClearDTC parameters.
 *
 * \param[in]     FirstEventId
 *                Numerically smallest eventid belonging to the range
 * \param[in]     LastEventId
 *                Numerically largest eventid belonging to the range
 *
 * \pre           The global clear DTC context must have been initialized
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Queue_ProcessClearDtcGroup(
  CONST(uint16, AUTOMATIC)  FirstEventId,
  CONST(uint16, AUTOMATIC)  LastEventId
  );

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

#if ( ((DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_DATA_CURRENT_FDC == STD_ON)) \
   && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) )
/* ****************************************************************************
 * Dem_Data_CombinedGroupGetFDC
 *****************************************************************************/
/*!
 * \brief         Calculates the fault detection counter of a combined event
 *
 * \details       This function iterates through all sub-events, and takes the
 *                largest fault detection counter to represent the combined
 *                FDC.
 *                This is not stable against preemptive modification of the
 *                set of FDCs concerned. This is not prevented as it would
 *                lead to a large runtime within a critical section, without
 *                actually increasing the expected quality of the result.
 *
 *                Explanation: If all sub-events report a fairly stable result
 *                (the FDCs count fairly linearly), the combined FDC is also
 *                reliable if it is collected without critical section.
 *                If the sub-events change their result often and chaotically,
 *                the combined FDC also behaves chaotically, based on report
 *                order and task priorities. Collecting the FDCs within a
 *                critical section will not improve the result.
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 * \param[out]    FaultDetectionCounter
 *                Pointer to receive the FDC value
 *
 * \return        E_OK
 *                The combined FDC was returned in FaultDetectionCounter
 * \return        E_NOT_OK
 *                The combined FDC could not be determined.
 *
 * \pre           RTE is started (if RTE is used)
 * \config        ((DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_DATA_CURRENT_FDC == STD_ON))
 *                && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) )
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Data_CombinedGroupGetFDC(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId,
  CONSTP2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter
  );
#endif

#if ( (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) \
   && ( ((DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)) \
     || ((DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)) ) )
/* ****************************************************************************
 * Dem_Data_CombinedGroupGetFDCMax
 *****************************************************************************/
/*!
 * \brief         Calculates the maximum fault detection counter this cycle of
 *                a combined event
 *
 * \details       This function iterates through all sub-events, and takes the
 *                largest maximum fault detection counter to represent the
 *                combined maximum FDC.
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 *
 * \return        The maximum FDC value
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *             && ( (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON && DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)
 *               || (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON) )
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(sint8, DEM_CODE)
Dem_Data_CombinedGroupGetFDCMax(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId
  );
#endif

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Data_CombinedGroupGetStatus
 *****************************************************************************/
/*!
 * \brief         Gets the combined event group status of a combined event
 *
 * \details       This calculates the logical OR of all subevent status bytes.
 *                Combined event status bytes only change on the main function,
 *                so no critical section is required from the main function.
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Data_CombinedGroupGetStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId
  );
#endif

#if ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON))
/* ****************************************************************************
 * Dem_Data_CollectDid
 *****************************************************************************/
/*!
 * \brief         Collects the environment data to store for a data identifier
 *
 * \details       Stores all data elements attached to a data identifier object
 *                into the destination buffer.
 *                Note that a data identifier in this context is not only a
 *                UDS DID, but can also be an extended data record or PID.
 *
 * \param[in,out] CollectDidInfoPtr
 *                CollectDid context
 * \param[in]     DidIndex
 *                Unique handle of the DID
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_USER_ERECS == STD_ON  ||
 *                DEM_CFG_SUPPORT_SRECS == STD_ON  ||
 *                DEM_CFG_SUPPORT_OBDII == STD_ON  ||
 *                DEM_CFG_SUPPORT_WWHOBD == STD_ON ||
 *                DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON ||
 *                DEM_FEATURE_NEED_TIME_SERIES == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Data_CollectDid(
  CONST(Dem_Data_CollectDidInfoPtrType, AUTOMATIC)  CollectDidInfoPtr,
  CONST(Dem_Cfg_DidIndexType, AUTOMATIC)  DidIndex
  );
#endif

#if ( (DEM_CFG_SUPPORT_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON))
/* ****************************************************************************
 * Dem_Data_CopyDid
 *****************************************************************************/
/*!
 * \brief         Copies DID data into a buffer.
 *
 * \details       Copies all stored data elements attached to a data identifier
 *                object into the destination buffer, filling in internal data
 *                where needed.
 *                Note that a data identifier in this context is not only a
 *                UDS DID, but can also be an extended data record or PID.
 *
 * \param[in,out] CopyDidInfoStruct
 *                CopyDid context
 * \param[in]     DidIndex
 *                Unique handle of the DID
 *
 * \pre           A memory entry has to be locked for Dcm readout
 * \config        DEM_CFG_SUPPORT_ERECS == STD_ON  ||
 *                DEM_CFG_SUPPORT_SRECS == STD_ON  ||
 *                DEM_CFG_SUPPORT_OBDII == STD_ON  ||
 *                DEM_CFG_SUPPORT_WWHOBD == STD_ON ||
 *                DEM_FEATURE_NEED_TIME_SERIES == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Data_CopyDid(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DidIndexType, AUTOMATIC)  DidIndex
  );
#endif

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_MemorySetBlockStateImmediate
 *****************************************************************************/
/*!
 * \brief         Marks an event memory entry block as 'dirty' and commits it to
 *                NvM
 *
 * \details       This function checks the occurrence limit (if configured) and
 *                removes an immediate update request if necessary. Otherwise
 *                it behaves like Dem_Nvm_SetBlockStateImmediate.
 *
 * \param[in]     MemoryIndex
 *                Memory entry index
 * \param[in]     BlockState
 *                State modification of the block
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different blocks
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Nvm_MemorySetBlockStateImmediate(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex,
  CONST(uint8, AUTOMATIC)  BlockState
  );
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_SetBlockStateImmediate
 *****************************************************************************/
/*!
 * \brief         Marks a block as 'dirty' and commits it to NvM
 *
 * \details       This function processes the NV block according to BlockState:
 *                DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG - The block is queued for
 *                immediate NV update.
 *                DEM_NVM_BLOCKSTATE_CLEARFLAG - The block was cleared.
 *                DEM_NVM_BLOCKSTATE_DIRTY - The block should be synchronized
 *                to NV-Ram during WriteAll.
 *                The NV block state will not downgrade, e.g. setting a block
 *                to DIRTY will not remove a CLEARFLAG or IMMEDIATEFLAG.
 *
 * \param[in]     MemoryIndex
 *                Memory entry index
 * \param[in]     BlockState
 *                State modification of the block
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different blocks
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Nvm_SetBlockStateImmediate(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex,
  CONST(uint8, AUTOMATIC)  BlockState
  );
#endif

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Dcm_ClearDtc_TestForAllDtc
 *****************************************************************************/
/*!
 * \brief         Test whether a DTC number encodes an 'AllDTC' mask
 *
 * \details       Test whether a DTC number encodes an 'AllDTC' mask. If so,
 *                this function also initializes the filter parameters.
 *
 * \param[in]     DTC
 *                DTC number
 * \param[in,out] ClearRequest
 *                Clear request evaluation context
 *
 * \return        DEM_CLEAR_OK
 *                The DTC has matched this test.
 * \return        DEM_CLEAR_WRONG_DTC
 *                The DTC has not matched this test.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForAllDtc(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  );

#if (DEM_CFG_CLEAR_GROUP_DTCS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_ClearDtc_TestForGroupDtc
 *****************************************************************************/
/*!
 * \brief         Test if a DTC number encodes a specific DTC group (not
 *                ALLDTCs)
 *
 * \details       Test if a DTC number encodes a specific DTC group (not
 *                ALLDTCs). If so, this function also initializes the filter
 *                parameters.
 *
 * \param[in]     DTC
 *                DTC number
 * \param[in,out] ClearRequest
 *                Clear request evaluation context
 *
 * \return        DEM_CLEAR_OK
 *                The DTC has matched this test.
 * \return        DEM_CLEAR_WRONG_DTC
 *                The DTC has not matched this test.
 *
 * \pre           -
 * \config        DEM_CFG_CLEAR_GROUP_DTCS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForGroupDtc(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  );
#endif

#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_ClearDtc_TestForSingleDtc
 *****************************************************************************/
/*!
 * \brief         Test if a DTC number encodes a specific DTC
 *
 * \details       Test if a DTC number encodes a specific DTC. If so,
 *                this function also initializes the filter parameters.
 *
 * \param[in]     DTC
 *                DTC number
 * \param[in,out] ClearRequest
 *                Clear request evaluation context
 *
 * \return        DEM_CLEAR_OK
 *                The DTC has matched this test.
 * \return        DEM_CLEAR_WRONG_DTC
 *                The DTC has not matched this test.
 *
 * \pre           -
 * \config        DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForSingleDtc(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  );
#endif

/* ****************************************************************************
 * Dem_Dcm_ClearDtc_TestWrongOrigin
 *****************************************************************************/
/*!
 * \brief         Test that always fails with result DEM_CLEAR_WRONG_DTCORIGIN
 *
 * \details       Test that always fails with result DEM_CLEAR_WRONG_DTCORIGIN
 *
 * \param[in]     DTC
 *                DTC number
 * \param[in,out] ClearRequest
 *                Clear request evaluation context
 *
 * \return        DEM_CLEAR_WRONG_DTCORIGIN
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestWrongOrigin(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  );

/* ****************************************************************************
 * Dem_Dcm_ClearDtc_Internal
 *****************************************************************************/
/*!
 * \brief         Processes a clear request.
 *
 * \details       Processes a clear request.
 *
 * \param[in]     DTC
 *                The DTC number
 * \param[in]     ClearRequest
 *                Clear request evaluation context
 *
 * \return        DEM_CLEAR_OK
 *                Clearing is completed, the requested DTC(s) are reset.
 * \return        DEM_CLEAR_WRONG_DTC
 *                The requested DTC is not valid in the context of DTCFormat
 *                and DTCOrigin
 * \return        DEM_CLEAR_WRONG_DTCORIGIN
 *                The requested DTC origin is not available in the context of
 *                DTCFormat
 * \return        DEM_CLEAR_FAILED
 *                The clear operation could not be started
 * \return        DEM_CLEAR_MEMORY_ERROR
 *                The clear operation has completed, but the NV synchronization
 *                has failed
 * \return        DEM_CLEAR_PENDING
 *                The clear operation was started and is currently processed
 * \return        DEM_CLEAR_BUSY
 *                Another clear operation is currently processing
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_Internal(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  );

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterNumberMemory
 *****************************************************************************/
/*!
 * \brief         Calculates the number of filtered events.
 *
 * \details       Calculates the number of filtered events.
 *
 * \return        Number of DTCs matching the filter criteria
 *
 * \pre           A Dcm filter has been set
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(uint16, DEM_CODE)
Dem_Dcm_FilterNumberMemory(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterMemoryByEvent
 *****************************************************************************/
/*!
 * \brief         Iterates events in the event memory matching the Dcm DTC filter
 *
 * \details       This function iterates all events in order of their event ID.
 *                Events which have been reported before by the chronological
 *                iterator Dem_Dcm_FilterMemoryChrono will be ignored.
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 *
 * \return        EventId of the next event maching the filter criteria
 *
 * \pre           A Dcm filter has been set
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterMemoryByEvent(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );
#endif

#if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterMemoryChrono
 *****************************************************************************/
/*!
 * \brief         Iterates events in memory matching the Dcm DTC
 *                filter
 *
 * \details       This function iterates all events in order of occurrence.
 *                If all stored events have been checked, this function
 *                replaces the iterator function by the non-chronological
 *                version Dem_Dcm_FilterMemoryByEvent to also find the
 *                remaining events.
 *
 * \param[in]     MemoryInfo
 *                Event memory descriptor
 *
 * \return        EventId of the next event maching the filter criteria
 *
 * \pre           A Dcm filter has been set
 * \config        DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterMemoryChrono(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterForEventMatch
 *****************************************************************************/
/*!
 * \brief         Checks whether an event matches the filter criteria
 *
 * \details       Checks whether an event matches the filter criteria
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *                The EventId must be in range [1..Dem_Cfg_GlobalEventCount()[.
 *
 * \return        E_OK
 *                The event matches the filter criteria
 * \return        E_NOT_OK
 *                The event does not match the filter criteria
 *
 * \pre           A Dcm filter has been set
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_FilterForEventMatch(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FindEventByDTCAndOrigin
 *****************************************************************************/
/*!
 * \brief         Find the event attached to a given DTC in a specific event
 *                memory, and the memory id of the DTC origin requested
 *
 * \details       If the DTC number is found, and the attached event is mapped
 *                to the correct event memory, this function will set MemoryId
 *                to the corresponding handle.
 *                Otherwise, MemoryId will be set to DEM_CFG_MEMORYID_INVALID.
 *
 * \param[in]     DTC
 *                The DTC number
 * \param[in]     DTCOrigin
 *                The external identifier of the event memory
 * \param[out]    MemoryId
 *                Pointer receiving the internal memory Id
 *
 * \return        The event id of the event attached to DTC, if no such DTC
 *                exists (in the requested event memory) the function returns
 *                DEM_EVENT_INVALID
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_DCM == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FindEventByDTCAndOrigin(
  CONST(uint32, AUTOMATIC)  DTC,
  CONST(Dem_DTCOriginType, AUTOMATIC)  DTCOrigin,
  CONSTP2VAR(uint8, AUTOMATIC, AUTOMATIC)  MemoryId
  );
#endif

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  Object definitions
 *********************************************************************************************************************/

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! MemoryInfo for the primary memory */
DEM_LOCAL CONST(Dem_Mem_MemoryInfoType, DEM_CONST) Dem_Mem_PrimaryInfo =                                                         /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  &Dem_Cfg_PrimaryChronology[0],
  &Dem_Mem_PrimaryCurrentCount,
  DEM_CFG_MEMORY_PRIMARY_INDEX,
  DEM_CFG_GLOBAL_PRIMARY_FIRST,
  DEM_CFG_GLOBAL_PRIMARY_LAST,
  DEM_CFG_GLOBAL_PRIMARY_SIZE,
  DEM_CFG_MEMORYID_PRIMARY
};

#if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
/*! MemoryInfo for the secondary memory */
DEM_LOCAL CONST(Dem_Mem_MemoryInfoType, DEM_CONST) Dem_Mem_SecondaryInfo =                                                       /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  &Dem_Cfg_SecondaryChronology[0],
  &Dem_Mem_SecondaryCurrentCount,
  DEM_CFG_MEMORY_SECONDARY_INDEX,
  DEM_CFG_GLOBAL_SECONDARY_FIRST,
  DEM_CFG_GLOBAL_SECONDARY_LAST,
  DEM_CFG_GLOBAL_SECONDARY_SIZE,
  DEM_CFG_MEMORYID_SECONDARY
};
#endif

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! DebounceInfo for the supported de-bounce algorithms */
DEM_LOCAL CONST(Dem_DebounceFunctionTableType, DEM_CONST) Dem_Esm_DebounceFunctionTable[DEM_ESM_DEBOUNCE_ALGORITHM_COUNT + 1] =  /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
  /*! DebounceInfo for counter based de-bouncing */
  {
    Dem_Esm_CounterBasedCalculate,
    Dem_Esm_CounterBasedValidate,
    Dem_Esm_CounterBasedCommit,
    Dem_Esm_CounterBasedFreeze,
    Dem_Esm_CounterBasedReset
  },
#else
  /*! Fallback DebounceInfo for counter based de-bouncing when it is not supported */
  {
    Dem_Esm_DebounceInvalidCalculate,
    Dem_Esm_DebounceInvalidBoolean,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid
  },
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
  /*! DebounceInfo for time based de-bouncing */
  {
    Dem_Esm_TimeBasedCalculate,
    Dem_Esm_TimeBasedValidate,
    Dem_Esm_TimeBasedCommit,
    Dem_Esm_TimeBasedFreeze,
    Dem_Esm_TimeBasedReset
  },
#else
  /*! Fallback DebounceInfo for time based de-bouncing when it is not supported */
  {
    Dem_Esm_DebounceInvalidCalculate,
    Dem_Esm_DebounceInvalidBoolean,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid
  },
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
  /*! DebounceInfo for monitor internal de-bouncing */
  {
    Dem_Esm_MonitorInternalCalculate,
    Dem_Esm_MonitorInternalValidate,
    Dem_Esm_MonitorInternalCommit,
    Dem_Esm_MonitorInternalFreeze,
    Dem_Esm_MonitorInternalReset
  },
#else
  /*! Fallback DebounceInfo for monitor internal de-bouncing when it is not supported */
  {
    Dem_Esm_DebounceInvalidCalculate,
    Dem_Esm_DebounceInvalidBoolean,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid
  },
#endif

  /*! Fallback DebounceInfo for missing de-bouncing configuration */
  {
    Dem_Esm_DebounceInvalidCalculate,
    Dem_Esm_DebounceInvalidBoolean,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid
  }
};

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_CONST_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! Mapping table DtcOrigin -> MemoryId */
DEM_LOCAL CONST(uint8, DEM_CONST) Dem_Dcm_MemoryIdMapping[5] =                                                                   /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  /* 0: Invalid */
  DEM_CFG_MEMORYID_INVALID,
  /* DEM_DTC_ORIGIN_PRIMARY_MEMORY */
  DEM_CFG_MEMORYID_PRIMARY,
  /* DEM_DTC_ORIGIN_MIRROR_MEMORY */
  DEM_CFG_MEMORYID_MIRROR,
  /* DEM_DTC_ORIGIN_PERMANENT_MEMORY */
  DEM_CFG_MEMORYID_PERMANENT,
  /* DEM_DTC_ORIGIN_SECONDARY_MEMORY */
  DEM_CFG_MEMORYID_SECONDARY
};

#define DEM_STOP_SEC_CONST_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/*! List of functions to check the DTC number when clearing DTCs by OBD protocol */
DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestObd[] =
{
  NULL_PTR
};

/*! List of functions to check the DTC number when clearing DTCs by UDS protocol */
DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestUds[] =
{
  Dem_Dcm_ClearDtc_TestForAllDtc,
#if (DEM_CFG_CLEAR_GROUP_DTCS == STD_ON)
  Dem_Dcm_ClearDtc_TestForGroupDtc,
#endif
#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
  Dem_Dcm_ClearDtc_TestForSingleDtc,
#endif
  NULL_PTR
};

/*! List of functions to check the DTC number when clearing DTCs by J1939 protocol */
DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestJ1939[] =
{
  NULL_PTR
};

/*! List of functions to always fail the DTC check (used as fallback) */
DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestFailWrongDtc[] =                               /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  NULL_PTR
};

/*! List of functions to always fail the DTC check with NRC 'wrong origin' (used as fallback) */
DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestFailWrongOrigin[] =                            /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  Dem_Dcm_ClearDtc_TestWrongOrigin,
  NULL_PTR
};

/*! Table with function lists to check the DTC argument for each protocol when clearing primary memory */
DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestPrimary[3] =                                       /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  /* DEM_DTC_FORMAT_OBD */
  Dem_Dcm_ClearDtc_TestObd,
  /* DEM_DTC_FORMAT_UDS */
  Dem_Dcm_ClearDtc_TestUds,
  /* DEM_DTC_FORMAT_J1939 */
  Dem_Dcm_ClearDtc_TestJ1939
};

#if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
/*! Table with function lists to check the DTC argument for each protocol when clearing secondary memory */
DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestSecondary[3] =                                     /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  /* DEM_DTC_FORMAT_OBD */
  Dem_Dcm_ClearDtc_TestFailWrongDtc,
  /* DEM_DTC_FORMAT_UDS */
  Dem_Dcm_ClearDtc_TestUds,
  /* DEM_DTC_FORMAT_J1939 */
  Dem_Dcm_ClearDtc_TestJ1939,
};
#endif

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  LOCAL INLINE FUNCTION DEFINITIONS
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */
                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetDebounceStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_GetDebounceStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus & DEM_ESM_DEBOUNCE_STATUS);
}
#endif

/* ****************************************************************************
 % Dem_Mem_SetDebounceStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetDebounceStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) InternalStatus,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC) Status                                                                       /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(Status)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
  return (Dem_Cfg_EventInternalStatusType)
    ((InternalStatus & DEM_ESM_DEBOUNCE_STATUS_MASK) | (Status & DEM_ESM_DEBOUNCE_STATUS));
#else
  return InternalStatus;
#endif
}

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Mem_TestDebounceDirection
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_TestDebounceDirection(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(Dem_Mem_GetDebounceStatus(InternalStatus) & 0x01U);
}
#endif

/* Internal event status 'storage' ----------------------------------------- */

/* ****************************************************************************
 % Dem_Mem_GetStoredStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_GetStoredStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus & DEM_ESM_STORED_STATUS);
}

/* ****************************************************************************
 % Dem_Mem_SetStoredStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetStoredStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  Status
  )
{
  return (Dem_Cfg_EventInternalStatusType)
    ((InternalStatus & DEM_ESM_STORED_STATUS_MASK) | (Status & DEM_ESM_STORED_STATUS));
}

/* Internal status bit 'event suppressed' ---------------------------------- */

/* ****************************************************************************
 % Dem_Mem_TestEventSuppressedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestEventSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(InternalStatus)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
  return (boolean)((InternalStatus & DEM_ESM_SUPPRESSED_EVENT) != 0);
#else
  return FALSE;
#endif
}

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetEventSuppressedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetEventSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus | DEM_ESM_SUPPRESSED_EVENT);
}
#endif

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_ResetEventSuppressedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetEventSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus & DEM_ESM_SUPPRESSED_EVENT_MASK);
}
#endif

/* Internal status bit 'DTC suppressed' ------------------------------------ */

/* ****************************************************************************
 % Dem_Mem_TestDtcSuppressedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestDtcSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(InternalStatus)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
  return (boolean)((InternalStatus & DEM_ESM_SUPPRESSED_DTC) != 0);
#else
  return FALSE;
#endif
}

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetDtcSuppressedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetDtcSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus | DEM_ESM_SUPPRESSED_DTC);
}
#endif

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_ResetDtcSuppressedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetDtcSuppressedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus & DEM_ESM_SUPPRESSED_DTC_MASK);
}
#endif

/* Internal status bit 'event available' ----------------------------------- */

/* ****************************************************************************
 % Dem_Mem_TestEventDisconnectedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestEventDisconnectedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(InternalStatus)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
  return (boolean)((InternalStatus & DEM_ESM_DISCONNECTED_EVENT) != 0);
#else
  return FALSE;
#endif
}

/* ****************************************************************************
 % Dem_Mem_SetEventDisconnectedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetEventDisconnectedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus | DEM_ESM_DISCONNECTED_EVENT);
#else
  return InternalStatus;
#endif
}

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) || (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Mem_ResetEventDisconnectedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetEventDisconnectedStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus & DEM_ESM_DISCONNECTED_EVENT_MASK);
}
#endif

/* Internal status bit 'event already crossed FDC threshold in this cycle' - */

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
/* ****************************************************************************
 % Dem_Mem_TestFdcTripStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestFdcTripStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  return (boolean)((InternalStatus & DEM_ESM_FDC_TRIP) != 0);
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON) && (DEM_CFG_STORAGE_AT_FDC == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetFdcTripStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetFdcTripStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus | DEM_ESM_FDC_TRIP);
}
#endif

/* ****************************************************************************
 % Dem_Mem_ResetFdcTripStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetFdcTripStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus & DEM_ESM_FDC_TRIP_MASK);
#else
  return InternalStatus;
#endif
}

/* Internal status bit 'event maximum FDC updated this cycle' -------------- */

#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_TestFdcMaxStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestFdcMaxStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  return (boolean)((InternalStatus & DEM_ESM_FDC_MAX) != 0);
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON) && (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetFdcMaxStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetFdcMaxStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus | DEM_ESM_FDC_MAX);
}
#endif

/* ****************************************************************************
 % Dem_Mem_ResetFdcMaxStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetFdcMaxStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus & DEM_ESM_FDC_MAX_MASK);
#else
  return InternalStatus;
#endif
}

/* Internal status bit 'event crossed FDC threshold in this cycle' --------- */

#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) || (DEM_CFG_STORAGE_AT_FDC == STD_ON)
/* ****************************************************************************
 % Dem_Mem_TestFdcTocStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestFdcTocStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(InternalStatus)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
# if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
  return (boolean)((InternalStatus & DEM_ESM_FDC_TOC) != 0);
# else
  return FALSE;
# endif
}
#endif

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetFdcTocStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetFdcTocStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
# if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus | DEM_ESM_FDC_TOC);
# else
  return InternalStatus;
# endif
}
#endif

/* ****************************************************************************
 % Dem_Mem_ResetFdcTocStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetFdcTocStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus & DEM_ESM_FDC_TOC_MASK);
#else
  return InternalStatus;
#endif
}

/* Internal status bit 'DTC disabled by PB selectable' --------------------- */

/* ****************************************************************************
 % Dem_Mem_TestAvailableInVariantStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestAvailableInVariantStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(InternalStatus)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON) && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  return (boolean)((InternalStatus & DEM_ESM_AVAILABLEINVARIANT) != 0);
#else
  return TRUE;
#endif
}

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetAvailableInVariantStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetAvailableInVariantStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus | DEM_ESM_AVAILABLEINVARIANT);
# else
  return InternalStatus;
# endif
}
#endif

/* Internal status bit 'user controlled warning indicator' ----------------- */

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) || (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_TestUserControlledWirStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_TestUserControlledWirStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(InternalStatus)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
# if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
  return (boolean)((InternalStatus & DEM_ESM_USER_CONTROLLED_WIR) != 0);
# else
  return FALSE;
# endif
}
#endif

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetUserControlledWirStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_SetUserControlledWirStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus | DEM_ESM_USER_CONTROLLED_WIR);
}
#endif

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_ResetUserControlledWirStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_ResetUserControlledWirStatus(
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
  return (Dem_Cfg_EventInternalStatusType)(InternalStatus & DEM_ESM_USER_CONTROLLED_WIR_MASK);
}
#endif

/* ****************************************************************************
 % Dem_Mem_CycleGetCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_CycleGetCounter(
  CONST(uint8, AUTOMATIC)  CycleId
  )
{
  return Dem_Cfg_AdminData.CycleCounter[CycleId];
}

/* ****************************************************************************
 % Dem_Mem_CycleSetCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CycleSetCounter(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint16, AUTOMATIC)  CycleCounter
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (CycleId >= Dem_Cfg_GlobalCycleCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_AdminData.CycleCounter[CycleId] = CycleCounter;                                                                      /* SBSW_DEM_ARRAY_WRITE_ADMINDATA_CYCLECOUNTER */
  }
}

/* ****************************************************************************
 % Dem_Mem_EventGetStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_EventGetStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  return Dem_Cfg_StatusData.EventStatus[EventId];
}

/* ****************************************************************************
 % Dem_Mem_EventSetStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  Status
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_StatusData.EventStatus[EventId] = Status;                                                                            /* SBSW_DEM_ARRAY_WRITE_STATUSDATA_EVENTSTATUS */
  }
}

#if (DEM_FEATURE_NEED_TRIPCOUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EventGetTripCount
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_EventGetTripCount(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  return Dem_Cfg_StatusData.TripCount[EventId];
}
#endif

#if (DEM_FEATURE_NEED_TRIPCOUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EventSetTripCount
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetTripCount(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  TripCount
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
    Dem_Cfg_StatusData.TripCount[EventId] = TripCount;                                                                           /* SBSW_DEM_ARRAY_WRITE_STATUSDATA_TRIPCOUNT */
  }
}
#endif

/* ****************************************************************************
 % Dem_Mem_EventGetInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_EventGetInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  return Dem_Cfg_GetEventInternalStatus(EventId);
}

/* ****************************************************************************
 % Dem_Mem_EventSetInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  Status
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
#endif
  {
    Dem_Cfg_SetEventInternalStatus(EventId, Status);                                                                             /* SBSW_DEM_ARRAY_WRITE_EVENTINTERNALSTATUS */
  }
}

/* ****************************************************************************
 % Dem_Mem_EventGetDebounceValue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(sint16, DEM_CODE)
Dem_Mem_EventGetDebounceValue(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  return Dem_Cfg_GetEventDebounceValue(EventId);
}

/* ****************************************************************************
 % Dem_Mem_EventSetDebounceValue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetDebounceValue(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(sint16, AUTOMATIC)  DebounceValue
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_SetEventDebounceValue(EventId, DebounceValue);                                                                       /* SBSW_DEM_ARRAY_WRITE_EVENTDEBOUNCEVALUE */
  }
}

#if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON) && (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EventGetDebounceValueMax
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(sint16, DEM_CODE)
Dem_Mem_EventGetDebounceValueMax(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  return Dem_Cfg_GetEventMaxDebounceValues(EventId);
}
#endif

/* ****************************************************************************
 % Dem_Mem_EventSetDebounceValueMax
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetDebounceValueMax(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(sint16, AUTOMATIC)  DebounceValue                                                                                        /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(DebounceValue)                                                                                /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
    Dem_Cfg_SetEventMaxDebounceValues(EventId, DebounceValue);                                                                   /* SBSW_DEM_ARRAY_WRITE_EVENTMAXDEBOUNCEVALUES */
  }
#endif
}

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_CombinedGroupGetStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_CombinedGroupGetStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId
  )
{
  return Dem_Cfg_GetCombinedGroupStatus(GroupId);
}
#endif

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_CombinedGroupSetStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CombinedGroupSetStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId,
  CONST(uint8, AUTOMATIC)  Status
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (GroupId >= Dem_Cfg_GetSizeOfCombinedGroupStatus())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
    Dem_Cfg_SetCombinedGroupStatus(GroupId, Status);                                                                             /* SBSW_DEM_ARRAY_WRITE_COMBINEDGROUPSTATUS */
  }
}
#endif

/* ****************************************************************************
 % Dem_Mem_CombinedGroupGetInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Mem_CombinedGroupGetInternalStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(GroupId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  return Dem_Cfg_GetCombinedGroupInternalStatus(GroupId);
#else
  return 0;
#endif
}

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_CombinedGroupSetInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CombinedGroupSetInternalStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  Status
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (GroupId >= Dem_Cfg_GetSizeOfCombinedGroupInternalStatus())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
    Dem_Cfg_SetCombinedGroupInternalStatus(GroupId, Status);                                                                     /* SBSW_DEM_ARRAY_WRITE_COMBINEDGROUPINTERNALSTATUS */
  }
}
#endif

#if (DEM_FEATURE_NEED_OBD == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EventGetQualifyStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_EventGetQualifyStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
# if (DEM_CFG_PROCESS_CDTC_ALL_DTC == STD_ON)
  return Dem_Cfg_StatusData.State[EventId];
# else
  return Dem_Cfg_GetEventCycleStatus(EventId);
# endif
}
#endif

#if (DEM_FEATURE_NEED_OBD == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EventSetQualifyStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetQualifyStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  Status
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
# if (DEM_CFG_PROCESS_CDTC_ALL_DTC == STD_ON)
    Dem_Cfg_StatusData.State[EventId] = Status;
# else
    Dem_Cfg_SetEventCycleStatus(EventId, Status);
# endif
  }
}
# endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Mem_DebounceGetStoredValue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(sint16, DEM_CODE)
Dem_Mem_DebounceGetStoredValue(
  CONST(uint16, AUTOMATIC)  Index
  )
{
  return Dem_Cfg_DebounceData[Index];
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Mem_DebounceSetStoredValue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_DebounceSetStoredValue(
  CONST(uint16, AUTOMATIC)  Index,
  CONST(sint16, AUTOMATIC)  DebounceValue
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Index >= Dem_Cfg_GlobalDebounceStorageEventCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
    Dem_Cfg_DebounceData[Index] = DebounceValue;                                                                                 /* SBSW_DEM_ARRAY_WRITE_DEBOUNCEDATA */
  }
}
#endif

#if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EventGetAvailableMask
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_EventGetAvailableMask(
  CONST(uint16, AUTOMATIC)  Index                                                                                                /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  return Dem_Cfg_EventAvailableData[Index];
}
#endif

#if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EventSetAvailableMask
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_EventSetAvailableMask(
  CONST(uint16, AUTOMATIC)  Index,
  CONST(uint8, AUTOMATIC)  Mask
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Index >= ((Dem_Cfg_GlobalEventCount() + 7) / 8))
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
    Dem_Cfg_EventAvailableData[Index] = Mask;                                                                                    /* SBSW_DEM_ARRAY_WRITE_EVENTAVAILABLEDATA */
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageGetEntry
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Mem_PrestoredEntryPtrType, DEM_CODE)
Dem_Mem_PrestorageGetEntry(
  CONST(Dem_Cfg_PrestorageIndexType, AUTOMATIC)  PrestorageIndex
  )
{
  Dem_Mem_PrestoredEntryPtrType lReturnValue;

#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (PrestorageIndex >= Dem_Cfg_GlobalPrestorageMaxCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
    lReturnValue = &Dem_Cfg_Prestorage[0];
  }
  else
#endif
  {
    lReturnValue = &Dem_Cfg_Prestorage[PrestorageIndex];
  }

  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageGetRef
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageGetRef(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  return Dem_Cfg_PrestorageIndex[Dem_Cfg_EventPrestorageIndex(EventId)];
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageSetRef
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageSetRef(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Cfg_PrestorageIndexType, AUTOMATIC)  PrestorageIndex
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Dem_Cfg_EventPrestorageIndex(EventId) >= Dem_Cfg_GlobalPrestorageEventCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_PrestorageIndex[Dem_Cfg_EventPrestorageIndex(EventId)] = PrestorageIndex;                                            /* SBSW_DEM_ARRAY_WRITE_PRESTORAGEINDEX */
  }
}
#endif

/* ****************************************************************************
 % Dem_Mem_MemoryUpdateInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateInit(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (MemoryIndex >= Dem_Cfg_GetSizeOfMemoryCommitNumber())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_SetMemoryCommitNumber(MemoryIndex, DEM_MEM_INIT_COMMIT_NUMBER);                                                      /* SBSW_DEM_ARRAY_WRITE_MEMORYCOMMITNUMBER */
  }
}

/* ****************************************************************************
 % Dem_Mem_MemoryUpdateStart
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateStart(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (MemoryIndex >= Dem_Cfg_GetSizeOfMemoryCommitNumber())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_SetMemoryCommitNumber(MemoryIndex, DEM_MEM_SET_COMMIT_STARTED(Dem_Cfg_GetMemoryCommitNumber(MemoryIndex)));          /* SBSW_DEM_ARRAY_WRITE_MEMORYCOMMITNUMBER */
  }
}

/* ****************************************************************************
 % Dem_Mem_MemoryUpdateFinish
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateFinish(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (MemoryIndex >= Dem_Cfg_GetSizeOfMemoryCommitNumber())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_SetMemoryCommitNumber(MemoryIndex, DEM_MEM_SET_COMMIT_FINISHED(Dem_Cfg_GetMemoryCommitNumber(MemoryIndex)));         /* SBSW_DEM_ARRAY_WRITE_MEMORYCOMMITNUMBER */
  }
}

#if ( (DEM_CFG_SUPPORT_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
/* ****************************************************************************
 % Dem_Mem_MemoryUpdateGetState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryUpdateGetState(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
  return Dem_Cfg_GetMemoryCommitNumber(MemoryIndex);
}
#endif

/* ****************************************************************************
 % Dem_Mem_MemoryGetEntry
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Mem_EntryPtrType, DEM_CODE)
Dem_Mem_MemoryGetEntry(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
  Dem_Mem_EntryPtrType lReturnValue;

#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Dem_Mem_IsMemoryEntryIndex(MemoryIndex) == FALSE)                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
  {
    Dem_RunTimeCheckFailed(__LINE__);
    lReturnValue = (Dem_Mem_EntryPtrType)Dem_Cfg_MemoryDataPtr[Dem_Mem_MemoryIndexAll_Begin()];                                  /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
  }
  else
#endif
  {
    lReturnValue = (Dem_Mem_EntryPtrType)Dem_Cfg_MemoryDataPtr[MemoryIndex];                                                     /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
  }
  return lReturnValue;
}

/* ****************************************************************************
 % Dem_Mem_MemoryInfoInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Mem_MemoryInfoPtrType, DEM_CODE)
Dem_Mem_MemoryInfoInit(
  CONST(uint8, AUTOMATIC)  MemoryId                                                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Mem_MemoryInfoPtrType lReturnValue;
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(MemoryId)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
  if (MemoryId == DEM_CFG_MEMORYID_SECONDARY)
  {
    lReturnValue = &Dem_Mem_SecondaryInfo;
  }
  else
#endif
  {
    lReturnValue = &Dem_Mem_PrimaryInfo;
  }
  return lReturnValue;
}

/* ****************************************************************************
 % Dem_Mem_MemoryGetId
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryGetId(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{
  return MemoryInfo->MemoryId;
}

/* ****************************************************************************
 % Dem_Mem_MemoryGetChronology
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryGetChronology(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  ChronoIndex
  )
{
  return (MemoryInfo->ChronoPtr)[ChronoIndex];
}

/* ****************************************************************************
 % Dem_Mem_MemorySetChronology
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemorySetChronology(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  ChronoIndex,
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (ChronoIndex >= MemoryInfo->MaxSize)
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    (MemoryInfo->ChronoPtr)[ChronoIndex] = MemoryIndex;                                                                          /* SBSW_DEM_ARRAY_WRITE_MEMORYCHRONOLOGY */
  }
}

/* ****************************************************************************
 % Dem_Mem_MemoryIter_Begin
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryIter_Begin(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{
  return MemoryInfo->FirstMemoryIndex;
}

/* ****************************************************************************
 % Dem_Mem_MemoryIter_End
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryIter_End(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{
  return (Dem_Cfg_MemoryIndexType)(MemoryInfo->FirstMemoryIndex + MemoryInfo->MaxSize);
}

/* ****************************************************************************
 % Dem_Mem_MemoryGetMaxSize
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryGetMaxSize(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{
  return MemoryInfo->MaxSize;
}

/* ****************************************************************************
 % Dem_Mem_MemoryGetCurrentSize
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryGetCurrentSize(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{
  return *(MemoryInfo->SizePtr);
}

/* ****************************************************************************
 % Dem_Mem_MemorySetCurrentSize
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemorySetCurrentSize(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  Size
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Size > Dem_Mem_MemoryGetMaxSize(MemoryInfo))                                                                               /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  {
    Dem_RunTimeCheckFailed(__LINE__);
    *(MemoryInfo->SizePtr) = Dem_Mem_MemoryGetMaxSize(MemoryInfo);                                                               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  }
  else
#endif
  {
    *(MemoryInfo->SizePtr) = Size;                                                                                               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
}

/* ****************************************************************************
 % Dem_Mem_MemoryGetFirstEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Mem_MemoryGetFirstEvent(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{
  return MemoryInfo->FirstEvent;
}

/* ****************************************************************************
 % Dem_Mem_MemoryGetLastEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Mem_MemoryGetLastEvent(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{
  return MemoryInfo->LastEvent;
}

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EntryGetERecDataPtr
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_SharedDataPtrType, DEM_CODE)
Dem_Mem_EntryGetERecDataPtr(
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry,                                                                           /* PRQA S 3673 */ /* MD_DEM_16.7_False */
  CONST(uint8, AUTOMATIC)  ERecIndex
  )
{
  Dem_SharedDataPtrType lReturnValue;

# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (ERecIndex >= Dem_Cfg_GlobalERecMaxCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
    lReturnValue = &(MemoryEntry->ExtendedData[0][0]);
  }
  else
# endif
  {
    lReturnValue = &(MemoryEntry->ExtendedData[ERecIndex][0]);
  }
  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EntryGetERecConstDataPtr
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ConstSharedDataPtrType, DEM_CODE)
Dem_Mem_EntryGetERecConstDataPtr(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry,                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint8, AUTOMATIC)  ERecIndex                                                                                             /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_ConstSharedDataPtrType lReturnValue;

  DEM_IGNORE_UNUSED_CONST_ARGUMENT(MemoryEntry)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(ERecIndex)                                                                                    /* PRQA S 3112 */ /* MD_DEM_14.2 */
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (ERecIndex >= Dem_Cfg_GlobalERecMaxCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
    lReturnValue = &(MemoryEntry->ExtendedData[0][0]);
  }
  else
# endif
  {
    lReturnValue = &(MemoryEntry->ExtendedData[ERecIndex][0]);
  }
  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EntryGetSRecDataPtr
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_SharedDataPtrType, DEM_CODE)
Dem_Mem_EntryGetSRecDataPtr(
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry,                                                                           /* PRQA S 3673 */ /* MD_DEM_16.7_False */
  CONST(uint8, AUTOMATIC)  SRecIndex
  )
{
  Dem_SharedDataPtrType lReturnValue;

# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (SRecIndex >= Dem_Cfg_GlobalSRecMaxCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
    lReturnValue = &(MemoryEntry->SnapshotData[0][0]);
  }
  else
# endif
  {
    lReturnValue = &(MemoryEntry->SnapshotData[SRecIndex][0]);
  }
  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Mem_EntryGetSRecConstDataPtr
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ConstSharedDataPtrType, DEM_CODE)
Dem_Mem_EntryGetSRecConstDataPtr(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  SRecIndex
)
{
  Dem_ConstSharedDataPtrType lReturnValue;

# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (SRecIndex >= Dem_Cfg_GlobalSRecMaxCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
    lReturnValue = &(MemoryEntry->SnapshotData[0][0]);
  }
  else
# endif
  {
    lReturnValue = &(MemoryEntry->SnapshotData[SRecIndex][0]);
  }
  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Mem_IndicatorGetEventCountContinuous
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_IndicatorGetEventCountContinuous(
  CONST(uint8, AUTOMATIC)  IndicatorId,                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint8, AUTOMATIC)  J1939NodeId                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(IndicatorId)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(J1939NodeId)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_INDICATORCONTINUOUS == STD_ON)
  return Dem_Cfg_IndicatorContinuous[IndicatorId][J1939NodeId];
#else
  return 0;
#endif
}

#if (DEM_CFG_SUPPORT_INDICATORS == STD_ON)
/* ****************************************************************************
 % Dem_Mem_IndicatorSetEventCountContinuous
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_IndicatorSetEventCountContinuous(
  CONST(uint8, AUTOMATIC)  IndicatorId,                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint8, AUTOMATIC)  J1939NodeId,                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint16, AUTOMATIC)  ActiveEventCount                                                                                     /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(IndicatorId)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(J1939NodeId)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(ActiveEventCount)                                                                             /* PRQA S 3112 */ /* MD_DEM_14.2 */
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if ( (IndicatorId >= Dem_Cfg_GlobalIndicatorCount())                                                                           /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    || (J1939NodeId >= Dem_Cfg_GlobalJ1939NodeCount()))
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
# if (DEM_CFG_INDICATORCONTINUOUS == STD_ON)
    Dem_Cfg_IndicatorContinuous[IndicatorId][J1939NodeId] = ActiveEventCount;                                                    /* SBSW_DEM_ARRAY_WRITE_INDICATORCONTINUOUS */
# endif
  }
}
#endif

/* ****************************************************************************
 % Dem_Mem_IndicatorGetEventCountBlinking
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_IndicatorGetEventCountBlinking(
  CONST(uint8, AUTOMATIC)  IndicatorId,                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint8, AUTOMATIC)  J1939NodeId                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(IndicatorId)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(J1939NodeId)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_INDICATORBLINKING == STD_ON)
  return Dem_Cfg_IndicatorBlinking[IndicatorId][J1939NodeId];
#else
  return 0;
#endif
}

#if (DEM_CFG_SUPPORT_INDICATORS == STD_ON)
/* ****************************************************************************
 % Dem_Mem_IndicatorSetEventCountBlinking
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_IndicatorSetEventCountBlinking(
  CONST(uint8, AUTOMATIC)  IndicatorId,                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint8, AUTOMATIC)  J1939NodeId,                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint16, AUTOMATIC)  ActiveEventCount                                                                                     /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(IndicatorId)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(J1939NodeId)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(ActiveEventCount)                                                                             /* PRQA S 3112 */ /* MD_DEM_14.2 */
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if ( (IndicatorId >= Dem_Cfg_GlobalIndicatorCount())                                                                            /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    || (J1939NodeId >= Dem_Cfg_GlobalJ1939NodeCount()) )
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
# if (DEM_CFG_INDICATORBLINKING == STD_ON)
    Dem_Cfg_IndicatorBlinking[IndicatorId][J1939NodeId] = ActiveEventCount;                                                      /* SBSW_DEM_ARRAY_WRITE_INDICATORBLINKING */
# endif
  }
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_IumprGetUpdatePending
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_ObdIumprUpdatePendingType, DEM_CODE)
Dem_Mem_IumprGetUpdatePending(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex
  )
{
  return Dem_Cfg_GetObdIumprUpdatePending(RatioIndex);
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_IumprSetUpdatePending
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_IumprSetUpdatePending(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex,
  CONST(Dem_Cfg_ObdIumprUpdatePendingType, AUTOMATIC)  Value
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (RatioIndex >= Dem_Cfg_ObdRatioIdCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_SetObdIumprUpdatePending(RatioIndex, Value);
  }
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetDenominator
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_GetDenominator(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex
  )
{
  return (uint16)(Dem_Cfg_ObdIumprData.Denominator[RatioIndex]);
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetDenominator
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetDenominator(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex,
  CONST(uint16, AUTOMATIC)  Value
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (RatioIndex >= Dem_Cfg_ObdRatioIdCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_ObdIumprData.Denominator[RatioIndex] = Value;
  }
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetGeneralDenominator
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_GetGeneralDenominator(
  void
  )
{
  return (uint16)(Dem_Cfg_ObdIumprData.GeneralDenominator);
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetGeneralDenominator
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetGeneralDenominator(
  CONST(uint16, AUTOMATIC)  Value
  )
{
  Dem_Cfg_ObdIumprData.GeneralDenominator = Value;
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetGeneralDenominatorStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetGeneralDenominatorStatus(
  void
  )
{
  return (uint8)(Dem_Cfg_ObdIumprData.GeneralDenominatorStatus);
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetGeneralDenominatorStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetGeneralDenominatorStatus(
  CONST(uint8, AUTOMATIC)  Value
  )
{
  Dem_Cfg_ObdIumprData.GeneralDenominatorStatus = Value;
}
#endif

# if (DEM_FEATURE_NEED_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetGlobalIumprHybridStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetGlobalIumprHybridStatus(
  void
  )
{
#if (DEM_CFG_SUPPORT_CYCLE_IGNITION_HYBRID == STD_ON)
  return Dem_Cfg_ObdIumprData.GlobalHybridStatus;
#else
  return 0;
#endif
}
#endif

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetGlobalIumprHybridStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetGlobalIumprHybridStatus(
  CONST(uint8, AUTOMATIC)  Value                                                                                                 /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(Value)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
# if (DEM_CFG_SUPPORT_CYCLE_IGNITION_HYBRID == STD_ON)
  Dem_Cfg_ObdIumprData.GlobalHybridStatus = Value;
# endif
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetGlobalNumeratorsLocked
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetGlobalNumeratorsLocked(
  void
  )
{
  return (uint8)(Dem_Cfg_ObdIumprData.GlobalNumeratorsLocked);
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetGlobalNumeratorsLocked
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetGlobalNumeratorsLocked(
  CONST(uint8, AUTOMATIC)  Value
  )
{
  Dem_Cfg_ObdIumprData.GlobalNumeratorsLocked = Value;
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetIumprStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetIumprStatus(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex
  )
{
  return Dem_Cfg_ObdIumprData.Status[RatioIndex];
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetIumprStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetIumprStatus(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex,
  CONST(uint8, AUTOMATIC)  Value
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (RatioIndex >= Dem_Cfg_ObdRatioIdCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_ObdIumprData.Status[RatioIndex] = Value;
  }
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetNumerator
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Mem_GetNumerator(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex
  )
{
  return Dem_Cfg_ObdIumprData.Numerator[RatioIndex];
}
#endif

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetNumerator
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetNumerator(
  CONST(Dem_RatioIdIndexType, AUTOMATIC)  RatioIndex,
  CONST(uint16, AUTOMATIC)  Value
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (RatioIndex >= Dem_Cfg_ObdRatioIdCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
    Dem_Cfg_ObdIumprData.Numerator[RatioIndex] = Value;
  }
}
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryFindIndex_Checked
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryFindIndex_Checked(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;

  lMemoryIndex = Dem_Mem_MemoryFindIndex(MemoryInfo, EventId);                                                                   /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  /* Cannot happen except after the Dem state becomes inconsistent */
  if (lMemoryIndex == DEM_MEM_INVALID_MEMORY_INDEX)
  {
    Dem_RunTimeCheckFailed(__LINE__);
    lMemoryIndex = 0;
  }
#endif

  return lMemoryIndex;
}

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_GetBlockState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Nvm_GetBlockState(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
  return Dem_Cfg_GetMemoryStatus(MemoryIndex);
}
#endif

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_SetBlockState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_SetBlockState(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex,
  CONST(uint8, AUTOMATIC)  Status
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (MemoryIndex >= DEM_CFG_GLOBAL_NV_BLOCK_COUNT)
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
    Dem_Cfg_SetMemoryStatus(MemoryIndex, Status);                                                                                /* SBSW_DEM_ARRAY_WRITE_MEMORYSTATUS */
  }
}
#endif

                                                              /* Calibration */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Cal_TestEventAvailable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestEventAvailable(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId                                                                                     /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  boolean lReturnValue;
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
  lReturnValue = (boolean)(Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE);
#else
  lReturnValue = TRUE;
#endif
  return lReturnValue;
}

/* ****************************************************************************
 * Dem_Cal_TestGroupAvailable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestGroupAvailable(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  boolean lReturnValue;
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(GroupId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) && (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
  lReturnValue = (boolean)(Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_CombinedGroupGetInternalStatus(GroupId)) == FALSE);
#else
  lReturnValue = TRUE;
#endif
  return lReturnValue;
}

/* ****************************************************************************
 * Dem_Cal_TestDtcAvailable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestDtcAvailable(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  boolean lReturnValue;
  if (Dem_Cfg_EventIsCombined(EventId) == TRUE)
  {
    lReturnValue = Dem_Cal_TestGroupAvailable(Dem_Cfg_EventCombinedGroup(EventId));
  }
  else
  {
    lReturnValue = Dem_Cal_TestEventAvailable(EventId);
  }
  return lReturnValue;
}

/* ****************************************************************************
 % Dem_Cal_TestGroupAvailableInVariant
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestGroupAvailableInVariant(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  boolean lReturnValue;
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(GroupId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
  lReturnValue = Dem_Mem_TestAvailableInVariantStatus(Dem_Mem_CombinedGroupGetInternalStatus(GroupId));
  return lReturnValue;
}

/* ****************************************************************************
 % Dem_Cal_TestDtcAvailableInVariant
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestDtcAvailableInVariant(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  boolean lReturnValue;
  if (Dem_Cfg_EventIsCombined(EventId) == TRUE)
  {
    lReturnValue = Dem_Cal_TestGroupAvailableInVariant(Dem_Cfg_EventCombinedGroup(EventId));
  }
  else
  {
    lReturnValue = Dem_Cfg_EventAvailableByVariant(EventId);
  }
  return lReturnValue;
}

/* ****************************************************************************
 * Dem_Cal_TestGroupSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestGroupSuppression(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  boolean lReturnValue;
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(GroupId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) && (DEM_FEATURE_NEED_SUPPRESSION == STD_ON)
  lReturnValue = (boolean)                                                                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    ( (Dem_Mem_TestDtcSuppressedStatus(Dem_Mem_CombinedGroupGetInternalStatus(GroupId)) == TRUE)
   || (Dem_Mem_TestEventSuppressedStatus(Dem_Mem_CombinedGroupGetInternalStatus(GroupId)) == TRUE) );
#else
  lReturnValue = FALSE;
#endif
  return lReturnValue;
}

/* ****************************************************************************
 * Dem_Cal_TestEventSuppression
 *****************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestEventSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  return (boolean)                                                                                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    ( (Dem_Mem_TestDtcSuppressedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == TRUE)
   || (Dem_Mem_TestEventSuppressedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == TRUE) );
}

/* ****************************************************************************
 * Dem_Cal_TestDtcSuppression
 *****************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestDtcSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  boolean lReturnValue;

  if (Dem_Cfg_EventIsCombined(EventId) == TRUE)
  {
    lReturnValue = Dem_Cal_TestGroupSuppression(Dem_Cfg_EventCombinedGroup(EventId));
  }
  else
  {
    lReturnValue = Dem_Cal_TestEventSuppression(EventId);
  }

  return lReturnValue;
}

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_Cal_TestEventSuppressed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestEventSuppressed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  boolean lReturnValue;
  lReturnValue = (boolean)                                                                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
     ( (Dem_Cal_TestEventSuppression(EventId) == TRUE)
    || (Dem_Cfg_EventAvailableByVariant(EventId) == FALSE)
    || ( (Dem_Cal_TestEventAvailable(EventId) == FALSE)
      && (Dem_Mem_GetStoredStatus(Dem_Mem_EventGetInternalStatus(EventId)) == DEM_ESM_STORED_STATUS_NONE) )
      );
  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Cal_TestDtcSuppressed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Cal_TestDtcSuppressed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  boolean lReturnValue;
  lReturnValue = (boolean)                                                                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
     ( (Dem_Cal_TestDtcSuppression(EventId) == TRUE)
    || (Dem_Cal_TestDtcAvailableInVariant(EventId) == FALSE)
    || ( (Dem_Cal_TestDtcAvailable(EventId) == FALSE)
      && (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(EventId)) == DEM_ESM_STORED_STATUS_NONE) )
     );
  return lReturnValue;
}

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Util_TestEventValid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Util_TestEventValid(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  return (boolean)( (EventId != DEM_EVENT_INVALID)                                                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
                 && (EventId < Dem_Cfg_GlobalEventCount()) );
}

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
/* ****************************************************************************
 % Dem_Util_CallClearEventAllowed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Util_CallClearEventAllowed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  boolean lClearAllowed;
  Dem_ClearEventAllowedFPtrType lpClearAllowedFunc;

  lClearAllowed = TRUE;
  lpClearAllowedFunc = Dem_Cfg_EventCbkClearAllowed(EventId);
  if (NULL_PTR != lpClearAllowedFunc)
  {
    if (E_OK != (*lpClearAllowedFunc)(&lClearAllowed))                                                                           /* SBSW_DEM_CLEARALLOWED_FPTR */
    { /* Make sure a failed call does not influence lDoClear */
      lClearAllowed = TRUE;
    }
  }
  return lClearAllowed;
}
#endif

/* ****************************************************************************
 % Dem_Util_DtcApplyUserControlledWIR
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyUserControlledWIR(
  CONST(uint8, AUTOMATIC)  DtcStatus,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(InternalStatus)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
  return ((uint8)((DtcStatus) | ((InternalStatus) & DEM_ESM_USER_CONTROLLED_WIR)));
#else
  return DtcStatus;
#endif
}

#if ( (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) \
   || (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON) \
   || (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) \
   || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON) )
/* ****************************************************************************
 % Dem_Util_DtcApplyCombinedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyCombinedStatus(
  CONST(uint8, AUTOMATIC)  DtcStatus
  )
{
  uint8 lReturnValue;
  lReturnValue = DtcStatus;
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFSLC(lReturnValue))
  {
    lReturnValue = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lReturnValue);
  }
  if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFTOC(lReturnValue))
  {
    lReturnValue = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lReturnValue);
  }
# endif
  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Util_DtcApplyExternalOnlyStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyExternalOnlyStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint8, AUTOMATIC)  DtcStatus
  )
{
  uint8 lReturnValue;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
#endif

  DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lReturnValue = DtcStatus;

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    /* EventId is a combined event*/
    boolean lWirActive = FALSE;
    Dem_Cfg_CombinedGroupIterType lCombinedIter;

    /* Scan through all active sub-events */
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterExists(&lCombinedIter) == TRUE;                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterNext(&lCombinedIter))                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_EventIdType lSubEventId;

      lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lCombinedIter);                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if ( (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)                                                                /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE) )
      {
        lWirActive = (boolean)(lWirActive                                                                                        /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          || (Dem_Mem_TestUserControlledWirStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == TRUE));
      }
    }
    if (FALSE != lWirActive)
    {
      lReturnValue = DEM_ESM_SET_UDS_STATUS_WIR(lReturnValue);
    }
    lReturnValue = Dem_Util_DtcApplyCombinedStatus(lReturnValue);
  }
  else
#endif
  {
    /* EventId is not a combined event */
    lReturnValue = (uint8)(Dem_Util_DtcApplyUserControlledWIR(lReturnValue, Dem_Mem_EventGetInternalStatus(EventId)));
  }
  return lReturnValue;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Util_DtcGetInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Util_DtcGetInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
  }
  else
#endif
  {
    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  }
  return lInternalStatus;
}

/* ****************************************************************************
 % Dem_Util_DtcSetInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Util_DtcSetInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Cfg_EventInternalStatusType, AUTOMATIC)  InternalStatus
  )
{
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, InternalStatus);
  }
  else
#endif
  {
    Dem_Mem_EventSetInternalStatus(EventId, InternalStatus);
  }
}

/* ****************************************************************************
 % Dem_Util_DtcGetStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcGetStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  uint8 lDtcStatus;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lDtcStatus = Dem_Mem_CombinedGroupGetStatus(lGroupId);
  }
  else
#endif
  {
    lDtcStatus = Dem_Mem_EventGetStatus(EventId);
  }
  return lDtcStatus;
}

#if ( (DEM_CFG_SUPPORT_DCM == STD_ON) \
  || (DEM_CFG_DATA_CURRENT_FDC == STD_ON) )
/* ****************************************************************************
 % Dem_Util_DtcGetFaultDetectionCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Util_DtcGetFaultDetectionCounter(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONSTP2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter
  )
{
  Std_ReturnType lGetFdcReturnValue;
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lGetFdcReturnValue = Dem_Data_CombinedGroupGetFDC(lGroupId, FaultDetectionCounter);                                          /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  }
  else
# endif
  {
    lGetFdcReturnValue = Dem_GetFaultDetectionCounter(EventId, FaultDetectionCounter);                                           /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  }

  return lGetFdcReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_DATA_CURRENT_FDC == STD_ON) */

/* ****************************************************************************
 % Dem_Util_CombinedGroupGetEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Util_CombinedGroupGetEvent(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Cfg_CombinedGroupIterType lGroupIter;

  /* In rare cases GroupId is not required */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(GroupId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */

  Dem_Cfg_CombinedGroupIterInit(GroupId, &lGroupIter);                                                                           /* SBSW_DEM_CALL_ITERATOR_POINTER */
  return Dem_Cfg_CombinedGroupIterGet(&lGroupIter);                                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
}

/* ****************************************************************************
 % Dem_Util_DtcGetMasterEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Util_DtcGetMasterEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_EventIdType  lMasterEventId;

  lMasterEventId = EventId;
  if (EventId != DEM_EVENT_INVALID)
  {
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    lGroupId = Dem_Cfg_EventCombinedGroup(EventId);

    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      lMasterEventId = Dem_Util_CombinedGroupGetEvent(lGroupId);
    }
  }

  return lMasterEventId;
}

/* ****************************************************************************
 % Dem_Util_ForEachCombinedEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Util_ForEachCombinedEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedFuncType, AUTOMATIC)  FuncPtr,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr
  )
{
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    /* EventId is a combined event */

    uint8 lDtcStatus;
    Dem_Cfg_CombinedGroupIterType lCombinedIter;
    Dem_EventIdType lSubEventId;

    lDtcStatus = 0; /* neutral value */
    ArgPtr->Common.OldDtcStatus = Dem_Mem_CombinedGroupGetStatus(lGroupId);                                                      /* SBSW_DEM_POINTER_WRITE_ARGUMENT */

    /* Iterate through all active sub-events */
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterExists(&lCombinedIter) == TRUE;                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterNext(&lCombinedIter))                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lCombinedIter);                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */

      if ( (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)                                                                /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE) )
      {
        (*FuncPtr)(lSubEventId, ArgPtr);                                                                                         /* SBSW_DEM_CALL_FOREACH_FUNCPTR */
        /* Combined event status created by ORing the status bits or all sub-events */
        lDtcStatus = (uint8)(lDtcStatus | Dem_Mem_EventGetStatus(lSubEventId));
      }
    }
    Dem_Mem_CombinedGroupSetStatus(lGroupId, lDtcStatus);

    ArgPtr->Common.NewDtcStatus = lDtcStatus;                                                                                    /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  else
#endif
  {
    /* EventId is not a combined event */

    ArgPtr->Common.OldDtcStatus = Dem_Mem_EventGetStatus(EventId);                                                               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    (*FuncPtr)(EventId, ArgPtr);                                                                                                 /* SBSW_DEM_CALL_FOREACH_FUNCPTR */
    ArgPtr->Common.NewDtcStatus = Dem_Mem_EventGetStatus(EventId);                                                               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

                                                      /* Queue Setter/Getter */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ChronologyGetEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Queue_ChronologyGetEvent(
  CONST(uint8, AUTOMATIC)  QueueIndex
  )
{
  return Dem_Cfg_EventQueue[QueueIndex];
}
#endif

#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ChronologySetEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ChronologySetEvent(
  CONST(uint8, AUTOMATIC)  QueueIndex,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (QueueIndex >= Dem_Cfg_GlobalQueueMaxCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
# endif
  {
    Dem_Cfg_EventQueue[QueueIndex] = EventId;                                                                                    /* SBSW_DEM_ARRAY_WRITE_EVENTQUEUE */
  }
}
#endif

/* ****************************************************************************
 % Dem_Queue_GetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Queue_GetEventStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
)
{
  return Dem_Cfg_GetEventQueueStatus(EventId);
}

/* ****************************************************************************
 % Dem_Queue_SetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_SetEventStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  Status
)
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_SetEventQueueStatus(EventId, Status);                                                                                /* SBSW_DEM_ARRAY_WRITE_EVENTQUEUESTATUS */
  }
}

/* ****************************************************************************
 % Dem_Queue_GetPendingCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Queue_GetPendingCycle(
  CONST(uint8, AUTOMATIC)  CycleId
  )
{
  return (boolean)(((Dem_Queue_CycleState & (uint16)(1U << CycleId)) != 0U)
                     ? DEM_QUEUE_CYCLE_STARTED
                     : DEM_QUEUE_CYCLE_STOPPED);
}

/* ****************************************************************************
 % Dem_Queue_SetPendingCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_SetPendingCycle(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint8, AUTOMATIC)  Status
  )
{
  uint16 lMask = (uint16)(1U << CycleId);

  Dem_Queue_CycleFlag = (uint16)(Dem_Queue_CycleFlag | lMask);

  if (DEM_QUEUE_CYCLE_STOPPED == Status)
  {
    Dem_Queue_CycleState = (uint16)(Dem_Queue_CycleState & ((uint16)~lMask));
  }
  else
  {
    Dem_Queue_CycleState = (uint16)(Dem_Queue_CycleState | lMask);
  }
}

/* ****************************************************************************
 % Dem_Queue_SetPendingEvent_Enqueue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Queue_SetPendingEvent_Enqueue(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  uint8 lQueueStatus;

  lQueueStatus = Dem_Queue_GetEventStatus(EventId);

  if (DEM_QUEUE_EVENT_NONE == DEM_QUEUE_GET_QUEUESTATE(lQueueStatus))
  {
    /* Event not queued yet, enter in queue if possible and set pending actions */
#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
    uint8 lQueueWriteIndex = Dem_Queue_EventWriteIndex;

    if ( (Dem_Queue_EventReadIndex != lQueueWriteIndex)                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_cs */
      || (Dem_Queue_EventCount == 0U) )                                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_cs */
    {
      Dem_Queue_ChronologySetEvent(lQueueWriteIndex, EventId);
      Dem_WrappingIncrement(lQueueWriteIndex, Dem_Cfg_GlobalQueueMaxCount())
      Dem_Queue_EventWriteIndex = lQueueWriteIndex;
      lQueueStatus = DEM_QUEUE_SET_QUEUESTATE(lQueueStatus, DEM_QUEUE_EVENT_QUEUED);
    }
    else
#endif
    {
      lQueueStatus = DEM_QUEUE_SET_QUEUESTATE(lQueueStatus, DEM_QUEUE_EVENT_PENDING);
    }
    ++Dem_Queue_EventCount;
  }

  return lQueueStatus;
}

/* ****************************************************************************
 % Dem_Queue_SetPendingEvent_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Queue_SetPendingEvent_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  MonitorStatus
  )
{
  Std_ReturnType lReturnValue;
  uint8 lQueueStatus;

  lQueueStatus = Dem_Queue_SetPendingEvent_Enqueue(EventId);

  if (MonitorStatus == DEM_EVENT_STATUS_FAILED)
  {
    switch (DEM_QUEUE_GET_QUEUEACTION(lQueueStatus))
    {
    case 0:
      lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 5);
      lReturnValue = E_OK;
      break;
    case 1:
    case 6:
      ++lQueueStatus;
      lReturnValue = E_OK;
      break;
    case 2:
    case 5:
    case 7:
      lReturnValue = E_OK;
      break;
    default:
      lReturnValue = E_NOT_OK;
      break;
    }
  }
  else if (MonitorStatus == DEM_EVENT_STATUS_PASSED)
  {
    switch (DEM_QUEUE_GET_QUEUEACTION(lQueueStatus))
    {
    case 0:
      lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 1);
      lReturnValue = E_OK;
      break;
    case 2:
    case 5:
      ++lQueueStatus;
      lReturnValue = E_OK;
      break;
    case 1:
    case 3:
    case 6:
      lReturnValue = E_OK;
      break;
    default:
      lReturnValue = E_NOT_OK;
      break;
    }
  }
  else
  {
    /* Not a qualified result */
    lReturnValue = E_OK;
  }
  Dem_Queue_SetEventStatus(EventId, lQueueStatus);

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030 */ /* MD_MSR_STCYC */

/* ****************************************************************************
 % Dem_Queue_SetPendingEvent_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Queue_SetPendingEvent_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  MonitorResult,
  CONST(uint8, AUTOMATIC)  EventStatus
  )
{
  Std_ReturnType lReturnValue;
  uint8 lQueueStatus;

  lReturnValue = E_OK;
  lQueueStatus = Dem_Queue_SetPendingEvent_Enqueue(EventId);

  switch (DEM_QUEUE_GET_QUEUEACTION(lQueueStatus))
  {
  case 0:
#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
  case 22:
#endif
    if (MonitorResult == DEM_EVENT_STATUS_FAILED)
    {
      /* #010 With trigger 'TestFailed' enter next state according to the transition table */
      switch (EventStatus & (DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC))
      {
      case DEM_UDS_STATUS_TNCTOC:
      case DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 1);
        break;

      case DEM_UDS_STATUS_TFTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 7);
        break;

      case DEM_UDS_STATUS_TF:
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TNCTOC:
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 10);
        break;

      case 0:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 4);
        break;

#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC:
        if (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(EventId)) == DEM_ESM_STORED_STATUS_NONE)
        {
          lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 22);
        }
        break;
#endif

      default:
        break;
      }
    }
    else
    if (MonitorResult == DEM_EVENT_STATUS_PASSED)
    {
      /* #020 With trigger 'TestPassed' enter next state according to the transition table */
      switch (EventStatus & (DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC))
      {
      case DEM_UDS_STATUS_TF:
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TNCTOC:
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 13);
        break;

      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 16);
        break;

      case DEM_UDS_STATUS_TNCTOC:
      case DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 19);
        break;

      default:
        break;
      }
    }
    else
    {
      /* No state change on unqualified results */
    }
    break;

  case 1:
  case 4:
  case 7:
  case 10:
  case 14:
  case 17:
  case 20:
    if (MonitorResult == DEM_EVENT_STATUS_PASSED)
    {
      ++lQueueStatus;
    }
    break;

  case 2:
  case 5:
  case 8:
  case 11:
  case 13:
  case 16:
  case 19:
    if (MonitorResult == DEM_EVENT_STATUS_FAILED)
    {
      if (Dem_Cfg_EventAgingTarget(EventId) == 0)
      {
        lReturnValue = E_NOT_OK;
      }
      else
      {
        ++lQueueStatus;
      }
    }
    break;

  case 3:
  case 6:
  case 9:
  case 12:
    /* queue overflow */
    if (MonitorResult == DEM_EVENT_STATUS_PASSED)
    {
      lReturnValue = E_NOT_OK;
    }
    break;

  case 15:
  case 18:
  case 21:
    /* queue overflow */
    if (MonitorResult == DEM_EVENT_STATUS_FAILED)
    {
      lReturnValue = E_NOT_OK;
    }
    break;

  default:
    lReturnValue = E_NOT_OK;
    break;
  }

  Dem_Queue_SetEventStatus(EventId, lQueueStatus);

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030 */ /* MD_MSR_STCYC */

/* ****************************************************************************
 % Dem_Queue_ResetPendingEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ResetPendingEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  uint8 lQueueStatus;

  lQueueStatus = Dem_Queue_GetEventStatus(EventId);

  Dem_Queue_SetEventStatus(EventId, (uint8)(lQueueStatus & DEM_QUEUE_EVENT_CLEARMASK));
}

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Data_EventFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_EventFailed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  Effects
  )
{
  if ( (Dem_Cfg_GlobalPrimaryFirst() <= EventId)                                                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && (Dem_Cfg_GlobalPrimaryLast() >= EventId) )
  {
    if (0 != (Effects & DEM_CFG_TRIGGER_CONFIRMED))
    {
      if ( DEM_EVENT_INVALID == Dem_Mem_GetFirstConfirmedEvent() )
      {
        Dem_Mem_SetFirstConfirmedEvent(EventId);
      }

      Dem_Mem_SetMostRecentConfmdEvent(EventId);
    }

    if (DEM_EVENT_INVALID == Dem_Mem_GetFirstFailedEvent())
    {
      Dem_Mem_SetFirstFailedEvent(EventId);
    }
    Dem_Mem_SetMostRecentFailedEvent(EventId);
  }
}

                                                            /* Notifications */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Cbk_DtcStatusChanged
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_DtcStatusChanged(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  EventStatusOld,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  EventStatusNew,
  CONST(uint8, AUTOMATIC)  NotificationReason
  )
{
  Dem_Cbk_DtcStatusChanged_Internal(
    EventId,
    Dem_Util_DtcApplyExternalOnlyStatus(EventId, EventStatusOld),
    Dem_Util_DtcApplyExternalOnlyStatus(EventId, EventStatusNew),
    NotificationReason
  );
}

/* ****************************************************************************
 % Dem_Cbk_EventDataChanged
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_EventDataChanged(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  if (Dem_Cfg_EventCbkData(EventId) != NULL_PTR)
  {
    (void)(*Dem_Cfg_EventCbkData(EventId))();                                                                                    /* SBSW_DEM_EVENTCBKDATA_FPTR */
  }
  if (Dem_Cfg_GlobalCbkData() != NULL_PTR)
  {
    (void)(*Dem_Cfg_GlobalCbkData())(EventId);                                                                                   /* SBSW_DEM_GLOBALCBKEVENTDATA_FPTR */
  }
}

/* ****************************************************************************
 % Dem_Cbk_InitMonitorForEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_InitMonitorForEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_InitMonitorReasonType, AUTOMATIC)  InitReason
  )
{
  Dem_InitMonitorForEventFPtrType lpInitMonitorForEventFunc;

  lpInitMonitorForEventFunc = Dem_Cfg_EventCbkInitMonitor(EventId);

  if (NULL_PTR != lpInitMonitorForEventFunc)
  {
    (void)(*lpInitMonitorForEventFunc)(InitReason);                                                                              /* SBSW_DEM_INITMONITORFOREVENT_FPTR */
  }
}

/* ****************************************************************************
 % Dem_Cbk_InitMonitorForFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_InitMonitorForFunction(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_EventCbkInitFuncIterType lIter;

  for (Dem_Cfg_EventCbkInitFuncIterInit(EventId, &lIter);                                                                        /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
       Dem_Cfg_EventCbkInitFuncIterExists(&lIter) == TRUE;                                                                       /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
       Dem_Cfg_EventCbkInitFuncIterNext(&lIter))                                                                                 /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
  {
    Dem_InitMonitorForFuncFPtrType lpInitMonitorForFuncFunc;

    lpInitMonitorForFuncFunc = Dem_Cfg_EventCbkInitFuncIterGet(&lIter);                                                          /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
    if (lpInitMonitorForFuncFunc != NULL_PTR)
    {
      (void)(lpInitMonitorForFuncFunc());                                                                                        /* SBSW_DEM_INITMONITORFORFUNCTION_FPTR */
    }
  }
}

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Data_EntryInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_EntryInit(
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry                                                                            /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(MemoryEntry)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */

#if (DEM_FEATURE_NEED_OCC_COUNTER == STD_ON)
  Dem_Mem_EntrySetOccurrenceCount(MemoryEntry, DEM_DATA_OCCURRENCE_INIT);                                                        /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif

  Dem_Mem_EntrySetAgingCount(MemoryEntry, DEM_ESM_CYCLECOUNT_INVALID);                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  MemoryEntry->ExtendedHeader = 0;                                                                                               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
  MemoryEntry->SnapshotHeader = 0;                                                                                               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
  Dem_Mem_EntrySetDebounceValueMax(MemoryEntry, 0);                                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
#if (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
  Dem_Mem_EntrySetFailedCycleCount(MemoryEntry, 0);                                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
#if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
  Dem_Mem_EntrySetConsecutiveFailedCycleCount(MemoryEntry, 0);                                                                   /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
#if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
  Dem_Mem_EntrySetFirstFailedCycleCount(MemoryEntry, DEM_ESM_CYCLECOUNT_INVALID);                                                /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
#if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
  Dem_Mem_EntrySetLastFailedCycleCount(MemoryEntry, DEM_ESM_CYCLECOUNT_INVALID);                                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
  Dem_Mem_EntrySetTestedSinceFirstFailedCycleCount(MemoryEntry, 0);                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
#if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON) || (DEM_FEATURE_NEED_OBD == STD_ON)                                          /* COV_MSR_UNSUPPORTED TF tf xf */
  Dem_Mem_EntrySetState(MemoryEntry, 0);                                                                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
}

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_CollectSnapshot
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectSnapshot(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_SharedDataPtrType, AUTOMATIC)  DestinationBuffer,
  CONST(uint16, AUTOMATIC)  BufferSize
  )
{
  Dem_Data_CollectDidInfoType lCollectDidInfo;
  Dem_Cfg_EventDidIterType lDidIter;

  /* Initialize collection context */
  lCollectDidInfo.EventId = EventId;
  lCollectDidInfo.DestinationBuffer = DestinationBuffer;
  lCollectDidInfo.BufferSize = BufferSize;
  lCollectDidInfo.WriteIndex = 0;

  for (Dem_Cfg_EventDidIterInit(EventId, &lDidIter);                                                                             /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventDidIterExists(&lDidIter) == TRUE;                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventDidIterNext(&lDidIter))                                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_DidIndexType lDidIndex;
    lDidIndex = Dem_Cfg_EventDidIterGet(&lDidIter);                                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
    Dem_Data_CollectDid(&lCollectDidInfo, lDidIndex);                                                                            /* SBSW_DEM_POINTER_LOCAL_COLLECTDIDINFO */
  }
}
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON) && (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Data_PrestorageApplySRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_PrestorageApplySRec(
  CONST(Dem_SharedDataPtrType, AUTOMATIC)  DestinationBuffer,
  CONST(uint16, AUTOMATIC)  BufferSize
  )
{
  boolean lReturnValue;

  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != Dem_Esm_PrestorageLockedIndex)
  {
    Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;
    lPrestoredEntry = Dem_Mem_PrestorageGetEntry(Dem_Esm_PrestorageLockedIndex);

    Dem_MemCpy(DestinationBuffer,                                                                                                /* PRQA S 0310, 0602 */ /* MD_DEM_11.4_cpy, MD_DEM_20.2 */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
               Dem_Mem_PrestoredEntryGetSRecDataPtr(lPrestoredEntry),
               BufferSize);

    lReturnValue = TRUE;
  }
  else
  {
    lReturnValue = FALSE;
  }
  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) && (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON) */

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_EntryUpdate_UserERecs
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_EntryUpdate_UserERecs(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry
  )
{
  uint8 lBlockModification;
  uint8 lValidMask;
  uint8 lBufferIndex;
  Dem_Cfg_EventERecIterType lIterator;
  Dem_Data_CollectDidInfoType lCollectDidInfo;

  lBlockModification = DEM_DATA_NO_CHANGES;
  lValidMask = 0x01U;
  lCollectDidInfo.EventId = EventId;
  lBufferIndex = 0;

  for (Dem_Cfg_EventERecIterInit(EventId, &lIterator);                                                                           /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventERecIterExists(&lIterator) == TRUE;                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventERecIterNext(&lIterator))                                                                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_ERecIndexType lERecIndex;
    lERecIndex = Dem_Cfg_EventERecIterGet(&lIterator);                                                                           /* SBSW_DEM_CALL_ITERATOR_POINTER */

    if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lERecIndex))
    {
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
      if (lBufferIndex >= Dem_Cfg_GlobalERecMaxCount())
      {
        Dem_RunTimeCheckFailed(__LINE__);
        break;
      }
# endif
      if ( (Dem_Cfg_ERecUpdate(lERecIndex) == TRUE)
        || ((lValidMask & MemoryEntry->ExtendedHeader) == 0) )
      {
        MemoryEntry->ExtendedHeader = (uint8)(MemoryEntry->ExtendedHeader | lValidMask);                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        lCollectDidInfo.DestinationBuffer = Dem_Mem_EntryGetERecDataPtr(MemoryEntry, lBufferIndex);                              /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
        lCollectDidInfo.BufferSize = Dem_Cfg_GlobalERecMaxRawSize();
        lCollectDidInfo.WriteIndex = 0;

        Dem_Data_CollectDid(&lCollectDidInfo, Dem_Cfg_ERecDid(lERecIndex));                                                      /* SBSW_DEM_POINTER_EXTENDEDDATA_BUFFER */
        lBlockModification = DEM_DATA_USERDATA_CHANGED;
      }

      ++lBufferIndex;
      Dem_LROT1_Byte(lValidMask)
    }
  }

  return lBlockModification;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_EntryUpdate_SRecs
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_EntryUpdate_SRecs(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  UpdateFlags
  )
{
  uint8 lBlockModification;
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  uint8 lValidMask;
  uint8 lLastStoredBufferIndex;
# endif
  uint8 lBufferIndex;
  Dem_Cfg_EventSRecIterType lIterator;

  lBlockModification = DEM_DATA_NO_CHANGES;
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  lValidMask = 0x01U;
  lLastStoredBufferIndex = 0xffU; /* Invalid */
# endif
  lBufferIndex = 0;

  for (Dem_Cfg_EventSRecIterInit(EventId, &lIterator);                                                                           /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventSRecIterExists(&lIterator) == TRUE;                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventSRecIterNext(&lIterator))                                                                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_SRecIndexType lSRecId;

    lSRecId = Dem_Cfg_EventSRecIterGet(&lIterator);                                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */

    /* If an update is needed: Updates are required when the configured trigger matches,
     * and the record is either not stored or configured for updates */
    if ( (                                                                                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_FEATURE_NEED_SREC_OEMTRIGGER == STD_ON)
           (Dem_Data_OemSRecTrigger(EventId, MemoryEntry, lSRecId, UpdateFlags)) ||                                              /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
# endif
           (Dem_Cfg_SRecTrigger(lSRecId) == (UpdateFlags & Dem_Cfg_SRecTrigger(lSRecId))) )
      && ( (Dem_Cfg_SRecUpdate(lSRecId) == TRUE)
        ||
#  if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
           ((lValidMask & MemoryEntry->SnapshotHeader) == FALSE)
#  endif
#  if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
           (lBufferIndex == MemoryEntry->SnapshotHeader)
#  endif
         )
      )
    {
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
      MemoryEntry->SnapshotHeader = (uint8)(MemoryEntry->SnapshotHeader | lValidMask);                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# endif
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
      if (lBufferIndex == MemoryEntry->SnapshotHeader)
      { /* Only increment if a new snapshot is added, updates keep the current ID */
        MemoryEntry->SnapshotHeader = (uint8)(MemoryEntry->SnapshotHeader + 1);                                                  /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
# endif

# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
      /* For configured snapshot numbers, if the snapshot is already collected copy its data */
      if (lLastStoredBufferIndex != 0xffU)
      {
        Dem_MemCpy((Dem_NvDataPtrType)(Dem_Mem_EntryGetSRecDataPtr(MemoryEntry, lBufferIndex)),                                  /* SBSW_DEM_POINTER_SNAPSHOT_BUFFER */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
                   (Dem_NvDataPtrType)(Dem_Mem_EntryGetSRecDataPtr(MemoryEntry, lLastStoredBufferIndex)),
                   Dem_Cfg_GlobalSRecMaxRawSize());
      }
      else
# endif
      {
# if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
        /* If 'prestore freezeframe' is enabled and data is prestored, copy the prestored data */
        if (Dem_Data_PrestorageApplySRec(Dem_Mem_EntryGetSRecDataPtr(MemoryEntry, lBufferIndex),                                 /* SBSW_DEM_POINTER_SNAPSHOT_BUFFER */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
                                         Dem_Cfg_GlobalSRecMaxRawSize()) == FALSE)
# endif
        {
          /* Otherwise, collect new samples from the application. */
          Dem_Data_CollectSnapshot(EventId,                                                                                      /* SBSW_DEM_POINTER_SNAPSHOT_BUFFER */
                                   Dem_Mem_EntryGetSRecDataPtr(MemoryEntry, lBufferIndex),                                       /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
                                   Dem_Cfg_GlobalSRecMaxRawSize());
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
          lLastStoredBufferIndex = lBufferIndex;
# endif
        }
        lBlockModification = DEM_DATA_USERDATA_CHANGED;
      }
      /* For calculated snapshot records, processing is completed */
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
      break;
# endif
    }
    /* Move to the next snapshot record buffer */
    ++lBufferIndex;
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
    Dem_LROT1_Byte(lValidMask)
# endif
  }

  return lBlockModification;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */

/* ****************************************************************************
 % Dem_Data_EntryUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_EntryUpdate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint8, AUTOMATIC)  UpdateFlags,
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
  uint8 lBlockModification;

  lBlockModification = DEM_DATA_NO_CHANGES;

  if (DEM_MEM_INVALID_MEMORY_INDEX != MemoryIndex)
  {
    Dem_Mem_EntryPtrType lEntry;

    lEntry = Dem_Mem_MemoryGetEntry(MemoryIndex);

    Dem_Mem_MemoryUpdateStart(MemoryIndex);

    /* On a TestFailed trigger */
    if (0 != (UpdateFlags & DEM_CFG_TRIGGER_TESTFAILED))
    {
#if (DEM_FEATURE_NEED_OCC_COUNTER == STD_ON)
      {
        Dem_Data_OccurrenceCounterType lOccurrenceCount;

        lOccurrenceCount = Dem_Mem_EntryGetOccurrenceCount(lEntry);
# if (DEM_CFG_PROCESS_OCCTR_CONFIRMED == STD_ON)
        if (FALSE != DEM_ESM_TEST_UDS_STATUS_CDTC(Dem_Util_DtcGetStatus(EventId))) /* Event had confirmed earlier */
# endif
        {
          if (lOccurrenceCount < DEM_DATA_OCCURRENCE_MAX)
          {
            lOccurrenceCount = (Dem_Data_OccurrenceCounterType)(lOccurrenceCount + 1);
            Dem_Mem_EntrySetOccurrenceCount(lEntry, lOccurrenceCount);                                                           /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
            lBlockModification = DEM_DATA_SET_STATISTICS_CHANGED(lBlockModification);
          }
        }
      }
#endif
      {
        Dem_Mem_EntrySetAgingCount(lEntry, DEM_ESM_CYCLECOUNT_INVALID);                                                          /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
        lBlockModification = DEM_DATA_SET_STATISTICS_CHANGED(lBlockModification);
      }
#if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
      {
        if (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetFirstFailedCycleCount(lEntry))
        {
          Dem_Mem_EntrySetFirstFailedCycleCount(lEntry, Dem_Mem_CycleGetCounter(Dem_Cfg_EventOperationCycle(EventId)));          /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
          lBlockModification = DEM_DATA_SET_STATISTICS_CHANGED(lBlockModification);
        }
      }
#endif
#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
      {
        Dem_Mem_EntrySetDebounceValueMax(lEntry, (sint16)0x7F);                                                                  /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
        lBlockModification = DEM_DATA_SET_STATISTICS_CHANGED(lBlockModification);
      }
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
      lBlockModification |= Dem_Data_EntryUpdate_UserERecs(EventId, lEntry);                                                     /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
#endif
    } /* TEST PASSED->FAILED */

    /* On a TestFailedThisCycle trigger */
#if ( (DEM_CFG_DATA_FAILED_CYCLES == STD_ON) \
   || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON) \
   || (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON) )
    if (0 != (UpdateFlags & DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE))
    {
# if (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
      {
        uint8 lCycleCount;

        lCycleCount = Dem_Mem_EntryGetFailedCycleCount(lEntry);
        if (lCycleCount < 0xffU)
        {
          lCycleCount = (uint8)(lCycleCount + 1);
          Dem_Mem_EntrySetFailedCycleCount(lEntry, lCycleCount);                                                                 /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
          lBlockModification = DEM_DATA_SET_STATISTICS_CHANGED(lBlockModification);
        }
      }
# endif
# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
      {
        uint8 lCycleCount;

        lCycleCount = Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry);
        if (lCycleCount < 0xffU)
        {
          lCycleCount = (uint8)(lCycleCount + 1);
          Dem_Mem_EntrySetConsecutiveFailedCycleCount(lEntry, lCycleCount);                                                      /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
          lBlockModification = DEM_DATA_SET_STATISTICS_CHANGED(lBlockModification);
        }
      }
# endif
# if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
      {
        Dem_Mem_EntrySetLastFailedCycleCount(lEntry, Dem_Mem_CycleGetCounter(Dem_Cfg_EventOperationCycle(EventId)));             /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
        lBlockModification = DEM_DATA_SET_STATISTICS_CHANGED(lBlockModification);
      }
# endif

    }
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
    if (0 != (UpdateFlags & DEM_CFG_TRIGGER_TESTFAILED))
# endif
    {
      lBlockModification |= Dem_Data_EntryUpdate_SRecs(EventId, lEntry, UpdateFlags);                                            /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
    }
#endif /* #if (DEM_CFG_SUPPORT_SRECS == STD_ON) */

    Dem_Mem_MemoryUpdateFinish(MemoryIndex);
  } /* if (DEM_MEM_INVALID_MEMORY_INDEX != MemoryIndex) */

  /* In rare cases this function does nothing */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */

  return lBlockModification;
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Data_CalculateFDC_CounterBased
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_CalculateFDC_CounterBased(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(sint16, AUTOMATIC)  DebounceValue
  )
{
  sint8 lReturnedFdc;

  if (DebounceValue == 0)
  {
    lReturnedFdc = 0;
  }
  else
  {
    sint16 lFailedTarget = Dem_Cfg_EventFailedTarget(EventId);
    sint16 lPassedTarget = Dem_Cfg_EventPassedTarget(EventId);

    if (lFailedTarget == DebounceValue)
    {
      lReturnedFdc = 127;
    }
    else
    if (lPassedTarget == DebounceValue)
    {
      lReturnedFdc = -128;
    }
    else
    { /* current debounce counter value is somewhere in range of passed threshold and failed threshold but not 0 */
      if (DebounceValue > 0)
      {
        lReturnedFdc = (sint8)(((sint32)DebounceValue * 127) / lFailedTarget);
        /* result has to be greater than 0 */
        if (lReturnedFdc == 0)
        {
          lReturnedFdc = 1;
        }
      }
      else
      {
        lReturnedFdc = (sint8)(((sint32)DebounceValue * -128)  / lPassedTarget);
        /* result has to be smaller than 0 */
        if (lReturnedFdc == 0)
        {
          lReturnedFdc = -1;
        }
      }
    }
  }

  return lReturnedFdc;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Data_CalculateFDC_TimeBased
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_CalculateFDC_TimeBased(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(sint16, AUTOMATIC)  DebounceValue,
  CONST(uint8, AUTOMATIC)  DebounceStatus
  )
{
  sint8 lReturnedFdc;

  switch (DebounceStatus)
  {
  case DEM_ESM_DEBOUNCE_STATUS_NONE:
    lReturnedFdc = 0;
    break;
  case DEM_ESM_DEBOUNCE_DONE_FAILED:
    lReturnedFdc = 127;
    break;
  case DEM_ESM_DEBOUNCE_DONE_PASSED:
    lReturnedFdc = -128;
    break;
  case DEM_ESM_DEBOUNCE_COUNT_FAILED:
  case DEM_ESM_DEBOUNCE_FREEZE_FAILED:
  case DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC:
  case DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC:
    {
      sint16 lQualifyTarget;
      lQualifyTarget = Dem_Cfg_EventFailedTime(EventId);
      lReturnedFdc = (sint8)((sint32)((sint32)(lQualifyTarget - DebounceValue) * 127) / lQualifyTarget);

      /* Already counting, assert an FDC of at least 1 */
      if (lReturnedFdc == 0)
      {
        lReturnedFdc = 1;
      }
    }
    break;
  case DEM_ESM_DEBOUNCE_RESET_FAILED:
    lReturnedFdc = 1;
    break;

  case DEM_ESM_DEBOUNCE_COUNT_PASSED:
  case DEM_ESM_DEBOUNCE_FREEZE_PASSED:
    {
      sint16 lQualifyTarget;
      lQualifyTarget = Dem_Cfg_EventPassedTime(EventId);
      lReturnedFdc = (sint8)((sint32)((sint32)(lQualifyTarget - DebounceValue) * -128) / lQualifyTarget);

      /* Already counting, assert an FDC of at most -1 */
      if (lReturnedFdc == 0)
      {
        lReturnedFdc = -1;
      }
    }
    break;
  case DEM_ESM_DEBOUNCE_RESET_PASSED:
    lReturnedFdc = -1;
    break;

  default:
    Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_INCONSISTENT_STATE)
    lReturnedFdc = 0;
    break;
  }

  return lReturnedFdc;
}
#endif /* (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) */

#if ((DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)) \
 || ((DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON))
/* ****************************************************************************
 % Dem_Data_EventGetFDCMax
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_EventGetFDCMax(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  sint8 lFaultDetectionCounter;

  /* Optimization: Don't call the calculation methods if we know the event has already failed this cycle */
  if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFTOC(Dem_Mem_EventGetStatus(EventId)))
  {
    lFaultDetectionCounter = 127U;
  }
  else
  {
    switch (Dem_Cfg_EventDebounceType(EventId))
    {
#  if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
    case DEM_CFG_DEBOUNCETYPE_COUNTER:
      lFaultDetectionCounter = Dem_Data_CalculateFDC_CounterBased(EventId,
                                                                    Dem_Mem_EventGetDebounceValueMax(EventId));
      break;
#  endif  /* (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON) */
#  if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
    case DEM_CFG_DEBOUNCETYPE_TIMER:
      if (Dem_Mem_EventGetDebounceValueMax(EventId) != Dem_Cfg_EventFailedTime(EventId))
      {
        lFaultDetectionCounter = Dem_Data_CalculateFDC_TimeBased(EventId,
                                                                 Dem_Mem_EventGetDebounceValueMax(EventId),
                                                                 DEM_ESM_DEBOUNCE_COUNT_FAILED);
      }
      else
      { /* Delay Max FDC until the timer has ticked once. */
        lFaultDetectionCounter = 0;
      }
      break;
#  endif /* (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) */
#  if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
    case DEM_CFG_DEBOUNCETYPE_EXTERNAL:
      lFaultDetectionCounter = 0U;
      break;
#  endif
    default:
      /* unreachable MISRA case */
      lFaultDetectionCounter = 0;
      break;
    }
  }
  return lFaultDetectionCounter;
}
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_ERecIsStored
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_ERecIsStored(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  ERecStoredIndex
  )
{
  uint8 lMask;
  lMask = ((uint8)(1u << ERecStoredIndex));

  return (boolean)((0 != (MemoryEntry->ExtendedHeader & lMask))?(TRUE):(FALSE));
}
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_SRecCount
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_SRecCount(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry
  )
{
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
  /* If calculated records are used, the snapshot header corresponds to the snapshot count */
  return MemoryEntry->SnapshotHeader;
# endif
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  /* If configured records are used, count the number of bits set in the snapshot header */
  uint8 lReturnValue = 0;
  uint8 lSnapshotHeader = MemoryEntry->SnapshotHeader;
  while (0 != lSnapshotHeader)
  {
    lReturnValue = (uint8)(lReturnValue + (lSnapshotHeader & 0x01U));
    lSnapshotHeader = (uint8)(lSnapshotHeader >> 0x01U);
  }
  return lReturnValue;
# endif
}
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_SRecIsStored
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_SRecIsStored(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint8, AUTOMATIC)  SRecStoredIndex
  )
{
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
  return (boolean)((MemoryEntry->SnapshotHeader > SRecStoredIndex)?(TRUE):(FALSE));
# endif
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  uint8 lMask;
  lMask = ((uint8)(1u << SRecStoredIndex));

  return (boolean)((0 != (MemoryEntry->SnapshotHeader & lMask))?(TRUE):(FALSE));
# endif
}
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if ( (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
/* ****************************************************************************
 % Dem_Data_SkipDid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_SkipDid(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DidIndexType, AUTOMATIC)  DidIndex
  )
{
  Dem_Cfg_DidDataIterType lDataIter;

  /* #010 Iterate all data elements in the DID */
  for (Dem_Cfg_DidDataIterInit(DidIndex, &lDataIter);                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_DidDataIterExists(&lDataIter) == TRUE;                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_DidDataIterNext(&lDataIter))                                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_DataIndexType lDataIndex;
    lDataIndex = Dem_Cfg_DidDataIterGet(&lDataIter);                                                                             /* SBSW_DEM_CALL_ITERATOR_POINTER */

    switch (Dem_Cfg_DataCallbackType(lDataIndex))
    {
    case DEM_CFG_DATA_FROM_ROOTCAUSE_EVENTID:
    case DEM_CFG_DATA_FROM_CBK_STORED:
    case DEM_CFG_DATA_FROM_CBK_STORED_WITH_EVENTID:
      Dem_Internal_AssertReturnVoid(CopyDidInfoPtr->SourceBuffer != NULL_PTR, DEM_E_INCONSISTENT_STATE)
      CopyDidInfoPtr->ReadIndex += Dem_Cfg_DataSize(lDataIndex);                                                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      break;

    default:
      break;
    }
  }
}
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_CFG_SUPPORT_OBDII == STD_ON) || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && ((DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON))
/* ****************************************************************************
 % Dem_Data_SRecCopyData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_SRecCopyData(
  CONST(Dem_SharedDataPtrType, AUTOMATIC)  DestBuffer,
  CONST(Dem_ConstSharedDataPtrType, AUTOMATIC)  SourceBuffer,
  CONST(uint16, AUTOMATIC)  BufferSize,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  if (BufferSize > 0)
  {
    uint16 lDidCount;
    Dem_Cfg_EventDidIterType lDidIter;
    Dem_Data_CopyDidInfoType lCopyDidInfo;

    /* Initialize a CopyDid Context. */
    lCopyDidInfo.DestinationBuffer = DestBuffer;
    lCopyDidInfo.BufferSize        = BufferSize;
    lCopyDidInfo.WriteIndex        = 1;
    lCopyDidInfo.SourceBuffer      = SourceBuffer;
    lCopyDidInfo.ReadIndex         = 0;
    lCopyDidInfo.Entry             = &Dem_Cfg_ReadoutBuffer;
    lCopyDidInfo.EventId           = Dem_Cfg_ReadoutBuffer.EventId;

    /* Initialize number of DIDs */
    lDidCount = 0;
    for (Dem_Cfg_EventDidIterInit(EventId, &lDidIter);                                                                           /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventDidIterExists(&lDidIter) == TRUE;                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventDidIterNext(&lDidIter))                                                                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      if (lCopyDidInfo.BufferSize > (lCopyDidInfo.WriteIndex + DEM_DATA_ADDITIONAL_BYTES_PER_DID))
      {
        Dem_Cfg_DidIndexType lDidIndex;
        lDidIndex = Dem_Cfg_EventDidIterGet(&lDidIter);                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */

        ++lDidCount;

        lCopyDidInfo.DestinationBuffer[lCopyDidInfo.WriteIndex + 0] = Dem_GetHiByte(Dem_Cfg_DidNumber(lDidIndex));               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
        lCopyDidInfo.DestinationBuffer[lCopyDidInfo.WriteIndex + 1] = Dem_GetLoByte(Dem_Cfg_DidNumber(lDidIndex));               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
        lCopyDidInfo.WriteIndex += DEM_DATA_ADDITIONAL_BYTES_PER_DID;

        {
          (void)Dem_Data_CopyDid(&lCopyDidInfo, lDidIndex);                                                                      /* SBSW_DEM_POINTER_LOCAL_COPYDIDINFO */
        }
      }
    }

    /* Set the DID count to 0 in case of more than 255 DIDs. */
    if (lDidCount > 255)
    {
      lCopyDidInfo.DestinationBuffer[0] = 0;                                                                                     /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    }
    else
    {
      lCopyDidInfo.DestinationBuffer[0] = Dem_GetLoByte(lDidCount);                                                              /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    }
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_FEATURE_NEED_CYCLE_COUNTERS == STD_ON)
/* ****************************************************************************
 % Dem_Data_EntryOpCycleStart
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryOpCycleStart(
  CONST(Dem_Mem_EntryPtrType, AUTOMATIC)  MemoryEntry,
  CONST(uint16, AUTOMATIC)  CycleCount
  )
{
  boolean lReturnValue;
  lReturnValue = FALSE;

# if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
  if ( (DEM_ESM_CYCLECOUNT_MAX > Dem_Mem_EntryGetFirstFailedCycleCount(MemoryEntry))                                             /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && (Dem_Esm_CycleCountDistance(Dem_Mem_EntryGetFirstFailedCycleCount(MemoryEntry), CycleCount) >= 0xffU) )
  {
    Dem_Mem_EntrySetFirstFailedCycleCount(MemoryEntry, DEM_ESM_CYCLECOUNT_LATCHED);                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    lReturnValue = TRUE;
  }
# endif
# if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
  if ( (DEM_ESM_CYCLECOUNT_MAX > Dem_Mem_EntryGetLastFailedCycleCount(MemoryEntry))                                              /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && (Dem_Esm_CycleCountDistance(Dem_Mem_EntryGetLastFailedCycleCount(MemoryEntry), CycleCount) >= 0xffU) )
  {
    Dem_Mem_EntrySetLastFailedCycleCount(MemoryEntry, DEM_ESM_CYCLECOUNT_LATCHED);                                               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    lReturnValue = TRUE;
  }
# endif
  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_ENTRY_CYCLE_COUNTERS == STD_ON) */

#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 % Dem_Data_DtcOpCycleUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_DtcOpCycleUpdate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  DtcStatus,
  CONST(uint8, AUTOMATIC)  CycleStatus
  )
{
  if ( (0 != (CycleStatus & DEM_QUEUE_CYCLE_STOPPED))                                                                            /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(DtcStatus))
    && (DEM_ESM_STORED_STATUS_NONE != Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(EventId))) )
  {
    Dem_Mem_MemoryInfoPtrType lMemoryInfo;
    Dem_Cfg_MemoryIndexType lMemoryIndex;
    Dem_Mem_EntryPtrType lEntry;

    lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
    lMemoryIndex = Dem_Mem_MemoryFindIndex_Checked(lMemoryInfo, EventId);                                                        /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
    lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);

# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
    if (DEM_ESM_TEST_UDS_STATUS_TFTOC(DtcStatus) == FALSE)
    { /* reset the 'consecutive failed cycles' */
      Dem_Mem_EntrySetConsecutiveFailedCycleCount(lEntry, 0);                                                                    /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
    }
# endif

# if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
#  if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFSLC(DtcStatus))
#  endif
    {
      if (Dem_Mem_EntryGetTestedSinceFirstFailedCycleCount(lEntry) < 255)
      {
        Dem_Mem_EntrySetTestedSinceFirstFailedCycleCount(lEntry, (uint8)(Dem_Mem_EntryGetTestedSinceFirstFailedCycleCount(lEntry) + 1));  /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
      }
    }
# endif
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Data_PrestorageEntryUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_PrestorageEntryUpdate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(Dem_Mem_PrestoredEntryPtrType, AUTOMATIC)  PrestoredEntry                                                                /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_False */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(PrestoredEntry)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)
  /* Sample a UDS snapshot into the prestorage buffer */
  Dem_Data_CollectSnapshot(EventId,                                                                                              /* SBSW_DEM_PRESTORED_SNAPSHOT */
                           Dem_Mem_PrestoredEntryGetSRecDataPtr(PrestoredEntry),
                           Dem_Cfg_GlobalSRecMaxRawSize());
# endif

}
#endif

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Mem_Init_RestoreMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_Init_RestoreMemory(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{ /* No reinitialization - restore primary stack */
  Dem_Cfg_MemoryIndexType lMemoryIndex;

  Dem_Mem_MemorySetCurrentSize(MemoryInfo, 0);                                                                                   /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

  /* Iterate through all memory entries. The iteration order must be identical to Dem_Mem_MemoryEntryFind. */
  for (lMemoryIndex = Dem_Mem_MemoryIter_Begin(MemoryInfo);                                                                      /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
       lMemoryIndex < Dem_Mem_MemoryIter_End(MemoryInfo);                                                                        /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
       ++lMemoryIndex)
  {
    CONST(Dem_Mem_EntryPtrType, AUTOMATIC) lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);
    Dem_EventIdType lEventId;

    lEventId = Dem_Mem_EntryGetEventId(lEntry);
    if (lEventId != DEM_EVENT_INVALID)
    {
      uint32 lTimestamp;
      uint8 lSortedIndex;
      Dem_Cfg_EventInternalStatusType lInternalStatus;

      if ( (lEventId >= Dem_Cfg_GlobalEventCount())                                                                              /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        || (Dem_Cfg_EventDestination(lEventId) != Dem_Mem_MemoryGetId(MemoryInfo))                                               /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
        || (Dem_Util_DtcGetMasterEvent(lEventId) != lEventId)
#endif
        )
      {
        /* The memory entry is not allocated to the master event. Remove it. */
        Dem_Mem_EntrySetEventId(lEntry, DEM_EVENT_INVALID);                                                                      /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
        Dem_Mem_EntrySetTimestamp(lEntry, 0U);                                                                                   /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
        Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);

        /* DET: To get this inconsistency, it requires a configuration change without clearing the NV contents */
        Dem_Det_ReportError(DEM_INIT_APIID, DEM_E_INCONSISTENT_STATE)
        continue;                                                                                                                /* PRQA S 0770 */ /* MD_DEM_14.5 */                                                                                                              /* PRQA S 0770 */ /* MD_DEM_14.5 */
      }

      lInternalStatus = Dem_Util_DtcGetInternalStatus(lEventId);
      lTimestamp = Dem_Mem_EntryGetTimestamp(lEntry);

      if (Dem_Mem_GetStoredStatus(lInternalStatus) != DEM_ESM_STORED_STATUS_NONE)
      { /* Runtime error, no DET. This can happen due to NV errors */
        uint8 lOtherIndex;

        /* Dem_Mem_MemoryFindIndex will always succeed since we are processing a duplicate */
        lOtherIndex = Dem_Mem_MemoryFindIndex_Checked(MemoryInfo, lEventId);                                                     /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

        /* Clear the older entry */
        if (Dem_Mem_EntryGetTimestamp(Dem_Mem_MemoryGetEntry(lOtherIndex)) < lTimestamp)
        {
          Dem_Mem_MemoryFreeIndex(MemoryInfo, lOtherIndex);                                                                      /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
          Dem_Mem_MemorySetBlockState(lOtherIndex, DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
        }
        else
        {
          Dem_Mem_EntrySetEventId(lEntry, DEM_EVENT_INVALID);                                                                    /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
          Dem_Mem_EntrySetTimestamp(lEntry, 0U);                                                                                 /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
          Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
          continue;                                                                                                              /* PRQA S 0770 */ /* MD_DEM_14.5 */
        }
      }

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID == Dem_Cfg_EventCombinedGroup(lEventId))
#endif
      {
        uint8 lEventStatus;
        lEventStatus = Dem_Mem_EventGetStatus(lEventId);

#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
        if (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(lEntry))
        {
          /* The DTC has already aged. Unless storage happens at ConfirmedDTC, make sure TF and WIR are not set */
# if (DEM_CFG_STORAGE_AT_CONFIRMED != STD_ON)
          lEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lEventStatus);
          lEventStatus = DEM_ESM_RESET_UDS_STATUS_WIR(lEventStatus);
# endif
        }
        else
#endif
        {
#if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > 0)
          {
            /* The last n cycles had TFTOC set -> Make sure PDTC and TFSLC are set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lEventStatus);
            lEventStatus = DEM_ESM_SET_UDS_STATUS_PDTC(lEventStatus);
          }
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > Dem_Cfg_EventTripTarget(lEventId))
          {
            /* With the trip target exceeded, make sure CDTC is set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(lEventStatus);
          }
# elif ((DEM_CFG_DATA_OCCCTR == STD_ON) || (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON))
          if (Dem_Mem_EntryGetOccurrenceCount(lEntry) > 0)
          {
            /* We know about some TF 0->1 transitions -> make sure TFSLC is set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lEventStatus);
          }
# endif
#elif (DEM_CFG_STORAGE_AT_CONFIRMED == STD_ON)
          /* Since DTCs are stored only on confirmed #220 Make sure CDTC and TFSLC are set */
          lEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lEventStatus);
          lEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(lEventStatus);
# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > 0)
          {
            /* If there are consecutive failed cycles > 0 make sure PDTC is set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_PDTC(lEventStatus);
          }
# endif
#else
          /* Make sure TFSCL is set */
          lEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lEventStatus);
# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > 0)
          { /* Make sure PDTC is set when the last cycle(s) were failed */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_PDTC(lEventStatus);
          }
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > Dem_Cfg_EventTripTarget(lEventId))
          {
            lEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(lEventStatus);
          }
# else
          if (Dem_Cfg_EventTripTarget(lEventId) == 0)
          {
            lEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(lEventStatus);
          }
# endif
#endif
        }
        Dem_Mem_EventSetStatus(lEventId, lEventStatus);
      }

      /* If the memory entry is currently aging, mark the event as AGING */
      if ( (DEM_ESM_CYCLECOUNT_MAX >= Dem_Mem_EntryGetAgingCount(lEntry))
        || (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetAgingCount(lEntry)) )
      {
        lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_AGING);
      }
      else
#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
      /* If aging keeps memory entries intact and the entry is aged, mark the event as AGED */
      if (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(lEntry))
      {
        lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_AGED);
      }
      else
#endif
      {
        lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_ACTIVE);
      }

      Dem_Util_DtcSetInternalStatus(lEventId, lInternalStatus);

      /* Synchronize the global timestamp with the timestamp stored in the memory entry */
      if (lTimestamp > Dem_Mem_CurrentTimestamp)
      {
        Dem_Mem_CurrentTimestamp = lTimestamp;
      }

      /* Sort the memory entry into the chronological list */
      lSortedIndex = Dem_Mem_MemoryGetCurrentSize(MemoryInfo);                                                                   /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      while ( (lSortedIndex > 0)
           && (Dem_Mem_EntryGetTimestamp(Dem_Mem_MemoryGetEntry(Dem_Mem_MemoryGetChronology(MemoryInfo, lSortedIndex-1))) > lTimestamp) )  /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      {
        Dem_Mem_MemorySetChronology(MemoryInfo, lSortedIndex, Dem_Mem_MemoryGetChronology(MemoryInfo, lSortedIndex-1));          /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
        --lSortedIndex;
      }

      Dem_Mem_MemorySetChronology(MemoryInfo, lSortedIndex, lMemoryIndex);                                                       /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

      /* Update the number of occupied memory entries */
      Dem_Mem_MemorySetCurrentSize(MemoryInfo, (uint8)(Dem_Mem_MemoryGetCurrentSize(MemoryInfo) + 1));                           /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    }
  }
  /* Update the global timestamp */
  ++Dem_Mem_CurrentTimestamp;
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_Mem_GetCycleStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetCycleStatus(
  CONST(uint8, AUTOMATIC)  CycleId
  )
{
  return (uint8)(((Dem_Mem_CurrentCycleState & (uint16)(1U << (CycleId))) != 0)
    ? DEM_QUEUE_CYCLE_STARTED
    : DEM_QUEUE_CYCLE_STOPPED);
}

/* ****************************************************************************
 % Dem_Mem_SetCycleStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetCycleStatus(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint8, AUTOMATIC)  Status
  )
{
  uint16 lMask;

  lMask = (uint16)(1U << CycleId);
  if (DEM_QUEUE_CYCLE_STOPPED == Status)
  {
    lMask = (uint16)~lMask;
    Dem_Mem_CurrentCycleState = (uint16)(Dem_Mem_CurrentCycleState & lMask);
  }
  else
  {
    Dem_Mem_CurrentCycleState = (uint16)(Dem_Mem_CurrentCycleState | lMask);
  }
}

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetOverflow
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_GetOverflow(
  CONST(uint8, AUTOMATIC)  MemoryId
  )
{
  boolean lReturnValue;

  if ((Dem_Mem_GetMemoryOverflow() & (1U << MemoryId)) != 0)
  {
    lReturnValue = TRUE;
  }
  else
  {
    lReturnValue = FALSE;
  }

  return lReturnValue;
}
#endif

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetOverflow
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetOverflow(
  CONST(uint8, AUTOMATIC)  MemoryId
  )
{
  uint8 lOldOverflow;
  uint8 lNewOverflow;

  lOldOverflow = Dem_Mem_GetMemoryOverflow();
  lNewOverflow = (uint8)(lOldOverflow | ((uint8)(1U << MemoryId)));
  if (lOldOverflow != lNewOverflow)
  {
    Dem_Mem_SetMemoryOverflow(lNewOverflow);
  }
}
#endif

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 % Dem_Mem_ResetOverflow
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_ResetOverflow(
  CONST(uint8, AUTOMATIC)  MemoryId
  )
{
  uint8 lOldOverflow;
  uint8 lNewOverflow;

  lOldOverflow = Dem_Mem_GetMemoryOverflow();
  lNewOverflow = (uint8)(lOldOverflow & ((uint8)~((uint8)(1U << MemoryId))));
  if (lOldOverflow != lNewOverflow)
  {
    Dem_Mem_SetMemoryOverflow(lNewOverflow);
  }
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Mem_CopyDataDebounceNv
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CopyDataDebounceNv(
  void
  )
{
  Dem_EventIdType lEventId;
  Dem_EventIdType lDebounceNvIndex;

  lDebounceNvIndex = Dem_Cfg_GlobalDebounceStorageEventCount();
  lEventId = Dem_Cfg_GlobalEventCount();

  Dem_Internal_AssertReturnVoid(lEventId >= lDebounceNvIndex, DEM_E_PARAM_CONFIG)

  while (lDebounceNvIndex != 0U)
  {
    Dem_Internal_AssertReturnVoid(lEventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE)

    --lEventId;

    if (FALSE != Dem_Cfg_EventSupportDebounceNv(lEventId))
    {
      --lDebounceNvIndex;
      Dem_Mem_DebounceSetStoredValue(lDebounceNvIndex, Dem_Mem_EventGetDebounceValue(lEventId));
    }
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageInit(
  void
  )
{
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;
  for (lPrestorageIndex = 0; lPrestorageIndex < Dem_Cfg_GlobalPrestorageMaxCount(); ++lPrestorageIndex)
  { /* Chain the blocks */
    Dem_Mem_PrestoredEntrySetNext(Dem_Mem_PrestorageGetEntry(lPrestorageIndex), lPrestorageIndex + 1);                           /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
  }
  /* Last block points to end, head points to first block */
  Dem_Mem_PrestoredEntrySetNext(Dem_Mem_PrestorageGetEntry(Dem_Cfg_GlobalPrestorageMaxCount() - 1), DEM_MEM_INVALID_PRESTORAGE_INDEX);  /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
  Dem_Mem_PrestorageHeadIndex = 0;

  Dem_MemSet(Dem_Cfg_PrestorageIndex, DEM_MEM_INVALID_PRESTORAGE_INDEX, Dem_Cfg_GlobalPrestorageEventCount()*sizeof(Dem_Cfg_PrestorageIndexType));  /* PRQA S 0312, 0602, 3109 */ /* MD_DEM_11.5, MD_DEM_20.2, MD_MSR_14.3 */ /* SBSW_DEM_MEMSET_PRESTORAGEINDEX */
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageFindEntry
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageFindEntry(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Internal_AssertReturnValue(DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId), DEM_E_PARAM_DATA, DEM_MEM_INVALID_PRESTORAGE_INDEX)
  return Dem_Mem_PrestorageGetRef(EventId);
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageAllocateEntry
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageAllocateEntry(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;
  Dem_Internal_AssertReturnValue(DEM_MEM_INVALID_PRESTORAGE_INDEX == Dem_Mem_PrestorageFindEntry(EventId), DEM_E_PARAM_DATA, DEM_MEM_INVALID_PRESTORAGE_INDEX)

  lPrestorageIndex = Dem_Mem_PrestorageHeadIndex;
  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
  {
    Dem_Mem_PrestorageHeadIndex = Dem_Mem_PrestoredEntryGetNext(Dem_Mem_PrestorageGetEntry(lPrestorageIndex));
    Dem_Mem_PrestorageSetRef(
      EventId,
      lPrestorageIndex
    );
    Dem_Mem_PrestoredEntrySetEventId(Dem_Mem_PrestorageGetEntry(lPrestorageIndex), EventId);                                     /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
  }

  return lPrestorageIndex;
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageFreeEntry
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageFreeEntry(
  CONST(Dem_Cfg_PrestorageIndexType, AUTOMATIC)  PrestorageIndex
  )
{
  Dem_Internal_AssertReturnVoid(DEM_MEM_INVALID_PRESTORAGE_INDEX != PrestorageIndex, DEM_E_PARAM_DATA)

  Dem_Mem_PrestorageSetRef(
    Dem_Mem_PrestoredEntryGetEventId(Dem_Mem_PrestorageGetEntry(PrestorageIndex)),
    DEM_MEM_INVALID_PRESTORAGE_INDEX
  );

  Dem_Mem_PrestoredEntrySetNext(Dem_Mem_PrestorageGetEntry(PrestorageIndex), Dem_Mem_PrestorageHeadIndex);                       /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
  Dem_Mem_PrestorageHeadIndex = PrestorageIndex;
}
#endif

/* ****************************************************************************
 % Dem_Mem_MemoryUpdateIndex
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  MemoryIndex
  )
{
  uint8 lChronoIterator;
  uint8 lTempIndex;

  /* Store the global timestamp to the entry, and update it */
  Dem_Mem_EntrySetTimestamp(Dem_Mem_MemoryGetEntry(MemoryIndex), Dem_Mem_CurrentTimestamp);                                      /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
  ++Dem_Mem_CurrentTimestamp;

  /* move downwards the chronology moving all entries, until the updated element is overwritten */
  lChronoIterator = (uint8)(Dem_Mem_MemoryGetCurrentSize(MemoryInfo) - 1);                                                       /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  lTempIndex = Dem_Mem_MemoryGetChronology(MemoryInfo, lChronoIterator);                                                         /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  while (lTempIndex != MemoryIndex)
  {
    uint8 lSwap;

    lSwap = lTempIndex;
    --lChronoIterator;
    lTempIndex = Dem_Mem_MemoryGetChronology(MemoryInfo, lChronoIterator);                                                       /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    Dem_Mem_MemorySetChronology(MemoryInfo, lChronoIterator, lSwap);                                                             /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if ((lChronoIterator == 0) && (lTempIndex != MemoryIndex))
    {
      /* chronology is inconsistent */
      Dem_RunTimeCheckFailed(__LINE__);
      break;
    }
#endif
  }

  Dem_Mem_MemorySetChronology(MemoryInfo, (uint8)(Dem_Mem_MemoryGetCurrentSize(MemoryInfo) - 1), MemoryIndex);                   /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
}

/* ****************************************************************************
 % Dem_Mem_PreInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PreInit(
  void
  )
{
  Dem_MemSet((Dem_DataPtrType)Dem_Cfg_EventInternalStatus,                                                                       /* PRQA S 0310, 0312, 0602, 3109 */ /* MD_DEM_11.4_cpy, MD_DEM_11.5, MD_DEM_20.2, MD_MSR_14.3 */ /* SBSW_DEM_MEMSET_EVENTINTERNALSTATUS */
             DEM_ESM_STORED_STATUS_NONE,
             Dem_Cfg_GlobalEventCount()*sizeof(Dem_Cfg_EventInternalStatusType));
}

/* ****************************************************************************
 % Dem_Mem_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_Init(
  void
  )
{
  uint8 lResetStoredData;
  Dem_EventIdType lEventId;
#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
  Dem_EventIdType lDebounceNvIndex = 0;
#endif

  for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
  { /* Only reset stored status, since debouncing can have changed since pre-initalization */
    Dem_Mem_EventSetInternalStatus(lEventId,
      Dem_Mem_SetStoredStatus(Dem_Mem_EventGetInternalStatus(lEventId), DEM_ESM_STORED_STATUS_NONE));

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
    /* If NV storage of debounce values is configured, and the event uses that feature */
    /* Its safe to do it here since supporting events are not allowed to report before Dem_Init() */
    if (FALSE != Dem_Cfg_EventSupportDebounceNv(lEventId))
    {
      sint16 lDebounceValue;

      Dem_Internal_AssertReturnVoid(lDebounceNvIndex < Dem_Cfg_GlobalDebounceStorageEventCount(), DEM_E_INCONSISTENT_STATE)

      lDebounceValue = Dem_Mem_DebounceGetStoredValue(lDebounceNvIndex);
      if ( /* Unqualified debounce state is ok */
           ( (Dem_Cfg_EventFailedTarget(lEventId) > lDebounceValue)                                                              /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          && (Dem_Cfg_EventPassedTarget(lEventId) < lDebounceValue) )
           /* If debouncing counter has reached qualified threshold, the event status must match */
        || ( (Dem_Cfg_EventFailedTarget(lEventId) == lDebounceValue)
          && (FALSE != DEM_ESM_TEST_UDS_STATUS_TF(Dem_Mem_EventGetStatus(lEventId))) )
        || ( (Dem_Cfg_EventPassedTarget(lEventId) == lDebounceValue)
          && (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(Dem_Mem_EventGetStatus(lEventId))) ) )
      {
        /* Validate the NV debounce value. Discard out of range values, and restore a valid value into working RAM */
        /* implausible data e.g. due to debouncing thresholds changed by calibration */
        Dem_Mem_EventSetDebounceValue(lEventId, lDebounceValue);
      }
      ++lDebounceNvIndex;
    }
#endif
  }

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  {
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    for (lGroupId = 0; lGroupId < Dem_Cfg_GlobalCombinedGroupCount(); ++lGroupId)
    {
      Dem_Cfg_EventInternalStatusType lInternalStatus;
      Dem_Cfg_CombinedGroupIterType lSubEventIter;

      /* Initialize the combination group internal status */
      lInternalStatus = DEM_ESM_STORED_STATUS_NONE;

      /* For all combination groups, test if at least one sub-events is available by configuration.
         Initialization in PreInit and Init can have different settings for
         event availability, so repeat the calculation for combined DTCs */
      for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lSubEventIter);                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
           Dem_Cfg_CombinedGroupIterExists(&lSubEventIter) == TRUE;                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
           Dem_Cfg_CombinedGroupIterNext(&lSubEventIter))                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
      {
        if (Dem_Cfg_EventAvailableByVariant(Dem_Cfg_CombinedGroupIterGet(&lSubEventIter)) == TRUE)                               /* SBSW_DEM_CALL_ITERATOR_POINTER */
        { /* If so, set the availability in the combination status. */
          lInternalStatus = Dem_Mem_SetAvailableInVariantStatus(lInternalStatus);
          break;
        }
      }
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lInternalStatus);
    }
  }
#endif
  /* Initialize transactional update commit numbers */
  Dem_MemSet(Dem_Cfg_MemoryCommitNumber, DEM_MEM_INIT_COMMIT_NUMBER, Dem_Cfg_GlobalNvBlockCount()*sizeof(uint8));                /* PRQA S 0312, 0602, 3109 */ /* MD_DEM_11.5, MD_DEM_20.2, MD_MSR_14.3 */ /* SBSW_DEM_MEMSET_MEMORYCOMMITNUMBER */

  lResetStoredData = (uint8)( (Dem_Cfg_AdminData.ImplementationVersion != Dem_Make16Bit(DEM_SW_MAJOR_VERSION, DEM_SW_MINOR_VERSION))  /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
                           || (Dem_Cfg_AdminData.ConfigurationId != Dem_Cfg_GlobalConfigurationId()) );

  if (lResetStoredData != FALSE)
  {
    /* If the NV data is not compatible to the configuration */
    /* Re-initialize all NV data content and reset the global time stamp */
    Dem_Cfg_MemoryIndexType lMemoryIndex;
    Dem_Cfg_MemoryIndexType lMemoryIndexEnd;

    Dem_MemSet(Dem_Cfg_MemoryStatus, DEM_NVM_BLOCKSTATE_DIRTY, Dem_Cfg_GlobalNvBlockCount()*sizeof(uint8));                      /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */ /* SBSW_DEM_MEMSET_MEMORYSTATUS */

    (void)Dem_NvM_InitAdminData();
    (void)Dem_NvM_InitStatusData();
#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
    (void)Dem_NvM_InitDebounceData();
#endif

    Dem_Mem_CurrentTimestamp = 1U;
    Dem_Mem_PrimaryCurrentCount = 0U;

#if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
    Dem_Mem_SecondaryCurrentCount = 0U;
#endif
    lMemoryIndexEnd = Dem_Mem_MemoryIndexAll_End();
    for (lMemoryIndex = Dem_Mem_MemoryIndexAll_Begin(); lMemoryIndex < lMemoryIndexEnd; ++lMemoryIndex)
    {
      Dem_Mem_EntryPtrType lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);
      Dem_MemCpy((Dem_NvDataPtrType)lEntry,                                                                                      /* PRQA S 0310, 0311, 0602 */ /* MD_DEM_11.4_cpy, MD_DEM_11.5, MD_DEM_20.2 */ /* SBSW_DEM_POINTER_MEMCPY_MEMORYENTRY */
                 (Dem_ConstDataPtrType)(&Dem_Cfg_MemoryEntryInit),                                                               /* PRQA S 0311 */ /* MD_DEM_11.5 */
                 sizeof(*lEntry));
      Dem_Mem_MemoryUpdateInit(lMemoryIndex);
    }
  }
  /* Otherwise */
  else
  {
    Dem_Mem_CurrentTimestamp = 0U;

    /* Rebuild the event memory control data from NV data contents */
    Dem_Mem_Init_RestoreMemory(Dem_Mem_MemoryInfoInit(DEM_CFG_MEMORYID_PRIMARY));                                                /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
    Dem_Mem_Init_RestoreMemory(Dem_Mem_MemoryInfoInit(DEM_CFG_MEMORYID_SECONDARY));                                              /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
# endif

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_ON)
    /* If operation cycle states are stored in NV, restore them */
    Dem_Mem_CurrentCycleState = Dem_Cfg_AdminData.CycleState;
#endif
  }
#if (DEM_CFG_SUPPORT_INDICATORS == STD_ON)
  {
    /* If indicators are configured, initialize all indicator state counters */
    uint8 lIndicatorId;
    for (lIndicatorId = 0; lIndicatorId < Dem_Cfg_GlobalIndicatorCount(); ++lIndicatorId)
    {
      {
        Dem_Mem_IndicatorSetEventCountContinuous(lIndicatorId, DEM_J1939_NODE_ID, 0);
        Dem_Mem_IndicatorSetEventCountBlinking(lIndicatorId, DEM_J1939_NODE_ID, 0);
      }
    }
  }
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  /* If prestore freeze frame is enabled, initialize freeze frame prestorage */
  Dem_Mem_PrestorageInit();
#endif

}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Esm_DebounceInfoInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_DebounceInfoInit(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONSTP2VAR(Dem_DebounceInfoType, AUTOMATIC, AUTOMATIC)  DebounceInfo
  )
{
  DebounceInfo->Common.EventId = EventId;                                                                                        /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Dem_Cfg_EventDebounceType(EventId) > DEM_ESM_DEBOUNCE_ALGORITHM_COUNT)
  {
    Dem_RunTimeCheckFailed(__LINE__);
    DebounceInfo->Common.FunctionTable = &Dem_Esm_DebounceFunctionTable[DEM_CFG_DEBOUNCETYPE_INVALID];                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  else
#endif
  {
    DebounceInfo->Common.FunctionTable = &Dem_Esm_DebounceFunctionTable[Dem_Cfg_EventDebounceType(EventId)];                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
}

/* ****************************************************************************
 % Dem_Esm_AddCycleCount
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Esm_AddCycleCount(
  CONST(uint16, AUTOMATIC)  CurrentCounter,
  CONST(uint8, AUTOMATIC)  DeltaValue
  )
{
  uint16 lTargetCycle;

  lTargetCycle = (uint16)(CurrentCounter + DeltaValue);

  if (lTargetCycle > DEM_ESM_CYCLECOUNT_MAX)
  { /* Overflow needs to wrap around at DEM_ESM_CYCLECOUNT_MAX */
    lTargetCycle = (uint16)(lTargetCycle - DEM_ESM_CYCLECOUNT_MAX);
  }

  return lTargetCycle;
}

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_PrestorageDiscard
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PrestorageDiscard(
  void
  )
{
  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != Dem_Esm_PrestorageLockedIndex)
  {
    Dem_Mem_PrestoredEntrySetState(Dem_Mem_PrestorageGetEntry(Dem_Esm_PrestorageLockedIndex), DEM_ESM_PRESTORED_STATUS_DISCARDED);  /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPrestorageLock
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPrestorageLock(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;

  if (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
  {
    lPrestorageIndex = Dem_Mem_PrestorageFindEntry(EventId);
    if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
    {
      Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;
      lPrestoredEntry = Dem_Mem_PrestorageGetEntry(lPrestorageIndex);
      if (DEM_ESM_PRESTORED_STATUS_READY == Dem_Mem_PrestoredEntryGetState(lPrestoredEntry))
      {
        Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_LOCKED);                                        /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
        Dem_Mem_PrestorageSetRef(EventId, DEM_MEM_INVALID_PRESTORAGE_INDEX);
        Dem_Esm_PrestorageLockedIndex = lPrestorageIndex;
      }
    }
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPrestorageRelease
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPrestorageRelease(
  void
  )
{
  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != Dem_Esm_PrestorageLockedIndex)
  {
    Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;
    Dem_EventIdType lEventId;

    lPrestoredEntry = Dem_Mem_PrestorageGetEntry(Dem_Esm_PrestorageLockedIndex);
    lEventId = lPrestoredEntry->EventId;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if (DEM_ESM_PRESTORED_STATUS_LOCKED == Dem_Mem_PrestoredEntryGetState(lPrestoredEntry))
    { /* Entry unused, return it to the event */
      Dem_Cfg_PrestorageIndexType lPrestorageIndex;
      lPrestorageIndex = Dem_Mem_PrestorageFindEntry(lEventId);
      if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
      { /* Event has created a new prestored slot since locking the old, so free the locked entry */
        Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_FREE);                                          /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
        Dem_Mem_PrestorageFreeEntry(Dem_Esm_PrestorageLockedIndex);
        /* FreeEntry removes the prestored block from the event, repair the link */
        Dem_Mem_PrestorageSetRef(lEventId, lPrestorageIndex);
      }
      else
      { /* Return the unused prestorage entry to the event*/
        Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_READY);                                         /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
        Dem_Mem_PrestorageSetRef(lEventId, Dem_Esm_PrestorageLockedIndex);
      }
    }
    else
    {
      Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_FREE);                                            /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
      Dem_Mem_PrestorageFreeEntry(Dem_Esm_PrestorageLockedIndex);
    }

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */

    Dem_Esm_PrestorageLockedIndex = DEM_MEM_INVALID_PRESTORAGE_INDEX;
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPrestorageUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventPrestorageUpdate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Std_ReturnType lReturnValue;
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;
  Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;

  lPrestoredEntry = NULL_PTR;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lPrestorageIndex = Dem_Mem_PrestorageFindEntry(EventId);
  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
  { /* there already is an entry allocated to this event */
    lPrestoredEntry = Dem_Mem_PrestorageGetEntry(lPrestorageIndex);
    Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_UPDATING);                                          /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
  }
  else
  { /* try to find a free entry for this event */
    lPrestorageIndex = Dem_Mem_PrestorageAllocateEntry(EventId);
    if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
    {
      lPrestoredEntry = Dem_Mem_PrestorageGetEntry(lPrestorageIndex);
      Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_UPDATING);                                        /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
    }
  }

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */

  if (NULL_PTR != lPrestoredEntry)
  {
    Dem_Data_PrestorageEntryUpdate(EventId, lPrestoredEntry);                                                                    /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
    Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_READY);                                             /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
    lReturnValue = E_OK;
  }
  else
  {
    lReturnValue = E_NOT_OK;
  }

  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Esm_EventCreateMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventCreateMemory(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Mem_MemoryInfoPtrType lMemoryInfo;
  Dem_Cfg_MemoryIndexType lMemoryIndex;

  lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
  lMemoryIndex = Dem_Mem_MemoryAllocateIndex(lMemoryInfo, EventId);                                                              /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
  if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
  { /* Created new entry */
    Dem_Cfg_EventInternalStatusType lInternalStatus;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    Dem_Cfg_CombinedGroupIndexType lGroupId;

    lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
    if (lGroupId != DEM_CFG_COMBINED_GROUP_INVALID)
    {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
      lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_ACTIVE);
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lInternalStatus);
      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */
    }
    else
#endif
    {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
      lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_ACTIVE);
      Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */
    }

    if (Dem_Cfg_EventSupportImmediateNv(EventId) == TRUE)
    {
      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE);
    }
    else
    {
      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
    }
  }
  return lMemoryIndex;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventUpdateMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventUpdateMemory(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  MemoryIndex,
  CONST(boolean, AUTOMATIC)  Occurrence
  )
{
  Dem_Mem_MemoryInfoPtrType lMemoryInfo;
  uint8 lBlockModification;

  lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));
  lBlockModification = DEM_DATA_NO_CHANGES;

#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON) || (DEM_FEATURE_NEED_AGING_REALLOCATION)
  if (
# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
       (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(Dem_Mem_MemoryGetEntry(MemoryIndex)))
# endif
# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON) && (DEM_FEATURE_NEED_AGING_REALLOCATION)
    ||
# endif
# if (DEM_FEATURE_NEED_AGING_REALLOCATION)
       (DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(Dem_Mem_MemoryGetEntry(MemoryIndex))) == TRUE)
# endif
     )
  {
    /* Re-Initialize the memory entry - this will reset special flags like aging only */
    Dem_Data_EntryInit(Dem_Mem_MemoryGetEntry(MemoryIndex));                                                                     /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
    lBlockModification = DEM_DATA_SET_STATISTICS_CHANGED(lBlockModification);

    /* Prepare expected statistics */
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    Dem_Mem_EntrySetDebounceValueMax(Dem_Mem_MemoryGetEntry(MemoryIndex), 0);                                                    /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
# endif
  }
#endif
  if (Occurrence == TRUE)
  {
    /* On re-occurrence also update the chronology */
    Dem_Mem_MemoryUpdateIndex(lMemoryInfo, MemoryIndex);                                                                         /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
    lBlockModification = DEM_DATA_SET_STATISTICS_CHANGED(lBlockModification);
  }

  return lBlockModification;
}

#if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)
/* ****************************************************************************
 % Dem_Esm_UserIndicatorEnable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_UserIndicatorEnable(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_EventIndicatorIterType lIndicatorIter;

  for (Dem_Cfg_EventIndicatorIterInit(EventId, &lIndicatorIter);                                                                 /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventIndicatorIterExists(&lIndicatorIter) == TRUE;                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventIndicatorIterNext(&lIndicatorIter))                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_IndicatorIndexType lIndicatorIndex;
    lIndicatorIndex = Dem_Cfg_EventIndicatorIterGet(&lIndicatorIter);                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
    DEM_IGNORE_UNUSED_VARIABLE(lIndicatorIndex)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */

    {
      /* Increment the (node specific) indicator counter for continuous or blinking, according to configuration */
      if (0 != (DEM_INDICATOR_CONTINUOUS & Dem_Cfg_IndicatorStatus(lIndicatorIndex)))
      {
        Dem_Mem_IndicatorSetEventCountContinuous(Dem_Cfg_IndicatorId(lIndicatorIndex), DEM_J1939_NODE_ID,
          Dem_Mem_IndicatorGetEventCountContinuous(Dem_Cfg_IndicatorId(lIndicatorIndex), DEM_J1939_NODE_ID) + 1);
      }
      if (0 != (DEM_INDICATOR_BLINKING & Dem_Cfg_IndicatorStatus(lIndicatorIndex)))
      {
        Dem_Mem_IndicatorSetEventCountBlinking(Dem_Cfg_IndicatorId(lIndicatorIndex), DEM_J1939_NODE_ID,
          Dem_Mem_IndicatorGetEventCountBlinking(Dem_Cfg_IndicatorId(lIndicatorIndex), DEM_J1939_NODE_ID) + 1);
      }
    }
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON) */

#if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)
/* ****************************************************************************
 % Dem_Esm_UserIndicatorDisable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_UserIndicatorDisable(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_EventIndicatorIterType lIndicatorIter;

  for (Dem_Cfg_EventIndicatorIterInit(EventId, &lIndicatorIter);                                                                 /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventIndicatorIterExists(&lIndicatorIter) == TRUE;                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventIndicatorIterNext(&lIndicatorIter))                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_IndicatorIndexType lIndicatorIndex;

    lIndicatorIndex = Dem_Cfg_EventIndicatorIterGet(&lIndicatorIter);                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
    DEM_IGNORE_UNUSED_VARIABLE(lIndicatorIndex)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */

    {
      if (0 != (DEM_INDICATOR_CONTINUOUS & Dem_Cfg_IndicatorStatus(lIndicatorIndex)))
      {
        Dem_Mem_IndicatorSetEventCountContinuous(Dem_Cfg_IndicatorId(lIndicatorIndex), DEM_J1939_NODE_ID,
          Dem_Mem_IndicatorGetEventCountContinuous(Dem_Cfg_IndicatorId(lIndicatorIndex), DEM_J1939_NODE_ID) - 1);
      }
      if (0 != (DEM_INDICATOR_BLINKING & Dem_Cfg_IndicatorStatus(lIndicatorIndex)))
      {
        Dem_Mem_IndicatorSetEventCountBlinking(Dem_Cfg_IndicatorId(lIndicatorIndex), DEM_J1939_NODE_ID,
          Dem_Mem_IndicatorGetEventCountBlinking(Dem_Cfg_IndicatorId(lIndicatorIndex), DEM_J1939_NODE_ID) - 1);
      }
    }
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* DEM_CFG_SUPPORT_USER_INDICATORS */

/* ****************************************************************************
 % Dem_Esm_TestLatchedTestFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestLatchedTestFailed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
)
{
  boolean lReturnValue;

  if (Dem_Cfg_EventLatchTestFailed(EventId) == TRUE)
  {
    lReturnValue = (boolean)(((DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_CDTC) & Dem_Mem_EventGetStatus(EventId)) != 0);
  }
  else
  {
    lReturnValue = FALSE;
  }
  return lReturnValue;
}

#if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TestEventHealed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestEventHealed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint8, AUTOMATIC)  EventStatus                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
)
{
  boolean lReturnValue;

  DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventStatus)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */

# if (DEM_CFG_AGING_AFTER_HEALING_ALL_DTC == STD_ON)
#  if (DEM_CFG_ISCONST_HEALINGTARGET != STD_ON)
  if (Dem_Cfg_EventHealingTarget(EventId) == 0)
#  endif
  {
#  if (DEM_FEATURE_NEED_IMMEDIATEHEAL == STD_ON)
    lReturnValue = ( (DEM_ESM_TEST_UDS_STATUS_TF(EventStatus) == FALSE)
                  && (DEM_ESM_TEST_UDS_STATUS_TNCTOC(EventStatus) == FALSE) );
#  endif
  }
#  if (DEM_CFG_ISCONST_HEALINGTARGET != STD_ON)
  else /* Dem_Cfg_EventHealingTarget(EventId) > 0 */
#  endif
  {
#  if (DEM_FEATURE_NEED_SINGLEHEAL == STD_ON)
    lReturnValue = (DEM_ESM_TEST_UDS_STATUS_PDTC(EventStatus) == FALSE);
#  elif (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
    /* TripCount is the healing counter when PDTC == false */
    lReturnValue = ( (Dem_Mem_EventGetTripCount(EventId) == 0)
             && (DEM_ESM_TEST_UDS_STATUS_PDTC(EventStatus) == FALSE) );
#  endif
  }
# else
  lReturnValue = (boolean)(DEM_ESM_TEST_UDS_STATUS_WIR(EventStatus) == FALSE);
# endif

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON) */

#if ( (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON) \
   && ( (DEM_CFG_AGING_START_TRIGGER_PASSED == STD_ON) || (DEM_CFG_AGING_00_START_TRIGGER_PASSED == STD_ON) \
     || ( (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) && ((DEM_CFG_AGING_00_START_TRIGGER_PASSED == STD_OFF) || (DEM_CFG_AGING_START_TRIGGER_PASSED == STD_OFF)) ) ) )
/* ****************************************************************************
 % Dem_Esm_TestDtcHealed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestDtcHealed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  boolean lReturnValue;
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
# endif

# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (lGroupId != DEM_CFG_COMBINED_GROUP_INVALID)
  {
    Dem_Cfg_CombinedGroupIterType lGroupIter;
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lGroupIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterExists(&lGroupIter) == TRUE;                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterNext(&lGroupIter))                                                                             /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_EventIdType lSubEvent;
      lSubEvent = Dem_Cfg_CombinedGroupIterGet(&lGroupIter);                                                                     /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if (Dem_Esm_TestEventHealed(lSubEvent, Dem_Mem_EventGetStatus(lSubEvent)) == FALSE)
      {
        break;
      }
    }
    lReturnValue = !(Dem_Cfg_CombinedGroupIterExists(&lGroupIter));                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
  }
  else
# endif
  {
    lReturnValue = Dem_Esm_TestEventHealed(EventId, Dem_Mem_EventGetStatus(EventId));
  }

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON) */

/* ****************************************************************************
 % Dem_Esm_EventResetDebounceState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDebounceState(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_DebounceResetStatusType, AUTOMATIC)  Status
  )
{
  Dem_DebounceInfoType lDebounceInfo;
  Dem_Esm_DebounceInfoInit(EventId, &lDebounceInfo);                                                                             /* SBSW_DEM_CALL_DEBOUNCEINFO_INIT */

  if (Status == DEM_DEBOUNCE_STATUS_RESET)
  {
    lDebounceInfo.Common.FunctionTable->Reset(&lDebounceInfo);                                                                   /* SBSW_DEM_CALL_FUNCPTR_DEBOUNCEINFO_POINTER */
  }
  else
  {
    lDebounceInfo.Common.FunctionTable->Freeze(&lDebounceInfo);                                                                  /* SBSW_DEM_CALL_FUNCPTR_DEBOUNCEINFO_POINTER */
  }
}

/* ****************************************************************************
 % Dem_Esm_EventResetDebounceValues
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDebounceValues(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Mem_EventSetDebounceValue(EventId, 0);

  if (Dem_Cfg_EventDebounceType(EventId) == DEM_CFG_DEBOUNCETYPE_TIMER)
  {
    Dem_Mem_EventSetDebounceValueMax(EventId, Dem_Cfg_EventFailedTime(EventId));
  }
  else
  {
    Dem_Mem_EventSetDebounceValueMax(EventId, 0);
  }
}

#if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON) || (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventSetDisconnectedBit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetDisconnectedBit(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(boolean, AUTOMATIC)  IsDisconnected
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);

  if (IsDisconnected == TRUE)
  {
    lInternalStatus = Dem_Mem_SetEventDisconnectedStatus(lInternalStatus);
    Dem_Mem_EventSetStatus(EventId, 0x00);
  }
  else
  {
    lInternalStatus = Dem_Mem_ResetEventDisconnectedStatus(lInternalStatus);
  }

  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
}
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventMayDisconnect
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventMayDisconnect(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  boolean lReturnValue;
  uint8 lEventStatus;
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lEventStatus = Dem_Mem_EventGetStatus(EventId);
  lInternalStatus = Dem_Util_DtcGetInternalStatus(EventId);

  if ( (DEM_ESM_TEST_UDS_STATUS_TF(lEventStatus) == FALSE)
    && (DEM_ESM_TEST_UDS_STATUS_WIR(lEventStatus) == FALSE)
    && (DEM_ESM_TEST_UDS_STATUS_CDTC(lEventStatus) == FALSE)
     )
  {
    if (DEM_ESM_STORED_STATUS_NONE == Dem_Mem_GetStoredStatus(lInternalStatus))
    {
      lReturnValue = TRUE;
    }
    else
    {
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      Dem_Cfg_CombinedGroupIndexType lGroupId;

      lReturnValue = FALSE;
      lGroupId = Dem_Cfg_EventCombinedGroup(EventId);

      /* If a combined event has a stored DTC, only allow disabling a subevent
         if at least one other event is enabled */
      if (lGroupId != DEM_CFG_COMBINED_GROUP_INVALID)
      {
        Dem_Cfg_CombinedGroupIterType lCombinedIter;

        for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
            Dem_Cfg_CombinedGroupIterExists(&lCombinedIter) == TRUE;                                                             /* SBSW_DEM_CALL_ITERATOR_POINTER */
            Dem_Cfg_CombinedGroupIterNext(&lCombinedIter))                                                                       /* SBSW_DEM_CALL_ITERATOR_POINTER */
        {
          Dem_EventIdType lSubEventId;
          lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lCombinedIter);                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
          if ( (lSubEventId != EventId)                                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
            && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE) )
          {
            lReturnValue = TRUE;
            break;
          }
        }
      }
      else
# endif
      {
        lReturnValue = FALSE;
      }
    }
  }
  else
  {
    lReturnValue = FALSE;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisconnect_Combined
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisconnect_Combined(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  Dem_Cfg_EventInternalStatusType lInternalStatus;
  Dem_Cfg_EventInternalStatusType lGroupInternalStatus;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);

  lInternalStatus = Dem_Mem_SetEventDisconnectedStatus(lInternalStatus);

  /* Remove pending actions: time debouncing, FDC triggers and queue state  */
  lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
  lInternalStatus = Dem_Mem_ResetFdcTripStatus(lInternalStatus);
  lInternalStatus = Dem_Mem_ResetFdcMaxStatus(lInternalStatus);

  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
  Dem_Queue_ResetPendingEvent(EventId);

  Dem_Mem_EventSetStatus(EventId, 0x00U);
  Dem_Esm_EventResetDebounceValues(EventId);

  if (Dem_Mem_TestEventDisconnectedStatus(lGroupInternalStatus) == FALSE)
  { /* If all Events belonging to a DTC are disconnected, that DTC is disconnected as well */
    /* If all connected events are suppressed or disconnected, the DTC is suppressed as well */
    uint8 lCombinedGroupStatus;
    boolean lDoDisconnect;
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    boolean lDoSuppress;
# endif
    Dem_Cfg_CombinedGroupIterType lCombinedIter;

    lCombinedGroupStatus = 0x00;
    lDoDisconnect = TRUE;
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    lDoSuppress = TRUE;
# endif

    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterExists(&lCombinedIter) == TRUE;                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterNext(&lCombinedIter))                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lCombinedIter);                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)
      {
        /* If all events are disconnected now, the combined group is set to disconnected */
        lDoDisconnect = (boolean)(lDoDisconnect                                                                                  /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == TRUE));
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
        /* If all events are either disconnected or suppressed, the combined group is suppressed */
        lDoSuppress = (boolean)(lDoSuppress                                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          && ( (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == TRUE)
            || (Dem_Mem_TestEventSuppressedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == TRUE) ) );
# endif
        lCombinedGroupStatus = (uint8)(lCombinedGroupStatus | Dem_Mem_EventGetStatus(lSubEventId));
      }
    }
    if (FALSE != lDoDisconnect)
    {
      lGroupInternalStatus = Dem_Mem_SetEventDisconnectedStatus(lGroupInternalStatus);
    }
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    if (FALSE != lDoSuppress)
    {
      lGroupInternalStatus = Dem_Mem_SetEventSuppressedStatus(lGroupInternalStatus);
    }
# endif
    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lGroupInternalStatus);
    Dem_Mem_CombinedGroupSetStatus(lGroupId, lCombinedGroupStatus);
  }
# if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  if (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
  { /* #120 Clear a present prestored freeze frame */
    (void)Dem_Esm_EventPrestorageClear(EventId);
  }
# endif
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisconnect_Normal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisconnect_Normal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  lInternalStatus = Dem_Mem_SetEventDisconnectedStatus(lInternalStatus);
  lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
  lInternalStatus = Dem_Mem_ResetFdcTripStatus(lInternalStatus);
  lInternalStatus = Dem_Mem_ResetFdcMaxStatus(lInternalStatus);

  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);

  Dem_Queue_ResetPendingEvent(EventId);
  Dem_Mem_EventSetStatus(EventId, 0x00U);
  Dem_Esm_EventResetDebounceValues(EventId);
# if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  if (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
  {
    (void)Dem_Esm_EventPrestorageClear(EventId);
  }
# endif

}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisconnect
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventDisconnect(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Std_ReturnType lReturnValue;

  if (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE)
  {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if (Dem_Esm_EventMayDisconnect(EventId) == TRUE)
    {
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID != Dem_Cfg_EventCombinedGroup(EventId))
      {
        /* In case of event combination, disconnect the sub-event */
        Dem_Esm_EventDisconnect_Combined(EventId);
      }
      else
# endif
      {
        /* Otherwise disconnect the event dircetly */
        Dem_Esm_EventDisconnect_Normal(EventId);
      }

# if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
      {
        uint8 lNvAvailableMask;
        lNvAvailableMask = Dem_Mem_EventGetAvailableMask(EventId / 8u);
        lNvAvailableMask = (uint8)(lNvAvailableMask | DEM_BIT(EventId % 8u));
        Dem_Mem_EventSetAvailableMask(EventId / 8u, lNvAvailableMask);
        Dem_Mem_EventAvailableSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
      }
# endif
      lReturnValue = E_OK;
    }
    else
    {
      lReturnValue = E_NOT_OK;
    }

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
#if (DEM_CFG_NOTIFY_FIM == STD_ON)
    if ( (lReturnValue == E_OK)
      && (Dem_InitState == DEM_INIT_INITIALIZED) )
    {
      (void)FiM_DemTriggerOnEventStatus(EventId, 0x50, 0x00);
    }
#endif
  }
  else
  { /* Already disconnected */
    lReturnValue = E_OK;
  }
  return lReturnValue;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) */

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventReconnect_Combined
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect_Combined(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  Dem_Cfg_EventInternalStatusType lGroupInternalStatus;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);

  Dem_Mem_EventSetInternalStatus(EventId, Dem_Mem_ResetEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)));
  Dem_Mem_EventSetStatus(EventId, 0x50U);

  if ( (Dem_Mem_TestEventDisconnectedStatus(lGroupInternalStatus) == TRUE)                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    || (Dem_Mem_TestEventSuppressedStatus(lGroupInternalStatus) == TRUE)
# endif
    )
  {
    uint8 lCombinedGroupStatus;
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    boolean lDoSuppress;
# endif
    Dem_Cfg_CombinedGroupIterType lCombinedIter;

    lCombinedGroupStatus = 0x00;
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    lDoSuppress = TRUE;
# endif

    /* Reconnecting an event can cause a suppressed DTC to become un-suppressed */
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterExists(&lCombinedIter) == TRUE;                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterNext(&lCombinedIter))                                                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lCombinedIter);                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)
      {
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
        /* (If suppression is supported) If all sub-events are either disconnected or suppressed, the combined
         * group is still suppressed */
        lDoSuppress = (boolean)(lDoSuppress                                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          && ( (Dem_Mem_TestEventSuppressedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == TRUE)
            || (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == TRUE)));
# endif
        /* Calculate the combined event status - logical 'or' of all connected event status bytes (includes self) */
        lCombinedGroupStatus = (uint8)(lCombinedGroupStatus | Dem_Mem_EventGetStatus(lSubEventId));
      }
    }

    /* Since at least one sub-events is connected now, set the combined group to connected */
    lGroupInternalStatus = Dem_Mem_ResetEventDisconnectedStatus(lGroupInternalStatus);

# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    if (FALSE == lDoSuppress)
    {
      /* (If suppression is supported) If all sub-events are either disconnected or suppressed, the combined
       * group is still suppressed */
      lGroupInternalStatus = Dem_Mem_ResetEventSuppressedStatus(lGroupInternalStatus);
    }
# endif
    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lGroupInternalStatus);
    Dem_Mem_CombinedGroupSetStatus(lGroupId, lCombinedGroupStatus);
  }

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventReconnect_Normal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect_Normal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  /* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dem_Mem_EventSetInternalStatus(EventId, Dem_Mem_ResetEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)));
  Dem_Mem_EventSetStatus(EventId, 0x50U);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventReconnect
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  if (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == TRUE)
  {
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    if (DEM_CFG_COMBINED_GROUP_INVALID != Dem_Cfg_EventCombinedGroup(EventId))
    {
      Dem_Esm_EventReconnect_Combined(EventId);
    }
    else
# endif
    {
      Dem_Esm_EventReconnect_Normal(EventId);
    }
# if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
    {
      uint8 lNvAvailableMask;
      lNvAvailableMask = Dem_Mem_EventGetAvailableMask(EventId / 8u);
      lNvAvailableMask = (uint8)(lNvAvailableMask & DEM_BIT_MASK(EventId % 8u, DEM_1BYTE));
      Dem_Mem_EventSetAvailableMask(EventId / 8u, lNvAvailableMask);
      Dem_Mem_EventAvailableSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
    }
# endif

#if (DEM_CFG_NOTIFY_FIM == STD_ON)
    if (Dem_InitState == DEM_INIT_INITIALIZED)
    {
      (void)FiM_DemTriggerOnEventStatus(EventId, 0x00, 0x50);
    }
#endif
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) */

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventSetSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
# endif

# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_EventInternalStatusType lGroupInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
    Dem_Mem_EventSetInternalStatus(EventId, Dem_Mem_SetEventSuppressedStatus(Dem_Mem_EventGetInternalStatus(EventId)));

    if (FALSE == Dem_Mem_TestEventSuppressedStatus(lGroupInternalStatus))
    {
      boolean lDoSuppress;
      Dem_Cfg_CombinedGroupIterType lCombinedIter;

      lDoSuppress = TRUE;
      for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
           Dem_Cfg_CombinedGroupIterExists(&lCombinedIter) == TRUE;                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
           Dem_Cfg_CombinedGroupIterNext(&lCombinedIter))                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
      {
        Dem_EventIdType lSubEventId;

        lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lCombinedIter);                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
        if (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)
        {
          if (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE)
          {
            lDoSuppress = (boolean)Dem_Mem_TestEventSuppressedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId));
          }
        }

        if (lDoSuppress == FALSE)
        {
          break;
        }
      }
      if (lDoSuppress == TRUE)
      {
        Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, Dem_Mem_SetEventSuppressedStatus(lGroupInternalStatus));
      }
    }

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
  else
# endif
  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    Dem_Mem_EventSetInternalStatus(EventId, Dem_Mem_SetEventSuppressedStatus(lInternalStatus));

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON) */

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventResetSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_EventInternalStatusType lGroupInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
    Dem_Mem_EventSetInternalStatus(EventId, Dem_Mem_ResetEventSuppressedStatus(Dem_Mem_EventGetInternalStatus(EventId)));
    if (FALSE != Dem_Mem_TestEventSuppressedStatus(lGroupInternalStatus))
    { /* if at least one event of a combined event group is active, the dtc is not suppressed */
      /* Unavailable event cannot be set unsuppressed, they are rejected by the API.
         So the assumption is that this event is available, so is the DTC */
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, Dem_Mem_ResetEventSuppressedStatus(lGroupInternalStatus));
    }
    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
  else
# endif
  {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dem_Mem_EventSetInternalStatus(EventId, Dem_Mem_ResetEventSuppressedStatus(Dem_Mem_EventGetInternalStatus(EventId)));

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON) */

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventSetDtcSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetDtcSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);

    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, Dem_Mem_SetDtcSuppressedStatus(lInternalStatus));

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
  else
# endif
  {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);

    Dem_Mem_EventSetInternalStatus(EventId, Dem_Mem_SetDtcSuppressedStatus(lInternalStatus));

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON) */

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventResetDtcSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDtcSuppression(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, Dem_Mem_ResetDtcSuppressedStatus(lInternalStatus));
    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
  else
# endif
  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    Dem_Mem_EventSetInternalStatus(EventId, Dem_Mem_ResetDtcSuppressedStatus(lInternalStatus));
    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON) */
/* ****************************************************************************
 % Dem_Esm_EventAged
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAged(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
  if (FALSE != Dem_Cfg_EventSupportAging(EventId))
  {
    Dem_Util_ForEachCombinedArgType lArgs;

    /* Process aging for each sub-event status */
    Dem_Util_ForEachCombinedEvent(EventId, Dem_Esm_EventAged_Internal, &lArgs);                                                  /* SBSW_DEM_CALL_FOREACH_COMBINED_EVENT */

    if (DEM_MEM_INVALID_MEMORY_INDEX != MemoryIndex)
    {
#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
      Dem_Mem_EntrySetAgingCount(Dem_Mem_MemoryGetEntry(MemoryIndex), DEM_ESM_CYCLECOUNT_EVENT_AGED);                            /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
#else
      {
        Dem_Mem_MemoryInfoPtrType lMemoryInfo;

        lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));

        Dem_Mem_MemoryFreeIndex(lMemoryInfo, MemoryIndex);                                                                       /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
      }
#endif
      Dem_Mem_MemorySetBlockState(MemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      /* For combined events, synchronize the combined internal stored status */
      {
        Dem_Cfg_CombinedGroupIndexType lGroupId;
        lGroupId = Dem_Cfg_EventCombinedGroup(EventId);

        if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
        {
          Dem_Cfg_EventInternalStatusType lGroupInternalStatus;
          lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);

          Dem_Mem_CombinedGroupSetStatus(lGroupId, lArgs.Common.NewDtcStatus);
# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
          lGroupInternalStatus = Dem_Mem_SetStoredStatus(lGroupInternalStatus, DEM_ESM_STORED_STATUS_AGED);
# else
          lGroupInternalStatus = Dem_Mem_SetStoredStatus(lGroupInternalStatus, DEM_ESM_STORED_STATUS_NONE);
# endif
          Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lGroupInternalStatus);
        }
      }
#endif

      /* If configured, notify the DTC status change */
      Dem_Cbk_DtcStatusChanged(EventId, lArgs.Common.OldDtcStatus, lArgs.Common.NewDtcStatus, DEM_CBK_DTC_AGED);
    }
  }
  else
  {
    if (DEM_MEM_INVALID_MEMORY_INDEX != MemoryIndex)
    {
      /* Latch the aging counter and set the memory entries NV status to DIRTY */
      Dem_Mem_EntrySetAgingCount(Dem_Mem_MemoryGetEntry(MemoryIndex), DEM_ESM_CYCLECOUNT_LATCHED);                               /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
      Dem_Mem_MemorySetBlockState(MemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
    }
  }
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_Esm_EventAgingStartZeroTarget
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingStartZeroTarget(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lInternalStatus = Dem_Util_DtcGetInternalStatus(EventId);
  if (DEM_ESM_STORED_STATUS_AGING > Dem_Mem_GetStoredStatus(lInternalStatus))
  { /* <=> DEM_ESM_STORED_STATUS_NONE || DEM_ESM_STORED_STATUS_ACTIVE */

    if (Dem_Cfg_EventSupportAging(EventId) == TRUE)
    {
      Dem_Cfg_MemoryIndexType  lMemoryIndex;
      Dem_Mem_MemoryInfoPtrType lMemoryInfo;

      lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
      lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));

# if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
      if (DEM_ESM_TEST_UDS_STATUS_PDTC(Dem_Mem_EventGetStatus(EventId)) == TRUE)
      { /* PDTC == TRUE -> TripCounter */
        Dem_Mem_EventSetTripCount(EventId, 0);
      }
# endif
      if (DEM_ESM_STORED_STATUS_ACTIVE == Dem_Mem_GetStoredStatus(lInternalStatus))
      {
        lMemoryIndex = Dem_Mem_MemoryFindIndex_Checked(lMemoryInfo, EventId);                                                    /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
      }
      Dem_Esm_EventAged(EventId, lMemoryIndex);
    }
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventAgingStartMultiTarget
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingStartMultiTarget(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lInternalStatus = Dem_Util_DtcGetInternalStatus(EventId);
  if (DEM_ESM_STORED_STATUS_AGING > Dem_Mem_GetStoredStatus(lInternalStatus))
  { /* <=> DEM_ESM_STORED_STATUS_NONE || DEM_ESM_STORED_STATUS_ACTIVE */
    Dem_Cfg_MemoryIndexType  lMemoryIndex;
    Dem_Mem_MemoryInfoPtrType lMemoryInfo;

    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
    lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));

#if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
    if (Dem_Mem_GetStoredStatus(lInternalStatus) == DEM_ESM_STORED_STATUS_NONE)
    {
      /* If necessary allocate an aging counter */
      if (FALSE != DEM_ESM_TEST_UDS_STATUS_CDTC(Dem_Util_DtcGetStatus(EventId)))
      {
        lMemoryIndex = Dem_Mem_MemoryAllocateAging(lMemoryInfo, EventId);                                                        /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
      }
    }
    else
#endif
    if (Dem_Mem_GetStoredStatus(lInternalStatus) == DEM_ESM_STORED_STATUS_ACTIVE)
    {
      lMemoryIndex = Dem_Mem_MemoryFindIndex_Checked(lMemoryInfo, EventId);                                                      /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
    }
    else
    { /* MISRA */ }

    if (DEM_MEM_INVALID_MEMORY_INDEX != lMemoryIndex)
    { /* Start Aging */
      uint16 lAgingCounter;

#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
      if (DEM_ESM_CYCLECOUNT_INVALID != Dem_Mem_EntryGetAgingCount(Dem_Mem_MemoryGetEntry(lMemoryIndex)))
      {
        Dem_RunTimeCheckFailed(__LINE__);
      }
#endif
      /* Initialize the aging target of the memory entry */
      lAgingCounter = Dem_Mem_CycleGetCounter(Dem_Cfg_EventAgingCycle(EventId));
      lAgingCounter = Dem_Esm_AddCycleCount(lAgingCounter, Dem_Cfg_EventAgingTarget(EventId));
      Dem_Mem_EntrySetAgingCount(Dem_Mem_MemoryGetEntry(lMemoryIndex), lAgingCounter);                                           /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */

      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lInternalStatus = Dem_Util_DtcGetInternalStatus(EventId);
      /* In critical section 'DiagMonitor', set the events stored status to 'AGING' */
      lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_AGING);
      Dem_Util_DtcSetInternalStatus(EventId, lInternalStatus);
      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */
    }
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) || (DEM_CFG_STORAGE_AT_FDC == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventFdcTrip
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFdcTrip(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(boolean, AUTOMATIC)  FirstThisCycle
  )
{
  Dem_Mem_MemoryInfoPtrType lMemoryInfo;
  Dem_Cfg_MemoryIndexType lMemoryIndex;

  lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));
  lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;

  if (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(EventId)) != DEM_ESM_STORED_STATUS_NONE)
  {
    lMemoryIndex = Dem_Mem_MemoryFindIndex_Checked(lMemoryInfo, EventId);                                                        /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
# if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
#  if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON) || (DEM_FEATURE_NEED_AGING_REALLOCATION)
    if (
#   if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
         (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(Dem_Mem_MemoryGetEntry(lMemoryIndex)))
#   endif
#   if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON) && (DEM_FEATURE_NEED_AGING_REALLOCATION)
      ||
#   endif
#   if (DEM_FEATURE_NEED_AGING_REALLOCATION)
         (DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(Dem_Mem_MemoryGetEntry(lMemoryIndex))) == TRUE)
#   endif
      )
    {
      Dem_Data_EntryInit(Dem_Mem_MemoryGetEntry(lMemoryIndex));                                                                  /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
    }
#  endif
# endif
  }
# if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
  else
  {
    /* FdcTrip is the storage trigger and the event is not yet stored */
    lMemoryIndex = Dem_Esm_EventCreateMemory(EventId);
  }
# endif

  if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
  {
    uint8 lBlockModification;

    /* If the event is stored, update the event data with FDC respectively FDC & FirstThisCycle */
    lBlockModification = Dem_Data_EntryUpdate(EventId,
                                             (uint8)((FALSE != FirstThisCycle)?DEM_CFG_TRIGGER_FDC_FIRST_IN_CYCLE:DEM_CFG_TRIGGER_FDC),
                                             lMemoryIndex);

    if (lBlockModification != DEM_DATA_NO_CHANGES)
    {
      if (Dem_Cfg_EventSupportImmediateNv(EventId) == TRUE)
      {
        Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE);
      }
      else
      {
        Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
      }
    }

    if (DEM_DATA_TEST_USERDATA_CHANGED(lBlockModification) == TRUE)
    {
      Dem_Cbk_EventDataChanged(EventId);
    }
  }

# if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_PrestorageDiscard();
# endif
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventFdcMax
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFdcMax(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  if (DEM_ESM_STORED_STATUS_NONE != Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(EventId)))
  { /* Already stored - Find, *but don't update* the memory entry */
    Dem_Mem_MemoryInfoPtrType lMemoryInfo;
    Dem_Cfg_MemoryIndexType lMemoryIndex;

    lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));
    lMemoryIndex = Dem_Mem_MemoryFindIndex_Checked(lMemoryInfo, EventId);                                                        /* SBSW_DEM_CALL_MEMORYINFO_POINTER */

# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if (DEM_MEM_INVALID_MEMORY_INDEX == lMemoryIndex)
    {
      Dem_RunTimeCheckFailed(__LINE__);
    }
    else
# endif
    {
      Dem_Mem_EntryPtrType lEntry;

      lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID != Dem_Cfg_EventCombinedGroup(EventId))
      {
        /* synchronize the current max FDC with the stored FDC max value */
        sint8 lOldFdc;
        sint8 lNewFdc;

        lOldFdc = (sint8)Dem_Mem_EntryGetDebounceValueMax(lEntry);
        lNewFdc = Dem_Data_CombinedGroupGetFDCMax(Dem_Cfg_EventCombinedGroup(EventId));
        if (lOldFdc < lNewFdc)
        {
          Dem_Mem_EntrySetDebounceValueMax(lEntry, (sint16)lNewFdc);                                                             /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
          Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
        }
      }
      else
# endif
      {
        /* synchronize the current max FDC with the stored FDC max value */
        sint8 lOldFdc;
        sint8 lNewFdc;

        lOldFdc = (sint8)Dem_Mem_EntryGetDebounceValueMax(lEntry);
        lNewFdc = Dem_Data_EventGetFDCMax(EventId);
        if (lOldFdc < lNewFdc)
        {
          Dem_Mem_EntrySetDebounceValueMax(lEntry, (sint16)lNewFdc);                                                             /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
          Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
        }
      }
    }
    /*
      No data changed callbacks for modified internal data
    */
  }
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON) */

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
/* ****************************************************************************
 % Dem_Esm_ProcessFdc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_ProcessFdc(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lOldEventInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
  {
    Dem_Cfg_EventInternalStatusType lNewEventInternalStatus;

    lOldEventInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    lNewEventInternalStatus = lOldEventInternalStatus;
    lNewEventInternalStatus = Dem_Mem_ResetFdcTripStatus(lNewEventInternalStatus);
    lNewEventInternalStatus = Dem_Mem_ResetFdcMaxStatus(lNewEventInternalStatus);
    if (Dem_Mem_TestFdcTripStatus(lOldEventInternalStatus) == TRUE)
    {
      lNewEventInternalStatus = Dem_Mem_SetFdcTocStatus(lNewEventInternalStatus);
    }

    Dem_Mem_EventSetInternalStatus(EventId, lNewEventInternalStatus);
  }
  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */

  /* no events without a DTC attached, disabled storage conditions, dtc/event suppressed... */
  if ( (DEM_CFG_DTC_UDS_INVALID != Dem_Cfg_EventUdsDtc(EventId))                                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
        /* Don't store with disabled storage conditions */
    && ((Dem_StorageConditionStates & Dem_Cfg_EventStorageConditions(EventId)) == Dem_Cfg_EventStorageConditions(EventId))
# endif
    )
  {
# if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) || (DEM_CFG_STORAGE_AT_FDC == STD_ON)
    if (Dem_Mem_TestFdcTripStatus(lOldEventInternalStatus) == TRUE)
    {
      /* Pass 'TRUE' if the old bit is false, so the status change did happen just now */
      Dem_Esm_EventFdcTrip(EventId, (boolean)(Dem_Mem_TestFdcTocStatus(lOldEventInternalStatus) == FALSE));
    }
# endif
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    if (Dem_Mem_TestFdcMaxStatus(lOldEventInternalStatus) == TRUE)
    {
      Dem_Esm_EventFdcMax(EventId);
    }
# endif
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_FEATURE_NEED_IMMEDIATEHEAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPassed_ProcessHealing
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_ProcessHealing(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Design */
  )
{
  if (Dem_Cfg_EventHealingTarget(EventContext->EventId) == 0)
  {
    /* Remove WarningIndicatorReq bit with the first 'TestPassed' result */
# if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON) && (DEM_CFG_AGING_AFTER_HEALING_ALL_DTC == STD_ON)
    Dem_Mem_EventSetTripCount(EventContext->EventId, 0);
# endif

# if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_WIR(EventContext->OldEventStatus))
    {

#  if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON) && (DEM_CFG_AGING_AFTER_HEALING_ALL_DTC == STD_OFF)
      Dem_Mem_EventSetTripCount(EventContext->EventId, 0);
#  endif

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */

      EventContext->OldEventStatus = Dem_Mem_EventGetStatus(EventContext->EventId);                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      EventContext->NewEventStatus = DEM_ESM_RESET_UDS_STATUS_WIR(EventContext->OldEventStatus);                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */

      Dem_Mem_EventSetStatus(EventContext->EventId, EventContext->NewEventStatus);

      {
#  if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)                                                                                /* COV_MSR_UNSUPPORTED TX */
        Dem_Esm_UserIndicatorDisable(EventContext->EventId);
#  endif
      }

      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */

      DEM_NVM_CHECK_DIRTY_STATUS(EventContext->OldEventStatus, EventContext->NewEventStatus)

      if (EventContext->OldEventStatus != EventContext->NewEventStatus)
      {
        Dem_Cbk_StatusChanged(EventContext->EventId, EventContext->OldEventStatus, EventContext->NewEventStatus);
#  if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
        if (DEM_CFG_COMBINED_GROUP_INVALID == EventContext->GroupId)
#  endif
        {
          Dem_Cbk_DtcStatusChanged(EventContext->EventId, EventContext->OldEventStatus, EventContext->NewEventStatus, DEM_CBK_DTC_HEALED);
        }
      }
    }
# endif /* (DEM_FEATURE_NEED_INDICATORS == STD_ON) */
  }
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* DEM_FEATURE_NEED_IMMEDIATEHEAL == STD_ON */

/* ****************************************************************************
 % Dem_Esm_EventPassed_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  if (Dem_Esm_TestLatchedTestFailed(EventId) == FALSE)
  {
    uint8 lOldEventStatus;
    uint8 lNewEventStatus;
    uint8 lEventEffects;

    lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
    lNewEventStatus = lOldEventStatus;
    lEventEffects = DEM_CFG_TRIGGER_NONE;

    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lNewEventStatus);
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lNewEventStatus);
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lNewEventStatus);

    Dem_Mem_EventSetStatus(EventId, lNewEventStatus);
    DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

    /* Derive the triggers for the event from the changes of the status bits */
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_TF(lOldEventStatus))
    {
      lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_TESTPASSED);
    }
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_TNCTOC(lOldEventStatus))
    {
      lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_FIRSTTHISCYCLE);
    }

    if (lOldEventStatus != lNewEventStatus)
    {
      Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      if (Dem_Cfg_EventCombinedGroup(EventId) == DEM_CFG_COMBINED_GROUP_INVALID)
#endif
      {
        Dem_Cbk_DtcStatusChanged(EventId, lOldEventStatus, lNewEventStatus, DEM_CBK_DTC_UPDATED);
      }

      Dem_Esm_EventPassed_Immediate(EventId, lEventEffects);
    }
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventPassed_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  Effects
  )
{
  Dem_Esm_EventContextType lEventContext;

  lEventContext.EventId = EventId;
  lEventContext.OldEventStatus = Dem_Mem_EventGetStatus(EventId);
  lEventContext.NewEventStatus = lEventContext.OldEventStatus;
  lEventContext.EventEffects = Effects;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  lEventContext.GroupId = Dem_Cfg_EventCombinedGroup(EventId);
  lEventContext.OldDtcStatus = Dem_Util_DtcGetStatus(EventId);
  lEventContext.NewDtcStatus = lEventContext.OldDtcStatus;
  lEventContext.DtcEffects = DEM_CFG_TRIGGER_NONE;
#endif

  DEM_IGNORE_UNUSED_VARIABLE(lEventContext.EventEffects)                                                                         /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_VARIABLE(lEventContext.EventId)                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_VARIABLE(lEventContext.NewEventStatus)                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */

#if (DEM_FEATURE_NEED_IMMEDIATEHEAL == STD_ON)
  Dem_Esm_EventPassed_ProcessHealing(&lEventContext);                                                                            /* SBSW_DEM_POINTER_FORWARD_STACK */
#endif

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  if (DEM_CFG_COMBINED_GROUP_INVALID != lEventContext.GroupId)
  {
    lEventContext.NewDtcStatus = Dem_Data_CombinedGroupGetStatus(lEventContext.GroupId);
    Dem_Mem_CombinedGroupSetStatus(lEventContext.GroupId, lEventContext.NewDtcStatus);
    Dem_Cbk_DtcStatusChanged(lEventContext.EventId, lEventContext.OldDtcStatus, lEventContext.NewDtcStatus, DEM_CBK_DTC_UPDATED);
  }
#endif

#if (DEM_FEATURE_NEED_AGING_TRIGGER_PASSED == STD_ON)
  if (Dem_Cfg_EventAgingTarget(EventId) == 0)
#endif
  {
#if (DEM_CFG_AGING_00_START_TRIGGER_PASSED == STD_ON)
# if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
    if (Dem_Esm_TestDtcHealed(EventId) == TRUE)
# endif
    {
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID != lEventContext.GroupId)
      {
        if ( (DEM_ESM_TEST_UDS_STATUS_TF(lEventContext.NewDtcStatus) == FALSE)
          && (DEM_ESM_TEST_UDS_STATUS_TNCTOC(lEventContext.NewDtcStatus) == FALSE)
#  if (DEM_CFG_AGING_00_START_TESTS_TFTOC == STD_ON)
          && (DEM_ESM_TEST_UDS_STATUS_TFTOC(lEventContext.NewDtcStatus) == FALSE)
#  endif
          )
        {
          Dem_Esm_EventAgingStartZeroTarget(EventId);
        }
      }
      else
# endif
      {
# if (DEM_CFG_AGING_00_START_TESTS_TFTOC == STD_ON)
        if (DEM_ESM_TEST_UDS_STATUS_TFTOC(lEventContext.NewEventStatus) == FALSE)
# endif
        {
          Dem_Esm_EventAgingStartZeroTarget(EventId);
        }
      }
    }
#endif
  }
#if (DEM_CFG_AGING_START_TRIGGER_PASSED == STD_ON)
  else
  {
# if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
    if (Dem_Esm_TestDtcHealed(EventId) == TRUE)
# endif
    {
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID != lEventContext.GroupId)
      {
        if ( (DEM_ESM_TEST_UDS_STATUS_TF(lEventContext.NewDtcStatus) == FALSE)
          && (DEM_ESM_TEST_UDS_STATUS_TNCTOC(lEventContext.NewDtcStatus) == FALSE)
#  if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_ON)
          && (DEM_ESM_TEST_UDS_STATUS_TFTOC(lEventContext.NewDtcStatus) == FALSE)
#  endif
          )
        {
          Dem_Esm_EventAgingStartMultiTarget(EventId);
        }
      }
      else
# endif
      {
# if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_ON)
        if (DEM_ESM_TEST_UDS_STATUS_TFTOC(lEventContext.NewEventStatus) == FALSE)
# endif
        {
          Dem_Esm_EventAgingStartMultiTarget(EventId);
        }
      }
    }
  }
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_PrestorageDiscard();
#endif
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_Esm_EventTestConfirmed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventTestConfirmed(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Design */
  )
{
  boolean lReturnValue;
  lReturnValue = FALSE;

  {
# if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
    if (Dem_Mem_EventGetTripCount(EventContext->EventId) >= Dem_Cfg_EventTripTarget(EventContext->EventId))
    {
      /* multi-trip target reached */
      lReturnValue = TRUE;
    }
# else
    if ( (0 == Dem_Cfg_EventTripTarget(EventContext->EventId))
      || ( (FALSE != (DEM_ESM_TEST_UDS_STATUS_PDTC(EventContext->OldEventStatus)))
        && (FALSE != (EventContext->EventEffects & DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE))) )
    {
      /* event is either configured as single-trip, or event has tripped twice */
      lReturnValue = TRUE;
    }
# endif
  }

  return lReturnValue;
}

/* ****************************************************************************
 % Dem_Esm_EventFailed_ProcessPending
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessPending(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  )
{
  /* Confirm n cycles after pending was set */
  if (FALSE == DEM_ESM_TEST_UDS_STATUS_PDTC(EventContext->OldEventStatus))
  { /* Not yet pending, set pending independently of TFTOC */
    EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_PENDING);                                  /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_PDTC(EventContext->OldDtcStatus))
    {
      EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_PENDING);                                    /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
#endif

#if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
    /* Initialize trip counter */
    Dem_Mem_EventSetTripCount(EventContext->EventId, 0);
#endif

  }
#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON) && (DEM_CFG_PROCESS_PDTC_ALL_DTC == STD_ON)
  else if (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(EventContext->EventId)) == DEM_ESM_STORED_STATUS_NONE)
  {
    EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_PENDING);                                  /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_PENDING);                                      /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# endif
  }
#endif
  else
  {
    /* Nothing to do */
  }
}

/* ****************************************************************************
 % Dem_Esm_EventFailed_ProcessConfirmed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessConfirmed(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC)  EventContext
  )
{
  boolean lEventConfirmed;
  lEventConfirmed = Dem_Esm_EventTestConfirmed(EventContext);                                                                    /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  if (FALSE != lEventConfirmed)
  { /* Event has confirmed */
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_WIR(EventContext->OldEventStatus))
    {
      Dem_Cfg_EventIndicatorIterType lIndicatorIter;

      Dem_Cfg_EventIndicatorIterInit(EventContext->EventId, &lIndicatorIter);                                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if ( (Dem_Cfg_EventIndicatorIterExists(&lIndicatorIter) == TRUE)                                                           /* PRQA S 3415 */ /* MD_DEM_12.4_cf */ /* SBSW_DEM_CALL_ITERATOR_POINTER */
        || (Dem_Cfg_EventSpecialIndicator(EventContext->EventId) != DEM_CFG_SPECIAL_INDICATOR_NONE) )
      {
        EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_INDICATOR);                            /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
        if (FALSE == DEM_ESM_TEST_UDS_STATUS_WIR(EventContext->OldDtcStatus))
        {
          EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_INDICATOR);                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
# endif
      }
    }
#endif

    if (FALSE == DEM_ESM_TEST_UDS_STATUS_CDTC(EventContext->OldEventStatus))
    {
      EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_CONFIRMED);                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      if (FALSE == DEM_ESM_TEST_UDS_STATUS_CDTC(EventContext->OldDtcStatus))
      {
        EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_CONFIRMED);                                /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
#endif
    } /* else: No transition for confirmed dtc, so no update */
#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON) && (DEM_CFG_PROCESS_CDTC_ALL_DTC == STD_ON)
    else if (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(EventContext->EventId)) == DEM_ESM_STORED_STATUS_NONE)
    {
      EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_CONFIRMED);                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_CONFIRMED);                                  /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# endif
    }
#endif
    else
    {
      /* Nothing to do */
    }
  } /* else: not yet confirmed, no further action */
}

/* ****************************************************************************
 % Dem_Esm_EventFailed_ProcessStorage
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventFailed_ProcessStorage(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_Cfg_EventInternalStatusType lInternalStatus;
  boolean lIsOccurrence;
  uint8 lBlockModification;
#if (DEM_CFG_SUPPORT_NVM_WRITELIMIT == STD_ON)
  uint16 lOldOccurrenceCount;
#endif

  lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
  lInternalStatus = Dem_Util_DtcGetInternalStatus(EventContext->EventId);
  lIsOccurrence = FALSE;                                                                                                         /* PRQA S 3198 */ /* MD_DEM_3198_fp */
  lBlockModification = DEM_DATA_NO_CHANGES;

  if (DEM_ESM_STORED_STATUS_NONE == Dem_Mem_GetStoredStatus(lInternalStatus))
  { /* Not stored yet - If no entry can be created we need to discard some updates */
#if (DEM_CFG_SUPPORT_NVM_WRITELIMIT == STD_ON)
    lOldOccurrenceCount = 0;
#endif
    if ((Dem_Esm_SelectStorageEffects(EventContext) & DEM_ESM_EVENT_STORAGE_TRIGGER) != 0)
    { /* We have to store this event in memory */
      lMemoryIndex = Dem_Esm_EventCreateMemory(EventContext->EventId);
    }
    if (DEM_MEM_INVALID_MEMORY_INDEX == lMemoryIndex)
    { /* Storage was not possible, discard changes that require storage */
      EventContext->EventEffects = (uint8)(EventContext->EventEffects & DEM_ESM_EVENT_RESET_TRIGGER_MASK);                       /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      EventContext->DtcEffects = (uint8)(EventContext->DtcEffects & DEM_ESM_EVENT_RESET_TRIGGER_MASK);                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
    }
    else
    {
      /* Make sure failed update data is correctly stored for first time entry */
      EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_TESTFAILED);                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
      EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_TESTFAILED);                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
    }
  }
  else
  { /* Already stored - Update the existing entry if necessary */
    Dem_Mem_MemoryInfoPtrType lMemoryInfo;

    lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventContext->EventId));
    lMemoryIndex = Dem_Mem_MemoryFindIndex_Checked(lMemoryInfo, EventContext->EventId);                                          /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
    if (DEM_ESM_STORED_STATUS_AGED == Dem_Mem_GetStoredStatus(lInternalStatus))
    {
      if ((Dem_Esm_SelectStorageEffects(EventContext) & DEM_ESM_EVENT_STORAGE_TRIGGER) != 0)
      { /* Reclaim aged event */
        lIsOccurrence = TRUE;
        lBlockModification = Dem_Esm_EventUpdateMemory(EventContext->EventId, lMemoryIndex, lIsOccurrence);
      }
    }
    else
#endif
    {
      lIsOccurrence = (boolean)((Dem_Esm_SelectStorageEffects(EventContext) & DEM_ESM_EVENT_UPDATE_TRIGGER) != 0);
      lBlockModification = Dem_Esm_EventUpdateMemory(EventContext->EventId, lMemoryIndex, lIsOccurrence);
    }
#if (DEM_CFG_SUPPORT_NVM_WRITELIMIT == STD_ON)
    lOldOccurrenceCount = Dem_Mem_EntryGetOccurrenceCount(Dem_Mem_MemoryGetEntry(lMemoryIndex));
#endif
  }

  lBlockModification |= Dem_Data_EntryUpdate(EventContext->EventId, Dem_Esm_SelectStorageEffects(EventContext), lMemoryIndex);

  if ( (lIsOccurrence == TRUE)                                                                                                   /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && (Dem_Cfg_EventSupportImmediateNv(EventContext->EventId) == TRUE) )
  {
    /* #100 If the event is configured for immediate NV updates, set the entries NV state to immediate update */
#if (DEM_CFG_SUPPORT_NVM_WRITELIMIT == STD_ON)
    uint16 lNewOccurrenceCount;
    lNewOccurrenceCount = Dem_Mem_EntryGetOccurrenceCount(Dem_Mem_MemoryGetEntry(lMemoryIndex));
    if ( (lNewOccurrenceCount > Dem_Cfg_GlobalNvStorageLimit())                                                                  /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      || ( (lNewOccurrenceCount == Dem_Cfg_GlobalNvStorageLimit())
        && (lNewOccurrenceCount == lOldOccurrenceCount) ) )
    {
      Dem_Mem_SetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
    }
    else
#endif
    {
      Dem_Mem_SetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE);
    }
  }
  else
  if (lBlockModification != DEM_DATA_NO_CHANGES)
  {
    /* #110 Otherwise set the entries NV state to 'DIRTY' */
    Dem_Mem_SetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
  }
  else
  {
    /* MISRA */
  }

  return (boolean)DEM_DATA_TEST_USERDATA_CHANGED(lBlockModification);
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventFailed_CommitToMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_CommitToMemory(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  )
{
  Dem_Cfg_EventInternalStatusType lNewInternalStatus;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* We cannot simply store the status byte, synchronous modifications may have
   * modified it. Instead, reapply modified bits on the current status value */
  EventContext->NewEventStatus = Dem_Mem_EventGetStatus(EventContext->EventId);                                                  /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  EventContext->OldEventStatus = EventContext->NewEventStatus;                                                                   /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  lNewInternalStatus = Dem_Util_DtcGetInternalStatus(EventContext->EventId);

  if (DEM_ESM_STORED_STATUS_NONE != Dem_Mem_GetStoredStatus(lNewInternalStatus))
  {
#if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON)
    EventContext->NewEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(EventContext->NewEventStatus);                                   /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#endif
    lNewInternalStatus = Dem_Mem_SetStoredStatus(lNewInternalStatus, DEM_ESM_STORED_STATUS_ACTIVE);
    Dem_Util_DtcSetInternalStatus(EventContext->EventId, lNewInternalStatus);
  }
  if (0 != (EventContext->EventEffects & DEM_CFG_TRIGGER_PENDING))
  {
    EventContext->NewEventStatus = DEM_ESM_SET_UDS_STATUS_PDTC(EventContext->NewEventStatus);                                    /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  if (0 != (EventContext->EventEffects & DEM_CFG_TRIGGER_CONFIRMED))
  {
    EventContext->NewEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(EventContext->NewEventStatus);                                    /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  if (0 != (EventContext->EventEffects & DEM_CFG_TRIGGER_INDICATOR))
  {
    EventContext->NewEventStatus = DEM_ESM_SET_UDS_STATUS_WIR(EventContext->NewEventStatus);                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    {
# if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)                                                                                 /* COV_MSR_UNSUPPORTED TX */
      Dem_Esm_UserIndicatorEnable(EventContext->EventId);
# endif
    }
  }
#endif /* (DEM_FEATURE_NEED_INDICATORS == STD_ON) */

  Dem_Mem_EventSetStatus(EventContext->EventId, EventContext->NewEventStatus);
  /* Status block will later be marked unconditionally */

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  if (DEM_CFG_COMBINED_GROUP_INVALID != EventContext->GroupId)
  {
    EventContext->NewDtcStatus = Dem_Data_CombinedGroupGetStatus(EventContext->GroupId);                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    Dem_Mem_CombinedGroupSetStatus(EventContext->GroupId, EventContext->NewDtcStatus);
  }
  else
  {
    EventContext->NewDtcStatus = EventContext->NewEventStatus;                                                                   /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
#endif

}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventFailed_ProcessNotifications
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessNotifications(
  CONSTP2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC)  EventContext,                                                      /* PRQA S 3673 */ /* MD_DEM_16.7_Design */
  CONST(boolean, AUTOMATIC)  DataModified
  )
{
  if (EventContext->OldEventStatus != EventContext->NewEventStatus)
  {
    Dem_Cbk_StatusChanged(EventContext->EventId, EventContext->OldEventStatus, EventContext->NewEventStatus);
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    Dem_Cbk_DtcStatusChanged(EventContext->EventId, EventContext->OldDtcStatus, EventContext->NewDtcStatus, DEM_CBK_DTC_UPDATED);
#else
    Dem_Cbk_DtcStatusChanged(EventContext->EventId, EventContext->OldEventStatus, EventContext->NewEventStatus, DEM_CBK_DTC_UPDATED);
#endif
  }

  if (FALSE != DataModified)
  {
    Dem_Cbk_EventDataChanged(EventContext->EventId);
  }
}

/* ****************************************************************************
 % Dem_Esm_EventOpCycleStart
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleStart(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);

  lNewEventStatus = lOldEventStatus;
#if (DEM_CFG_SUPPORT_CLEAR_TESTFAILED_ON_OPCYCLE == STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lNewEventStatus);
#endif
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TFTOC(lNewEventStatus);
  lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TNCTOC(lNewEventStatus);

  Dem_Mem_EventSetStatus(EventId, lNewEventStatus);

#if (DEM_CFG_SUPPORT_IUMPR == STD_ON)
  {
    Dem_RatioIdIndexType lRatioIndex;
    lRatioIndex = Dem_Cfg_EventRatioIdIdx(EventId);

    if (lRatioIndex != DEM_CFG_RATIOINDEX_INVALID)
    {
      /* reset all status bits of this ratio to the following setting:
       * - denominator not incremented
       * - denominator conditions not fulfilled
       * - denominator not locked
       * - numerator not incremented
       * - numerator conditions not fulfilled (no fault detected / detectable)
       * - ratio not locked by suppression
       * - ratio not locked by pending FID
       */
      Dem_Mem_SetIumprStatus(lRatioIndex, 0);
    }
  }
#endif

#if ( (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_FEATURE_NEED_CYCLEAUTOMATICEND == STD_ON) \
   || (DEM_CFG_SUPPORT_RESTART_CYCLE == STD_ON) )                                                                                /* COV_MSR_UNSUPPORTED TF xf tf tf */
  if (Dem_InitState == DEM_INIT_INITIALIZED)
#endif
  {
    Dem_Esm_EventResetDebounceValues(EventId);

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    {
      Dem_Cfg_EventInternalStatusType lInternalStatus;
      lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
      lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
      lInternalStatus = Dem_Mem_ResetFdcTripStatus(lInternalStatus);
      lInternalStatus = Dem_Mem_ResetFdcMaxStatus(lInternalStatus);
      lInternalStatus = Dem_Mem_ResetFdcTocStatus(lInternalStatus);
      Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
    }
    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */

#endif
  }

}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventHealed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventHealed(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,                                                                                    /* PRQA S 3112 */ /* MD_DEM_14.2 */
  CONST(uint8, AUTOMATIC)  EventStatus
  )
{
  uint8 lNewEventStatus;
#if (DEM_FEATURE_NEED_SPECIAL_INDICATORS == STD_ON)                                                                              /* COV_MSR_UNSUPPORTED XF */
  uint8 lSpecialIndicator;
# if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_PID21 == STD_ON)
  uint8 lOldMilIndicatorState = Dem_Util_GlobalSpecialIndicatorState(Dem_Cfg_GlobalMilIndicator());
# endif
#endif

  DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_WIR(EventStatus);

#if (DEM_FEATURE_NEED_OBD == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED XF */
  if (Dem_Cfg_GlobalMilIndicator() == Dem_Cfg_EventSpecialIndicator(EventId))
  { /* only OBD related events supports the qualification of Confirmed and WIR bit */
    Dem_Mem_EventSetQualifyStatus(EventId, DEM_ESM_RESET_QUALIFY_STATUS_WIR(Dem_Mem_EventGetQualifyStatus(EventId)));
  }
#endif

#if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON) || (DEM_FEATURE_NEED_SPECIAL_INDICATORS == STD_ON)
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

# if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)                                                                                 /* COV_MSR_UNSUPPORTED TX */
  Dem_Esm_UserIndicatorDisable(EventId);
# endif
# if (DEM_FEATURE_NEED_SPECIAL_INDICATORS == STD_ON)                                                                             /* COV_MSR_UNSUPPORTED XF */
  lSpecialIndicator = Dem_Esm_SpecialIndicatorDisable(EventId);
# endif
  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
#endif

#if (DEM_FEATURE_NEED_SPECIAL_INDICATORS == STD_ON)
  if (DEM_CFG_SPECIAL_INDICATOR_NONE != lSpecialIndicator)
  { /* Special indicator was modified, recalculate new state */
    Dem_Mem_UpdateGlobalSpecialIndicatorStates(lSpecialIndicator);
# if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_PID21 == STD_ON)
    if (Dem_Cfg_GlobalMilIndicator() == lSpecialIndicator)
    {
      if ( (lOldMilIndicatorState != DEM_INDICATOR_OFF)                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Util_GlobalSpecialIndicatorState(Dem_Cfg_GlobalMilIndicator()) == DEM_INDICATOR_OFF) )
      { /* MIL indicator has changed to OFF */
        Dem_Esm_GlobalMilStateDisable();
      }
    }
# endif
  }
#endif
  return lNewEventStatus;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventProcessHealing
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventProcessHealing(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventStatus
  )
{
  uint8 lNewEventStatus;

  lNewEventStatus = EventStatus;
#if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
  if (Dem_Mem_EventGetTripCount(EventId) > 0)
  { /* Continue healing */
    Dem_Mem_EventSetTripCount(EventId, (uint8)(Dem_Mem_EventGetTripCount(EventId) - 1));
  }
  if (Dem_Mem_EventGetTripCount(EventId) == 0)
  {
    if (DEM_ESM_TEST_UDS_STATUS_WIR(EventStatus) == TRUE)
    { /* Healing target reached -> heal all related indicators */
      lNewEventStatus = Dem_Esm_EventHealed(EventId, EventStatus);
    }
  }
#else
  if (DEM_ESM_TEST_UDS_STATUS_WIR(EventStatus) == TRUE)
  { /* Healing target reached -> heal all related indicators */
    lNewEventStatus = Dem_Esm_EventHealed(EventId, lNewEventStatus);
  }
#endif

  return lNewEventStatus;
}

/* ****************************************************************************
 % Dem_Esm_EventOpCycleEnd_Healing
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventOpCycleEnd_Healing(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventStatus
  )
{
  boolean lEventMayAge;
  uint8 lNewEventStatus;

  lEventMayAge = FALSE;
  lNewEventStatus = EventStatus;

  if (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(lNewEventStatus))
  {
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TFTOC(lNewEventStatus))
    { /* Event tested this operation cycle and was not failed, reset pending state */
#if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON) || (DEM_FEATURE_NEED_MIL_GROUPS == STD_ON)
      if (FALSE != DEM_ESM_TEST_UDS_STATUS_PDTC(lNewEventStatus))
      {
# if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
        Dem_Mem_EventSetTripCount(EventId, Dem_Cfg_EventHealingTarget(EventId));
# endif
# if (DEM_FEATURE_NEED_MIL_GROUPS == STD_ON)
        /* pending bit was set before and is now reset: reduce number of pending events in MIL group */
        if (DEM_CFG_MIL_GROUP_INVALID != Dem_Cfg_EventMilGroupIndex(EventId) )
        {
#  if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
          if (Dem_Mem_GetMilGroupPendingCount(Dem_Cfg_EventMilGroupIndex(EventId)) <= 0)
          {
            Dem_RunTimeCheckFailed(__LINE__);
          }
#  endif
          Dem_Mem_DecrementMilGroupPendingCount(Dem_Cfg_EventMilGroupIndex(EventId));
        }
# endif
      }
#endif
      lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lNewEventStatus);
      lNewEventStatus = Dem_Esm_EventProcessHealing(EventId, lNewEventStatus);

#if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      if ( (Dem_Esm_TestEventHealed(EventId, lNewEventStatus) == TRUE)                                                           /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        )
#endif
#if (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      {
        lEventMayAge = TRUE;
      }
#endif
    }
#if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
    else
    {
      /* test failed: increment trip counter if trip target has not yet been reached */
      if (Dem_Mem_EventGetTripCount(EventId) < Dem_Cfg_EventTripTarget(EventId))
      {
        Dem_Mem_EventSetTripCount(EventId, (uint8)(Dem_Mem_EventGetTripCount(EventId) + 1));
      }
    }
#endif

    Dem_Mem_EventSetStatus(EventId, lNewEventStatus);
  }

  return lEventMayAge;
}                                                                                                                                /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

#if (DEM_FEATURE_NEED_AGING_TRIGGER_CYCLE == STD_ON) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventOpCycleEnd_Aging
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleEnd_Aging(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventStatus,
  CONST(uint8, AUTOMATIC)  OldDtcStatus                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  /* Argument unused in some configurations */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(OldDtcStatus)                                                                                 /* PRQA S 3112 */ /* MD_DEM_14.2 */

# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  if (Dem_Cfg_EventCombinedGroup(EventId) != DEM_CFG_COMBINED_GROUP_INVALID)
  {
    if (Dem_Cfg_EventAgingTarget(EventId) == 0)
    {
#  if (DEM_CFG_AGING_00_START_TRIGGER_PASSED == STD_OFF) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      if ( (DEM_ESM_TEST_UDS_STATUS_TNCTOC(OldDtcStatus) == FALSE)                                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
#   if (DEM_CFG_AGING_00_START_TESTS_TFTOC == STD_ON)
        && (DEM_ESM_TEST_UDS_STATUS_TFTOC(OldDtcStatus) == FALSE)
#   else
        && (DEM_ESM_TEST_UDS_STATUS_TF(OldDtcStatus) == FALSE)
#   endif
#   if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
        && ( (Dem_Esm_TestDtcHealed(EventId) == TRUE)
        )
#   endif
        )
      {
        Dem_Esm_EventAgingStartZeroTarget(EventId);
      }
#  endif
    }
    else
    {
#  if (DEM_CFG_AGING_START_TRIGGER_PASSED == STD_OFF) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      if ( (DEM_ESM_TEST_UDS_STATUS_TNCTOC(OldDtcStatus) == FALSE)                                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
#   if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_ON)
        && (DEM_ESM_TEST_UDS_STATUS_TFTOC(OldDtcStatus) == FALSE)
#   else
        && (DEM_ESM_TEST_UDS_STATUS_TF(OldDtcStatus) == FALSE)
#   endif
#   if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
        && ( (Dem_Esm_TestDtcHealed(EventId) == TRUE)
        )
#   endif
        )
      {
        Dem_Esm_EventAgingStartMultiTarget(EventId);
      }
#  endif
    }
  }
  else
# endif
  {
    if (Dem_Cfg_EventAgingTarget(EventId) == 0)
    {
# if (DEM_CFG_AGING_00_START_TRIGGER_PASSED == STD_OFF) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      if ( (DEM_ESM_TEST_UDS_STATUS_TNCTOC(EventStatus) == FALSE)
#  if (DEM_CFG_AGING_00_START_TESTS_TFTOC == STD_ON)
        && (DEM_ESM_TEST_UDS_STATUS_TFTOC(EventStatus) == FALSE)
#  else
        && (DEM_ESM_TEST_UDS_STATUS_TF(EventStatus) == FALSE)
#  endif
        )
      {
        Dem_Esm_EventAgingStartZeroTarget(EventId);
      }
# endif
    }
    else
    {
# if (DEM_CFG_AGING_START_TRIGGER_PASSED == STD_OFF) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      if ( (DEM_ESM_TEST_UDS_STATUS_TNCTOC(EventStatus) == FALSE)
#  if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_ON)
        && (DEM_ESM_TEST_UDS_STATUS_TFTOC(EventStatus) == FALSE)
#  else
        && (DEM_ESM_TEST_UDS_STATUS_TF(EventStatus) == FALSE)
#  endif
        )
      {
        Dem_Esm_EventAgingStartMultiTarget(EventId);
      }
# endif
    }
  }
}
#endif

/* ****************************************************************************
 % Dem_Esm_EventOpCycleEnd
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleEnd(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  OldDtcStatus                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
)
{
  uint8 lEventStatus;
#if (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
  boolean lEventMayAge;
#endif

  /* Argument unused in some configurations */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(OldDtcStatus)                                                                                 /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lEventStatus = Dem_Mem_EventGetStatus(EventId);
#if (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
  lEventMayAge = Dem_Esm_EventOpCycleEnd_Healing(EventId, lEventStatus);
#else
  (void)Dem_Esm_EventOpCycleEnd_Healing(EventId, lEventStatus);
#endif

#if (DEM_FEATURE_NEED_AGING_TRIGGER_CYCLE == STD_ON) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
# if (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
  if (lEventMayAge == TRUE)
# endif
  {
    Dem_Esm_EventOpCycleEnd_Aging(EventId, lEventStatus, OldDtcStatus);
  }
#endif
}

#if ((DEM_CFG_AGING_NEXT_TESTS_TNCTOC == STD_ON) || (DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON))
/* ****************************************************************************
 % Dem_Esm_TestStatusForAgingCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestStatusForAgingCycle(
  CONST(uint8, AUTOMATIC)  EventStatus
  )
{
  return (boolean)(
# if (DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON)
    (FALSE == DEM_ESM_TEST_UDS_STATUS_TFTOC(EventStatus))
      &&
# endif
    (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(EventStatus)) );
}
#endif

/* ****************************************************************************
 % Dem_Esm_EventAgingCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingCycle(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint16, AUTOMATIC)  CycleCounter,
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex
  )
{
  uint8 lDtcStatus;

  lDtcStatus = Dem_Util_DtcGetStatus(EventId);

  if (DEM_ESM_TEST_UDS_STATUS_TF(lDtcStatus) == FALSE)
  { /* passive event */
    Dem_Mem_EntryPtrType lEntry;
    lEntry = Dem_Mem_MemoryGetEntry(MemoryIndex);

#if ((DEM_CFG_AGING_NEXT_TESTS_TNCTOC == STD_ON) || (DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON))
    if (Dem_Esm_TestStatusForAgingCycle(lDtcStatus) == FALSE)
    { /* Untested cycle requires recalculation of aging target */
      uint16 lCycleCount = Dem_Mem_EntryGetAgingCount(lEntry);
      if (lCycleCount <= DEM_ESM_CYCLECOUNT_MAX)
      { /* Ignore maxed (latched) counter */
        lCycleCount = Dem_Esm_AddCycleCount(lCycleCount, 1);
        Dem_Mem_EntrySetAgingCount(lEntry, lCycleCount);                                                                         /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */

        Dem_Mem_MemorySetBlockState(MemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
      }
    }
    else
#endif
    if (CycleCounter == Dem_Mem_EntryGetAgingCount(lEntry))
    { /* Aging cycle reached, so this event has aged */
      Dem_Esm_EventAged(EventId, MemoryIndex);
    }
    else
    { /* Still counting */ }
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventCleared_Optional
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventCleared_Optional(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  boolean lDoClear;
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
# endif

# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  lDoClear = TRUE;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_CombinedGroupIterType lGroupIter;
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lGroupIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterExists(&lGroupIter) == TRUE;                                                                   /* PRQA S 3415 */ /* MD_DEM_12.4_cf */ /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterNext(&lGroupIter))                                                                             /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lGroupIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)
      {
        if (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE)
        {
          lDoClear = Dem_Util_CallClearEventAllowed(lSubEventId);
        }
      }
      if (lDoClear == FALSE)
      {
        break;
      }
    }
  }
  else
# endif
  {
    lDoClear = Dem_Util_CallClearEventAllowed(EventId);
  }

  if (FALSE != lDoClear)
  {
    Dem_Esm_EventCleared_Internal(EventId);
  }

  /* Always call init monitor callbacks */
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_CombinedGroupIterType lGroupIter;
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lGroupIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterExists(&lGroupIter) == TRUE;                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterNext(&lGroupIter))                                                                             /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lGroupIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)
      {
        if (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE)
        {
          Dem_Cbk_InitMonitorForEvent(lSubEventId, DEM_INIT_MONITOR_CLEAR);
        }
      }
    }
  }
  else
# endif
  {
    Dem_Cbk_InitMonitorForEvent(EventId, DEM_INIT_MONITOR_CLEAR);
  }

  Dem_Cbk_InitMonitorForFunction(EventId);

  return lDoClear;
}                                                                                                                                /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#endif

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED != STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventCleared_Always
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventCleared_Always(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
# endif

  Dem_Esm_EventCleared_Internal(EventId);

  /* Always call init monitor callbacks */
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_CombinedGroupIterType lGroupIter;
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lGroupIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterExists(&lGroupIter) == TRUE;                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_CombinedGroupIterNext(&lGroupIter))                                                                             /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lGroupIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)
      {
        if (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE)
        {
          Dem_Cbk_InitMonitorForEvent(lSubEventId, DEM_INIT_MONITOR_CLEAR);
        }
      }
    }
  }
  else
# endif
  {
    Dem_Cbk_InitMonitorForEvent(EventId, DEM_INIT_MONITOR_CLEAR);
  }
  Dem_Cbk_InitMonitorForFunction(EventId);
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_CFG_NOTIFY_CLEAR_ALLOWED != STD_ON) */

#if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_RESTART_DCY_ON_CLEAR_DTC == STD_ON)                                     /* COV_MSR_UNSUPPORTED XF xf xf */
/* ****************************************************************************
 % Dem_Esm_PreOnClear_AllDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PreOnClear_AllDtc(
  CONST(uint8, AUTOMATIC)  MemoryId
  )
{
  if (DEM_CFG_MEMORYID_PRIMARY == MemoryId)
  {
    Dem_Esm_CycleUpdate(Dem_Cfg_GlobalObdDrivingCycleId(), DEM_QUEUE_CYCLE_RESTARTED);
  }
}
#endif

/* ****************************************************************************
 % Dem_Esm_PostOnClear_AllDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PostOnClear_AllDtc(
  CONST(uint8, AUTOMATIC)  MemoryId
  )
{
#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
  Dem_Mem_ResetOverflow(MemoryId);
#endif

  if (DEM_CFG_MEMORYID_PRIMARY == MemoryId)
  {
    Dem_Mem_SetFirstFailedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetFirstConfirmedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetMostRecentFailedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetMostRecentConfmdEvent(DEM_EVENT_INVALID);
  }
}

/* ****************************************************************************
 % Dem_Esm_PostOnClear_Always
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PostOnClear_Always(
  CONST(uint8, AUTOMATIC)  MemoryId                                                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(MemoryId)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
  /* copy debounce values from debounce array to nvram mirror */
  Dem_Mem_CopyDataDebounceNv();
  Dem_Mem_DebounceSetBlockState(DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
#endif

  Dem_Mem_AdminSetBlockState(DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisplaced
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisplaced(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Util_ForEachCombinedArgType lArgs;
  Dem_Util_ForEachCombinedEvent(EventId, Dem_Esm_EventDisplaced_Internal, &lArgs);                                               /* SBSW_DEM_CALL_FOREACH_COMBINED_EVENT */

# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  {
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      Dem_Cfg_EventInternalStatusType lInternalStatus;
      lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
      lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_NONE);
      Dem_Mem_CombinedGroupSetStatus(lGroupId, lArgs.Common.NewDtcStatus);
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lInternalStatus);
    }
  }
# endif
  /* Call status changed notifications (there is always a change) */
  Dem_Cbk_DtcStatusChanged(EventId, lArgs.Common.OldDtcStatus, lArgs.Common.NewDtcStatus, DEM_CBK_DTC_DISPLACED);
}
#endif

/* ****************************************************************************
 % Dem_Esm_CycleUpdateStored
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdateStored(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint16, AUTOMATIC)  CycleCounter
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_Cfg_MemoryIndexType lMemoryIndexEnd;
  /* Iterate through the primary indices - the chronological index becomes
      invalid in case an event ages */
  lMemoryIndexEnd = Dem_Mem_MemoryIndexAll_End();
  for (lMemoryIndex = Dem_Mem_MemoryIndexAll_Begin(); lMemoryIndex < lMemoryIndexEnd; ++lMemoryIndex)
  {
    Dem_Mem_EntryPtrType lEntry;
    Dem_EventIdType lEventId;

    lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);
    lEventId = Dem_Mem_EntryGetEventId(lEntry);
    if (Dem_Util_TestEventValid(lEventId) == TRUE)
    {
      if (Dem_Cfg_EventAgingCycle(lEventId) == CycleId)
      {
        Dem_Esm_EventAgingCycle(lEventId, CycleCounter, lMemoryIndex);
      }
#if (DEM_FEATURE_NEED_CYCLE_COUNTERS == STD_ON)
      if (Dem_Cfg_EventOperationCycle(lEventId) == CycleId)
      {
        boolean lDirty;
        lDirty = Dem_Data_EntryOpCycleStart(lEntry, CycleCounter);                                                               /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
        if (FALSE != lDirty)
        {
          Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
        }
      }
#endif
    }
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_CycleUpdateReadiness
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdateReadiness(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint8, AUTOMATIC)  CycleStatus
  )
{
  Dem_EventIdType lEventId;

  /* Perform transitions due to cycle end or tick */

  for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
  {
    Dem_Util_ForEachCombinedArgType lArgs;

    if (Dem_Cfg_EventOperationCycle(lEventId) != CycleId)
    { /* Event needs to depend on the modified cycle */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE == Dem_Cal_TestDtcAvailableInVariant(lEventId))
    { /* Don't process unavailable DTCs */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
#endif
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    if (Dem_Util_DtcGetMasterEvent(lEventId) != lEventId)
    { /* Make sure to only process each event once */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
#endif
    if (Dem_Mem_TestEventDisconnectedStatus(Dem_Util_DtcGetInternalStatus(lEventId)) == TRUE)
    { /* Don't process unavailable DTCs */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }

#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
    Dem_Data_DtcOpCycleUpdate(
       lEventId,
       Dem_Util_DtcApplyCombinedStatus(Dem_Util_DtcGetStatus(lEventId)),
       CycleStatus
    );
#endif

    lArgs.Specific.EventOpCycle_Internal.CycleStatus = CycleStatus;
    Dem_Util_ForEachCombinedEvent(lEventId, Dem_Esm_EventOpCycle_Internal, &lArgs);                                              /* SBSW_DEM_CALL_FOREACH_COMBINED_EVENT */

    /* Skip notifications if the cycle started was during Dem_Init - the
       environment is not initialized yet and cannot handle callbacks */
    if (Dem_InitState == DEM_INIT_INITIALIZED)
    {
      if (lArgs.Common.OldDtcStatus != lArgs.Common.NewDtcStatus)
      { /* Call notifications only if event status has changed */
        Dem_Cbk_DtcStatusChanged(lEventId, lArgs.Common.OldDtcStatus, lArgs.Common.NewDtcStatus, DEM_CBK_DTC_REINIT);
      }
      /* Call Init Monitor Callbacks */
      Dem_Cbk_InitMonitorForFunction(lEventId);
    }
  } /* while (lEventId > DEM_EVENT_INVALID) */

}                                                                                                                                /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

                                                                    /* Timer */
/* ------------------------------------------------------------------------- */
                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Queue_PreInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_PreInit(
  void
  )
{
  Dem_EventIdType lEventId;

  Dem_Queue_CycleState = 0U;
  Dem_Queue_CycleFlag = 0U;
  Dem_Queue_EventCount = 0U;
#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
  Dem_Queue_EventReadIndex = 0U;
  Dem_Queue_EventWriteIndex = 0U;
#endif

  for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
  {
    Dem_Queue_SetEventStatus(lEventId, 0U);
  }
}

/* ****************************************************************************
 % Dem_Queue_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_Init(
  void
  )
{
  Dem_Queue_SetClearState(DEM_QUEUE_CLEARSTATE_IDLE);
#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT== STD_ON)
  Dem_Queue_ClearEventIterator = DEM_EVENT_INVALID;
#endif
#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
  Dem_Queue_EnableConditionStates = Dem_Cfg_GlobalEnableCondInit();
#endif
}

/* ****************************************************************************
 % Dem_Queue_Shutdown
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_Shutdown(
  void
  )
{
  Dem_Queue_CycleState = 0U;
  Dem_Queue_CycleFlag = 0U;

}

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ProcessFilterEventData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessFilterEventData(
  void
  )
{
  Dem_EventIdType lEventId;

  lEventId = Dem_Dcm_FilterDataGetEventId();

  if (DEM_EVENT_INVALID != lEventId)
  {
    /* copy memory entry */
    if (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(lEventId)) == DEM_ESM_STORED_STATUS_NONE)
    { /* Event not stored - there is no data to be copied */
      /* Mark the buffer as unused - this can be used to verify the validity of statistic records */
      Dem_Cfg_ReadoutBuffer.EventId = DEM_EVENT_INVALID;
      /* Initialize 'no record stored', this allows a common test for the validity of stored records */
      Dem_Data_EntryInit(&Dem_Cfg_ReadoutBuffer);                                                                                /* SBSW_DEM_POINTER_FORWARD_GLOBAL */
    }
    else
    {
      Dem_Mem_MemoryInfoPtrType lMemoryInfo;
      Dem_Cfg_MemoryIndexType lMemoryIndex;

      lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Dcm_FilterDataGetMemoryId());
      lMemoryIndex = Dem_Mem_MemoryFindIndex_Checked(lMemoryInfo, lEventId);                                                     /* SBSW_DEM_CALL_MEMORYINFO_POINTER */

      if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
      {
        Dem_MemCpy((Dem_DataPtrType)(&Dem_Cfg_ReadoutBuffer),                                                                    /* PRQA S 0310, 3305, 0602 */ /* MD_DEM_11.4_cpy, MD_DEM_3305, MD_DEM_20.2 */ /* SBSW_DEM_POINTER_MEMCPY_READOUTBUFFER */
          (Dem_NvDataPtrType)(Dem_Mem_MemoryGetEntry(lMemoryIndex)),
          sizeof(Dem_Cfg_ReadoutBuffer));
      }
    }
  }

  Dem_Dcm_FilterDataSetState(DEM_DCM_FILTERDATA_READY);
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ProcessClearSingleDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Queue_ProcessClearSingleDtc(
  void
  )
{
  boolean lReturnValue;
  uint8 lClearState;

# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Dem_Queue_GetClearMemory() != Dem_Cfg_EventDestination(Dem_Queue_GetClearEvent()))
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
# endif

# if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
  lReturnValue = Dem_Esm_EventCleared_Optional(Dem_Queue_GetClearEvent());
# else
  Dem_Esm_EventCleared_Always(Dem_Queue_GetClearEvent());
  lReturnValue = TRUE;
# endif

# if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
  if (FALSE == lReturnValue)
  {
/* >>>> ------------------------------------- Enter Critical Section: DcmApi */
    Dem_EnterCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lClearState = Dem_Queue_GetClearState();
    lClearState = DEM_QUEUE_RESETCLEARSTATE_PENDING(lClearState);
    lClearState = DEM_QUEUE_SETCLEARSTATE_DONE(lClearState);
    lClearState = DEM_QUEUE_SETCLEARSTATE_FAILED(lClearState);
    Dem_Queue_SetClearState(lClearState);
    Dem_LeaveCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< ------------------------------------- Enter Critical Section: DcmApi */
  }
  else
# endif
  {
    Dem_Esm_PostOnClear_Always(Dem_Queue_GetClearMemory());
    Dem_Mem_StatusSetBlockState(DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
/* >>>> ------------------------------------- Enter Critical Section: DcmApi */
    Dem_EnterCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lClearState = Dem_Queue_GetClearState();
    lClearState = DEM_QUEUE_RESETCLEARSTATE_PENDING(lClearState);
    lClearState = DEM_QUEUE_SETCLEARSTATE_DONE(lClearState);
    Dem_Queue_SetClearState(lClearState);
    Dem_LeaveCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< ------------------------------------- Enter Critical Section: DcmApi */
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

/* ****************************************************************************
 % Dem_Queue_ProcessClearDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessClearDtc(
  void
  )
{
  Dem_Mem_MemoryInfoPtrType lMemoryInfo;
#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT == STD_ON)
  uint16 lEventLowerLimit;
#endif
#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
  boolean lClearSuccess;
#endif

  lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Queue_GetClearMemory());

#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
  if (DEM_EVENT_INVALID != Dem_Queue_GetClearEvent())
  { /* Clear single event */
    lClearSuccess = Dem_Queue_ProcessClearSingleDtc();
  }
  else
#endif
  { /* Clear group of events */
#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT == STD_ON)
    if (DEM_EVENT_INVALID == Dem_Queue_ClearEventIterator)
    { /* Not yet started */
      Dem_Queue_ClearEventIterator = Dem_Mem_MemoryGetLastEvent(lMemoryInfo);                                                    /* SBSW_DEM_CALL_MEMORYINFO_POINTER */

# if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_RESTART_DCY_ON_CLEAR_DTC == STD_ON)                                    /* COV_MSR_UNSUPPORTED XF xf xf */
      if (Dem_Queue_GetClearGroup() == DEM_CFG_GROUPMASK_ALLDTCS)
      {
        Dem_Esm_PreOnClear_AllDtc(Dem_Queue_GetClearMemory());
      }
# endif
    }

    if (Dem_Cfg_GlobalClearDtcRuntimeLimit() > Dem_Queue_ClearEventIterator)
    { /* At most delete all events to prevent overflow */
      lEventLowerLimit = (uint16)(Dem_Mem_MemoryGetFirstEvent(lMemoryInfo) - 1);                                                 /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
    }
    else
    {
      lEventLowerLimit = (uint16)(Dem_Queue_ClearEventIterator - Dem_Cfg_GlobalClearDtcRuntimeLimit());
# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
      if (lEventLowerLimit < Dem_Mem_MemoryGetFirstEvent(lMemoryInfo))                                                           /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
      {
        lEventLowerLimit = (uint16)(Dem_Mem_MemoryGetFirstEvent(lMemoryInfo) - 1);                                               /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
      }
# endif
    }

    {
      /* Attention: lEventLowerLimit is numerically smaller than current iterator */
      Dem_Queue_ProcessClearDtcGroup(lEventLowerLimit + 1, Dem_Queue_ClearEventIterator);
    }
    Dem_Queue_ClearEventIterator = lEventLowerLimit;
#else
# if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_RESTART_DCY_ON_CLEAR_DTC == STD_ON)                                    /* COV_MSR_UNSUPPORTED XF xf xf */
    if (Dem_Queue_GetClearGroup() == DEM_CFG_GROUPMASK_ALLDTCS)
    {
      Dem_Esm_PreOnClear_AllDtc(Dem_Queue_GetClearMemory());
    }
# endif
    {
      /* Attention: lEventLowerLimit is numerically smaller than current iterator */
      Dem_Queue_ProcessClearDtcGroup(Dem_Mem_MemoryGetFirstEvent(lMemoryInfo), Dem_Mem_MemoryGetLastEvent(lMemoryInfo));         /* SBSW_DEM_CALL_MEMORYINFO_POINTER */ /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
    }
#endif
#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
    lClearSuccess = TRUE;
#endif
  } /* Clear group of events */

#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT == STD_ON)
  if (Dem_Mem_MemoryGetFirstEvent(lMemoryInfo) > Dem_Queue_ClearEventIterator)                                                   /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
#endif
  {
#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
    if (FALSE != lClearSuccess)
#endif
    {
      uint8 lClearState;

#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT== STD_ON)
      Dem_Queue_ClearEventIterator = DEM_EVENT_INVALID;
#endif

      {
        if (Dem_Queue_GetClearGroup() == DEM_CFG_GROUPMASK_ALLDTCS)
        {
          Dem_Esm_PostOnClear_AllDtc(Dem_Queue_GetClearMemory());
        }
      }
      Dem_Esm_PostOnClear_Always(Dem_Queue_GetClearMemory());
      Dem_Mem_StatusSetBlockState(DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);

      /* Set state as last action because of concurrency */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
      Dem_EnterCritical_DcmApi();                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lClearState = Dem_Queue_GetClearState();
      lClearState = DEM_QUEUE_RESETCLEARSTATE_PENDING(lClearState);
      lClearState = DEM_QUEUE_SETCLEARSTATE_DONE(lClearState);
      Dem_Queue_SetClearState(lClearState);
      Dem_LeaveCritical_DcmApi();                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Enter Critical Section: DcmApi */
    }
  }
}                                                                                                                                /* PRQA S 6010, 6050, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCAL, MD_MSR_STCYC, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_Queue_ProcessEvent_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  QueueStatus
  )
{
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  if (DEM_QUEUE_TEST_FDCPROCESSING(QueueStatus) == TRUE)
  {
    Dem_Esm_ProcessFdc(EventId);
  }
#endif

  switch (DEM_QUEUE_GET_QUEUEACTION(QueueStatus))
  {
  case 1:
    Dem_Esm_EventPassed_Queued(EventId);
    break;
  case 2:
    Dem_Esm_EventPassed_Queued(EventId);
    Dem_Esm_EventFailed_Queued(EventId);
    break;
  case 3:
    Dem_Esm_EventPassed_Queued(EventId);
    Dem_Esm_EventFailed_Queued(EventId);
    Dem_Esm_EventPassed_Queued(EventId);
    break;

  case 5:
    Dem_Esm_EventFailed_Queued(EventId);
    break;
  case 6:
    Dem_Esm_EventFailed_Queued(EventId);
    Dem_Esm_EventPassed_Queued(EventId);
    break;
  case 7:
    Dem_Esm_EventFailed_Queued(EventId);
    Dem_Esm_EventPassed_Queued(EventId);
    Dem_Esm_EventFailed_Queued(EventId);
    break;

  default:
    /* No action */
    break;
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Queue_ProcessEvent_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  QueueStatus
  )
{
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  if (DEM_QUEUE_TEST_FDCPROCESSING(QueueStatus) == TRUE)
  {
    Dem_Esm_ProcessFdc(EventId);
  }
#endif

  switch (DEM_QUEUE_GET_QUEUEACTION(QueueStatus))
  {
  case 1:
  case 4:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
  case 2:
  case 5:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 3:
  case 6:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;

  case 7:
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;
  case 8:
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 9:
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;

  case 10:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
  case 11:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 12:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;

  case 13:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 14:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
  case 15:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;

  case 16:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 17:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;
  case 18:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;

  case 19:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_NONE);
    break;
  case 20:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_NONE);
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
  case 21:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_NONE);
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;

#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
  case 22:
    Dem_Esm_EventFailed_Immediate(EventId,
      (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
      (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
#endif

  default:
    /* Do nothing with this event */
    break;
  }
}                                                                                                                                /* PRQA S 6030 */ /* MD_MSR_STCYC */

/* ****************************************************************************
 % Dem_Queue_ProcessEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  uint8 lEventQueueStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
/* A monitor could interrupt the MainFunction and try to publish a new test result. This critical section prevents
   such a monitor from modifying the toggle count. We removed the queue entry and reset the update pending flag as
   well. A monitor waiting on this critical section can immediately requeue this event without losing information. */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lEventQueueStatus = Dem_Queue_GetEventStatus(EventId);
  Dem_Queue_SetEventStatus(EventId, DEM_QUEUE_EVENT_NONE);

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_EventPrestorageLock(EventId);
#endif

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */

  if ( (Dem_Cfg_EventKind(EventId) == DEM_CFG_EVENT_KIND_BSW)                                                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    || (Dem_Cfg_EventCombinedGroup(EventId) != DEM_CFG_COMBINED_GROUP_INVALID)
#endif
# if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
    || (Dem_Cfg_EventDebounceType(EventId) == DEM_CFG_DEBOUNCETYPE_TIMER)
# endif
    )
  {
    Dem_Queue_ProcessEvent_Queued(EventId, lEventQueueStatus);
  }
  else
  {
    Dem_Queue_ProcessEvent_Immediate(EventId, lEventQueueStatus);
  }

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_EventPrestorageRelease();
#endif
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Queue_ProcessSetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessSetEventStatus(
  void
  )
{
  /* Count the number of events processed - This allows to modify the global 'Pending Events' counter only once,
   * and we could use it to implement a runtime limiter if we so desire */
  uint16 lProcessedEventCount;
  lProcessedEventCount = 0;

#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
  {
    /* Create a local copy of the global read index to optimize access - we are known to be the only writer of the
      * global variable, so it is safe to do so. On the other hand the global itself must be volatile since we might
      * interrupt a monitor */
    uint8 lQueueReadIndex;
    lQueueReadIndex = Dem_Queue_EventReadIndex;

    /* Dem_Queue_EventReadIndex == Dem_Queue_EventWriteIndex indicates a completely filled queue. So, the loop has
      * to run at least once, hence the do..while loop. After the first fetch we have exhausted the queue if we catch
      * up with the write index (again). */
    do
    {
      Dem_EventIdType lEventId;
      lEventId = Dem_Queue_ChronologyGetEvent(lQueueReadIndex);

      Dem_WrappingIncrement(lQueueReadIndex, Dem_Cfg_GlobalQueueMaxCount())
      Dem_Queue_EventReadIndex = lQueueReadIndex;

      Dem_Queue_ProcessEvent(lEventId);
      ++lProcessedEventCount;
    }
    while (lQueueReadIndex != Dem_Queue_EventWriteIndex);
  }
#endif
  if (Dem_Queue_EventCount > lProcessedEventCount)
  { /* Queue overflow (also no queue available) */
    Dem_EventIdType lEventId;

    for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
    { /* Clear stored status for all events */
      if (DEM_QUEUE_EVENT_PENDING == DEM_QUEUE_GET_QUEUESTATE(Dem_Queue_GetEventStatus(lEventId)))
      {
        Dem_Queue_ProcessEvent(lEventId);
        ++lProcessedEventCount;
      }
    }
  }

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dem_Queue_EventCount = (uint16)(Dem_Queue_EventCount - lProcessedEventCount);
  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Queue_ProcessCycles
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessCycles(
  void
  )
{
  uint8 lCycleId;
  uint16 lDem_Queue_CycleState;
  uint16 lDem_Queue_CycleFlag;

/* >>>> --------------------------------- Enter Critical Section: StateManager */
  Dem_EnterCritical_StateManager();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lDem_Queue_CycleState = Dem_Queue_CycleState;
  Dem_Queue_CycleState = 0U;

  lDem_Queue_CycleFlag = Dem_Queue_CycleFlag;
  Dem_Queue_CycleFlag = 0U;

  Dem_LeaveCritical_StateManager();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< --------------------------------- Leave Critical Section: StateManager */

  lCycleId = 0;
  while (0 != lDem_Queue_CycleFlag)
  {
    if ((lDem_Queue_CycleFlag & 0x01U) != 0)
    {
      uint8 lNewStatus;
      uint8 lOldStatus;
      lNewStatus = (uint8)(((lDem_Queue_CycleState & 0x01U) != 0)?DEM_QUEUE_CYCLE_STARTED:DEM_QUEUE_CYCLE_STOPPED);
      lOldStatus = Dem_Mem_GetCycleStatus(lCycleId);
      if (DEM_QUEUE_CYCLE_STARTED == lNewStatus)
      {

        if (lNewStatus == lOldStatus)
        {
          Dem_Esm_CycleUpdate(lCycleId, DEM_QUEUE_CYCLE_RESTARTED);
        }
        else
        {
          Dem_Esm_CycleUpdate(lCycleId, DEM_QUEUE_CYCLE_STARTED);
        }
      }
      else
      {
        Dem_Esm_CycleUpdate(lCycleId, DEM_QUEUE_CYCLE_STOPPED);
      }
    }
    ++lCycleId;
    lDem_Queue_CycleFlag = (uint16)(lDem_Queue_CycleFlag >> 1U);
    lDem_Queue_CycleState = (uint16)(lDem_Queue_CycleState >> 1U);
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ProcessEventEnableConditions
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEventEnableConditions(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint32, AUTOMATIC)  OldConditionStates,
  CONST(uint32, AUTOMATIC)  NewConditionStates
)
{
  /* Reset/Freeze de-bouncing on enable condition state change unlocked -> locked */
  if (((OldConditionStates & Dem_Cfg_EventEnableConditions(EventId)) == Dem_Cfg_EventEnableConditions(EventId))                  /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && ((NewConditionStates & Dem_Cfg_EventEnableConditions(EventId)) != Dem_Cfg_EventEnableConditions(EventId)))
  {
    /* Enable conditions become disabled.
       If DEM_CFG_RESET_DEBOUNCE_ON_ENABLE_ENABLE_CONDITIONS:
         If the event is configured to freeze, or will not continue counting: freeze it
       If DEM_CFG_RESET_DEBOUNCE_ON_DISABLE_ENABLE_CONDITIONS:
         If the event is configured to freeze: freeze it
         Otherwise: reset it
       */
#  if (DEM_CFG_RESET_DEBOUNCE_ON_ENABLE_ENABLE_CONDITIONS == STD_ON)
    if ( (Dem_Cfg_EventDebounceReset(EventId) == FALSE)                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      || (Dem_Cfg_EventDebounceContinuous(EventId) == FALSE) )
    {
      Dem_Esm_EventResetDebounceState(EventId, DEM_DEBOUNCE_STATUS_FREEZE);
    }
#  endif
#  if (DEM_CFG_RESET_DEBOUNCE_ON_DISABLE_ENABLE_CONDITIONS == STD_ON)
    if (Dem_Cfg_EventDebounceReset(EventId) == FALSE)
    {
      Dem_Esm_EventResetDebounceState(EventId, DEM_DEBOUNCE_STATUS_FREEZE);
    }
    else
    {
      Dem_Esm_EventResetDebounceState(EventId, DEM_DEBOUNCE_STATUS_RESET);
    }
#  endif
  }
  else
# if ( (DEM_CFG_NOTIFY_ENABLECONDITION == STD_ON) \
    || (DEM_CFG_RESET_DEBOUNCE_ON_ENABLE_ENABLE_CONDITIONS == STD_ON) )
  /* Un-freeze de-bouncing, notify enable condition state change locked -> unlocked */
  if ( ((OldConditionStates & Dem_Cfg_EventEnableConditions(EventId)) != Dem_Cfg_EventEnableConditions(EventId))                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && ((NewConditionStates & Dem_Cfg_EventEnableConditions(EventId)) == Dem_Cfg_EventEnableConditions(EventId)) )
  {
    /* Enable conditions become fulfilled.
       Freeze Debouncing:
         -
       Reset Debouncing:
         If the event is configured to reset, and the global setting is to reset on disable EC
       Call InitMonitor for event/function:
         If any are configured
       */
#  if (DEM_CFG_RESET_DEBOUNCE_ON_ENABLE_ENABLE_CONDITIONS == STD_ON)
    if (Dem_Cfg_EventDebounceReset(EventId) == TRUE)
    {
      Dem_Esm_EventResetDebounceState(EventId, DEM_DEBOUNCE_STATUS_RESET);
    }
#  endif
    Dem_Cbk_InitMonitorForEvent(EventId, DEM_INIT_MONITOR_REENABLED);
    Dem_Cbk_InitMonitorForFunction(EventId);
  }
  else
# endif
  {
    /* Do nothing */
  }
}
#endif

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ProcessEnableConditions
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEnableConditions(
  void
  )
{
  if ( (Dem_CurrentEnableConditionStates != Dem_Queue_EnableConditionStates)                                                     /* PRQA S 3415 */ /* MD_DEM_12.4_cs */
    || (Dem_CurrentEnableConditionStates != Dem_NextEnableConditionStates))
  {
    Dem_EventIdType lEventId;
    uint32 lCurrentEnableConditions;
    uint32 lNextEnableConditions;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
    Dem_EnterCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Copy current value to avoid concurrent modification */
    lCurrentEnableConditions = Dem_CurrentEnableConditionStates;
    lNextEnableConditions = Dem_NextEnableConditionStates;

    Dem_LeaveCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

    if ( (lCurrentEnableConditions != Dem_Queue_EnableConditionStates)
      || (lCurrentEnableConditions != lNextEnableConditions))
    {
      for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
      {
        if (Dem_Cfg_EventAvailableByVariant(lEventId) == TRUE)
        {
          if (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lEventId)) == FALSE)
          {
            /* Notify/Process for Queue->Current */
            Dem_Queue_ProcessEventEnableConditions(lEventId, Dem_Queue_EnableConditionStates, lCurrentEnableConditions);
            /* Notify/Process for Current->Next */
            Dem_Queue_ProcessEventEnableConditions(lEventId, lCurrentEnableConditions, lNextEnableConditions);
          }
        }
      }
    }

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
    Dem_EnterCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Keep newly disabled bits, but delay newly enabled bits until next task */
    lNextEnableConditions = (lNextEnableConditions & Dem_NextEnableConditionStates);
    Dem_CurrentEnableConditionStates = lNextEnableConditions;

    Dem_LeaveCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

    /* Store reference value */
    Dem_Queue_EnableConditionStates = lNextEnableConditions;
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

/* ****************************************************************************
 % Dem_Queue_MainFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_MainFunction(
  void
  )
{
#if (DEM_CFG_SUPPORT_DCM == STD_ON)
  if (DEM_DCM_FILTERDATA_PENDING == Dem_Dcm_FilterDataGetState())
  {
    Dem_Queue_ProcessFilterEventData();
  }
#endif

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
  Dem_Queue_ProcessEnableConditions();
#endif

  if (FALSE != DEM_QUEUE_TESTCLEARSTATE_PENDING(Dem_Queue_GetClearState()))
  {
    Dem_Queue_ProcessClearDtc();
  }

  if (0U != Dem_Queue_EventCount)
  {
    Dem_Queue_ProcessSetEventStatus();
  }

  if (0U != Dem_Queue_CycleFlag)
  {
    Dem_Queue_ProcessCycles();
  }

}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_AGINGCTR == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyUpwardsAgingCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyUpwardsAgingCounter(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  uint8 lAgingCounter;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

  if ( (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_AGING_COUNT_ONLY_AGEABLE == STD_ON)
    || (Dem_Cfg_EventSupportAging(CopyDidInfoPtr->EventId) == FALSE)
# endif
    )
  {
    lAgingCounter = 0x00U;
  }
  else
  if (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
  {
    lAgingCounter = 0xffU;
  }
# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
  else
  if (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
  {
    lAgingCounter = (uint8)(Dem_Cfg_EventAgingTarget(CopyDidInfoPtr->EventId));
  }
# endif
  else
  {
    uint16 lTarget = Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry);
    uint16 lCurrent = Dem_Mem_CycleGetCounter(Dem_Cfg_EventAgingCycle(CopyDidInfoPtr->EventId));
    lAgingCounter = (uint8)(Dem_Cfg_EventAgingTarget(CopyDidInfoPtr->EventId) - Dem_Esm_CycleCountDistance(lCurrent, lTarget));
# if (DEM_CFG_AGING_REPORT_ZERO_AS_ONE == STD_ON)
    if (lAgingCounter == 0x00U)
    {
      lAgingCounter = 0x01U;
    }
# endif
  }

  if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = lAgingCounter;                                               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 1;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_AGINGCTR == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyDownwardsAgingCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyDownwardsAgingCounter(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  uint8 lAgingCounter;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

  if ( (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_AGING_COUNT_ONLY_AGEABLE == STD_ON)
    || (FALSE == Dem_Cfg_EventSupportAging(CopyDidInfoPtr->EventId))
# endif
     )
  {
    lAgingCounter = Dem_Cfg_EventAgingTarget(CopyDidInfoPtr->EventId);
  }
  else
  if ( (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
#  if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
    || (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
#  endif
    )
  {
    lAgingCounter = 0x00U;
  }
  else
  {
    uint16 lTarget = Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry);
    uint16 lCurrent = Dem_Mem_CycleGetCounter(Dem_Cfg_EventAgingCycle(CopyDidInfoPtr->EventId));
    lAgingCounter = (uint8)(Dem_Esm_CycleCountDistance(lCurrent, lTarget));
  }

  if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = lAgingCounter;                                               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 1;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OCCCTR == STD_ON)
/* ****************************************************************************
 % Dem_Data_Copy1ByteOccurrenceCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_Copy1ByteOccurrenceCounter(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  boolean lReturnValue;
  uint8 lOccurrenceCounter;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)) == TRUE)
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
# if (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
    if (Dem_Mem_EntryGetOccurrenceCount(CopyDidInfoPtr->Entry) > 0xffU)
    {
      lOccurrenceCounter = 0xffU;
    }
    else
# endif
    {
      lOccurrenceCounter = (uint8)Dem_Mem_EntryGetOccurrenceCount(CopyDidInfoPtr->Entry);
    }

    if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
    {
      CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = lOccurrenceCounter;                                        /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
      CopyDidInfoPtr->WriteIndex += 1;                                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }

    lReturnValue = TRUE;
  }
  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OCCCTR == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
/* ****************************************************************************
 % Dem_Data_Copy2ByteOccurrenceCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_Copy2ByteOccurrenceCounter(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
    if (CopyDidInfoPtr->BufferSize >= (CopyDidInfoPtr->WriteIndex + 2))
    {
      CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex + 0] = Dem_GetHiByte(Dem_Mem_EntryGetOccurrenceCount(CopyDidInfoPtr->Entry));  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
      CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex + 1] = Dem_GetLoByte(Dem_Mem_EntryGetOccurrenceCount(CopyDidInfoPtr->Entry));  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
      CopyDidInfoPtr->WriteIndex += 2;                                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
    lReturnValue = TRUE;
  }
  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OVFLIND == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyOverflowIndication
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyOverflowIndication(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = (uint8)Dem_Mem_GetOverflow(Dem_Cfg_EventDestination(CopyDidInfoPtr->EventId));  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 1;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OVFLIND == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_SIGNIFICANCE == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyEventSignificance
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventSignificance(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = (uint8)(Dem_Cfg_EventSignificance(CopyDidInfoPtr->EventId) == DEM_CFG_EVENT_SIGNIFICANCE_FAULT);  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 1;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_SIGNIFICANCE == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_PRIORITY == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyEventPriority
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventPriority(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = (uint8)Dem_Cfg_EventPriority(CopyDidInfoPtr->EventId);       /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 1;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_PRIORITY == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyMaxFdcSinceLastClear
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyMaxFdcSinceLastClear(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  boolean lReturnValue;
  sint8 lFdc;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)) == TRUE)
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
    if (DEM_ESM_TEST_UDS_STATUS_TFSLC(Dem_Util_DtcGetStatus(CopyDidInfoPtr->EventId)) == TRUE)
    {
      lFdc = 127;
    }
    else
    {
      lFdc = (sint8)Dem_Mem_EntryGetDebounceValueMax(CopyDidInfoPtr->Entry);
    }
    if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
    {
      CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = (uint8)lFdc;                                               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
      CopyDidInfoPtr->WriteIndex += 1;                                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyMaxFdcThisCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyMaxFdcThisCycle(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  sint8 lFdc;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  {
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    lGroupId = Dem_Cfg_EventCombinedGroup(CopyDidInfoPtr->EventId);
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      lFdc = Dem_Data_CombinedGroupGetFDCMax(lGroupId);
    }
    else
# endif
    {
      lFdc = Dem_Data_EventGetFDCMax(CopyDidInfoPtr->EventId);
    }
  }

  if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = (uint8)lFdc;                                                 /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 1;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }

  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyCyclesSinceLastFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesSinceLastFailed(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  uint8 lCycleCounter;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  if (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetLastFailedCycleCount(CopyDidInfoPtr->Entry))
  {
    lCycleCounter = 0x00U;
  }
  else
  if (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetLastFailedCycleCount(CopyDidInfoPtr->Entry))
  {
    lCycleCounter = 0xffU;
  }
  else
  {
    lCycleCounter = (uint8)Dem_Esm_CycleCountDistance(
      Dem_Mem_EntryGetLastFailedCycleCount(CopyDidInfoPtr->Entry),
      Dem_Mem_CycleGetCounter(Dem_Cfg_EventOperationCycle(CopyDidInfoPtr->EventId)));
  }

  if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = lCycleCounter;                                               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 1;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyCyclesSinceFirstFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesSinceFirstFailed(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  uint8 lCycleCounter;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  if (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetFirstFailedCycleCount(CopyDidInfoPtr->Entry))
  {
    lCycleCounter = 0x00U;
  }
  else
  if (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetFirstFailedCycleCount(CopyDidInfoPtr->Entry))
  {
    lCycleCounter = 0xffU;
  }
  else
  {
    lCycleCounter = (uint8)Dem_Esm_CycleCountDistance(
      Dem_Mem_EntryGetFirstFailedCycleCount(CopyDidInfoPtr->Entry),
      Dem_Mem_CycleGetCounter(Dem_Cfg_EventOperationCycle(CopyDidInfoPtr->EventId)));
  }

  if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = lCycleCounter;                                               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 1;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyFailedCycles
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyFailedCycles(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
    if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
    {
      CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = Dem_Mem_EntryGetFailedCycleCount(CopyDidInfoPtr->Entry);   /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
      CopyDidInfoPtr->WriteIndex += 1;                                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_FAILED_CYCLES == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyConsecutiveFailedCycles
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyConsecutiveFailedCycles(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
    if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
    {
      CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = Dem_Mem_EntryGetConsecutiveFailedCycleCount(CopyDidInfoPtr->Entry);  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
      CopyDidInfoPtr->WriteIndex += 1;                                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyCyclesTestedSinceFirstFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesTestedSinceFirstFailed(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
    if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
    {
      CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = Dem_Mem_EntryGetTestedSinceFirstFailedCycleCount(CopyDidInfoPtr->Entry);  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
      CopyDidInfoPtr->WriteIndex += 1;                                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyRootCauseEventId
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyRootCauseEventId(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->SourceBuffer != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

  if (CopyDidInfoPtr->BufferSize >= (CopyDidInfoPtr->WriteIndex + 2))
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex + 0] = CopyDidInfoPtr->SourceBuffer[CopyDidInfoPtr->ReadIndex + 0];  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex + 1] = CopyDidInfoPtr->SourceBuffer[CopyDidInfoPtr->ReadIndex + 1];  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->ReadIndex += 2;                                                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    CopyDidInfoPtr->WriteIndex += 2;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OBDDTC == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyEventObdDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventObdDtc(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  if (CopyDidInfoPtr->BufferSize >= (CopyDidInfoPtr->WriteIndex + 2))
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex + 0] = Dem_GetHiByte(Dem_Cfg_EventObdDtc(CopyDidInfoPtr->EventId));  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex + 1] = Dem_GetLoByte(Dem_Cfg_EventObdDtc(CopyDidInfoPtr->EventId));  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 2;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OBDDTC == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OBDDTC_3BYTE == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyEventObdDtc_3Byte
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventObdDtc_3Byte(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  if (CopyDidInfoPtr->BufferSize >= (CopyDidInfoPtr->WriteIndex + 3))
  {
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex + 0] = Dem_GetHiByte(Dem_Cfg_EventObdDtc(CopyDidInfoPtr->EventId));  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex + 1] = Dem_GetLoByte(Dem_Cfg_EventObdDtc(CopyDidInfoPtr->EventId));  /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex + 2] = 0x00;                                                    /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CopyDidInfoPtr->WriteIndex += 3;                                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_OBDDTC == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CURRENT_FDC == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyCurrentFdc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCurrentFdc(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr
  )
{
  boolean lReturnValue;
  sint8 lFdc;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  lReturnValue = (boolean)(E_OK == Dem_Util_DtcGetFaultDetectionCounter(CopyDidInfoPtr->EventId, &lFdc));                        /* SBSW_DEM_POINTER_FORWARD_STACK */
  if (FALSE != lReturnValue)
  {
    if (CopyDidInfoPtr->BufferSize > CopyDidInfoPtr->WriteIndex)
    {
      CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex] = (uint8)lFdc;                                               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
      CopyDidInfoPtr->WriteIndex += 1;                                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
  }

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_CURRENT_FDC == STD_ON) */

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON)
/* ****************************************************************************
% Dem_Data_CopyStoredUserData
*****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyStoredUserData(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
)
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->SourceBuffer != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

  if (CopyDidInfoPtr->BufferSize >= (CopyDidInfoPtr->WriteIndex + Dem_Cfg_DataSize(DataIndex)))
  {
    Dem_MemCpy(&CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex],                                                   /* PRQA S 0311 */ /* MD_DEM_11.5 */ /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
               &CopyDidInfoPtr->SourceBuffer[CopyDidInfoPtr->ReadIndex],
               Dem_Cfg_DataSize(DataIndex));                                                                                     /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
    CopyDidInfoPtr->WriteIndex += Dem_Cfg_DataSize(DataIndex);                                                                   /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    CopyDidInfoPtr->ReadIndex += Dem_Cfg_DataSize(DataIndex);                                                                    /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  return TRUE;
}
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON)
/* ****************************************************************************
% Dem_Data_CopyCurrentUserData
*****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCurrentUserData(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
)
{
  if (CopyDidInfoPtr->BufferSize >= (CopyDidInfoPtr->WriteIndex + Dem_Cfg_DataSize(DataIndex)))
  {
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if ( (DataIndex >= Dem_Cfg_GlobalDataElementCount())                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      || (Dem_Cfg_DataCallbackType(DataIndex) != DEM_CFG_DATA_FROM_CBK_CURRENT) )
    {
      Dem_RunTimeCheckFailed(__LINE__);
    }
    else
#endif
    {
      if ((*((Dem_ReadDataStandardFPtrType)Dem_Cfg_DataCbkRead(DataIndex)))(                                                     /* PRQA S 0313 */ /* MD_DEM_11.1 */ /* SBSW_DEM_CALL_DIDINFO_DESTINATIONBUFFER */
                &CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex]) == E_NOT_OK)
      { /* In case the function failed, fill with padding bytes */
        Dem_MemSet(&CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex],                                               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
                   DEM_DATA_INVALID_DATA_PATTERN,
                   Dem_Cfg_DataSize(DataIndex));                                                                                 /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
      }
      CopyDidInfoPtr->WriteIndex += Dem_Cfg_DataSize(DataIndex);                                                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
  }
  return TRUE;
}
#endif

#if (DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON)
/* ****************************************************************************
% Dem_Data_CopyCurrentUserDataWithEventId
*****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCurrentUserDataWithEventId(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
)
{
  if (CopyDidInfoPtr->BufferSize >= (CopyDidInfoPtr->WriteIndex + Dem_Cfg_DataSize(DataIndex)))
  {
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if ( (DataIndex >= Dem_Cfg_GlobalDataElementCount())                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      || (Dem_Cfg_DataCallbackType(DataIndex) != DEM_CFG_DATA_FROM_CBK_CURRENT_WITH_EVENTID) )
    {
      Dem_RunTimeCheckFailed(__LINE__);
    }
    else
#endif
    {
      if ((*((Dem_ReadDataExtendedFPtrType)Dem_Cfg_DataCbkRead(DataIndex)))(                                                     /* PRQA S 0313 */ /* MD_DEM_11.1 */ /* SBSW_DEM_CALL_DIDINFO_DESTINATIONBUFFER */
                CopyDidInfoPtr->EventId,
                &CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex]) == E_NOT_OK)
      { /* In case the function failed, fill with padding bytes */
        Dem_MemSet(&CopyDidInfoPtr->DestinationBuffer[CopyDidInfoPtr->WriteIndex],                                               /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
                   DEM_DATA_INVALID_DATA_PATTERN,
                   Dem_Cfg_DataSize(DataIndex));                                                                                 /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
      }
      CopyDidInfoPtr->WriteIndex += Dem_Cfg_DataSize(DataIndex);                                                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
  }
  return TRUE;
}
#endif

#if ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
/* ****************************************************************************
 % Dem_Data_CollectStoredUserData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectStoredUserData(
  CONST(Dem_Data_CollectDidInfoPtrType, AUTOMATIC)  CollectDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
)
{
  if (CollectDidInfoPtr->BufferSize >= (CollectDidInfoPtr->WriteIndex + Dem_Cfg_DataSize(DataIndex)))
  {
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if ( (DataIndex >= Dem_Cfg_GlobalDataElementCount())                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      || (Dem_Cfg_DataCallbackType(DataIndex) != DEM_CFG_DATA_FROM_CBK_STORED) )
    {
      Dem_RunTimeCheckFailed(__LINE__);
    }
    else
# endif
    {
      if ((*((Dem_ReadDataStandardFPtrType)Dem_Cfg_DataCbkRead(DataIndex)))(                                                     /* PRQA S 0313 */ /* MD_DEM_11.1 */ /* SBSW_DEM_CALL_DIDINFO_DESTINATIONBUFFER */
                &CollectDidInfoPtr->DestinationBuffer[CollectDidInfoPtr->WriteIndex]) == E_NOT_OK)
      { /* In case the function failed, fill with padding bytes */
        Dem_MemSet(&CollectDidInfoPtr->DestinationBuffer[CollectDidInfoPtr->WriteIndex],                                         /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
                   DEM_DATA_INVALID_DATA_PATTERN,
                   Dem_Cfg_DataSize(DataIndex));                                                                                 /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
      }
      CollectDidInfoPtr->WriteIndex += Dem_Cfg_DataSize(DataIndex);                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
  }
}
#endif

#if ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
/* ****************************************************************************
 % Dem_Data_CollectStoredUserDataWithEventId
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectStoredUserDataWithEventId(
  CONST(Dem_Data_CollectDidInfoPtrType, AUTOMATIC)  CollectDidInfoPtr,
  CONST(Dem_Cfg_DataIndexType, AUTOMATIC)  DataIndex
)
{
  if (CollectDidInfoPtr->BufferSize >= (CollectDidInfoPtr->WriteIndex + Dem_Cfg_DataSize(DataIndex)))
  {
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if ( (DataIndex >= Dem_Cfg_GlobalDataElementCount())                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      || (Dem_Cfg_DataCallbackType(DataIndex) != DEM_CFG_DATA_FROM_CBK_STORED_WITH_EVENTID) )
    {
      Dem_RunTimeCheckFailed(__LINE__);
    }
    else
# endif
    {
      if ((*((Dem_ReadDataExtendedFPtrType)Dem_Cfg_DataCbkRead(DataIndex)))(                                                     /* PRQA S 0313 */ /* MD_DEM_11.1 */ /* SBSW_DEM_CALL_DIDINFO_DESTINATIONBUFFER */
                CollectDidInfoPtr->EventId,
                &CollectDidInfoPtr->DestinationBuffer[CollectDidInfoPtr->WriteIndex]) == E_NOT_OK)
      { /* In case the function failed, fill with padding bytes */
        Dem_MemSet(&CollectDidInfoPtr->DestinationBuffer[CollectDidInfoPtr->WriteIndex],                                         /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
                   DEM_DATA_INVALID_DATA_PATTERN,
                   Dem_Cfg_DataSize(DataIndex));                                                                                 /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
      }
      CollectDidInfoPtr->WriteIndex += Dem_Cfg_DataSize(DataIndex);                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
  }
}
#endif

#if ( ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON) \
     || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
     || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
     || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
     || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
     || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) ) \
   && (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON) )
/* ****************************************************************************
 % Dem_Data_CollectRootCauseEventId
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectRootCauseEventId(
  CONST(Dem_Data_CollectDidInfoPtrType, AUTOMATIC)  CollectDidInfoPtr
)
{
  if (CollectDidInfoPtr->BufferSize >= (CollectDidInfoPtr->WriteIndex + 2))
  {
    /* ROOTCAUSE_EVENTID: store configuration element in environmental data array */
    CollectDidInfoPtr->DestinationBuffer[CollectDidInfoPtr->WriteIndex + 0] = Dem_GetHiByte(CollectDidInfoPtr->EventId);         /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CollectDidInfoPtr->DestinationBuffer[CollectDidInfoPtr->WriteIndex + 1] = Dem_GetLoByte(CollectDidInfoPtr->EventId);         /* SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER */
    CollectDidInfoPtr->WriteIndex += 2;                                                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
}
#endif

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_CommitBlock
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_CommitBlock(
  void
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Dem_Nvm_CommitData.MemoryIndex >= DEM_CFG_GLOBAL_NV_BLOCK_COUNT)
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Std_ReturnType lNvmResult;

#if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
    Dem_Nvm_CommitData.BlockIsCleared = (boolean)(0 != (DEM_NVM_BLOCKSTATE_CLEARFLAG & Dem_Nvm_GetBlockState(Dem_Nvm_CommitData.MemoryIndex)));
#endif
    if (Dem_Nvm_CommitData.MemoryIndex == Dem_Cfg_MemoryAdminIndex())
    {
      Dem_Nvm_SetBlockState(Dem_Nvm_CommitData.MemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
    }
    else
    {
      Dem_Nvm_SetBlockState(Dem_Nvm_CommitData.MemoryIndex, DEM_NVM_BLOCKSTATE_UNMODIFIED);
    }

    Dem_MemCpy((Dem_DataPtrType)&Dem_Cfg_CommitBuffer.mRaw[0],                                                                   /* PRQA S 0602 */ /* MD_DEM_20.2 */ /* SBSW_DEM_MEMCOPY_MEMORY_DATA */
               Dem_Cfg_MemoryDataPtr[Dem_Nvm_CommitData.MemoryIndex],
               Dem_Cfg_MemoryDataSize[Dem_Nvm_CommitData.MemoryIndex]);

    /* Job End notification might return immediately - set the commit state before WriteBlock */
    Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_WRITING;
    lNvmResult = NvM_WriteBlock((NvM_BlockIdType)Dem_Cfg_MemoryBlockId[Dem_Nvm_CommitData.MemoryIndex],                          /* SBSW_DEM_NVM_WRITEBLOCK */
                                &Dem_Cfg_CommitBuffer.mRaw[0]);

    if (lNvmResult != E_OK)
    { /* Write attempt failed - act as if callback had returned failed. This case is handled by Dem_NvM_MainFunction */
      Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FAILED;
    }
  }
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) */

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_Init(
  void
  )
{
  Dem_MemSet(Dem_Cfg_MemoryStatus, DEM_NVM_BLOCKSTATE_UNMODIFIED, Dem_Cfg_GlobalNvBlockCount()*sizeof(uint8));                   /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */                      /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */ /* SBSW_DEM_MEMSET_MEMORYSTATUS */
  Dem_Mem_AdminSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);

# if (DEM_CFG_SUPPORT_NVM_APPL_SYNCHRONIZE == STD_ON)
  Dem_Nvm_SynchronizationRequest = FALSE;
# endif
# if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
  Dem_Nvm_PendingStatusBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
#  if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
  Dem_Nvm_PendingEventAvailabilityBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
#  endif
  Dem_Nvm_CommitData.MemoryIndex = 0;
  Dem_Nvm_CommitData.PendingCount = 0;
  Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_IDLE;
# endif
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
  Dem_Nvm_CommitData.PendingClearCount = 0;
  Dem_Nvm_CommitData.BlockIsCleared = FALSE;
# endif
}
#endif /* (DEM_CFG_USE_NVM == STD_ON) */

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_Shutdown
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_Shutdown(
  void
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;

# if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
  /* Process queued modification status of the status data block */
  if (Dem_Nvm_PendingStatusBlockState != DEM_NVM_BLOCKSTATE_UNMODIFIED)
  {
    Dem_Nvm_StatusSetBlockState(Dem_Nvm_PendingStatusBlockState);
    Dem_Nvm_PendingStatusBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
  }
#  if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
  /* Process queued modification status of the status data block */
  if (Dem_Nvm_PendingEventAvailabilityBlockState != DEM_NVM_BLOCKSTATE_UNMODIFIED)
  {
    Dem_Nvm_EventAvailableSetBlockState(Dem_Nvm_PendingEventAvailabilityBlockState);
    Dem_Nvm_PendingEventAvailabilityBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
  }
#  endif
# endif

  for (lMemoryIndex = 0; lMemoryIndex < Dem_Cfg_GlobalNvBlockCount(); ++lMemoryIndex)
  {
    if (DEM_NVM_BLOCKSTATE_UNMODIFIED != Dem_Nvm_GetBlockState(lMemoryIndex))
    {
      (void)NvM_SetRamBlockStatus((NvM_BlockIdType)Dem_Cfg_MemoryBlockId[lMemoryIndex], TRUE);
    }
  }

# if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
  Dem_Nvm_CommitData.MemoryIndex = 0;
  Dem_Nvm_CommitData.PendingCount = 0;
  Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_IDLE;
# endif
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
  Dem_Nvm_CommitData.PendingClearCount = 0;
  Dem_Nvm_CommitData.BlockIsCleared = FALSE;
# endif
}                                                                                                                                /* PRQA S 6010 */ /* MD_MSR_STPTH */
#endif /* (DEM_CFG_USE_NVM == STD_ON) */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_ProcessQueue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_ProcessQueue(
  void
  )
{
  /* Process queued modification status of the status data block */
  if (Dem_Nvm_PendingStatusBlockState != DEM_NVM_BLOCKSTATE_UNMODIFIED)
  {
    Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryStatusIndex(), Dem_Nvm_PendingStatusBlockState);
    Dem_Nvm_PendingStatusBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
  }
  /* Process queued modification status of the status data block */
# if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
  if (Dem_Nvm_PendingEventAvailabilityBlockState != DEM_NVM_BLOCKSTATE_UNMODIFIED)
  {
    Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryEventAvailableIndex(), Dem_Nvm_PendingEventAvailabilityBlockState);
    Dem_Nvm_PendingEventAvailabilityBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
  }
#endif

#if (DEM_CFG_SUPPORT_NVM_APPL_SYNCHRONIZE == STD_ON)
  /* Process queued request for full NV sync */
  if (FALSE != Dem_Nvm_SynchronizationRequest)
  {
    Dem_Cfg_MemoryIndexType lMemoryIndex;
    for (lMemoryIndex = 0; lMemoryIndex < Dem_Cfg_GlobalNvBlockCount(); ++lMemoryIndex)
    {
      if (DEM_NVM_BLOCKSTATE_DIRTY == ((DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG | DEM_NVM_BLOCKSTATE_DIRTY) & Dem_Nvm_GetBlockState(lMemoryIndex)))
      {
        Dem_Nvm_SetBlockStateImmediate(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE);
      }
    }

    Dem_Nvm_SynchronizationRequest = FALSE;
  }
#endif
}
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) && (DEM_CFG_SUPPORT_NVM_POLLING == STD_ON )
/* ****************************************************************************
 % Dem_Nvm_GetNvMResult
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_GetNvMResult(
  void
  )
{
  if (Dem_Nvm_CommitData.WriteState == DEM_NVM_COMMIT_WRITING)
  {
    NvM_RequestResultType lRequestResult;
    Std_ReturnType lCallResult;

    lRequestResult = NVM_REQ_NOT_OK;

    lCallResult = NvM_GetErrorStatus((NvM_BlockIdType)Dem_Cfg_MemoryBlockId[Dem_Nvm_CommitData.MemoryIndex], &lRequestResult);   /* SBSW_DEM_POINTER_FORWARD_STACK */
    if (lCallResult == E_OK)
    {
      if (lRequestResult != NVM_REQ_PENDING)
      {
        if (lRequestResult != NVM_REQ_OK)
        { /* Write request aborted or otherwise failed. */
          Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FAILED;
        }
        else
        {
          /* continue with next block */
          Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FINISHED;
        }
      }
      /* else: NvM is still busy, wait */
    }
    else
    {
      Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FAILED;
    }
  }
}
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_MainFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_MainFunction(
  void
  )
{
  Dem_Nvm_ProcessQueue();

  /* Check for ongoing NV commit */
  if (Dem_Nvm_CommitData.PendingCount > 0)
  {
# if (DEM_CFG_SUPPORT_NVM_POLLING == STD_ON )
    Dem_Nvm_GetNvMResult();
# endif /* (DEM_CFG_SUPPORT_NVM_POLLING == STD_ON ) */

    switch (Dem_Nvm_CommitData.WriteState)
    {
    case DEM_NVM_COMMIT_FAILED:
    {
      /* Error handling:
         This implementation will mark the block as dirty in case of failed
         NvM_WriteBlock. Another immediate update is done only if the block
         changes again */
      (void)NvM_SetRamBlockStatus((NvM_BlockIdType)Dem_Cfg_MemoryBlockId[Dem_Nvm_CommitData.MemoryIndex], TRUE);
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
      if (Dem_Nvm_CommitData.BlockIsCleared == TRUE)
      { /* Note: on failure, PendingClearCount must be decremented after setting
           the failure bit to prevent an observable gap where the clear operation
           seems to have completed without error */
        uint8 lClearState;
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
        Dem_EnterCritical_DcmApi();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
        lClearState = Dem_Queue_GetClearState();
        lClearState = DEM_QUEUE_SETCLEARSTATE_NVFAILED(lClearState);
        Dem_Queue_SetClearState(lClearState);
        Dem_LeaveCritical_DcmApi();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DcmApi */
      }
# endif
    }
    /* FALL THROUGH */

    case DEM_NVM_COMMIT_FINISHED:                                                                                                /* PRQA S 2003 */ /* MD_DEM_15.2 */
    {
      /* Post-processing of NV update */
      Dem_Nvm_CommitData.PendingCount = (uint8)(Dem_Nvm_CommitData.PendingCount - 1);
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
      if (FALSE != Dem_Nvm_CommitData.BlockIsCleared)
      {
        Dem_Nvm_CommitData.BlockIsCleared = FALSE;
        Dem_Nvm_CommitData.PendingClearCount = (uint8)(Dem_Nvm_CommitData.PendingClearCount - 1);
      }
# endif
    }
    /* FALL THROUGH */

    case DEM_NVM_COMMIT_IDLE:                                                                                                    /* PRQA S 2003 */ /* MD_DEM_15.2 */
    {
      /* Look for next dirty/immediate NV block */
      if (Dem_Nvm_CommitData.PendingCount > 0)
      {
        /* Event states first, they are bound to be modified quickly */
        if (0 != (DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG & Dem_Nvm_StatusGetBlockState()))
        {
          Dem_Nvm_CommitData.MemoryIndex = Dem_Cfg_MemoryStatusIndex();
        }
        else
        {
          /* Start at last inspected index to write blocks fairly */
          uint8 lEndIndex;
          boolean lFoundBlock;

          lEndIndex = Dem_Nvm_CommitData.MemoryIndex;
          lFoundBlock = FALSE;
          do
          {
            Dem_WrappingIncrement(Dem_Nvm_CommitData.MemoryIndex, Dem_Cfg_GlobalNvBlockCount())                                  /* PRQA S 0715 */ /* MD_MSR_1.1_715 */

            if (0 != (DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG & Dem_Nvm_GetBlockState(Dem_Nvm_CommitData.MemoryIndex)))
            { /* Found a block that needs to be committed */                                                                     /* PRQA S 0715 */ /* MD_MSR_1.1_715 */
              lFoundBlock = TRUE;
              break;
            }
          }
          while (Dem_Nvm_CommitData.MemoryIndex != lEndIndex);   /* Stop when all slots have been inspected */

          if (lFoundBlock == FALSE)
          {
            Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_IDLE;
            break; /* We will continue looking for the pending block in the next task */                                         /* PRQA S 3333 */ /* MD_DEM_14.6_opt */
          }
        }

        Dem_Nvm_CommitBlock();
      }
      else
      {
        Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_IDLE;
      }
    }
    break;

    default: break;
      /* DEM_NVM_COMMIT_WRITING - NvM is still busy, do nothing until this changes (no timeout) */
    } /* end switch */
  } /* end if (Dem_Nvm_CommitData.PendingCount > 0) */
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) */

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterGetReportedEvents
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Dcm_FilterGetReportedEvents(
  CONST(uint16, AUTOMATIC)  FilterIndex
  )
{
  return Dem_Cfg_GetFilterReportedEvents(FilterIndex);
}
#endif

#if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterSetReportedEvents
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_FilterSetReportedEvents(
  CONST(uint16, AUTOMATIC)  FilterIndex,
  CONST(uint8, AUTOMATIC)  FilterValue
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (FilterIndex >= Dem_Cfg_GetSizeOfFilterReportedEvents())
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    Dem_Cfg_SetFilterReportedEvents(FilterIndex, FilterValue);                                                                   /* SBSW_DEM_ARRAY_WRITE_FILTERREPORTEDEVENTS */
  }
}
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_GetDtcCache
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Dcm_DtcCachePtrType, DEM_CODE)
Dem_Dcm_GetDtcCache(
  CONST(uint8, AUTOMATIC)  ClientId
  )
{
  Dem_Dcm_DtcCachePtrType lReturnValue;
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (ClientId >= DEM_DCM_CLIENT_COUNT)
  {
    Dem_RunTimeCheckFailed(__LINE__);
    lReturnValue = &Dem_Dcm_Cache[0];
  }
  else
# endif
  {
    lReturnValue = &Dem_Dcm_Cache[ClientId];
  }
  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Dcm_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_Init(
  void
  )
{
#if (DEM_CFG_NOTIFY_DCM == STD_ON)
  Dem_Dcm_SetNotificationState(FALSE);
#endif
#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
  Dem_Dcm_GetDtcCache(DEM_DCM_CLIENT_DCM)->Dtc = DEM_CFG_DTC_UDS_INVALID;                                                        /* SBSW_DEM_POINTER_WRITE_DTC_CACHE */
  Dem_Dcm_GetDtcCache(DEM_DCM_CLIENT_DCM)->EventId = DEM_EVENT_INVALID;                                                          /* SBSW_DEM_POINTER_WRITE_DTC_CACHE */
  Dem_Dcm_GetDtcCache(DEM_DCM_CLIENT_DCM)->MemoryId = DEM_CFG_MEMORYID_PRIMARY;                                                  /* SBSW_DEM_POINTER_WRITE_DTC_CACHE */

  Dem_Dcm_GetDtcCache(DEM_DCM_CLIENT_APPLICATION)->Dtc = DEM_CFG_DTC_UDS_INVALID;                                                /* SBSW_DEM_POINTER_WRITE_DTC_CACHE */
  Dem_Dcm_GetDtcCache(DEM_DCM_CLIENT_APPLICATION)->EventId = DEM_EVENT_INVALID;                                                  /* SBSW_DEM_POINTER_WRITE_DTC_CACHE */
  Dem_Dcm_GetDtcCache(DEM_DCM_CLIENT_APPLICATION)->MemoryId = DEM_CFG_MEMORYID_PRIMARY;                                          /* SBSW_DEM_POINTER_WRITE_DTC_CACHE */
#endif
#if (DEM_CFG_SUPPORT_DCM == STD_ON)
  Dem_Dcm_FilterResetCancelled();
  Dem_Dcm_FilterDtcSetFunctionPtr(NULL_PTR);
  Dem_Dcm_FilterDataSetState(DEM_DCM_FILTERDATA_IDLE);
  Dem_Dcm_FilterDataSetEventId(DEM_EVENT_INVALID);
#endif
}

#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FindEventFromUdsDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FindEventFromUdsDtc(
  CONST(uint32, AUTOMATIC)  UdsDtc,
  CONST(uint8, AUTOMATIC)  MemoryId,
  CONST(uint8, AUTOMATIC)  ClientId
  )
{
  Dem_EventIdType lEventId;

  if (UdsDtc >= DEM_CFG_DTC_UDS_INVALID)
  {
    lEventId = DEM_EVENT_INVALID;
  }
  else
  {
    Dem_Dcm_DtcCachePtrType lpCache;
    lpCache = Dem_Dcm_GetDtcCache(ClientId);

    if ( (lpCache->Dtc != UdsDtc)
      || (lpCache->MemoryId != MemoryId) )
    {
      lEventId = Dem_Util_DtcGetMasterEvent(Dem_Cfg_FindEventFromUdsDtc(UdsDtc, MemoryId));
      lpCache->Dtc = UdsDtc;                                                                                                     /* SBSW_DEM_POINTER_WRITE_DTC_CACHE */
      lpCache->MemoryId = MemoryId;                                                                                              /* SBSW_DEM_POINTER_WRITE_DTC_CACHE */
      lpCache->EventId = lEventId;                                                                                               /* SBSW_DEM_POINTER_WRITE_DTC_CACHE */
    }
    else
    {
      lEventId = lpCache->EventId;
    }
  }

  return lEventId;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON) */

/* ****************************************************************************
 % Dem_Dcm_ClearDtcTestIterInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_ClearDtcTestIterInit(
  CONST(uint8, AUTOMATIC)  MemoryId,
  CONST(uint8, AUTOMATIC)  DTCFormat,
  CONSTP2VAR(Dem_Dcm_ClearDtc_TestIterType, AUTOMATIC, AUTOMATIC) IterPtr
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (DTCFormat >= DEM_DTC_FORMAT_INVALID)
  {
    Dem_RunTimeCheckFailed(__LINE__);
    IterPtr->TestFuncPtr = Dem_Dcm_ClearDtc_TestFailWrongOrigin;                                                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
  else
#endif
  {
    switch (MemoryId)
    {
    case DEM_CFG_MEMORYID_PRIMARY:
      IterPtr->TestFuncPtr = Dem_Dcm_ClearDtc_TestPrimary[DTCFormat];                                                            /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      break;

#if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
    case DEM_CFG_MEMORYID_SECONDARY:
      IterPtr->TestFuncPtr = Dem_Dcm_ClearDtc_TestSecondary[DTCFormat];                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      break;
#endif

    default:
      IterPtr->TestFuncPtr = Dem_Dcm_ClearDtc_TestFailWrongOrigin;                                                               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      break;
    }
  }
  IterPtr->Index = 0;                                                                                                            /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
}

/* ****************************************************************************
 % Dem_Dcm_ClearDtcTestIterExists
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Dcm_ClearDtcTestIterExists(
  CONSTP2CONST(Dem_Dcm_ClearDtc_TestIterType, AUTOMATIC, AUTOMATIC) IterPtr
  )
{
  return (boolean)(IterPtr->TestFuncPtr[IterPtr->Index] != NULL_PTR);
}

/* ****************************************************************************
 % Dem_Dcm_ClearDtcTestIterGet
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CODE)
Dem_Dcm_ClearDtcTestIterGet(
  CONSTP2CONST(Dem_Dcm_ClearDtc_TestIterType, AUTOMATIC, AUTOMATIC) IterPtr
  )
{
  Dem_Dcm_ClearDtc_TestFuncPtrType lReturnValue;
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Dem_Dcm_ClearDtcTestIterExists(IterPtr) == FALSE)                                                                          /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  {
    Dem_RunTimeCheckFailed(__LINE__);
    lReturnValue = &Dem_Dcm_ClearDtc_TestWrongOrigin;
  }
  else
#endif
  {
    lReturnValue = IterPtr->TestFuncPtr[IterPtr->Index];
  }

  return lReturnValue;
}

/* ****************************************************************************
 % Dem_Dcm_ClearDtcTestIterNext
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_ClearDtcTestIterNext(
  CONSTP2VAR(Dem_Dcm_ClearDtc_TestIterType, AUTOMATIC, AUTOMATIC) IterPtr
  )
{
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
  if (Dem_Dcm_ClearDtcTestIterExists(IterPtr) == FALSE)                                                                          /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  {
    Dem_RunTimeCheckFailed(__LINE__);
  }
  else
#endif
  {
    IterPtr->Index += 1;                                                                                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }
}

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_CopyDidFromSRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyDidFromSRec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONST(boolean, AUTOMATIC)  ReportTotalRecord,
  CONST(uint16, AUTOMATIC)  DataId,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
  )
{
  Std_ReturnType lReturnValue;
  uint8 lSRecIndex;

  lReturnValue = E_OK;
  lSRecIndex = 0;

  /* Test for valid RecordNumber */
  if (RecordNumber != 0xff)
  {
    Dem_Cfg_EventSRecIterType lSRecIter;

    for (Dem_Cfg_EventSRecIterInit(EventId, &lSRecIter);                                                                         /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventSRecIterExists(&lSRecIter) == TRUE;                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventSRecIterNext(&lSRecIter))                                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_Cfg_SRecIndexType lCfgSRecIndex;

      lCfgSRecIndex = Dem_Cfg_EventSRecIterGet(&lSRecIter);                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
      DEM_IGNORE_UNUSED_VARIABLE(lCfgSRecIndex)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */

      if (RecordNumber == Dem_Cfg_SRecId(lCfgSRecIndex))
      {
        break;
      }
      else
      {
        ++lSRecIndex;
      }
    }
    if (Dem_Cfg_EventSRecIterExists(&lSRecIter) == FALSE)                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      lReturnValue = DEM_E_WRONG_RECORDNUMBER;
    }
  }
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  else
  {
    lReturnValue = DEM_E_WRONG_RECORDNUMBER;
  }
# endif

  if (lReturnValue == E_OK)
  {
    Dem_Mem_MemoryInfoPtrType lMemoryInfo;
    Dem_Cfg_MemoryIndexType lMemoryIndex;
    boolean lModificationDetected;

    lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));

    do
    {
      lModificationDetected = FALSE;
      lMemoryIndex = Dem_Mem_MemoryFindIndex(lMemoryInfo, EventId);                                                              /* SBSW_DEM_CALL_MEMORYINFO_POINTER */

      if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
      { /* The record currently exists, but without critical section it could age or displace */
        uint8 lUpdateState;

        lUpdateState = Dem_Mem_MemoryUpdateGetState(lMemoryIndex);

        if (FALSE == Dem_Mem_UpdateTestInProgress(lUpdateState))
        { /* This call does not currently interrupt a concurrent data update */
          Dem_Mem_EntryPtrType lEntry;
          lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);

# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
          if (RecordNumber == 0xffU)
          {
            lSRecIndex = (uint8)(lEntry->SnapshotHeader - 1);
          }
# endif
          if (FALSE != Dem_Data_SRecIsStored(lEntry, lSRecIndex))                                                                /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
          {
            lReturnValue = Dem_Dcm_CopyDidSRec_Internal(lEntry, lSRecIndex, ReportTotalRecord, DataId, DestBuffer);              /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
          }
          else
          {
            /* The requested data is currently not stored in the event memory */
            lReturnValue = DEM_E_NODATAAVAILABLE;
          }

          if ( (lReturnValue == E_OK)                                                                                            /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
            && (Dem_Mem_MemoryUpdateGetState(lMemoryIndex) != lUpdateState) )
          { /* The memory entry has been modified while trying to copy the stored data. */
            /* We cannot be sure it is still used by the same event, so start from the
            beginning */
            lModificationDetected = TRUE;
          }
        }
        else
        {
          /* The caller task has higher priority than Dem_MainFunction, but we cannot 'wait' for
             the update to complete. The requested data is not available at this moment. */
          lReturnValue = E_NOT_OK;
        }
      }
      else
      {
        /* The requested event is currently not stored in the event memory */
        lReturnValue = DEM_E_NODATAAVAILABLE;
      }
    }
    while (FALSE != lModificationDetected);
  }
  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_CopyDidSRec_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyDidSRec_Internal(
  CONST(Dem_Mem_ConstEntryPtrType, AUTOMATIC)  Entry,
  CONST(uint8, AUTOMATIC)  SRecIndex,
  CONST(boolean, AUTOMATIC)  ReportTotalRecord,
  CONST(uint16, AUTOMATIC)  DataId,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
  )
{
  Std_ReturnType lReturnValue;

  Dem_Cfg_EventDidIterType lDidIter;
  Dem_Data_CopyDidInfoType lCopyDidInfo;

  lCopyDidInfo.DestinationBuffer = DestBuffer;
  lCopyDidInfo.BufferSize        = Dem_Cfg_GlobalMaxDataValueSize();
  lCopyDidInfo.WriteIndex        = 0;
  lCopyDidInfo.SourceBuffer      = Dem_Mem_EntryGetSRecConstDataPtr(Entry, SRecIndex);                                           /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  lCopyDidInfo.ReadIndex         = 0;
  lCopyDidInfo.Entry             = Entry;
  lCopyDidInfo.EventId           = Entry->EventId;
  lReturnValue = DEM_E_WRONG_DIDNUMBER;

  for (Dem_Cfg_EventDidIterInit(Entry->EventId, &lDidIter);                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventDidIterExists(&lDidIter) == TRUE;                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventDidIterNext(&lDidIter))                                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_DidIndexType lDidIndex;
    lDidIndex = Dem_Cfg_EventDidIterGet(&lDidIter);                                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */

    if ( (Dem_Cfg_DidNumber(lDidIndex) == DataId)
      || (FALSE != ReportTotalRecord) )
    {
      if (Dem_Cfg_DidSize(lDidIndex) > lCopyDidInfo.BufferSize)
      {
        break;
      }

      (void)Dem_Data_CopyDid(&lCopyDidInfo, lDidIndex);                                                                          /* SBSW_DEM_POINTER_LOCAL_COPYDIDINFO */
      lReturnValue = E_OK;

      if (FALSE == ReportTotalRecord)
      {                                                                                                                          /* PRQA S 0715 */ /* MD_MSR_1.1_715 */
        break;                                                                                                                   /* PRQA S 0771 */ /* MD_DEM_14.6_err */
      }
    }
    else
    { /* not the requested DID */
      Dem_Data_SkipDid(&lCopyDidInfo, lDidIndex);                                                                                /* SBSW_DEM_POINTER_LOCAL_COPYDIDINFO */
    }
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_CopyERecs
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyERecs(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
)
{
  Std_ReturnType lReturnValue;
  Dem_Cfg_EventERecIterType lRecordIter;
  Dem_Cfg_ERecIndexType lCfgERecIndex;
  uint8 lERecStoredIndex;

  lCfgERecIndex = 0;
  lERecStoredIndex = 0;

  /* Find the requested record, and it's storage location */
  for (Dem_Cfg_EventERecIterInit(EventId, &lRecordIter);                                                                         /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventERecIterExists(&lRecordIter) == TRUE;                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventERecIterNext(&lRecordIter))                                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    lCfgERecIndex = Dem_Cfg_EventERecIterGet(&lRecordIter);                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */

    if (RecordNumber == Dem_Cfg_DidNumber(Dem_Cfg_ERecDid(lCfgERecIndex)))
    {
      break;
    }
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
    else
    {
      if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lCfgERecIndex))
      {
        ++lERecStoredIndex;
      }
    }
# endif
  }

  if (FALSE != Dem_Cfg_EventERecIterExists(&lRecordIter))                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
  { /* Found the record, retrieve it from its storage */
    uint8 lRecordType;
    lRecordType = Dem_Cfg_ERecType(lCfgERecIndex);

    if (DEM_CFG_EREC_TYPE_GLOBAL != lRecordType)
    { /* A stored record needs to be retrieved from event memory */
      Dem_Mem_MemoryInfoPtrType lMemoryInfo;
      Dem_Cfg_MemoryIndexType lMemoryIndex;
      boolean lModificationDetected;

      lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));

      do
      {
        lModificationDetected = FALSE;

        lMemoryIndex = Dem_Mem_MemoryFindIndex(lMemoryInfo, EventId);                                                            /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
        if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
        { /* The record currently exists, but without critical section it could age or displace */
          uint8 lUpdateState;
          lUpdateState = Dem_Mem_MemoryUpdateGetState(lMemoryIndex);

          if (Dem_Mem_UpdateTestInProgress(lUpdateState) == FALSE)
          { /* This call does not currently interrupt a concurrent data update */
            Dem_ConstSharedMemoryEntryPtrType lEntry;
            lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);

# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
            /* Supported record, test if it is currently stored */
            if ( (DEM_CFG_EREC_TYPE_USER == lRecordType)                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
              && (FALSE == Dem_Data_ERecIsStored(lEntry, lERecStoredIndex)) )                                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */ /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
            { /* The DTC has an event entry, but the requested record was not yet stored */
              lReturnValue = DEM_E_NODATAAVAILABLE;
            }
            else
# endif
            {
              Dem_Data_CopyDidInfoType  lCopyDidInfo;
              lCopyDidInfo.DestinationBuffer = DestBuffer;
              lCopyDidInfo.BufferSize        = Dem_Cfg_GlobalMaxDataValueSize();
              lCopyDidInfo.WriteIndex        = 0;
              lCopyDidInfo.ReadIndex         = 0;
              lCopyDidInfo.Entry             = lEntry;
              lCopyDidInfo.EventId           = EventId;

# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
              if (DEM_CFG_EREC_TYPE_USER == lRecordType)
              {
                lCopyDidInfo.SourceBuffer    = Dem_Mem_EntryGetERecConstDataPtr(lEntry, lERecStoredIndex);                       /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
              }
              else
# endif
              {
                /* No user data means there is no source buffer */
                lCopyDidInfo.SourceBuffer    = (Dem_ConstSharedDataPtrType)NULL_PTR;
              }

              if (Dem_Data_CopyDid(&lCopyDidInfo, Dem_Cfg_ERecDid(lCfgERecIndex)) == TRUE)                                       /* SBSW_DEM_POINTER_LOCAL_COPYDIDINFO */
              {
                lReturnValue = E_OK;
              }
              else
              {
                lReturnValue = DEM_E_NODATAAVAILABLE;
              }
            }

            if (lUpdateState != Dem_Mem_MemoryUpdateGetState(lMemoryIndex))
            { /* The memory entry has been modified while trying to copy the stored data. */
              /* We cannot be sure it is still used by the same event, so start from the
                 beginning */
              lModificationDetected = TRUE;
            }
          }
          else
          { /* The caller task has higher priority than Dem_MainFunction, but we cannot 'wait' for
               the update to complete. The requested data is not available at this moment. */
            lReturnValue = E_NOT_OK;
          }
        }
        else
        { /* The requested data is currently not stored in the event memory */
          lReturnValue = DEM_E_NODATAAVAILABLE;
        }
      }
      while (FALSE != lModificationDetected);
    }
    else
    { /* Statistic records always need to collect current data - if possible depending on event state */
      Dem_Data_CopyDidInfoType  lCopyDidInfo;
      lCopyDidInfo.DestinationBuffer = DestBuffer;
      lCopyDidInfo.BufferSize        = Dem_Cfg_GlobalMaxDataValueSize();
      lCopyDidInfo.WriteIndex        = 0;
      lCopyDidInfo.SourceBuffer      = (Dem_ConstSharedDataPtrType)NULL_PTR;
      lCopyDidInfo.ReadIndex         = 0;
      lCopyDidInfo.Entry             = (Dem_ConstSharedMemoryEntryPtrType)NULL_PTR;
      lCopyDidInfo.EventId           = EventId;

      /* Ignore return value, global statistics never fail the call. */
      if (Dem_Data_CopyDid(&lCopyDidInfo, Dem_Cfg_ERecDid(lCfgERecIndex)) == TRUE)                                               /* SBSW_DEM_POINTER_LOCAL_COPYDIDINFO */
      {
        lReturnValue = E_OK;
      }
      else
      {
        lReturnValue = DEM_E_NODATAAVAILABLE;
      }
    }
  }
  else
  {
    lReturnValue = DEM_E_WRONG_RECORDNUMBER;
  }
  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_ERECS == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_CopySRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetFreezeFrameDataByDTCType, DEM_CODE)
Dem_Dcm_CopySRec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  CONSTP2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  BufSize
  )
{
  Dem_ReturnGetFreezeFrameDataByDTCType lReturnValue;
  Dem_Cfg_EventSRecIterType lRecordIter;
  uint8 lSRecIndex;

  lReturnValue = DEM_GET_FFDATABYDTC_OK;
  lSRecIndex = 0;

  for (Dem_Cfg_EventSRecIterInit(EventId, &lRecordIter);                                                                         /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventSRecIterExists(&lRecordIter) == TRUE;                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventSRecIterNext(&lRecordIter))                                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_SRecIndexType lCfgSRecIndex;
    lCfgSRecIndex = Dem_Cfg_EventSRecIterGet(&lRecordIter);                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */

    DEM_IGNORE_UNUSED_VARIABLE(lCfgSRecIndex)                                                                                    /* PRQA S 3112 */ /* MD_DEM_14.2 */

# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
    if (RecordNumber < Dem_Cfg_SRecId(lCfgSRecIndex))
    { /* overshoot -> snapshot not supported */
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
    }
    else
# endif
    if (RecordNumber == Dem_Cfg_SRecId(lCfgSRecIndex))
    {
      if (*BufSize < Dem_Cfg_EventSRecUdsSize(EventId))
      { /* supported record, but the buffer is not large enough for all the data */
        lReturnValue = DEM_GET_FFDATABYDTC_WRONG_BUFFERSIZE;
      }
      else
      {
        if (Dem_Data_SRecIsStored(&Dem_Cfg_ReadoutBuffer, lSRecIndex) == TRUE)                                                   /* SBSW_DEM_POINTER_FORWARD_GLOBAL */
        {
          DestBuffer[0] = RecordNumber;                                                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT_BUFFER */
          Dem_Data_SRecCopyData(&DestBuffer[1],                                                                                  /* SBSW_DEM_POINTER_WRITE_ARGUMENT_BUFFER */
                                Dem_Mem_EntryGetSRecConstDataPtr(&Dem_Cfg_ReadoutBuffer, lSRecIndex),                            /* SBSW_DEM_POINTER_FORWARD_GLOBAL */
                                (Dem_Cfg_EventSRecUdsSize(EventId) - 1),
                                EventId);
          *BufSize = Dem_Cfg_EventSRecUdsSize(EventId);                                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
        else
        {
          *BufSize = 0;                                                                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
      }
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
    }
    else
    { /* next snapshot record */ }

    ++lSRecIndex;
  }
  if (Dem_Cfg_EventSRecIterExists(&lRecordIter) == FALSE)                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if ( (DEM_CFG_SUPPORT_DCM == STD_ON) \
   && ( (DEM_CFG_SUPPORT_SRECS == STD_ON) \
     || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) \
     || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
     || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) ) )                                                                                   /* COV_MSR_UNSUPPORTED TF tf tf xf xf */
/* ****************************************************************************
 % Dem_Dcm_GetSizeOfSRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_Dcm_GetSizeOfSRec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  SizeOfFreezeFrame                                                                /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_False */
  )
{
  Dem_ReturnGetSizeOfDataByDTCType lReturnValue;

  if (RecordNumber == 0xffU)
  { /* No data is a positive result for 0xff */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED TX */
    lReturnValue = DEM_GETSIZEBYDTC_OK;
    *SizeOfFreezeFrame = (uint16)(Dem_Data_SRecCount(&Dem_Cfg_ReadoutBuffer) * Dem_Cfg_EventSRecUdsSize(EventId));               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */ /* SBSW_DEM_POINTER_FORWARD_GLOBAL */
# else
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
    /* SizeOfFreezeFrame intentionally not modified due to invalid request */
# endif
  }
  else
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)
  { /* Specific record not found is a negative result */
    Dem_Cfg_EventSRecIterType lRecordIter;
    uint8 lSRecIndex;

    lReturnValue = DEM_GETSIZEBYDTC_OK;
    lSRecIndex = 0;

    for (Dem_Cfg_EventSRecIterInit(EventId, &lRecordIter);                                                                       /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventSRecIterExists(&lRecordIter) == TRUE;                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventSRecIterNext(&lRecordIter))                                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_Cfg_SRecIndexType lCfgSRecIndex;
      lCfgSRecIndex = Dem_Cfg_EventSRecIterGet(&lRecordIter);                                                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
      DEM_IGNORE_UNUSED_VARIABLE(lCfgSRecIndex)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */

      if (Dem_Cfg_SRecId(lCfgSRecIndex) == RecordNumber)
      {
        if (Dem_Data_SRecIsStored(&Dem_Cfg_ReadoutBuffer, lSRecIndex) == TRUE)                                                   /* SBSW_DEM_POINTER_FORWARD_GLOBAL */
        {
          *SizeOfFreezeFrame = Dem_Cfg_EventSRecUdsSize(EventId);                                                                /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
        else
        {
          *SizeOfFreezeFrame = 0;                                                                                                /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
        break;
      }
      else
      {
        /* next snapshot record */
      }

      ++lSRecIndex;
    }

    if (Dem_Cfg_EventSRecIterExists(&lRecordIter) == FALSE)                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
    }
  }
# else
  {
    DEM_IGNORE_UNUSED_CONST_ARGUMENT(SizeOfFreezeFrame)                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventId)                                                                                    /* PRQA S 3112 */ /* MD_DEM_14.2 */
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
  }
# endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_CopyERec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetExtendedDataRecordByDTCType , DEM_CODE)
Dem_Dcm_CopyERec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  CONSTP2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  BufSize
  )
{
  Dem_ReturnGetExtendedDataRecordByDTCType lReturnValue;
  Dem_Cfg_EventERecIterType lRecordIter;
  Dem_Data_CopyDidInfoType lCopyDidInfo;
  uint8 lERecStoredIndex;

  lReturnValue = DEM_RECORD_WRONG_NUMBER;
  lCopyDidInfo.DestinationBuffer = DestBuffer;
  lCopyDidInfo.BufferSize        = *BufSize;
  lCopyDidInfo.WriteIndex        = 0;
  lCopyDidInfo.EventId           = EventId;
  lERecStoredIndex = 0;

  /* Find the Record number */
  for (Dem_Cfg_EventERecIterInit(EventId, &lRecordIter);                                                                         /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventERecIterExists(&lRecordIter) == TRUE;                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_EventERecIterNext(&lRecordIter))                                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_ERecIndexType lCfgERecIndex;

    lCfgERecIndex = Dem_Cfg_EventERecIterGet(&lRecordIter);                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
    if (RecordNumber == Dem_Cfg_DidNumber(Dem_Cfg_ERecDid(lCfgERecIndex)))
    {
      uint8 lERecType = Dem_Cfg_ERecType(lCfgERecIndex);

      if (DEM_CFG_EREC_TYPE_GLOBAL != lERecType)
      { /* Supported record, test if it is stored - if no entry was found, the stored mask is cleared as well! */
        if ( (DEM_EVENT_INVALID != Dem_Cfg_ReadoutBuffer.EventId)                                                                /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
          && ( (DEM_CFG_EREC_TYPE_INTERNAL == lERecType)                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
            || (FALSE != Dem_Data_ERecIsStored(&Dem_Cfg_ReadoutBuffer, lERecStoredIndex)) )                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */ /* SBSW_DEM_POINTER_FORWARD_GLOBAL */
# endif
          )
        { /* Check buffer size after stored status - the buffer needs not be large enough for an empty response */
          if (Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) > lCopyDidInfo.BufferSize)
          {
            lReturnValue = DEM_RECORD_WRONG_BUFFERSIZE;
          }
          else
          {
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
            if (lERecType == DEM_CFG_EREC_TYPE_USER)
            {
              lCopyDidInfo.SourceBuffer = Dem_Mem_EntryGetERecConstDataPtr(&Dem_Cfg_ReadoutBuffer, lERecStoredIndex);            /* SBSW_DEM_POINTER_FORWARD_GLOBAL */
            }
            else
# endif
            {
              lCopyDidInfo.SourceBuffer = (Dem_ConstSharedDataPtrType)NULL_PTR;
            }

            lCopyDidInfo.ReadIndex    = 0;
            lCopyDidInfo.Entry        = (Dem_SharedMemoryEntryPtrType)&Dem_Cfg_ReadoutBuffer;

            if (Dem_Data_CopyDid(&lCopyDidInfo, Dem_Cfg_ERecDid(lCfgERecIndex)) == TRUE)                                         /* SBSW_DEM_POINTER_LOCAL_COPYDIDINFO */
            {
              *BufSize = Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex));                                                        /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
            }
            else
            {
              *BufSize = 0;                                                                                                      /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
            }
            lReturnValue = DEM_RECORD_OK;
          }
        }
        else
        { /* records not currently stored are returned with empty content */
          lReturnValue = DEM_RECORD_OK;
          *BufSize = 0;                                                                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
      }
      else
      { /* Statistic records always need to collect current data - if possible depending on event state */
        if (Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) > *BufSize)
        {
          lReturnValue = DEM_RECORD_WRONG_BUFFERSIZE;
        }
        else
        {
          lReturnValue = DEM_RECORD_OK;

          lCopyDidInfo.SourceBuffer = (Dem_ConstSharedDataPtrType)NULL_PTR;
          lCopyDidInfo.ReadIndex    = 0;
          lCopyDidInfo.Entry        = (Dem_SharedMemoryEntryPtrType)NULL_PTR;

          (void)Dem_Data_CopyDid(&lCopyDidInfo, Dem_Cfg_ERecDid(lCfgERecIndex));                                                 /* SBSW_DEM_POINTER_LOCAL_COPYDIDINFO */
          *BufSize = Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex));                                                            /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
      }
    }
    else
    {
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
      if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lCfgERecIndex))
      {
        ++lERecStoredIndex;
      }
# endif
    }
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_GetSizeOfERec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_Dcm_GetSizeOfERec(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  RecordNumber,
  CONSTP2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  SizeOfExtendedDataRecord
  )
{
  Dem_ReturnGetSizeOfDataByDTCType lReturnValue;
  Dem_Cfg_EventERecIterType lRecordIter;
  uint16 lAccumulatedSize;
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  uint8 lERecStoredIndex;
# endif

  /* Find the Record number */
  lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
  lAccumulatedSize = 0;
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  lERecStoredIndex = 0;
# endif

  if (RecordNumber < 0xf0U)
  {
    /* Look for one specific record */
    for (Dem_Cfg_EventERecIterInit(EventId, &lRecordIter);                                                                       /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventERecIterExists(&lRecordIter) == TRUE;                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventERecIterNext(&lRecordIter))                                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_Cfg_ERecIndexType lCfgERecIndex;

      lCfgERecIndex = Dem_Cfg_EventERecIterGet(&lRecordIter);                                                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if (RecordNumber == Dem_Cfg_DidNumber(Dem_Cfg_ERecDid(lCfgERecIndex)))
      { /* If the record is supported, the result is always 'OK' */
        uint8 lERecType;

        lERecType = Dem_Cfg_ERecType(lCfgERecIndex);
        lReturnValue = DEM_GETSIZEBYDTC_OK;

        if (DEM_CFG_EREC_TYPE_GLOBAL != lERecType)
        { /* Supported record, test if it is stored - if no entry was found, the stored mask is cleared as well! */
          if ( (DEM_EVENT_INVALID != Dem_Cfg_ReadoutBuffer.EventId)                                                              /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
            && ( (DEM_CFG_EREC_TYPE_INTERNAL == lERecType)                                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
              || (FALSE != Dem_Data_ERecIsStored(&Dem_Cfg_ReadoutBuffer, lERecStoredIndex)) )                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */ /* SBSW_DEM_POINTER_FORWARD_GLOBAL */
# endif
            )
          { /* add record id to data size */
            lAccumulatedSize = (uint16)(Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) + 1);
          }
          else
          {
            lAccumulatedSize = 0;
          }
        }
        else
        { /* Currently statistic data is always available, add record id to data size */
          lAccumulatedSize = (uint16)(Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) + 1);
        }
        break;
      }
      else
      {
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
        if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lCfgERecIndex))
        {
          ++lERecStoredIndex;
        }
# endif
      }
    }
  }
  else
  { /* Look for all supported records */
    uint8 lERecMinNumber;
    if (RecordNumber == 0xffU)
    {
      lERecMinNumber = 0x00U;
    }
    else
    {
      lERecMinNumber = 0x8fU;
    }

    for (Dem_Cfg_EventERecIterInit(EventId, &lRecordIter);                                                                       /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventERecIterExists(&lRecordIter) == TRUE;                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_EventERecIterNext(&lRecordIter))                                                                                /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      Dem_Cfg_ERecIndexType lCfgERecIndex;

      lCfgERecIndex = Dem_Cfg_EventERecIterGet(&lRecordIter);                                                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
      if (Dem_Cfg_DidNumber(Dem_Cfg_ERecDid(lCfgERecIndex)) > lERecMinNumber)
      { /* At least one record found - the result should be negative in case the event doesn't
            support any of the requested extended records. */
        uint8 lERecType;

        lERecType = Dem_Cfg_ERecType(lCfgERecIndex);
        lReturnValue = DEM_GETSIZEBYDTC_OK;

        if (DEM_CFG_EREC_TYPE_GLOBAL != lERecType)
        { /* Supported record, test if it is stored - if no entry was found, the stored mask is cleared as well! */
          if ( (DEM_EVENT_INVALID != Dem_Cfg_ReadoutBuffer.EventId)                                                              /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
            && ( (DEM_CFG_EREC_TYPE_INTERNAL == lERecType)                                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
              || (FALSE != Dem_Data_ERecIsStored(&Dem_Cfg_ReadoutBuffer, lERecStoredIndex)) )                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */ /* SBSW_DEM_POINTER_FORWARD_GLOBAL */
# endif
            )
          { /* add record id to data size */
            lAccumulatedSize = (uint16)(lAccumulatedSize + Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) + 1);
          }
        }
        else
        { /* Currently statistic data is always available, add record id to data size */
          lAccumulatedSize = (uint16)(lAccumulatedSize + Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) + 1);
        }
      }
      else
      {
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
        if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lCfgERecIndex))
        {
          ++lERecStoredIndex;
        }
# endif
      }
    }
  }

  if (lReturnValue == DEM_GETSIZEBYDTC_OK)
  {
    *SizeOfExtendedDataRecord = lAccumulatedSize;                                                                                /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_GetNumberOfSRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Dcm_GetNumberOfSRec(
  void
)
{
  Dem_Mem_MemoryInfoPtrType lMemoryInfo;
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_Cfg_MemoryIndexType lMemoryIndexEnd;
  uint16 lRecordCount;

  /* Count stored snapshot records in primary memory to prevent concurrent modification
  of the chrono index to have an effect on the iteration */
  lMemoryInfo = Dem_Mem_MemoryInfoInit(DEM_CFG_MEMORYID_PRIMARY);
  lMemoryIndex = Dem_Mem_MemoryIter_Begin(lMemoryInfo);                                                                          /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
  lMemoryIndexEnd = Dem_Mem_MemoryIter_End(lMemoryInfo);                                                                         /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
  lRecordCount = 0;

  while (lMemoryIndex < lMemoryIndexEnd)
  {
    Dem_EventIdType lEventId;

    lEventId = Dem_Mem_EntryGetEventId(Dem_Mem_MemoryGetEntry(lMemoryIndex));
    if (Dem_Util_TestEventValid(lEventId) == TRUE)
    {
      {
        {
          /* Occupied entry */
          lRecordCount = (uint16)(lRecordCount + Dem_Data_SRecCount(Dem_Mem_MemoryGetEntry(lMemoryIndex)));                        /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
        }
      }
    }

    ++lMemoryIndex;
  }

  return lRecordCount;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterSRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Dcm_FilterSRec(
  CONSTP2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,                                                                              /* PRQA S 3673 */ /* MD_DEM_16.7 */
  CONSTP2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  RecordNumber
  )
{
  Dem_Mem_MemoryInfoPtrType lMemoryInfo;
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_Cfg_MemoryIndexType lMemoryIndexEnd;
  uint8 lSnapshotIndex;
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  uint8 lSnapshotTestMask;
# endif

  lMemoryInfo = Dem_Mem_MemoryInfoInit(DEM_CFG_MEMORYID_PRIMARY);
  lMemoryIndex = Dem_Dcm_FilterRecordGetMemIndex();
  lMemoryIndexEnd = Dem_Mem_MemoryIter_End(lMemoryInfo);                                                                         /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
  lSnapshotIndex = Dem_Dcm_FilterRecordGetSRecIndex();

  while (lMemoryIndex < lMemoryIndexEnd)
  {
    Dem_EventIdType lEventId;
    Dem_Mem_EntryPtrType lEntry;

    lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);
    lEventId = Dem_Mem_EntryGetEventId(lEntry);
    if (Dem_Util_TestEventValid(lEventId) == TRUE)
    {
      {
        {
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
          if (lSnapshotIndex < lEntry->SnapshotHeader)
          { /* Current snapshot is stored, return it */
# else /* (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON) */
          if (lSnapshotIndex == 0)
          { /* Starting with the first record, we initialize the iterator needed to find supported record numbers */
            Dem_Cfg_EventSRecIterInit(lEventId, Dem_Dcm_FilterRecordGetIterator());                                              /* SBSW_DEM_DCM_FILTERRECORD_ITERATOR_POINTER */
          }
          lSnapshotTestMask = (uint8)(1U << lSnapshotIndex);
          while (Dem_Cfg_EventSRecIterExists(Dem_Dcm_FilterRecordGetIterator()) == TRUE)                                         /* SBSW_DEM_DCM_FILTERRECORD_ITERATOR_POINTER */
          {
            Dem_Cfg_SRecIndexType lCfgSRecIndex;
            lCfgSRecIndex = Dem_Cfg_EventSRecIterGet(Dem_Dcm_FilterRecordGetIterator());                                         /* SBSW_DEM_DCM_FILTERRECORD_ITERATOR_POINTER */
            DEM_IGNORE_UNUSED_VARIABLE(lCfgSRecIndex)                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */

            /* Increment iterator in global state, the next iteration will continue with the next record */
            Dem_Cfg_EventSRecIterNext(Dem_Dcm_FilterRecordGetIterator());                                                        /* SBSW_DEM_DCM_FILTERRECORD_ITERATOR_POINTER */

            if (0 == (lEntry->SnapshotHeader & lSnapshotTestMask))
            { /* Continue immediately with the next possible record in this iteration, the Dcm always expects a record */
              ++lSnapshotIndex;
              lSnapshotTestMask = (uint8)(lSnapshotTestMask << 1U);
              continue;                                                                                                          /* PRQA S 0770 */ /* MD_DEM_14.5 */
            }
# endif
            /* Increment in global state, the next iteration will continue with the next record */
            Dem_Dcm_FilterRecordSetMemIndex(lMemoryIndex);
            Dem_Dcm_FilterRecordSetSRecIndex((uint8)(lSnapshotIndex + 1));

            { /* Only EventIds with a valid DTC number are processed here */                                                     /* PRQA S 0715 */  /* MD_MSR_1.1_715 */
              /* -> DTC mapping will always return a valid DTC number */
              *DTC = Dem_Cfg_EventUdsDtc(lEventId);                                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
            }
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
            *RecordNumber = (uint8)(lSnapshotIndex + 1);                                                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# endif
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
            *RecordNumber = Dem_Cfg_SRecId(lCfgSRecIndex);                                                                       /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# endif
            return TRUE;
          }
        }
      }
    }
    ++lMemoryIndex;
    lSnapshotIndex = 0;
  }

  Dem_Dcm_FilterRecordSetSRecIndex(lSnapshotIndex);

  return FALSE;
}                                                                                                                                /* PRQA S 2006, 6030, 6050, 6080 */ /* MD_DEM_14.7, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON) */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Esm_EventQueueAsync_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventQueueAsync_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_ConstDebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  )
{
  Std_ReturnType lReturnValue;

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  if (FALSE != DebounceInfo->Common.RequestProcessing)
  { /* update event entry with a new max value > pre-confirmation limit on task level */
    Dem_Queue_SetEventStatus(EventId, DEM_QUEUE_SET_FDCPROCESSING(Dem_Queue_GetEventStatus(EventId)));
  }
#endif

  lReturnValue = Dem_Queue_SetPendingEvent_Queued(EventId, DebounceInfo->Common.MonitorStatus);

  return lReturnValue;
}

/* ****************************************************************************
 % Dem_Esm_EventQueueAsync_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventQueueAsync_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_ConstDebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  )
{
  Std_ReturnType lReturnValue;
  uint8 lOldEventStatus;

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  if (FALSE != DebounceInfo->Common.RequestProcessing)
  { /* update event entry with a new max value > pre-confirmation limit on task level */
    Dem_Queue_SetEventStatus(EventId, DEM_QUEUE_SET_FDCPROCESSING(Dem_Queue_GetEventStatus(EventId)));
  }
#endif

  lReturnValue = Dem_Queue_SetPendingEvent_Immediate(EventId,
                                                     DebounceInfo->Common.MonitorStatus,
                                                     lOldEventStatus);

  return lReturnValue;
}

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_ProcessTimeDebounce
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_ProcessTimeDebounce(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_DebounceInfoType lDebounceInfo;
  sint16 lOldDebounceTime;
  sint16 lNewDebounceTime;
  boolean lEnableConditionsSatisfied;

  Dem_Esm_DebounceInfoInit(EventId, &lDebounceInfo);                                                                             /* SBSW_DEM_CALL_DEBOUNCEINFO_INIT */
  lDebounceInfo.Specific.TimeBased.OldInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  switch (Dem_Mem_GetDebounceStatus(lDebounceInfo.Specific.TimeBased.OldInternalStatus))
  {
  case DEM_ESM_DEBOUNCE_FREEZE_PASSED:
  case DEM_ESM_DEBOUNCE_FREEZE_FAILED:
  case DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC:
  case DEM_ESM_DEBOUNCE_DONE_PASSED:
  case DEM_ESM_DEBOUNCE_DONE_FAILED:
  case DEM_ESM_DEBOUNCE_STATUS_NONE:
    /* nothing to do here */
    return;
  default:
    break;
  }

  lDebounceInfo.Specific.TimeBased.NewInternalStatus = lDebounceInfo.Specific.TimeBased.OldInternalStatus;
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  lDebounceInfo.Common.RequestProcessing = FALSE;
#endif
  lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_INVALID;
  lOldDebounceTime = Dem_Mem_EventGetDebounceValue(EventId);

  lEnableConditionsSatisfied = (boolean)
    ((Dem_CurrentEnableConditionStates & Dem_Cfg_EventEnableConditions(EventId)) == Dem_Cfg_EventEnableConditions(EventId));

  /* Process debounce counters */
  switch (Dem_Mem_GetDebounceStatus(lDebounceInfo.Specific.TimeBased.OldInternalStatus))
  {
  case DEM_ESM_DEBOUNCE_RESET_PASSED:
    lNewDebounceTime = Dem_Cfg_EventPassedTime(EventId);
    lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        Dem_Mem_SetDebounceStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_PASSED);
    break;

  case DEM_ESM_DEBOUNCE_RESET_FAILED:
    lNewDebounceTime = Dem_Cfg_EventFailedTime(EventId);
    lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        Dem_Mem_SetDebounceStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_FAILED);
    break;

  case DEM_ESM_DEBOUNCE_COUNT_PASSED:
    /* process event timer */
    lNewDebounceTime = (sint16)(lOldDebounceTime - 1);
    if (0 == lNewDebounceTime)
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        Dem_Mem_SetDebounceStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_PASSED);
      lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_PASSED;
    }
    break;

  case DEM_ESM_DEBOUNCE_COUNT_FAILED:
    /* process event timer */
    lNewDebounceTime = (sint16)(lOldDebounceTime - 1);
#if (DEM_CFG_STORAGE_AT_FDC != STD_ON)
    if (0 == lNewDebounceTime)
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        Dem_Mem_SetDebounceStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_FAILED);
      lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;
    }
#endif
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
# if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
    if (lNewDebounceTime <= Dem_Cfg_EventStorageTime(EventId))
    {
      if (0 == lNewDebounceTime)
      {
        lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          Dem_Mem_SetDebounceStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_FAILED);
        lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;
      }
      else
      {
        lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          Dem_Mem_SetDebounceStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC);
      }
      if (lEnableConditionsSatisfied == TRUE)
      {
        lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          Dem_Mem_SetFdcTripStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus);
        lDebounceInfo.Common.RequestProcessing = TRUE;
      }
    }
# endif
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    if ( (lEnableConditionsSatisfied == TRUE)                                                                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_EventGetDebounceValueMax(EventId) > lNewDebounceTime) )
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        Dem_Mem_SetFdcMaxStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus);
      lDebounceInfo.Common.RequestProcessing = TRUE;
    }
# endif
#endif
    break;

#if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
  case DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC:
    /* process event timer */
    lNewDebounceTime = (sint16)(lOldDebounceTime - 1);
    if (0 == lNewDebounceTime)
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          Dem_Mem_SetDebounceStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_FAILED);
      lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;
    }

# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    if ( (lEnableConditionsSatisfied == TRUE)                                                                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_EventGetDebounceValueMax(EventId) > lNewDebounceTime) )
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          Dem_Mem_SetFdcMaxStatus(lDebounceInfo.Specific.TimeBased.NewInternalStatus);
      lDebounceInfo.Common.RequestProcessing = TRUE;
    }
# endif
    break;
#endif

  default:
    Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_INCONSISTENT_STATE)
    return;
  }

  /* Commit changes */
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if (lDebounceInfo.Specific.TimeBased.OldInternalStatus == Dem_Mem_EventGetInternalStatus(EventId))
  {
    Dem_Mem_EventSetDebounceValue(EventId, lNewDebounceTime);
    Dem_Mem_EventSetInternalStatus(EventId, lDebounceInfo.Specific.TimeBased.NewInternalStatus);

# if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
    if (DEM_ESM_DEBOUNCE_COUNT_FAILED == Dem_Mem_GetDebounceStatus(lDebounceInfo.Specific.TimeBased.OldInternalStatus))
    {
      if (Dem_Mem_EventGetDebounceValueMax(EventId) > lNewDebounceTime)
      {
        Dem_Mem_EventSetDebounceValueMax(EventId, lNewDebounceTime);
      }
    }
# endif
    if ( (lEnableConditionsSatisfied == TRUE)
      && ( (lDebounceInfo.Common.MonitorStatus <= DEM_EVENT_STATUS_FAILED)
#  if ( (DEM_CFG_STORAGE_AT_FDC == STD_ON) \
     || (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON) )
        || (FALSE != lDebounceInfo.Common.RequestProcessing)
#  endif
       ) )
    {
      (void)Dem_Esm_EventQueueAsync_Queued(EventId, &lDebounceInfo);                                                             /* SBSW_DEM_CALL_DEBOUNCEINFO_POINTER */
    }
  }

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}                                                                                                                                /* PRQA S 2006, 6010, 6030, 6050 */ /* MD_DEM_14.7, MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */
#endif /* (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) */

/* ****************************************************************************
 % Dem_Esm_PreInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PreInit(
  void
  )
{
  Dem_Mem_CurrentCycleState = 0U;
#if (DEM_CFG_SUPPORT_RESTART_CYCLE == STD_ON)
  Dem_Mem_CurrentCycleState = (uint16)(Dem_Mem_CurrentCycleState | (uint16)(1U << Dem_Cfg_GlobalRestartCycleId()));
#endif
  {
    Dem_EventIdType lEventId;
    for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
    {
      Dem_Mem_EventSetDebounceValue(lEventId, 0);
      Dem_Mem_EventSetDebounceValueMax(lEventId, 0);

      if (Dem_Cfg_EventAvailableByDefault(lEventId) == TRUE)
      {
        Dem_Mem_EventSetInternalStatus(lEventId, 0);
      }
      else
      {
        Dem_Mem_EventSetInternalStatus(lEventId, Dem_Mem_SetEventDisconnectedStatus(0));
      }
    }
  }
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  {
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    for (lGroupId = 0; lGroupId < Dem_Cfg_GlobalCombinedGroupCount(); ++lGroupId)
    {
      Dem_Cfg_EventInternalStatusType lInternalStatus;
      Dem_Cfg_CombinedGroupIterType lSubEventIter;

      lInternalStatus = Dem_Mem_SetEventDisconnectedStatus(0);
      for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lSubEventIter);                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
          Dem_Cfg_CombinedGroupIterExists(&lSubEventIter) == TRUE;                                                               /* SBSW_DEM_CALL_ITERATOR_POINTER */
          Dem_Cfg_CombinedGroupIterNext(&lSubEventIter))                                                                         /* SBSW_DEM_CALL_ITERATOR_POINTER */
      {
        if (Dem_Cfg_EventAvailableByVariant(Dem_Cfg_CombinedGroupIterGet(&lSubEventIter)) == TRUE)                               /* SBSW_DEM_CALL_ITERATOR_POINTER */
        {
          lInternalStatus = Dem_Mem_SetAvailableInVariantStatus(lInternalStatus);
        }
        if (Dem_Cfg_EventAvailableByDefault(Dem_Cfg_CombinedGroupIterGet(&lSubEventIter)) == TRUE)                               /* SBSW_DEM_CALL_ITERATOR_POINTER */
        {
          lInternalStatus = Dem_Mem_ResetEventDisconnectedStatus(lInternalStatus);
        }
      }
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lInternalStatus);
    }
  }
#endif
#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME_LR == STD_ON)
  Dem_Esm_DebounceLoResTimer = Dem_Cfg_DebounceLoResTimerValue();
#endif
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_PrestorageInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PrestorageInit(
  void
  )
{
  Dem_Esm_PrestorageLockedIndex = DEM_MEM_INVALID_PRESTORAGE_INDEX;
}
#endif

/* ****************************************************************************
 % Dem_Esm_InitEventAvailableNV
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventAvailableNV(
  void
  )
{
#if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
  Dem_EventIdType lEventId;
  uint16_least lMaskIndex;
  uint16_least lMaskIndex_End;

  lEventId = 0;
  lMaskIndex_End = (uint16_least)((Dem_Cfg_GlobalEventCount() + 7) / 8);

  /* */
  for (lMaskIndex = 0; lMaskIndex < lMaskIndex_End; ++lMaskIndex)
  {
    Dem_EventIdType lEventId_End;
    uint8 lNvAvailableMask;

    lEventId_End = lEventId + 8;
    if (lEventId_End > Dem_Cfg_GlobalEventCount())
    {
      lEventId_End = Dem_Cfg_GlobalEventCount();
    }
    lNvAvailableMask = Dem_Mem_EventGetAvailableMask(lMaskIndex);

    while (lEventId < lEventId_End)
    {
      if ((lNvAvailableMask & 0x01) != 0)
      {
        boolean lMayDisconnect;
        lMayDisconnect = Dem_Esm_EventMayDisconnect(lEventId);
        Dem_Esm_EventSetDisconnectedBit(lEventId, lMayDisconnect);
      }
      else
      {
        Dem_Esm_EventSetDisconnectedBit(lEventId, FALSE);
      }
      lNvAvailableMask = (uint8)(lNvAvailableMask >> 1);
      ++lEventId;
    }
  }
#endif
}

/* ****************************************************************************
 % Dem_Esm_InitEventInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventInternalStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId                                                                                     /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(EventId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON)
  if (Dem_Cfg_EventAvailableByDefault(EventId) == FALSE)
  {
    Dem_Esm_EventSetDisconnectedBit(EventId, Dem_Esm_EventMayDisconnect(EventId));
  }
  else
  {
    Dem_Esm_EventSetDisconnectedBit(EventId, FALSE);
  }
#endif
}

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_InitGroupInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitGroupInternalStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
# if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON)
  Dem_Cfg_CombinedGroupIterType lSubEventIter;
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(GroupId);
  lInternalStatus = Dem_Mem_SetEventDisconnectedStatus(lInternalStatus);

  for (Dem_Cfg_CombinedGroupIterInit(GroupId, &lSubEventIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_CombinedGroupIterExists(&lSubEventIter) == TRUE;                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_CombinedGroupIterNext(&lSubEventIter))                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    if (FALSE != Dem_Cfg_EventAvailableByDefault(Dem_Cfg_CombinedGroupIterGet(&lSubEventIter)))                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      lInternalStatus = Dem_Mem_ResetEventDisconnectedStatus(lInternalStatus);
    }
  }
  Dem_Mem_CombinedGroupSetInternalStatus(GroupId, lInternalStatus);
# endif
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(GroupId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

/* ****************************************************************************
 % Dem_Esm_InitEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventStatus(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  uint8 lEventStatus;
  Dem_Cfg_EventInternalStatusType lAgedStatus;

  lEventStatus = Dem_Mem_EventGetStatus(EventId);
  lAgedStatus = Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(EventId));

  if (Dem_Cfg_EventAvailableByVariant(EventId) == FALSE)
  {
    lEventStatus = 0x00;
  }
  else
#if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
  if (DEM_ESM_STORED_STATUS_NONE == lAgedStatus)
  {
    /* Event is not stored, reset stored-only bits.
      * Note: this relies on the compiler to optimize the different bit operations into a single mask operation.
      * The intention is to find a dedicated access for each Bit modification for review purposes.*/
# if (DEM_CFG_PROCESS_PDTC_STOREDONLY == STD_ON)
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lEventStatus);
# endif
# if (DEM_CFG_PROCESS_CDTC_STOREDONLY == STD_ON)
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_CDTC(lEventStatus);
# endif
# if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON)
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_TFSLC(lEventStatus);
# endif
  }
  else
#endif
#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
  if (DEM_ESM_STORED_STATUS_AGED == lAgedStatus)
  {
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lEventStatus);
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_CDTC(lEventStatus);
# if (DEM_CFG_PROCESS_TFSLC_ALL_DTC == STD_ON)
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_TFSLC(lEventStatus);
# endif
  }
  else
#endif
  if (DEM_ESM_STORED_STATUS_AGING == lAgedStatus)
  {
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lEventStatus);
  }
  else
  {
    /* Satisfy MISRA */
  }

#if (DEM_CFG_SUPPORT_TESTFAILED_STORAGE != STD_ON)
  lEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lEventStatus);
#endif

  if ((DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC) == (lEventStatus & (DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC)))
  { /* Test not completed, but failed this cycle is not a consistent state.
       Reset TFTOC to restore consistency. This also makes sure a new test
       result is processed */
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_TFTOC(lEventStatus);
  }
  if ((DEM_UDS_STATUS_TFSLC | DEM_UDS_STATUS_TNCSLC) == (lEventStatus & (DEM_UDS_STATUS_TFSLC | DEM_UDS_STATUS_TNCSLC)))
  { /* Test not completed, but failed since last clear is not a consistent state.
       Reset TNCSLC to restore consistency. Keep TFSLC since it is sometimes
       set by correction code */
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lEventStatus);
  }

  {
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
# if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)                                                                                 /* COV_MSR_UNSUPPORTED TF */
    Dem_Cfg_EventIndicatorIterType lIndicatorIter;
    Dem_Cfg_EventIndicatorIterInit(EventId, &lIndicatorIter);                                                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
    if (Dem_Cfg_EventIndicatorIterExists(&lIndicatorIter) == FALSE)                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
# endif
    {
#endif /* (DEM_FEATURE_NEED_INDICATORS == STD_ON) */
      {
        lEventStatus = DEM_ESM_RESET_UDS_STATUS_WIR(lEventStatus);
      }
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
    }
#endif
  }

  Dem_Mem_EventSetStatus(EventId, lEventStatus);

#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  if (DEM_ESM_TEST_UDS_STATUS_WIR(lEventStatus) == TRUE)
  {
    {
# if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)                                                                                 /* COV_MSR_UNSUPPORTED TX */
      Dem_Esm_UserIndicatorEnable(EventId);
# endif
    }
  }
#endif /* (DEM_CFG_SUPPORT_INDICATORS == STD_ON) */
}                                                                                                                                /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC */                                                                                                        /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_Init(
  void
  )
{
  Dem_EventIdType lEventId;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
#endif

  for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
  {
    Dem_Esm_InitEventInternalStatus(lEventId);
    Dem_Esm_InitEventStatus(lEventId);

  } /* for each event */

  Dem_Esm_InitEventAvailableNV();

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  {
    lGroupId = Dem_Cfg_GlobalCombinedGroupCount();
    while (lGroupId > 0)
    {
      --lGroupId;
      Dem_Esm_InitGroupInternalStatus(lGroupId);
      Dem_Mem_CombinedGroupSetStatus(lGroupId, Dem_Data_CombinedGroupGetStatus(lGroupId));
    }
  }
#endif
#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_PrestorageInit();
#endif
#if (DEM_CFG_SUPPORT_RESTART_CYCLE == STD_ON)
  Dem_Esm_CycleUpdate(Dem_Cfg_GlobalRestartCycleId(), DEM_QUEUE_CYCLE_RESTARTED);
#endif
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_OFF) || (DEM_CFG_SUPPORT_OPCYCLE_AUTOMATIC_END == STD_ON)
/* ****************************************************************************
 % Dem_Esm_Shutdown
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_Shutdown(
  void
  )
{
  uint8 lCycleIndex;

  for (lCycleIndex = 0; lCycleIndex < Dem_Cfg_GlobalCycleCount(); ++lCycleIndex)
  {
    {
      if ( (DEM_QUEUE_CYCLE_STARTED == Dem_Mem_GetCycleStatus(lCycleIndex))                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Cfg_CycleIsAutomaticEnd(lCycleIndex) == TRUE)
        )
      {
        Dem_Esm_CycleUpdate(lCycleIndex, DEM_QUEUE_CYCLE_STOPPED);
      }
    }
  }

#if (DEM_CFG_SUPPORT_RESTART_CYCLE == STD_ON)
  Dem_Mem_CurrentCycleState = (uint16)(Dem_Mem_CurrentCycleState | (uint16)(1U << Dem_Cfg_GlobalRestartCycleId()));
#endif
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_MainFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_MainFunction(
  void
  )
{
  Dem_EventIdType lEventId;

# if (DEM_CFG_SUPPORT_DEBOUNCE_TIME_HR == STD_ON)
  {
    Dem_Cfg_DebounceHiResIterType lIter;

    /* Process Time Based Debounce Events which use the high resolution timer */
    for (Dem_Cfg_DebounceHiResIterInit(&lIter);                                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_DebounceHiResIterExists(&lIter) == TRUE;                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_DebounceHiResIterNext(&lIter))                                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      lEventId = Dem_Cfg_DebounceHiResIterGet(&lIter);                                                                           /* SBSW_DEM_CALL_ITERATOR_POINTER */
      Dem_Esm_ProcessTimeDebounce(lEventId);
    }
  }
# endif /* ( DEM_CFG_SUPPORT_DEBOUNCE_TIME_HR == STD_ON ) */

# if (DEM_CFG_SUPPORT_DEBOUNCE_TIME_LR == STD_ON)
  Dem_Esm_DebounceLoResTimer--;

  if (Dem_Esm_DebounceLoResTimer == 0)
  {
    Dem_Cfg_DebounceLoResIterType lIter;

    /* Process Time Based Debounce Events which use the low resolution timer */
    for (Dem_Cfg_DebounceLoResIterInit(&lIter);                                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_DebounceLoResIterExists(&lIter) == TRUE;                                                                        /* SBSW_DEM_CALL_ITERATOR_POINTER */
         Dem_Cfg_DebounceLoResIterNext(&lIter))                                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
    {
      lEventId = Dem_Cfg_DebounceLoResIterGet(&lIter);                                                                           /* SBSW_DEM_CALL_ITERATOR_POINTER */
      Dem_Esm_ProcessTimeDebounce(lEventId);
    }

    /* restart low resolution timer */
    Dem_Esm_DebounceLoResTimer = Dem_Cfg_DebounceLoResTimerValue();
  }
# endif /* (DEM_CFG_SUPPORT_DEBOUNCE_TIME_LR == STD_ON) */
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) */

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  LOCAL FUNCTION DEFINITIONS
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
/* ****************************************************************************
 % Dem_RunTimeCheckFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_RunTimeCheckFailed(
  CONST(uint16, AUTOMATIC) Line
  )
{
  Dem_LineOfRuntimeError = Line;
# if (DEM_DEV_DISABLE_ON_RUNTIME_ERRORS == STD_ON)
  Dem_InitState = DEM_INIT_HALTED_AFTER_ERROR;
# endif
  Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_INCONSISTENT_STATE)
}
#endif

                                                            /* Notifications */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Cbk_DtcStatusChanged_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Cbk_DtcStatusChanged_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  DtcStatusOld,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  DtcStatusNew,
  CONST(uint8, AUTOMATIC)  NotificationReason                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(NotificationReason)                                                                           /* PRQA S 3112 */ /* MD_DEM_14.2 */

  if (Dem_Cal_TestDtcSuppressed(EventId) == FALSE)
  {
    uint8 lDtcStatusOld;
    uint8 lDtcStatusNew;

    lDtcStatusOld = (uint8)(DtcStatusOld & Dem_Cfg_GlobalStatusMask());
    lDtcStatusNew = (uint8)(DtcStatusNew & Dem_Cfg_GlobalStatusMask());

    if (0 != (lDtcStatusOld ^ lDtcStatusNew))
    { /* DTC Status has changed */
      uint32 lUdsDtc;

      lUdsDtc = Dem_Cfg_EventUdsDtc(EventId);

      if (DEM_CFG_DTC_UDS_INVALID != lUdsDtc)
      {
        Dem_Cfg_GlobalCbkDtcIterType lIter;
        for (Dem_Cfg_GlobalCbkDtcIterInit(&lIter);                                                                               /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
             Dem_Cfg_GlobalCbkDtcIterExists(&lIter) == TRUE;                                                                     /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
             Dem_Cfg_GlobalCbkDtcIterNext(&lIter))                                                                               /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
        {
          Dem_DtcStatusChangedFPtrType lpDtcStatusFunc;
          lpDtcStatusFunc = Dem_Cfg_GlobalCbkDtcIterGet(&lIter);                                                                 /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
          if (lpDtcStatusFunc != NULL_PTR)
          {
            (void)lpDtcStatusFunc(lUdsDtc, lDtcStatusOld, lDtcStatusNew);                                                        /* SBSW_DEM_GLOBALCBKDTCSTATUS_FPTR */
          }
        }

#if (DEM_CFG_NOTIFY_DCM == STD_ON)
        if ( (Dem_Dcm_TestNotificationState() == TRUE)
          && (NotificationReason != DEM_CBK_DTC_CLEAR) )
        {
          /* Call Dcm Dtc status change callback */
          (void)Dcm_DemTriggerOnDTCStatus(lUdsDtc, lDtcStatusOld, lDtcStatusNew);
        }
#endif
      } /* if (DEM_CFG_DTC_UDS_INVALID != lUdsDtc) */

    } /* if DTC Status has changed */
  } /* if DTC is not suppressed */
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_Cbk_StatusChanged
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Cbk_StatusChanged(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  EventStatusOld,
  CONST(Dem_EventStatusExtendedType, AUTOMATIC)  EventStatusNew
  )
{
#if (DEM_CFG_NOTIFY_FIM == STD_ON)
  /* Call FiM event status change callback */
  (void)FiM_DemTriggerOnEventStatus(EventId, EventStatusOld, EventStatusNew);
#endif

#if (DEM_CFG_NOTIFY_DLT == STD_ON)
  /* Call Dlt event status change callback */
  Dlt_DemTriggerOnEventStatus(EventId, EventStatusOld, EventStatusNew);
#endif

  {
    Dem_Cfg_EventCbkStatusIterType lIter;
    /* Call all configured status change callbacks for this event */
    for (Dem_Cfg_EventCbkStatusIterInit(EventId, &lIter);                                                                        /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
         Dem_Cfg_EventCbkStatusIterExists(&lIter) == TRUE;                                                                       /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
         Dem_Cfg_EventCbkStatusIterNext(&lIter))                                                                                 /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
    {
      Dem_EventStatusChangedFPtrType lpEventCbkStatusFunc;
      lpEventCbkStatusFunc = Dem_Cfg_EventCbkStatusIterGet(&lIter);                                                              /* SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER */
      if (lpEventCbkStatusFunc != NULL_PTR)
      {
        (void)(lpEventCbkStatusFunc(EventStatusOld, EventStatusNew));                                                            /* SBSW_DEM_EVENTCBKSTATUS_FPTR */
      }
    }
  }

  /* Call general event status changed callback */
  if (Dem_Cfg_GlobalCbkStatus() != NULL_PTR)
  {
    (void)(Dem_Cfg_GlobalCbkStatus()(EventId, EventStatusOld, EventStatusNew));                                                  /* SBSW_DEM_GLOBALCBKEVENTSTATUS_FPTR */
  }
}

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SelectDisplacedIndex
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_SelectDisplacedIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  DisplacingEventId
  )
{
  struct DisplacementInfoType
  {
    uint16                   EventId;
    Dem_Cfg_MemoryIndexType  MemoryIndex;
    uint8                    DtcStatus;
  } lBestMatchInfo;

  uint8 lChronoIndexIterator;

  lBestMatchInfo.EventId = DisplacingEventId;
  lBestMatchInfo.MemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
  lBestMatchInfo.DtcStatus = DEM_UDS_STATUS_TF;

  DEM_IGNORE_UNUSED_VARIABLE(lBestMatchInfo.DtcStatus)                                                                           /* PRQA S 3112 */ /* MD_DEM_14.2 */

  /* find lowest priority DTC in memory. scan in chronological order, so the
     first found entry is the older one (to break ties) */
  for (lChronoIndexIterator = 0;
       lChronoIndexIterator < Dem_Mem_MemoryGetCurrentSize(MemoryInfo);                                                          /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
       ++lChronoIndexIterator)
  {
    struct DisplacementInfoType lCandidateInfo;
# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON) || (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
    Dem_Cfg_MemoryIndexType lMemoryIndex;
# endif

    lCandidateInfo.MemoryIndex = Dem_Mem_MemoryGetChronology(MemoryInfo, lChronoIndexIterator);                                  /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    {
      Dem_Mem_EntryPtrType lMemoryEntry;

# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON) || (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
      lMemoryIndex = lCandidateInfo.MemoryIndex;
# endif
      lMemoryEntry = Dem_Mem_MemoryGetEntry(lCandidateInfo.MemoryIndex);
      lCandidateInfo.EventId = Dem_Mem_EntryGetEventId(lMemoryEntry);
    }
    lCandidateInfo.DtcStatus = Dem_Util_DtcApplyCombinedStatus(Dem_Util_DtcGetStatus(lCandidateInfo.EventId));

    if (Dem_Util_TestEventValid(lCandidateInfo.EventId) == FALSE)
    {
      /* always replace an invalid memory entry */
      lBestMatchInfo = lCandidateInfo;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
    }

# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
    if (
      (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(Dem_Mem_MemoryGetEntry(lMemoryIndex))) )
    { /* aged event can be displaced immediately */
      lBestMatchInfo = lCandidateInfo;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
    }
# endif
# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
    if (
      (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(Dem_Mem_MemoryGetEntry(lMemoryIndex)))) )
    { /* aging counter can be displaced immediately */
      lBestMatchInfo = lCandidateInfo;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
    }
# endif

    if (Dem_Cfg_EventPriority(lCandidateInfo.EventId) < Dem_Cfg_EventPriority(lBestMatchInfo.EventId))
    { /* Never displace events with higher priority */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
    if (Dem_Cfg_EventPriority(lCandidateInfo.EventId) > Dem_Cfg_EventPriority(lBestMatchInfo.EventId))
    { /* always prefer an event with lowest priority */
      lBestMatchInfo = lCandidateInfo;
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }

# if (DEM_CFG_DISPLACEMENT_PREFER_PASSIVE == STD_ON)
    /* Compiler warning: condition is always false if no prior condition is enabled to set new best match */
    if (DEM_ESM_TEST_UDS_STATUS_TF(lBestMatchInfo.DtcStatus) == FALSE)
    { /* If current best candidate is passive, it is a better match as it is older */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(lCandidateInfo.DtcStatus))
    { /* did not find a passive event before, so candidate is a better match */
      lBestMatchInfo = lCandidateInfo;
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
# endif

# if (DEM_CFG_DISPLACEMENT_TNCTOC_IS_PASSIVE == STD_ON)
    if ( (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(lBestMatchInfo.DtcStatus))
      && (FALSE != DEM_ESM_TEST_UDS_STATUS_TNCTOC(lCandidateInfo.DtcStatus)) )
    {
      lBestMatchInfo = lCandidateInfo;
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
# endif
  }
# if (DEM_CFG_DISPLACEMENT_FALLBACK_OLDEST == STD_ON)
  if (lBestMatchInfo.EventId == DisplacingEventId)
  { /* no match found - use fallback */
    /* The oldest event can be always displaced (could be DEM_MEM_INVALID_MEMORY_INDEX!) */
#  if (DEM_CFG_SUPPORT_OBDII == STD_ON)                                                                                          /* COV_MSR_UNSUPPORTED XF */
    lBestMatchInfo.MemoryIndex = lOldestDisplaceableIndex;
#  else
    lBestMatchInfo.MemoryIndex = Dem_Mem_MemoryGetChronology(MemoryInfo, 0);                                                     /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
#  endif
  }
# endif

  return lBestMatchInfo.MemoryIndex;
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif

/* ****************************************************************************
 % Dem_Mem_MemoryAllocateIndex
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryAllocateIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_EventIdType lMasterEventId;

  lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);

  if (Dem_Mem_MemoryGetMaxSize(MemoryInfo) == Dem_Mem_MemoryGetCurrentSize(MemoryInfo))                                          /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  { /* Memory is filled up */
#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
    Dem_Mem_SetOverflow(Dem_Mem_MemoryGetId(MemoryInfo));                                                                        /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
#endif

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
    lMemoryIndex = Dem_Mem_SelectDisplacedIndex(MemoryInfo, EventId);                                                            /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
#else
    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX; /* Always failed */
#endif

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
    if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
    { /* a displaced DTC was identified, now remove that DTC */
      Dem_Mem_EntryPtrType lEntry;
      Dem_EventIdType lDisplacedEventId;

      lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);
      lDisplacedEventId = Dem_Mem_EntryGetEventId(lEntry);

      if (Dem_Util_TestEventValid(lDisplacedEventId) == TRUE)
      {
        Dem_Esm_EventDisplaced(lDisplacedEventId);
      }
      Dem_Mem_MemoryFreeIndex(MemoryInfo, lMemoryIndex);                                                                         /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    }
    /* else: no adequate DTC found, the new entry cannot be added - return an invalid index */
#endif
  }
  else
  { /* primary memory is not full */
    /* Memory is not full -> Find first free entry */
    lMemoryIndex = Dem_Mem_MemoryFindIndex(MemoryInfo, DEM_EVENT_INVALID);                                                       /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    /* if not found : lMemoryIndex == DEM_MEM_INVALID_MEMORY_INDEX */
  }

  if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
  {
    Dem_Mem_EntryPtrType lEntry;
    uint8 lMemorySize;

    lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);
    lMemorySize = Dem_Mem_MemoryGetCurrentSize(MemoryInfo);                                                                      /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

    /* At this point, the event memory is not completely filled */
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if (lMemorySize >= Dem_Mem_MemoryGetMaxSize(MemoryInfo))                                                                     /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    {
      Dem_RunTimeCheckFailed(__LINE__);
      lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
    }
    else
#endif
    {
      /* fill the chrono record with event id and lock the referenced PriMem slot */
      Dem_Mem_MemorySetChronology(MemoryInfo, lMemorySize, lMemoryIndex);                                                        /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

      Dem_Mem_EntrySetEventId(lEntry, lMasterEventId);                                                                           /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
      Dem_Mem_EntrySetTimestamp(lEntry, Dem_Mem_CurrentTimestamp);                                                               /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */

      Dem_Data_EntryInit(lEntry);                                                                                                /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */

      ++Dem_Mem_CurrentTimestamp;
      Dem_Mem_MemorySetCurrentSize(MemoryInfo, lMemorySize + 1);                                                                 /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    }
  }

  return lMemoryIndex;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
/* ****************************************************************************
 % Dem_Mem_MemoryAllocateAging
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryAllocateAging(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_EventIdType lMasterEventId;

  lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);

  /* Find empty slot if possible, otherwise remove aged slot */
  if (Dem_Mem_MemoryGetMaxSize(MemoryInfo) == Dem_Mem_MemoryGetCurrentSize(MemoryInfo))                                          /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  { /* Memory is filled up -
     * Aged environmental data is not displaced, the remaining slots (if any)
     * are still used -> no chance to allocate an aging counter */
    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
  }
  else
  { /* Memory is not full -> Find first free entry */
    lMemoryIndex = Dem_Mem_MemoryFindIndex(MemoryInfo, DEM_EVENT_INVALID);                                                       /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    /* if not found : lMemoryIndex == DEM_MEM_INVALID_MEMORY_INDEX */
  }

  if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
  {
    uint8 lMemorySize;
    Dem_Mem_EntryPtrType lMemoryEntry;

    lMemorySize = Dem_Mem_MemoryGetCurrentSize(MemoryInfo);                                                                      /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    lMemoryEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);

    /* At this point, the event memory is not completely filled */
# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if (lMemorySize >= Dem_Mem_MemoryGetMaxSize(MemoryInfo))                                                                     /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    {
      Dem_RunTimeCheckFailed(__LINE__);
      lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
    }
    else
# endif
    {
      /* fill the chrono record with event id and lock the referenced PriMem slot */
      Dem_Mem_EntrySetTimestamp(lMemoryEntry, Dem_Mem_CurrentTimestamp);                                                         /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
      Dem_Mem_MemorySetChronology(MemoryInfo, lMemorySize, lMemoryIndex);                                                        /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

      Dem_Mem_EntrySetEventId(lMemoryEntry, lMasterEventId);                                                                     /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */

      /* Data */
      Dem_Data_EntryInit(lMemoryEntry);                                                                                          /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
      Dem_Mem_EntrySetState(lMemoryEntry, DEM_MEM_SET_AGING_ONLY(0));                                                            /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */

      Dem_Mem_CurrentTimestamp = (uint32)(Dem_Mem_CurrentTimestamp + 1);
      Dem_Mem_MemorySetCurrentSize(MemoryInfo, (uint8)(lMemorySize + 1));                                                        /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    }
  }

  return lMemoryIndex;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON) */

/* ****************************************************************************
 % Dem_Mem_MemoryFreeIndex
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Mem_MemoryFreeIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(uint8, AUTOMATIC)  MemoryIndex
  )
{
  /* reduce count of used elements in the chrono stack */
  uint8 lChronoIterator;
  uint8 lTempChronoIndex;

  Dem_Internal_AssertReturnVoid(MemoryIndex - Dem_Mem_MemoryIter_Begin(MemoryInfo) < Dem_Mem_MemoryGetMaxSize(MemoryInfo), DEM_E_INCONSISTENT_STATE)  /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */ /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

  lChronoIterator = Dem_Mem_MemoryGetCurrentSize(MemoryInfo);                                                                    /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  --lChronoIterator;

  Dem_Mem_MemorySetCurrentSize(MemoryInfo, lChronoIterator);                                                                     /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

  /* free the primary element */
  Dem_Mem_EntrySetEventId(Dem_Mem_MemoryGetEntry(MemoryIndex), DEM_EVENT_INVALID);                                               /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */
  Dem_Mem_EntrySetTimestamp(Dem_Mem_MemoryGetEntry(MemoryIndex), 0);                                                             /* SBSW_DEM_POINTER_WRITE_MEMORYENTRY */

  /* go backwards through the chronological list and move down all entries, until the deleted element is overwritten */
  lTempChronoIndex = Dem_Mem_MemoryGetChronology(MemoryInfo, lChronoIterator);                                                   /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  while (lTempChronoIndex != MemoryIndex)
  {
    uint8 lSwap;

    lSwap = lTempChronoIndex;

    --lChronoIterator;
    lTempChronoIndex = Dem_Mem_MemoryGetChronology(MemoryInfo, lChronoIterator);                                                 /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    Dem_Mem_MemorySetChronology(MemoryInfo, lChronoIterator, lSwap);                                                             /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */

#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if ((lChronoIterator == 0) && (lTempChronoIndex != MemoryIndex))
    {
      /* Index not found, chronology is corrupted */
      Dem_RunTimeCheckFailed(__LINE__);
      break;
    }
#endif
  }
}

/* ****************************************************************************
 % Dem_Mem_MemoryFindIndex
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryFindIndex(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo,
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Dem_EventIdType lMasterEventId;
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_Cfg_MemoryIndexType lMemoryIndexEnd;

  lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);

  /* Iteration direction must be identical to Dem_Init! */

  lMemoryIndex = Dem_Mem_MemoryIter_Begin(MemoryInfo);                                                                           /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  lMemoryIndexEnd = Dem_Mem_MemoryIter_End(MemoryInfo);                                                                          /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
  while ( (lMemoryIndex < lMemoryIndexEnd)
       && (Dem_Mem_EntryGetEventId(Dem_Mem_MemoryGetEntry(lMemoryIndex)) != lMasterEventId) )
  {
    ++lMemoryIndex;
  }
  /* if not found, return DEM_MEM_INVALID_MEMORY_INDEX */
  if (lMemoryIndex >= lMemoryIndexEnd)
  {
    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
  }
  return lMemoryIndex;
}

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedCalculate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_CounterBasedCalculate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  )
{
  boolean lReturnValue;
  boolean lEnableConditionsSatisfied;
  sint16 lJumpToValue;

  lEnableConditionsSatisfied = (boolean)
    ((Dem_CurrentEnableConditionStates & Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId)) == Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId));

  if ( (lEnableConditionsSatisfied == TRUE)                                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    || (Dem_Cfg_EventDebounceContinuous(DebounceInfo->Common.EventId) == TRUE)
    )
  {
    DebounceInfo->Specific.CounterBased.OldDebounceValue = Dem_Mem_EventGetDebounceValue(DebounceInfo->Common.EventId);          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
    DebounceInfo->Specific.CounterBased.OldInternalStatus = Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId);        /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    DebounceInfo->Specific.CounterBased.NewInternalStatus = DebounceInfo->Specific.CounterBased.OldInternalStatus;               /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# endif

    switch (DebounceInfo->Common.MonitorStatus)
    {
    case DEM_EVENT_STATUS_PREPASSED:
      lJumpToValue = Dem_Cfg_EventJumpDownValue(DebounceInfo->Common.EventId);

      if ( (DebounceInfo->Specific.CounterBased.OldDebounceValue > lJumpToValue)                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Cfg_EventSupportJumpDown(DebounceInfo->Common.EventId) == TRUE) )
      {
        /* JumpDown */
        DebounceInfo->Specific.CounterBased.NewDebounceValue = lJumpToValue;                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
      else
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = DebounceInfo->Specific.CounterBased.OldDebounceValue;             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }

      if (DebounceInfo->Specific.CounterBased.NewDebounceValue <=
        (Dem_Cfg_EventPassedTarget(DebounceInfo->Common.EventId) - Dem_Cfg_EventPrepassedStep(DebounceInfo->Common.EventId))) /* No overflow possible */
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = Dem_Cfg_EventPassedTarget(DebounceInfo->Common.EventId);          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        if (lEnableConditionsSatisfied == TRUE)
        {
          /* qualified result, set result and final debounce counter */
          DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PASSED;                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
      }
      else
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = (sint16)                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
          (DebounceInfo->Specific.CounterBased.NewDebounceValue + Dem_Cfg_EventPrepassedStep(DebounceInfo->Common.EventId)); /* No overflow possible */
      }
      break;

    case DEM_EVENT_STATUS_PASSED:
      /* Qualified result - directly load threshold debounce counter from configuration */
      /* This also reduces exceeded counter values to match the passed threshold exactly (latch at bottom) */
      DebounceInfo->Specific.CounterBased.NewDebounceValue = Dem_Cfg_EventPassedTarget(DebounceInfo->Common.EventId);            /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      if (lEnableConditionsSatisfied == FALSE)
      {
        DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PREPASSED;                                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
      break;

    case DEM_EVENT_STATUS_PREFAILED:
      lJumpToValue = Dem_Cfg_EventJumpUpValue(DebounceInfo->Common.EventId);

      if ( (DebounceInfo->Specific.CounterBased.OldDebounceValue < lJumpToValue)                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Cfg_EventSupportJumpUp(DebounceInfo->Common.EventId) == TRUE) )
      {
        /* JumpUp */
        DebounceInfo->Specific.CounterBased.NewDebounceValue = lJumpToValue;                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
      else
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = DebounceInfo->Specific.CounterBased.OldDebounceValue;             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }

      if (DebounceInfo->Specific.CounterBased.NewDebounceValue >=
        (Dem_Cfg_EventFailedTarget(DebounceInfo->Common.EventId) - Dem_Cfg_EventPrefailedStep(DebounceInfo->Common.EventId))) /* No overflow possible */
      {
        /* qualified result, set result and final debounce counter */
        DebounceInfo->Specific.CounterBased.NewDebounceValue = Dem_Cfg_EventFailedTarget(DebounceInfo->Common.EventId);          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        if (lEnableConditionsSatisfied == TRUE)
        {
          DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
      }
      else
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = (sint16)                                                          /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
          (DebounceInfo->Specific.CounterBased.NewDebounceValue + Dem_Cfg_EventPrefailedStep(DebounceInfo->Common.EventId));  /* No overflow possible */
      }
      break;

    case DEM_EVENT_STATUS_FAILED:
      /* Qualified result - directly load threshold debounce counter from configuration */
      /* This also reduces counter values to match the failed threshold exactly (latch at ceiling) */
      DebounceInfo->Specific.CounterBased.NewDebounceValue = Dem_Cfg_EventFailedTarget(DebounceInfo->Common.EventId);            /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      if (lEnableConditionsSatisfied == FALSE)
      {
        DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PREFAILED;                                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
      break;

    default:
      /* Satisfy Misra */
      break;
    }

#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
    if ( (DebounceInfo->Common.MonitorStatus == DEM_EVENT_STATUS_FAILED)                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(DebounceInfo->Common.EventId)) == DEM_ESM_STORED_STATUS_NONE))
    {
      DebounceInfo->Common.DebouncingChanged = TRUE;                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
    else
#endif
    {
      DebounceInfo->Common.DebouncingChanged =                                                                                   /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        (boolean)(DebounceInfo->Specific.CounterBased.OldDebounceValue != DebounceInfo->Specific.CounterBased.NewDebounceValue);
    }

# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
    DebounceInfo->Common.RequestProcessing = FALSE;                                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */

#  if (DEM_CFG_STORAGE_AT_FDC == STD_ON) || (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    if (lEnableConditionsSatisfied == TRUE)
    {
#   if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
      if ( (DebounceInfo->Specific.CounterBased.NewDebounceValue >= Dem_Cfg_EventStorageTarget(DebounceInfo->Common.EventId))    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (DebounceInfo->Specific.CounterBased.OldDebounceValue < Dem_Cfg_EventStorageTarget(DebounceInfo->Common.EventId)) )
      {
        DebounceInfo->Specific.CounterBased.NewInternalStatus = Dem_Mem_SetFdcTripStatus(DebounceInfo->Specific.CounterBased.NewInternalStatus);  /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        DebounceInfo->Common.RequestProcessing = TRUE;                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
#   endif
#   if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
      /* Possible update of SLC based on update of TOC */
      if (DebounceInfo->Specific.CounterBased.NewDebounceValue > Dem_Mem_EventGetDebounceValueMax(DebounceInfo->Common.EventId))
      {
        DebounceInfo->Specific.CounterBased.NewInternalStatus = Dem_Mem_SetFdcMaxStatus(DebounceInfo->Specific.CounterBased.NewInternalStatus);  /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        DebounceInfo->Common.RequestProcessing = TRUE;                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
#   endif
    }
#  endif
# endif
    lReturnValue = TRUE;
  } /* (lEnableConditionsSatisfied == TRUE) || (Dem_Cfg_EventDebounceContinuous(DebounceInfo->Common.EventId) == TRUE) */
  else
  {
    lReturnValue = FALSE;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedValidate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_CounterBasedValidate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  return (boolean) (                                                                                                             /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      (DebounceInfo->Specific.CounterBased.OldDebounceValue == Dem_Mem_EventGetDebounceValue(DebounceInfo->Common.EventId))
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
   && (DebounceInfo->Specific.CounterBased.OldInternalStatus == Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId))
#endif
  );
}
#endif /* (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON) */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedCommit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedCommit(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, DebounceInfo->Specific.CounterBased.NewDebounceValue);
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  Dem_Mem_EventSetInternalStatus(DebounceInfo->Common.EventId, DebounceInfo->Specific.CounterBased.NewInternalStatus);
# endif
# if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
  /* Store a new max value */
  if (DebounceInfo->Specific.CounterBased.NewDebounceValue > Dem_Mem_EventGetDebounceValueMax(DebounceInfo->Common.EventId))
  {
    Dem_Mem_EventSetDebounceValueMax(DebounceInfo->Common.EventId, DebounceInfo->Specific.CounterBased.NewDebounceValue);
  }
# endif
}
#endif /* (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON) */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedFreeze
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedFreeze(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(DebounceInfo)                                                                                 /* PRQA S 3112 */ /* MD_DEM_14.2 */
  /* No action necessary */
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedReset
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedReset(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, 0);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedCalculate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_TimeBasedCalculate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  )
{
  boolean lReturnValue;
  boolean lEnableConditionsSatisfied;

  lEnableConditionsSatisfied = (boolean)
    ((Dem_CurrentEnableConditionStates & Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId)) == Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId));

  if ( (lEnableConditionsSatisfied == TRUE)                                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    || (Dem_Cfg_EventDebounceContinuous(DebounceInfo->Common.EventId) == TRUE)
    )
  {
    DebounceInfo->Specific.TimeBased.OldInternalStatus = Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId);           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    DebounceInfo->Specific.TimeBased.NewInternalStatus = DebounceInfo->Specific.TimeBased.OldInternalStatus;                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
    DebounceInfo->Common.RequestProcessing = FALSE;                                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# endif

    switch (DebounceInfo->Common.MonitorStatus)
    {
    case DEM_EVENT_STATUS_PREPASSED:
      /* ignore action if timer is still running in direction of prepassed or event is qualified as passed */
      if ((DEM_ESM_DEBOUNCE_STATUS_NONE == Dem_Mem_GetDebounceStatus(DebounceInfo->Specific.TimeBased.OldInternalStatus))        /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        || (DEM_ESM_DEBOUNCE_DIR_PASSED != Dem_Mem_TestDebounceDirection(DebounceInfo->Specific.TimeBased.OldInternalStatus)))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =                                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
          Dem_Mem_SetDebounceStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_RESET_PASSED);
      }
      else
      if (DEM_ESM_DEBOUNCE_FREEZE_PASSED == Dem_Mem_GetDebounceStatus(DebounceInfo->Specific.TimeBased.OldInternalStatus))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =                                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
          Dem_Mem_SetDebounceStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_PASSED);
      }
      else
      { /* Nothing to do */
      }
      break;

    case DEM_EVENT_STATUS_PREFAILED:
      /* ignore action if timer is still running in direction of prefailed or event is still qualified as failed */
      /* Test for debounce status == none is redundant with test for last bit != 0. Test removed due to avoid compiler warning */
      if (DEM_ESM_DEBOUNCE_DIR_PASSED == Dem_Mem_TestDebounceDirection(DebounceInfo->Specific.TimeBased.OldInternalStatus))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =                                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
          Dem_Mem_SetDebounceStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_RESET_FAILED);
      }
      else
      if (DEM_ESM_DEBOUNCE_FREEZE_FAILED == Dem_Mem_GetDebounceStatus(DebounceInfo->Specific.TimeBased.OldInternalStatus))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =                                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
          Dem_Mem_SetDebounceStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_FAILED);
      }
# if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
      else
      if (DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC == Dem_Mem_GetDebounceStatus(DebounceInfo->Specific.TimeBased.OldInternalStatus))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =                                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
          Dem_Mem_SetDebounceStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC);
      }
# endif
      else
      { /* Nothing to do */
      }
      break;

    case DEM_EVENT_STATUS_PASSED:
      DebounceInfo->Specific.TimeBased.NewInternalStatus =                                                                       /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        Dem_Mem_SetDebounceStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_PASSED);
      if (lEnableConditionsSatisfied == FALSE)
      {
        DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PREPASSED;                                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
      break;

    case DEM_EVENT_STATUS_FAILED:
      DebounceInfo->Specific.TimeBased.NewInternalStatus =                                                                       /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        Dem_Mem_SetDebounceStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_FAILED);
      if (lEnableConditionsSatisfied == FALSE)
      {
        DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PREFAILED;                                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
      else
      {
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
        if ( (DEM_ESM_DEBOUNCE_DIR_PASSED == Dem_Mem_TestDebounceDirection(DebounceInfo->Specific.TimeBased.OldInternalStatus))  /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          || (DEM_ESM_DEBOUNCE_FREEZE_FAILED == Dem_Mem_GetDebounceStatus(DebounceInfo->Specific.TimeBased.OldInternalStatus))
          || (DEM_ESM_DEBOUNCE_COUNT_FAILED == Dem_Mem_GetDebounceStatus(DebounceInfo->Specific.TimeBased.OldInternalStatus)))
        {
#  if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
          DebounceInfo->Specific.TimeBased.NewInternalStatus = Dem_Mem_SetFdcTripStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus);  /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#  endif
#  if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
          DebounceInfo->Specific.TimeBased.NewInternalStatus = Dem_Mem_SetFdcMaxStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus);  /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
#  endif
          DebounceInfo->Common.RequestProcessing = TRUE;                                                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
        }
# endif
      }
      break;

    default:
      /* Satisfy Misra */
      break;
    }

    DebounceInfo->Common.DebouncingChanged =                                                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      (boolean)(DebounceInfo->Specific.TimeBased.OldInternalStatus != DebounceInfo->Specific.TimeBased.NewInternalStatus);

# if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
    if ( (DebounceInfo->Common.DebouncingChanged == FALSE)                                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (lEnableConditionsSatisfied == TRUE)
      && (Dem_Mem_GetDebounceStatus(DebounceInfo->Specific.TimeBased.OldInternalStatus) == DEM_ESM_DEBOUNCE_DONE_FAILED)
      && (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(DebounceInfo->Common.EventId)) == DEM_ESM_STORED_STATUS_NONE) )
    {
      DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      DebounceInfo->Common.DebouncingChanged = TRUE;                                                                             /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    }
# endif

    lReturnValue = TRUE;
  }
  else
  {
    lReturnValue = FALSE;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedValidate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_TimeBasedValidate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  return (boolean)(DebounceInfo->Specific.TimeBased.OldInternalStatus == Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId));
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedCommit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedCommit(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  Dem_Mem_EventSetInternalStatus(DebounceInfo->Common.EventId, DebounceInfo->Specific.TimeBased.NewInternalStatus);
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
  /* Store a new max value if the event was reported 'failed' immediately */
  if ( (DebounceInfo->Specific.TimeBased.NewInternalStatus != DebounceInfo->Specific.TimeBased.OldInternalStatus)                /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && (Dem_Mem_TestFdcMaxStatus(DebounceInfo->Specific.TimeBased.NewInternalStatus) == TRUE) )
  {
    Dem_Mem_EventSetDebounceValueMax(DebounceInfo->Common.EventId, 0);
  }
# endif
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedFreeze
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedFreeze(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lInternalStatus = Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId);

  switch (Dem_Mem_GetDebounceStatus(lInternalStatus))
  {
  case DEM_ESM_DEBOUNCE_RESET_FAILED:
    Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, Dem_Cfg_EventFailedTime(DebounceInfo->Common.EventId));
    lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_FAILED);
    break;

  case DEM_ESM_DEBOUNCE_RESET_PASSED:
    Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, Dem_Cfg_EventPassedTime(DebounceInfo->Common.EventId));
    lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_PASSED);
    break;

  case DEM_ESM_DEBOUNCE_COUNT_FAILED:
    lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_FAILED);
    break;

  case DEM_ESM_DEBOUNCE_COUNT_PASSED:
    lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_PASSED);
    break;
# if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
  case DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC:
    lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC);
    break;
# endif
  default:
    /* Nothing to do */
    break;
  }

  Dem_Mem_EventSetInternalStatus(DebounceInfo->Common.EventId, lInternalStatus);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedReset
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedReset(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lInternalStatus = Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId);
  lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
  Dem_Mem_EventSetInternalStatus(DebounceInfo->Common.EventId, lInternalStatus);
  Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, 0);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_MonitorInternalCalculate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_MonitorInternalCalculate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  )
{
  boolean lReturnValue;

# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  DebounceInfo->Common.RequestProcessing = FALSE;                                                                                /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# endif

  /* No debouncing for this event supported */
  if ( (DebounceInfo->Common.MonitorStatus == DEM_EVENT_STATUS_PREPASSED)
    || (DebounceInfo->Common.MonitorStatus == DEM_EVENT_STATUS_PREFAILED) )
  {
    Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_PARAM_DATA)

    DebounceInfo->Common.DebouncingChanged = FALSE;                                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    lReturnValue = FALSE;
  }
  else
  {
    boolean lEnableConditionsSatisfied;

    lEnableConditionsSatisfied = (boolean)
      ((Dem_CurrentEnableConditionStates & Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId)) == Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId));

    if (lEnableConditionsSatisfied == TRUE)
    {
      DebounceInfo->Specific.MonitorInternal.OldMonitorStatus = Dem_Mem_EventGetDebounceValue(DebounceInfo->Common.EventId);     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */

      if (DebounceInfo->Common.MonitorStatus == DEM_EVENT_STATUS_FAILED)
      {
        DebounceInfo->Specific.MonitorInternal.NewMonitorStatus = DEM_ESM_MONITOR_STATUS_FAILED;                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
      else
      {
        DebounceInfo->Specific.MonitorInternal.NewMonitorStatus = DEM_ESM_MONITOR_STATUS_PASSED;                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }

#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
      if ( (DebounceInfo->Specific.MonitorInternal.NewMonitorStatus == DEM_ESM_MONITOR_STATUS_FAILED)                            /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(DebounceInfo->Common.EventId)) == DEM_ESM_STORED_STATUS_NONE))
      {
        DebounceInfo->Common.DebouncingChanged = TRUE;                                                                           /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      }
      else
#endif
      {
        DebounceInfo->Common.DebouncingChanged =                                                                                 /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
          (boolean)(DebounceInfo->Specific.MonitorInternal.NewMonitorStatus != DebounceInfo->Specific.MonitorInternal.OldMonitorStatus);
      }
      lReturnValue = TRUE;
    }
    else
    {
      DebounceInfo->Common.DebouncingChanged = FALSE;                                                                            /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      lReturnValue = FALSE;
    }
  }
  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_MonitorInternalValidate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_MonitorInternalValidate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  return (boolean)(                                                                                                              /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    (DebounceInfo->Specific.MonitorInternal.OldMonitorStatus == Dem_Mem_EventGetDebounceValue(DebounceInfo->Common.EventId)));
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_MonitorInternalCommit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_MonitorInternalCommit(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, DebounceInfo->Specific.MonitorInternal.NewMonitorStatus);
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_MonitorInternalFreeze
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_MonitorInternalFreeze(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(DebounceInfo)                                                                                 /* PRQA S 3112 */ /* MD_DEM_14.2 */
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_MonitorInternalReset
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_MonitorInternalReset(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, DEM_ESM_MONITOR_STATUS_NONE);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}
#endif

/* ****************************************************************************
 % Dem_Esm_DebounceInvalidCalculate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceInvalidCalculate(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo
  )
{
  DebounceInfo->Common.DebouncingChanged = FALSE;                                                                                /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  DebounceInfo->Common.RequestProcessing = FALSE;                                                                                /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
# endif
  Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_PARAM_CONFIG)
  return FALSE;
}

/* ****************************************************************************
 % Dem_Esm_DebounceInvalidBoolean
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceInvalidBoolean(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(DebounceInfo)                                                                                 /* PRQA S 3112 */ /* MD_DEM_14.2 */
  Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_PARAM_CONFIG)
  return TRUE;
}

/* ****************************************************************************
 % Dem_Esm_DebounceInvalidVoid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_DebounceInvalidVoid(
  CONST(Dem_DebounceInfoPtrType, AUTOMATIC)  DebounceInfo                                                                        /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(DebounceInfo)                                                                                 /* PRQA S 3112 */ /* MD_DEM_14.2 */
  Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_PARAM_CONFIG)
}

/* ****************************************************************************
 % Dem_Esm_EventFailed_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;
  uint8 lEventEffects;
  uint8 lDtcEffects;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  uint8 lOldDtcStatus;
  uint8 lNewDtcStatus;
#endif

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
  lNewEventStatus = lOldEventStatus;
  lEventEffects = DEM_CFG_TRIGGER_NONE;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  lDtcEffects = DEM_CFG_TRIGGER_NONE;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  lOldDtcStatus = Dem_Util_DtcGetStatus(EventId);
#endif

  /* #010 Process the deferred 'asynchronous' status bit transitions for the event */
  lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TFTOC(lNewEventStatus);
  lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TF(lNewEventStatus);
#if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_OFF)
  lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lNewEventStatus);
#endif
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lNewEventStatus);
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lNewEventStatus);

  Dem_Mem_EventSetStatus(EventId, lNewEventStatus);

  /* #020 Derive the triggers for the event from the changes of the status bits */
  if (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(lOldEventStatus))
  {
    lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_TESTFAILED);
  }
  if (FALSE == DEM_ESM_TEST_UDS_STATUS_TFTOC(lOldEventStatus))
  {
    lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE);
    lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_FIRSTTHISCYCLE);
  }

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  /* #030 For combined events, calculate the new DTC status and derive the
   *      triggers for the DTC from the changes of the DTC status bits */
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lNewDtcStatus = Dem_Data_CombinedGroupGetStatus(lGroupId);

    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(lOldDtcStatus))
    {
      lDtcEffects = (uint8)(lDtcEffects | DEM_CFG_TRIGGER_TESTFAILED);
    }
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TFTOC(lOldDtcStatus))
    {
      lDtcEffects = (uint8)(lDtcEffects | (DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE | DEM_CFG_TRIGGER_FIRSTTHISCYCLE));
    }

    Dem_Mem_CombinedGroupSetStatus(lGroupId, lNewDtcStatus);
  }
  else
#endif
  {
    lDtcEffects = lEventEffects;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    lNewDtcStatus = lNewEventStatus;
#endif
  }

  DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

  if (lOldEventStatus != lNewEventStatus)
  {
    Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    Dem_Cbk_DtcStatusChanged(EventId, lOldDtcStatus, lNewDtcStatus, DEM_CBK_DTC_UPDATED);
#else
    Dem_Cbk_DtcStatusChanged(EventId, lOldEventStatus, lNewEventStatus, DEM_CBK_DTC_UPDATED);
#endif

    /* #050 Process the remaining 'synchronous' status changes and effects */
    Dem_Esm_EventFailed_Immediate(EventId, lEventEffects, lDtcEffects);
  }
#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
  else
  if (Dem_Mem_GetStoredStatus(Dem_Util_DtcGetInternalStatus(EventId)) == DEM_ESM_STORED_STATUS_NONE)
  {
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
  }
  else
  {
    /* Do nothing */
  }
#endif
}                                                                                                                                /* PRQA S 6010, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCAL, MD_MSR_STPTH */

/* ****************************************************************************
 % Dem_Esm_EventFailed_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(uint8, AUTOMATIC)  EventEffects,
  CONST(uint8, AUTOMATIC)  DtcEffects                                                                                            /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Esm_EventContextType lEventContext;
  boolean lDataModified;

  lEventContext.EventId = EventId;
  lEventContext.OldEventStatus = Dem_Mem_EventGetStatus(EventId);
  lEventContext.NewEventStatus = lEventContext.OldEventStatus;
  lEventContext.EventEffects = EventEffects;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  lEventContext.GroupId = Dem_Cfg_EventCombinedGroup(EventId);
  lEventContext.OldDtcStatus = Dem_Util_DtcGetStatus(EventId);
  lEventContext.NewDtcStatus = lEventContext.OldDtcStatus;
  lEventContext.DtcEffects = DtcEffects;
#else
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(DtcEffects)                                                                                   /* PRQA S 3112 */ /* MD_DEM_14.2 */
#endif

  /* Process synchronous updates for externally visible events, if storage conditions are fulfilled */
  if ( (DEM_CFG_DTC_UDS_INVALID != Dem_Cfg_EventUdsDtc(EventId))                                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
    && ((Dem_StorageConditionStates & Dem_Cfg_EventStorageConditions(EventId)) == Dem_Cfg_EventStorageConditions(EventId))
#endif
    )
  {
    Dem_Esm_EventFailed_ProcessPending(&lEventContext);                                                                          /* SBSW_DEM_POINTER_FORWARD_STACK */
    Dem_Esm_EventFailed_ProcessConfirmed(&lEventContext);                                                                        /* SBSW_DEM_POINTER_FORWARD_STACK */

    lDataModified = Dem_Esm_EventFailed_ProcessStorage(&lEventContext);                                                          /* SBSW_DEM_POINTER_FORWARD_STACK */

    /* Commit changes to the event status to memory */
    if (DEM_CFG_TRIGGER_NONE != lEventContext.EventEffects)
    {
      Dem_Esm_EventFailed_CommitToMemory(&lEventContext);                                                                        /* SBSW_DEM_POINTER_FORWARD_STACK */
    }

    Dem_Esm_EventFailed_ProcessNotifications(&lEventContext, lDataModified);                                                     /* SBSW_DEM_POINTER_FORWARD_STACK */
    Dem_Data_EventFailed(EventId, Dem_Esm_SelectStorageEffects(&lEventContext));
#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
    Dem_Esm_PrestorageDiscard();
#endif
    Dem_Mem_StatusSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_CycleUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdate(
  CONST(uint8, AUTOMATIC)  CycleId,
  CONST(uint8, AUTOMATIC)  CycleStatus
  )
{
  uint16 lCycleCounter;

  Dem_Mem_SetCycleStatus(CycleId, DEM_QUEUE_CYCLE_STOPPED);

  /* Tick the cycle if necessary */
  lCycleCounter = Dem_Mem_CycleGetCounter(CycleId);
  if ((CycleStatus & DEM_QUEUE_CYCLE_STARTED) != 0U)
  {
    lCycleCounter = Dem_Esm_AddCycleCount(lCycleCounter, 1U);
    Dem_Mem_CycleSetCounter(CycleId, lCycleCounter);

    /* Aging cycle start */
    Dem_Esm_CycleUpdateStored(CycleId, lCycleCounter);
  }

  /* Operation Cycle start / end */
  Dem_Esm_CycleUpdateReadiness(CycleId, CycleStatus);

  if ((CycleStatus & DEM_QUEUE_CYCLE_STARTED) != 0U)
  {
    Dem_Mem_SetCycleStatus(CycleId, DEM_QUEUE_CYCLE_STARTED);

  } /* (CycleStatus & DEM_QUEUE_CYCLE_STARTED) != 0U) */

}                                                                                                                                /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

#if (DEM_FEATURE_NEED_AGING_CYCLE_DISTANCE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CycleCountDistance
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL FUNC(uint16, DEM_CODE)
Dem_Esm_CycleCountDistance(
  CONST(uint16, AUTOMATIC)  CurrentCounter,
  CONST(uint16, AUTOMATIC)  TargetCounter
  )
{
  uint16 lReturnValue;

  if (TargetCounter < CurrentCounter)
  {
    lReturnValue = (uint16)((DEM_ESM_CYCLECOUNT_MAX - CurrentCounter) + TargetCounter);
  }
  else
  {
    lReturnValue = (uint16)(TargetCounter - CurrentCounter);
  }

  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Esm_EventOpCycle_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycle_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr                                                                   /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
)
{
  uint8 lOldStatus;
  uint8 lNewStatus;

  lOldStatus = Dem_Mem_EventGetStatus(EventId);

  if ((ArgPtr->Specific.EventOpCycle_Internal.CycleStatus & DEM_QUEUE_CYCLE_STOPPED) != 0U)
  {
    Dem_Esm_EventOpCycleEnd(EventId, ArgPtr->Common.OldDtcStatus);
  }
  if ((ArgPtr->Specific.EventOpCycle_Internal.CycleStatus & DEM_QUEUE_CYCLE_STARTED) != 0U)
  {
    Dem_Esm_EventOpCycleStart(EventId);
  }
  lNewStatus = Dem_Mem_EventGetStatus(EventId);

  DEM_NVM_CHECK_DIRTY_STATUS(lOldStatus, lNewStatus)

  if (Dem_InitState == DEM_INIT_INITIALIZED)
  {
    if (lOldStatus != lNewStatus)
    { /* Call notifications only if event status has changed */
      Dem_Cbk_StatusChanged(EventId, lOldStatus, lNewStatus);
    }
    /* Call Init Monitor Callbacks */
    Dem_Cbk_InitMonitorForEvent(EventId, DEM_INIT_MONITOR_RESTART);
  }
}

/* ****************************************************************************
 % Dem_Esm_EventUpdateAsync_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventUpdateAsync_Queued(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusType, AUTOMATIC)  EventStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_DebounceInfoType lDebounceInfo;

  lReturnValue = E_OK;
  Dem_Esm_DebounceInfoInit(EventId, &lDebounceInfo);                                                                             /* SBSW_DEM_CALL_DEBOUNCEINFO_INIT */

  /* Possible concurrent modification :
     ClearEvent
     ResetEventStatus
     Displacement
     Aging */

  for (;;)
  {
    /* Perform all calculations on the stack. Original values are preserved
     * to detect concurrent modification.*/
    lDebounceInfo.Common.MonitorStatus = EventStatus;
    if (FALSE == lDebounceInfo.Common.FunctionTable->Calculate(&lDebounceInfo))                                                  /* SBSW_DEM_CALL_FUNCPTR_DEBOUNCEINFO_POINTER */
    { /* Error, abort */
      lReturnValue = E_NOT_OK;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_err */
    }

    if (FALSE != lDebounceInfo.Common.DebouncingChanged)
    {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */

      /* Verify the 'old' status we had based the status calculations on is
       * still the same as before */
      if (FALSE == lDebounceInfo.Common.FunctionTable->Validate(&lDebounceInfo))                                                 /* SBSW_DEM_CALL_FUNCPTR_DEBOUNCEINFO_POINTER */
      {
        /* Concurrent modification requires to repeat all calculations with
          * the new up-to-date values */
        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
        continue;                                                                                                                /* PRQA S 0770 */ /* MD_DEM_14.5 */
      }

      lReturnValue = Dem_Esm_EventQueueAsync_Queued(EventId, &lDebounceInfo);                                                    /* SBSW_DEM_CALL_DEBOUNCEINFO_POINTER */

      if (E_OK != lReturnValue)
      {
        /* Event update must be discarded due to queue overflow */
        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
        break;                                                                                                                   /* PRQA S 0771 */ /* MD_DEM_14.6_err */
      }
      else
      {
        lDebounceInfo.Common.FunctionTable->Commit(&lDebounceInfo);                                                              /* SBSW_DEM_CALL_FUNCPTR_DEBOUNCEINFO_POINTER */
      }

      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
    }

    break;                                                                                                                       /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
  } /* for (;;) */
  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_Esm_EventUpdateAsync_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventUpdateAsync_Immediate(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_EventStatusType, AUTOMATIC)  EventStatus
  )
{
  Std_ReturnType lReturnValue;
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;
  Dem_DebounceInfoType lDebounceInfo;

  lReturnValue = E_OK;
  Dem_Esm_DebounceInfoInit(EventId, &lDebounceInfo);                                                                             /* SBSW_DEM_CALL_DEBOUNCEINFO_INIT */

  /* Possible concurrent modification :
     ClearEvent
     ResetEventStatus
     Displacement
     Aging */
  for (;;)
  {
    /* Perform all calculations on the stack. Original values are preserved
     * to detect concurrent modification.*/
    lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
    lNewEventStatus = lOldEventStatus;

    lDebounceInfo.Common.MonitorStatus = EventStatus;
    if (FALSE == lDebounceInfo.Common.FunctionTable->Calculate(&lDebounceInfo))                                                  /* SBSW_DEM_CALL_FUNCPTR_DEBOUNCEINFO_POINTER */
    {
      lReturnValue = E_NOT_OK;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_err */
    }

    if (FALSE != lDebounceInfo.Common.DebouncingChanged)
    {
      if (lDebounceInfo.Common.MonitorStatus == DEM_EVENT_STATUS_PASSED)
      {
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lNewEventStatus);
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lNewEventStatus);
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lNewEventStatus);
      }
      else
      if (lDebounceInfo.Common.MonitorStatus == DEM_EVENT_STATUS_FAILED)
      {
        lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TFTOC(lNewEventStatus);
        lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TF(lNewEventStatus);
#if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_OFF)
        lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lNewEventStatus);
#endif
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lNewEventStatus);
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lNewEventStatus);
      }
      else
      { /* MISRA */ }

      {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
        Dem_EnterCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* Verify the 'old' status we had based the status calculations on is
         * still the same as before */
        if ( (lOldEventStatus != Dem_Mem_EventGetStatus(EventId))                                                                /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          || (FALSE == lDebounceInfo.Common.FunctionTable->Validate(&lDebounceInfo)))                                            /* SBSW_DEM_CALL_FUNCPTR_DEBOUNCEINFO_POINTER */
        {
          /* Concurrent modification requires to repeat all calculations with
           * the new up-to-date values */
          Dem_LeaveCritical_DiagMonitor();                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
          continue;                                                                                                              /* PRQA S 0770 */ /* MD_DEM_14.5 */
        }

        lReturnValue = Dem_Esm_EventQueueAsync_Immediate(EventId, &lDebounceInfo);                                               /* SBSW_DEM_CALL_DEBOUNCEINFO_POINTER */

        if (E_OK != lReturnValue)
        {
          /* Event update must be discarded due to queue overflow */
          Dem_LeaveCritical_DiagMonitor();                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
          break;                                                                                                                 /* PRQA S 0771 */ /* MD_DEM_14.6_err */
        }
        else
        {
          /* Commit the new values we calculated */
          Dem_Mem_EventSetStatus(EventId, lNewEventStatus);
          lDebounceInfo.Common.FunctionTable->Commit(&lDebounceInfo);                                                            /* SBSW_DEM_CALL_FUNCPTR_DEBOUNCEINFO_POINTER */
        }

        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
      }
    }
    break;                                                                                                                       /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
  } /* for (;;) */

  if (E_OK == lReturnValue)
  { /* No combined events at this point, so the DTC update is correct */
    DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

    if (lOldEventStatus != lNewEventStatus)
    { /* Call notifications only if event status has changed */
      Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
      Dem_Cbk_DtcStatusChanged(EventId, lOldEventStatus, lNewEventStatus, DEM_CBK_DTC_UPDATED);
    }
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventReset_Async
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventReset_Async(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Std_ReturnType lReturnValue;
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  uint8 lOldDtcStatus;
  uint8 lNewDtcStatus;
  Dem_Cfg_CombinedGroupIndexType lGroupId;
#endif

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
  if (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(lOldEventStatus))
  {
    lReturnValue = E_NOT_OK;
  }
  else
  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lOldEventStatus);

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    lGroupId = Dem_Cfg_EventCombinedGroup(EventId);

    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    { /* Update DTC status for combined events. */
      lOldDtcStatus = Dem_Mem_CombinedGroupGetStatus(lGroupId);
      lNewDtcStatus = Dem_Data_CombinedGroupGetStatus(lGroupId);
      Dem_Mem_CombinedGroupSetStatus(lGroupId, lNewDtcStatus);
    }
    else
    {
      lOldDtcStatus = lOldEventStatus;
      lNewDtcStatus = lNewEventStatus;
    }
#endif

    Dem_Mem_EventSetStatus(EventId, lNewEventStatus);

    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
    lInternalStatus = Dem_Mem_ResetFdcTripStatus(lInternalStatus);
    lInternalStatus = Dem_Mem_ResetFdcMaxStatus(lInternalStatus);
    lInternalStatus = Dem_Mem_ResetFdcTocStatus(lInternalStatus);
    Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Leave Critical Section: DiagMonitor */

    DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

    if (lOldEventStatus != lNewEventStatus)
    { /* Call notifications only if event status has changed */
      Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
    }
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    if (lOldDtcStatus != lNewDtcStatus)
    {
      Dem_Cbk_DtcStatusChanged(EventId, lOldDtcStatus, lNewDtcStatus, DEM_CBK_DTC_UPDATED);
    }
#else
    if (lOldEventStatus != lNewEventStatus)
    {
      Dem_Cbk_DtcStatusChanged(EventId, lOldEventStatus, lNewEventStatus, DEM_CBK_DTC_UPDATED);
    }
#endif

    lReturnValue = E_OK;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventAged_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventAged_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr                                                                   /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  DEM_IGNORE_UNUSED_CONST_ARGUMENT(ArgPtr)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
  lNewEventStatus = lOldEventStatus;

  /* remove the aged event from the primary memory */
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_CDTC(lNewEventStatus);
  if (Dem_Cfg_EventAgingTarget(EventId) == 0)
  {
#if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_PDTC(lOldEventStatus))
    {
      Dem_Mem_EventSetTripCount(EventId, Dem_Cfg_EventHealingTarget(EventId));
    }
#endif
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lNewEventStatus);
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TFTOC(lNewEventStatus);
  }
# if (DEM_CFG_PROCESS_TFSLC_CLEARONLY != STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TFSLC(lNewEventStatus);
# endif
  Dem_Mem_EventSetStatus(EventId, lNewEventStatus);

  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
  if (Dem_Mem_GetStoredStatus(lInternalStatus) != DEM_ESM_STORED_STATUS_NONE)
  {
    lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_AGED);
  }
# else
  lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_NONE);
# endif
  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

  DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

  if (lOldEventStatus != lNewEventStatus)
  {
    Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventClearState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventClearState(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr                                                                   /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
  uint8 lOldEventStatus;

  DEM_IGNORE_UNUSED_CONST_ARGUMENT(ArgPtr)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_NONE);
  lInternalStatus = Dem_Mem_SetDebounceStatus(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
  lInternalStatus = Dem_Mem_ResetFdcTripStatus(lInternalStatus);
  lInternalStatus = Dem_Mem_ResetFdcMaxStatus(lInternalStatus);
  lInternalStatus = Dem_Mem_ResetFdcTocStatus(lInternalStatus);

  Dem_Esm_EventResetDebounceValues(EventId);
  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
  /* Reset status byte */
  Dem_Mem_EventSetStatus(EventId, DEM_UDS_STATUS_INITIALIZE);
  /* EventStatus is marked modified by the caller to reduce runtime overhead */

  /* remove queued actions for this event */
  Dem_Queue_ResetPendingEvent(EventId);

#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  if (FALSE != DEM_ESM_TEST_UDS_STATUS_WIR(lOldEventStatus))
  {
    {
# if (DEM_CFG_SUPPORT_USER_INDICATORS == STD_ON)                                                                                 /* COV_MSR_UNSUPPORTED TX */
      Dem_Esm_UserIndicatorDisable(EventId);
# endif
    }
  }
#endif /* (DEM_FEATURE_NEED_INDICATORS == STD_ON) */
#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  if (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
  {
    (void)Dem_Esm_EventPrestorageClear(EventId);
  }
#endif

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

#if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
  Dem_Mem_EventSetTripCount(EventId, 0);
#endif

  /* Call status changed notifications if there is a change */
  if (lOldEventStatus != DEM_UDS_STATUS_INITIALIZE)
  {
    Dem_Cbk_StatusChanged(EventId, lOldEventStatus, DEM_UDS_STATUS_INITIALIZE);
  }
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventCleared_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventCleared_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
#endif

  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
    }
    else
#endif
    {
      lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    }

    if (DEM_ESM_STORED_STATUS_NONE != Dem_Mem_GetStoredStatus(lInternalStatus))
    {
      Dem_Mem_MemoryInfoPtrType lMemoryInfo;
      Dem_Cfg_MemoryIndexType lMemoryIndex;

      /* Remove the event from the memory */
      lMemoryInfo = Dem_Mem_MemoryInfoInit(Dem_Cfg_EventDestination(EventId));
      lMemoryIndex = Dem_Mem_MemoryFindIndex_Checked(lMemoryInfo, EventId);                                                      /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
      Dem_Mem_MemoryFreeIndex(lMemoryInfo, lMemoryIndex);                                                                        /* SBSW_DEM_CALL_MEMORYINFO_POINTER */
      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
    }

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_NONE));
    }
#endif
  }

  {
    Dem_Util_ForEachCombinedArgType lArgs;
    uint8 lOldDtcStatus;

    lOldDtcStatus = Dem_Util_DtcApplyExternalOnlyStatus(EventId, Dem_Util_DtcGetStatus(EventId));
    Dem_Util_ForEachCombinedEvent(EventId, Dem_Esm_EventClearState, &lArgs);                                                     /* SBSW_DEM_CALL_FOREACH_COMBINED_EVENT */

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      Dem_Mem_CombinedGroupSetStatus(lGroupId, DEM_UDS_STATUS_INITIALIZE);
    }
#endif
    /* Call status changed notifications if there is a change */
    if (lArgs.Common.OldDtcStatus != DEM_UDS_STATUS_INITIALIZE)
    {
      Dem_Cbk_DtcStatusChanged_Internal(EventId, lOldDtcStatus, DEM_UDS_STATUS_INITIALIZE, DEM_CBK_DTC_CLEAR);
    }
  }
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisplaced_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventDisplaced_Internal(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId,
  CONST(Dem_Util_ForEachCombinedArgPtrType, AUTOMATIC)  ArgPtr                                                                   /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;
# endif

  DEM_IGNORE_UNUSED_CONST_ARGUMENT(ArgPtr)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  lInternalStatus = Dem_Mem_SetStoredStatus(lInternalStatus, DEM_ESM_STORED_STATUS_NONE);
  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);

# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
  lNewEventStatus = lOldEventStatus;
# endif
  /* Update the status bit */
# if (DEM_CFG_PROCESS_PDTC_STOREDONLY == STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lNewEventStatus);
#  endif
# if (DEM_CFG_PROCESS_CDTC_STOREDONLY == STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_CDTC(lNewEventStatus);
# endif
# if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TFSLC(lNewEventStatus);
# endif
# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
  Dem_Mem_EventSetStatus(EventId, lNewEventStatus);
# endif
  /* Displacement follows an event status change. No need to mark Nv modification again. */
  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
  if (lNewEventStatus != lOldEventStatus)
  {
    /* DtcStatus has changed, call notifications */
    Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
  }
# endif
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPrestorageClear
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventPrestorageClear(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  Std_ReturnType lReturnValue;
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;

  lReturnValue = E_NOT_OK;
  lPrestorageIndex = Dem_Mem_PrestorageFindEntry(EventId);

  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
  { /* there already is an entry allocated to this event */
    Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;
    lPrestoredEntry = Dem_Mem_PrestorageGetEntry(lPrestorageIndex);
    if (DEM_ESM_PRESTORED_STATUS_LOCKED != Dem_Mem_PrestoredEntryGetState(lPrestoredEntry))
    {
      Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_FREE);                                            /* SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY */
      Dem_Mem_PrestorageFreeEntry(lPrestorageIndex);
      lReturnValue = E_OK;
    }
  }

  return lReturnValue;
}
#endif

                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Queue_ProcessClearDtcGroup
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Queue_ProcessClearDtcGroup(
  CONST(uint16, AUTOMATIC)  FirstEventId,
  CONST(uint16, AUTOMATIC)  LastEventId
  )
{
  if (FirstEventId != DEM_EVENT_INVALID)
  {
    uint8 lGroupMask;
    uint16 lEventIterator;

    lGroupMask = Dem_Queue_GetClearGroup();
    lEventIterator = LastEventId;

    while (FirstEventId <= lEventIterator)
    { /* Event must match the group */
      if ( ( (lGroupMask == DEM_CFG_GROUPMASK_ALLDTCS)                                                                           /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
#if (DEM_CFG_CLEAR_GROUP_DTCS == STD_ON)
          || ((Dem_Cfg_EventGroupMask(lEventIterator) & lGroupMask) != 0)
#endif
          )
      /* Do not test for suppression: suppressed DTCs are not exempt from ClearGroupOfDTC */
        && (Dem_Cal_TestDtcAvailableInVariant(lEventIterator) == TRUE)
        && (Dem_Mem_TestEventDisconnectedStatus(Dem_Util_DtcGetInternalStatus(lEventIterator)) == FALSE)
        )

      { /* For combined events, only clear each event once */
#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
        if (Dem_Util_DtcGetMasterEvent(lEventIterator) == lEventIterator)
#endif
        {
#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
          (void)Dem_Esm_EventCleared_Optional(lEventIterator);
#else
          Dem_Esm_EventCleared_Always(lEventIterator);
#endif
        }
      }
      --lEventIterator;
    }
  }
}

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

#if ( ((DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_DATA_CURRENT_FDC == STD_ON)) \
   && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) )
/* ****************************************************************************
 % Dem_Data_CombinedGroupGetFDC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Data_CombinedGroupGetFDC(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId,                                                                     /* PRQA S 3206 */ /* MD_DEM_3206 */
  CONSTP2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter
  )
{
  Std_ReturnType lReturnValue;
  sint8 lMaxFdc;
  Dem_Cfg_CombinedGroupIterType lCombinedIter;

  /* In rare cases GroupId is not required */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(GroupId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lReturnValue = E_OK;
  lMaxFdc = -128;

  for (Dem_Cfg_CombinedGroupIterInit(GroupId, &lCombinedIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_CombinedGroupIterExists(&lCombinedIter) == TRUE;                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_CombinedGroupIterNext(&lCombinedIter))                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_EventIdType lSubEventId;
    lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lCombinedIter);                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */

    if ( (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)                                                                  /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE) )
    {
      sint8 lFdc;
      lReturnValue = Dem_GetFaultDetectionCounter(lSubEventId, &lFdc);                                                           /* SBSW_DEM_POINTER_FORWARD_STACK */
      if ((lReturnValue == E_OK) && (lMaxFdc < lFdc))
      {
        lMaxFdc = lFdc;
      }
    }
    if (lReturnValue != E_OK)
    {
      break;
    }
  }

  if (lReturnValue == E_OK)
  {
    *FaultDetectionCounter = lMaxFdc;                                                                                            /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if ( (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON) \
   && ( ((DEM_FEATURE_NEED_STATISTICAL_DATA == STD_ON) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)) \
     || ((DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)) ) )
/* ****************************************************************************
 % Dem_Data_CombinedGroupGetFDCMax
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL FUNC(sint8, DEM_CODE)
Dem_Data_CombinedGroupGetFDCMax(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  sint8 lMaxFdc;
  Dem_Cfg_CombinedGroupIterType lCombinedIter;

  /* In rare cases GroupId is not required */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(GroupId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lMaxFdc = 0;
  for (Dem_Cfg_CombinedGroupIterInit(GroupId, &lCombinedIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_CombinedGroupIterExists(&lCombinedIter) == TRUE;                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_CombinedGroupIterNext(&lCombinedIter))                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_EventIdType lSubEventId;
    lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lCombinedIter);                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
    if ( (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)                                                                  /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE) )
    {
      sint8 lFdc;
      lFdc = Dem_Data_EventGetFDCMax(lSubEventId);
      if (lMaxFdc < lFdc)
      {
        lMaxFdc = lFdc;
      }
    }
  }

  return lMaxFdc;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Data_CombinedGroupGetStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Data_CombinedGroupGetStatus(
  CONST(Dem_Cfg_CombinedGroupIndexType, AUTOMATIC)  GroupId                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  uint8 lReturnValue;
  Dem_Cfg_CombinedGroupIterType lCombinedIter;

  /* In rare cases GroupId is not required */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(GroupId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lReturnValue = 0x00u;

  for (Dem_Cfg_CombinedGroupIterInit(GroupId, &lCombinedIter);                                                                   /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_CombinedGroupIterExists(&lCombinedIter) == TRUE;                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_CombinedGroupIterNext(&lCombinedIter))                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_EventIdType lSubEventId;

    lSubEventId = Dem_Cfg_CombinedGroupIterGet(&lCombinedIter);                                                                  /* SBSW_DEM_CALL_ITERATOR_POINTER */
    if ( (Dem_Cfg_EventAvailableByVariant(lSubEventId) == TRUE)                                                                  /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(lSubEventId)) == FALSE) )
    {
      lReturnValue = (uint8)(lReturnValue | Dem_Mem_EventGetStatus(lSubEventId));
    }
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if ( (DEM_CFG_SUPPORT_USER_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_J1939_FREEZEFRAME == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )
/* ****************************************************************************
 % Dem_Data_CollectDid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Data_CollectDid(
  CONST(Dem_Data_CollectDidInfoPtrType, AUTOMATIC)  CollectDidInfoPtr,
  CONST(Dem_Cfg_DidIndexType, AUTOMATIC)  DidIndex
  )
{
  Dem_Cfg_DidDataIterType lDataIter;

  /* Each DID consists of 1-* data elements. */
  for (Dem_Cfg_DidDataIterInit(DidIndex, &lDataIter);                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_DidDataIterExists(&lDataIter) == TRUE;                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_DidDataIterNext(&lDataIter))                                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_DataIndexType lDataIndex;

    lDataIndex = Dem_Cfg_DidDataIterGet(&lDataIter);                                                                             /* SBSW_DEM_CALL_ITERATOR_POINTER */
    switch (Dem_Cfg_DataCallbackType(lDataIndex))
    {
    case DEM_CFG_DATA_FROM_CBK_STORED:
      Dem_Data_CollectStoredUserData(CollectDidInfoPtr, lDataIndex);                                                             /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;

    case DEM_CFG_DATA_FROM_CBK_STORED_WITH_EVENTID:
      Dem_Data_CollectStoredUserDataWithEventId(CollectDidInfoPtr, lDataIndex);                                                  /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;

# if (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON)
    case DEM_CFG_DATA_FROM_ROOTCAUSE_EVENTID:
      Dem_Data_CollectRootCauseEventId(CollectDidInfoPtr);                                                                       /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

    default:
      /* Do not store (but skip) statistical data */
      break;
    } /* switch (Dem_Cfg_DataCallbackType(lDataIndex)) */
  } /* (FALSE != Dem_Cfg_DidDataIterExists(&lDataIter)) */
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if ( (DEM_CFG_SUPPORT_ERECS == STD_ON) \
   || (DEM_CFG_SUPPORT_SRECS == STD_ON) \
   || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
   || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON))
/* ****************************************************************************
 % Dem_Data_CopyDid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Data_CopyDid(
  CONST(Dem_Data_CopyDidInfoPtrType, AUTOMATIC)  CopyDidInfoPtr,
  CONST(Dem_Cfg_DidIndexType, AUTOMATIC)  DidIndex
  )
{
  boolean lReturnValue;
  Dem_Cfg_DidDataIterType lDataIter;

  lReturnValue = TRUE;
  for (Dem_Cfg_DidDataIterInit(DidIndex, &lDataIter);                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_DidDataIterExists(&lDataIter) == TRUE;                                                                            /* SBSW_DEM_CALL_ITERATOR_POINTER */
       Dem_Cfg_DidDataIterNext(&lDataIter))                                                                                      /* SBSW_DEM_CALL_ITERATOR_POINTER */
  {
    Dem_Cfg_DataIndexType lDataIndex;
    lDataIndex = Dem_Cfg_DidDataIterGet(&lDataIter);                                                                             /* SBSW_DEM_CALL_ITERATOR_POINTER */

    switch (Dem_Cfg_DataCallbackType(lDataIndex))
    {
# if (DEM_CFG_DATA_AGINGCTR == STD_ON)
    case DEM_CFG_DATA_FROM_AGINGCTR:
      lReturnValue = (boolean)((Dem_Data_CopyUpwardsAgingCounter(CopyDidInfoPtr)) & lReturnValue);                               /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_OCCCTR == STD_ON)
    case DEM_CFG_DATA_FROM_OCCCTR:
      lReturnValue = (boolean)((Dem_Data_Copy1ByteOccurrenceCounter(CopyDidInfoPtr)) & lReturnValue);                            /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
    case DEM_CFG_DATA_FROM_OCCCTR_2BYTE:
      lReturnValue = (boolean)((Dem_Data_Copy2ByteOccurrenceCounter(CopyDidInfoPtr)) & lReturnValue);                            /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_OVFLIND == STD_ON)
    case DEM_CFG_DATA_FROM_OVFLIND:
      lReturnValue = (boolean)((Dem_Data_CopyOverflowIndication(CopyDidInfoPtr)) & lReturnValue);                                /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_SIGNIFICANCE == STD_ON)
    case DEM_CFG_DATA_FROM_SIGNIFICANCE:
      lReturnValue = (boolean)((Dem_Data_CopyEventSignificance(CopyDidInfoPtr)) & lReturnValue);                                 /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_PRIORITY == STD_ON)
    case DEM_CFG_DATA_FROM_PRIORITY:
      lReturnValue = (boolean)((Dem_Data_CopyEventPriority(CopyDidInfoPtr)) & lReturnValue);                                     /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON)
    case DEM_CFG_DATA_FROM_AGINGCTR_INVERTED:
      lReturnValue = (boolean)((Dem_Data_CopyDownwardsAgingCounter(CopyDidInfoPtr)) & lReturnValue);                             /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    case DEM_CFG_DATA_FROM_MAX_FDC_SINCE_LAST_CLEAR:
      lReturnValue = (boolean)((Dem_Data_CopyMaxFdcSinceLastClear(CopyDidInfoPtr)) & lReturnValue);                              /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)
    case DEM_CFG_DATA_FROM_MAX_FDC_DURING_CURRENT_CYCLE:
      lReturnValue = (boolean)((Dem_Data_CopyMaxFdcThisCycle(CopyDidInfoPtr)) & lReturnValue);                                   /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
    case DEM_CFG_DATA_FROM_CYCLES_SINCE_LAST_FAILED:
      lReturnValue = (boolean)((Dem_Data_CopyCyclesSinceLastFailed(CopyDidInfoPtr)) & lReturnValue);                             /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
    case DEM_CFG_DATA_FROM_CYCLES_SINCE_FIRST_FAILED:
      lReturnValue = (boolean)((Dem_Data_CopyCyclesSinceFirstFailed(CopyDidInfoPtr)) & lReturnValue);                            /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
    case DEM_CFG_DATA_FROM_FAILED_CYCLES:
      lReturnValue = (boolean)((Dem_Data_CopyFailedCycles(CopyDidInfoPtr)) & lReturnValue);                                      /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
    case DEM_CFG_DATA_FROM_CONSECUTIVE_FAILED_CYCLES:
      lReturnValue = (boolean)((Dem_Data_CopyConsecutiveFailedCycles(CopyDidInfoPtr)) & lReturnValue);                           /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
    case DEM_CFG_DATA_FROM_CYCLES_TESTED_SINCE_FIRST_FAILED:
      lReturnValue = (boolean)((Dem_Data_CopyCyclesTestedSinceFirstFailed(CopyDidInfoPtr)) & lReturnValue);                      /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON)
    case DEM_CFG_DATA_FROM_ROOTCAUSE_EVENTID:
      lReturnValue = (boolean)((Dem_Data_CopyRootCauseEventId(CopyDidInfoPtr)) & lReturnValue);                                  /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_OBDDTC == STD_ON)
    case DEM_CFG_DATA_FROM_OBDDTC:
      lReturnValue = (boolean)((Dem_Data_CopyEventObdDtc(CopyDidInfoPtr)) & lReturnValue);                                       /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_OBDDTC_3BYTE == STD_ON)
    case DEM_CFG_DATA_FROM_OBDDTC_3BYTE:
      lReturnValue = (boolean)((Dem_Data_CopyEventObdDtc_3Byte(CopyDidInfoPtr)) & lReturnValue);                                 /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

# if (DEM_CFG_DATA_CURRENT_FDC == STD_ON)
    case DEM_CFG_DATA_FROM_CURRENT_FDC:
      lReturnValue = (boolean)((Dem_Data_CopyCurrentFdc(CopyDidInfoPtr)) & lReturnValue);                                        /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;
# endif

    case DEM_CFG_DATA_FROM_CBK_STORED:
    case DEM_CFG_DATA_FROM_CBK_STORED_WITH_EVENTID:
      lReturnValue = (boolean)((Dem_Data_CopyStoredUserData(CopyDidInfoPtr, lDataIndex)) & lReturnValue);                        /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;

    case DEM_CFG_DATA_FROM_CBK_CURRENT:
      lReturnValue = (boolean)((Dem_Data_CopyCurrentUserData(CopyDidInfoPtr, lDataIndex)) & lReturnValue);                       /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;

    case DEM_CFG_DATA_FROM_CBK_CURRENT_WITH_EVENTID:
      lReturnValue = (boolean)((Dem_Data_CopyCurrentUserDataWithEventId(CopyDidInfoPtr, lDataIndex)) & lReturnValue);            /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
      break;

    default:
      lReturnValue = FALSE;
      break;
    }
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#endif /* ( (DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON) ) */

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_MemorySetBlockStateImmediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Nvm_MemorySetBlockStateImmediate(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex,
  CONST(uint8, AUTOMATIC)  BlockState
  )
{
  uint8 lBlockState;
  Dem_Internal_AssertReturnVoid((MemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX), DEM_E_INCONSISTENT_STATE);

# if (DEM_CFG_SUPPORT_NVM_WRITELIMIT == STD_ON)
  if (DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE == BlockState)
  { /* downgrade immediate update when occurrence limit is reached */
    Dem_Mem_EntryPtrType lMemoryEntry;
    lMemoryEntry = Dem_Mem_MemoryGetEntry(MemoryIndex);

    if (Dem_Mem_EntryGetOccurrenceCount(lMemoryEntry) >= Dem_Cfg_GlobalNvStorageLimit())
    {
      lBlockState = DEM_NVM_BLOCKSTATE_DIRTY;
    }
    else
    {
      lBlockState = BlockState;
    }
  }
  else
# endif
  {
    lBlockState = BlockState;
  }

  Dem_Nvm_SetBlockStateImmediate(MemoryIndex, lBlockState);
}                                                                                                                                /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
#endif /* (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_SetBlockStateImmediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Nvm_SetBlockStateImmediate(
  CONST(Dem_Cfg_MemoryIndexType, AUTOMATIC)  MemoryIndex,
  CONST(uint8, AUTOMATIC)  BlockState
  )
{
  Dem_Internal_AssertReturnVoid((MemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX), DEM_E_INCONSISTENT_STATE);

  if ( (0 == (DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG & Dem_Nvm_GetBlockState(MemoryIndex)))
    && (0 != (DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG & BlockState)) )
  {
    Dem_Nvm_CommitData.PendingCount = (uint8)(Dem_Nvm_CommitData.PendingCount + 1);
  }

# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
  if ( (0 == (DEM_NVM_BLOCKSTATE_CLEARFLAG & Dem_Nvm_GetBlockState(MemoryIndex)))
    && (0 != (DEM_NVM_BLOCKSTATE_CLEARFLAG & BlockState)) )
  { /* Only if clear flag is being set, not if it is already set */
    Dem_Nvm_CommitData.PendingClearCount = (uint8)(Dem_Nvm_CommitData.PendingClearCount + 1);
  }
# endif /* (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON) */

  if (Dem_Nvm_GetBlockState(MemoryIndex) < BlockState)
  { /* Only if no information is lost (e.g. do not replace clear with dirty) */
    Dem_Nvm_SetBlockState(MemoryIndex, BlockState);
  }
}                                                                                                                                /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
#endif /* (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) */

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Dcm_ClearDtc_TestForAllDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForAllDtc(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  )
{
  Dem_ReturnClearDTCType lReturnValue;

  Dem_Internal_AssertReturnValue((ClearRequest->ClearFormat == DEM_DTC_FORMAT_OBD) || (ClearRequest->ClearFormat == DEM_DTC_FORMAT_UDS),
                                  DEM_E_PARAM_DATA,
                                  DEM_CLEAR_WRONG_DTC)

  if ( (DEM_DTC_GROUP_ALL_DTCS == DTC)
    )
  {
    ClearRequest->ClearGroup = DEM_CFG_GROUPMASK_ALLDTCS;                                                                        /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    ClearRequest->ClearEventId = DEM_EVENT_INVALID;                                                                              /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    lReturnValue = DEM_CLEAR_OK;
  }
  else
  {
    lReturnValue = DEM_CLEAR_WRONG_DTC;
  }
  return lReturnValue;
}

#if (DEM_CFG_CLEAR_GROUP_DTCS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_ClearDtc_TestForGroupDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForGroupDtc(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  )
{
  Dem_ReturnClearDTCType lReturnValue;
  Dem_Internal_AssertReturnValue(ClearRequest->ClearFormat == DEM_DTC_FORMAT_UDS,
                                 DEM_E_PARAM_DATA,
                                 DEM_CLEAR_WRONG_DTC)

  {
    uint8 lGroupMask;
    lGroupMask = Dem_Cfg_FindGroupMaskFromUdsDtc(DTC);
    if (DEM_CFG_GROUPMASK_NONE != lGroupMask)
    {
      ClearRequest->ClearGroup = lGroupMask;                                                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      ClearRequest->ClearEventId = DEM_EVENT_INVALID;                                                                            /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      lReturnValue = DEM_CLEAR_OK;
    }
    else
    {
      lReturnValue = DEM_CLEAR_WRONG_DTC;
    }
  }
  return lReturnValue;
}
#endif

#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_ClearDtc_TestForSingleDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForSingleDtc(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  )
{
  Dem_ReturnClearDTCType lReturnValue;
  Dem_Internal_AssertReturnValue(ClearRequest->ClearFormat == DEM_DTC_FORMAT_UDS,
                                 DEM_E_PARAM_DATA,
                                 DEM_CLEAR_WRONG_DTC)

  {
    Dem_EventIdType lEventId;

    if ( (DEM_CFG_DTC_UDS_INVALID == DTC)
      || (0 == DTC) )
    {
      lEventId = DEM_EVENT_INVALID;
    }
    else
    {
      lEventId = Dem_Dcm_FindEventFromUdsDtc(DTC, ClearRequest->ClearMemoryId, ClearRequest->ClearClient);
    }

    if ( (DEM_EVENT_INVALID != lEventId)                                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_m */
      && (ClearRequest->ClearMemoryId == Dem_Cfg_EventDestination(lEventId))
      && (Dem_Cal_TestDtcSuppressed(lEventId) == FALSE)                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_m */
      )
    { /* Event does belong to the requested origin */
      ClearRequest->ClearGroup = DEM_CFG_GROUPMASK_NONE;                                                                         /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      ClearRequest->ClearEventId = lEventId;                                                                                     /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
      lReturnValue = DEM_CLEAR_OK;
    }
    else
    {
      lReturnValue = DEM_CLEAR_WRONG_DTC;
    }
  }
  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Dcm_ClearDtc_TestWrongOrigin
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestWrongOrigin(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest                                                /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(DTC)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_CONST_ARGUMENT(ClearRequest)                                                                                 /* PRQA S 3112 */ /* MD_DEM_14.2 */

  return DEM_CLEAR_WRONG_DTCORIGIN;
}

/* ****************************************************************************
 % Dem_Dcm_ClearDtc_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_Internal(
  CONST(uint32, AUTOMATIC)  DTC,
  CONSTP2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  )
{
  Dem_ReturnClearDTCType lReturnValue;
  Dem_Dcm_ClearDtc_TestIterType lClearDtcTestIter;

  lReturnValue = DEM_CLEAR_WRONG_DTC;

  /* Validate the combination of parameters */
  for (Dem_Dcm_ClearDtcTestIterInit(ClearRequest->ClearMemoryId, ClearRequest->ClearFormat, &lClearDtcTestIter);                 /* SBSW_DEM_CLEARDTCTEST_ITERATOR */
       Dem_Dcm_ClearDtcTestIterExists(&lClearDtcTestIter) == TRUE;                                                               /* SBSW_DEM_CLEARDTCTEST_ITERATOR */
       Dem_Dcm_ClearDtcTestIterNext(&lClearDtcTestIter))                                                                         /* SBSW_DEM_CLEARDTCTEST_ITERATOR */
  {
    lReturnValue = (*Dem_Dcm_ClearDtcTestIterGet(&lClearDtcTestIter))(DTC, ClearRequest);                                        /* SBSW_DEM_CLEARDTCTEST_ITERATOR */ /* SBSW_DEM_CLEARDTCTEST_ITERATOR */
    if (lReturnValue != DEM_CLEAR_WRONG_DTC)
    {
      /* A test has matched the DTC parameter */
      break;
    }
  }

  if (DEM_CLEAR_OK == lReturnValue)
  { /* The requested DTC or DTC group exists, as well as the requested memory.
     * Test if there is another clear operation ongoing at the moment */
    uint8 lClearState;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
    Dem_EnterCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lClearState = Dem_Queue_GetClearState();

    if ( (lClearState == DEM_QUEUE_CLEARSTATE_IDLE)
      || ( (FALSE != DEM_QUEUE_TESTCLEARSTATE_CANCEL(lClearState))
        && (FALSE != DEM_QUEUE_TESTCLEARSTATE_DONE(lClearState)) ) )
    { /* Set up new request if no old request is pending (idle), or the last
       * request has finished and was cancelled in the process */
      /* Remember the arguments of a new request, it will be processed on the
       * task level of Dem */
      Dem_Queue_SetClearMemory(ClearRequest->ClearMemoryId);
      Dem_Queue_SetClearFormat(ClearRequest->ClearFormat);
      Dem_Queue_SetClearGroup(ClearRequest->ClearGroup);
      Dem_Queue_SetClearEvent(ClearRequest->ClearEventId);
      Dem_Queue_SetClearClient(ClearRequest->ClearClient);
      lClearState = DEM_QUEUE_CLEARSTATE_IDLE;
      lClearState = DEM_QUEUE_SETCLEARSTATE_PENDING(lClearState);
      Dem_Queue_SetClearState(lClearState);

      lReturnValue = DEM_CLEAR_PENDING;
    }
    else
    { /* Not the case if a new request was started above */
      if (FALSE != DEM_QUEUE_TESTCLEARSTATE_CANCEL(lClearState))
      { /* Canceled requests return failed until completion */
        lReturnValue = DEM_CLEAR_FAILED;
      }
      else
      if ( (Dem_Queue_GetClearMemory() == ClearRequest->ClearMemoryId)
        && (Dem_Queue_GetClearFormat() == ClearRequest->ClearFormat)
        && (Dem_Queue_GetClearGroup() == ClearRequest->ClearGroup)
        && (Dem_Queue_GetClearEvent() == ClearRequest->ClearEventId)
        && (Dem_Queue_GetClearClient() == ClearRequest->ClearClient)
        )
      { /* The same request, poll for the result */
#if ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON))
        if (FALSE == Dem_Nvm_GetPendingClear())
#endif
        {
          if (FALSE != DEM_QUEUE_TESTCLEARSTATE_DONE(lClearState))
          {
            if (FALSE != DEM_QUEUE_TESTCLEARSTATE_FAILED(lClearState))
            {
              lReturnValue = DEM_CLEAR_FAILED;
            }
#if ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON))
            else if (FALSE != DEM_QUEUE_TESTCLEARSTATE_NVFAILED(lClearState))
            {
# if (DEM_CFG_SUPPORT_API_VERSION_4_2_1 == STD_ON)
              lReturnValue = DEM_CLEAR_MEMORY_ERROR;
# else
              lReturnValue = DEM_CLEAR_OK;
# endif
            }
#endif
            else
            {
              lReturnValue = DEM_CLEAR_OK;
            }
            Dem_Queue_SetClearState(DEM_QUEUE_CLEARSTATE_IDLE);
          }
          else
          {
            lReturnValue = DEM_CLEAR_PENDING;
          }
        }
#if ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON))
        else
        { /* A request still in the process of being committed to NV blocks */
          lReturnValue = DEM_CLEAR_PENDING;
        }
#endif
      }
      else
      { /* A different request has to wait until the previous clear has completed */
        lReturnValue = DEM_CLEAR_BUSY;
      }
    }

    Dem_LeaveCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DcmApi */
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterNumberMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(uint16, DEM_CODE)
Dem_Dcm_FilterNumberMemory(
  void
  )
{
  uint16          lNumberOfEvents;
  Dem_EventIdType lEventIdStart;
  Dem_EventIdType lEventIdEnd;
  Dem_EventIdType lEventId;
# if (DEM_CFG_SUPPORT_SEVERITY != STD_ON) || (DEM_FEATURE_NEED_OBD != STD_ON)                                                    /* COV_MSR_UNSUPPORTED TX tf tx */
  uint8           lFilterCriteria;
# endif

# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
  if (Dem_Dcm_FilterDtcGetMemoryId() == DEM_CFG_MEMORYID_SECONDARY)
  {
    lEventIdStart  = Dem_Cfg_GlobalSecondaryFirst();
    lEventIdEnd    = Dem_Cfg_GlobalSecondaryLast();
  }
  else
#endif
  {
    lEventIdStart = Dem_Cfg_GlobalPrimaryFirst();
    lEventIdEnd   = Dem_Cfg_GlobalPrimaryLast();
  }

  lNumberOfEvents = 0;
# if (DEM_CFG_SUPPORT_SEVERITY != STD_ON) || (DEM_FEATURE_NEED_OBD != STD_ON)                                                    /* COV_MSR_UNSUPPORTED TX tf tx */
  lFilterCriteria = Dem_Dcm_FilterGetCriteria();
# endif

# if (DEM_CFG_SUPPORT_SEVERITY != STD_ON)
  if (FALSE != DEM_DCM_TEST_FILTER_USESEVERITY(lFilterCriteria))
  { /* No DTC can match the filter */
    lEventIdStart = DEM_EVENT_INVALID;
  }
# endif
# if (DEM_FEATURE_NEED_OBD != STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if ( (FALSE != DEM_DCM_TEST_FILTER_DTCKIND_EMISSION(lFilterCriteria))
    || (FALSE != DEM_DCM_TEST_FILTER_DTCFORMAT_OBD(lFilterCriteria))
    )
  { /* No DTC can match the filter */
    lEventIdStart = DEM_EVENT_INVALID;
  }
# endif

  /* valid start value, so at least one event is available which may match the filter criteria */
  if (DEM_EVENT_INVALID != lEventIdStart)                                                                                        /* PRQA S 3355, 3358 */ /* MD_DEM_13.7, MD_DEM_13.7 */
  {
    for (lEventId = lEventIdStart; lEventId <= lEventIdEnd; lEventId++)
    {
      if (E_NOT_OK != Dem_Dcm_FilterForEventMatch(lEventId))
      {
        ++lNumberOfEvents;
      }
    }
  }
  return lNumberOfEvents;
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF*/
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterMemoryByEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterMemoryByEvent(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{
  Dem_EventIdType lEventId;
  Dem_EventIdType lReturnValue;

  lEventId     = Dem_Dcm_FilterDtcGetEventIndex();
  lReturnValue = DEM_EVENT_INVALID;

  /* if last EventId is not valid or was still analyzed skip the filtering */
  if (lEventId != DEM_EVENT_INVALID)
  {
    Dem_EventIdType lEventIdLast;
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
    uint16 lFilterMarkerIndex;
    uint8 lFilterMarkerMask;
    uint8 lFilterMarkerValues;
# endif

    lEventIdLast = MemoryInfo->LastEvent;
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
    /* calculate current marker index and mask */
    lFilterMarkerIndex  = DEM_DCM_FILTER_CALC_MARKER_INDEX(lEventId);
    lFilterMarkerMask   = DEM_DCM_FILTER_CALC_MARKER_MASK(lEventId);
    lFilterMarkerValues = Dem_Dcm_FilterGetReportedEvents(lFilterMarkerIndex);
# endif
    /* iterate through the EventIds and check filter criteria */
    for (; lEventId <= lEventIdLast; lEventId++)
    {
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
      /* take event into account if it was not reported before */
      if (0 == DEM_DCM_GET_FILTER_EVENT_MARKER(lFilterMarkerValues, lFilterMarkerMask))
# endif
      {
      /* EventId was not reported before, proceed */
        if (E_NOT_OK != Dem_Dcm_FilterForEventMatch(lEventId))
        {
          /* identified an Event which matches the filter criteria */
          lReturnValue = lEventId;
          lEventId++;                                                                                                            /* PRQA S 2469 */ /* MD_DEM_13.6 */

          break;
        }
      }
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)

      /* shift filter mask and raise marker index and get marker values from index if mask has a overflow */
      Dem_LROT1_ADD_ACTION_Byte(lFilterMarkerIndex,
                                lFilterMarkerValues = Dem_Dcm_FilterGetReportedEvents(lFilterMarkerIndex),
                                lFilterMarkerMask)
# endif
    }

    if (lEventId > lEventIdLast)
    { /* last EventId has been processed */
      Dem_Dcm_FilterDtcSetEventIndex(DEM_EVENT_INVALID);
    }
    else
    { /* write back the EventId ( which was raised by 1 for the next repetition) */
      Dem_Dcm_FilterDtcSetEventIndex(lEventId);
    }
  }
  /* else lReturnValue = DEM_EVENT_INVALID initially set */

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) */

#if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterMemoryChrono
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterMemoryChrono(
  CONST(Dem_Mem_MemoryInfoPtrType, AUTOMATIC)  MemoryInfo
  )
{
  Dem_EventIdType lEventId;
  uint8 lChronoIndex;

  lChronoIndex = Dem_Dcm_FilterDtcGetChronoIndex();
  lEventId     = DEM_EVENT_INVALID;

  /* index set to 0 indicates that the filter was reset */
  if (lChronoIndex == 0)
  {
    lChronoIndex = *MemoryInfo->SizePtr;
  }
  /* else */ /* last stored index initially loaded */

  while (lChronoIndex != 0)
  {
    uint16 lFilterMarkerIndex;
    uint8 lFilterMarkerValues;
    uint8 lFilterMarkerMask;

    lChronoIndex--;

    /* Get EventId for current index and marker if event was reported before */
    lEventId = Dem_Mem_EntryGetEventId(Dem_Mem_MemoryGetEntry(Dem_Mem_MemoryGetChronology(MemoryInfo, lChronoIndex)));           /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    /* verify that a valid EventId was returned */
    if (Dem_Util_TestEventValid(lEventId) == TRUE)
    {
      lFilterMarkerIndex  = DEM_DCM_FILTER_CALC_MARKER_INDEX(lEventId);
      lFilterMarkerMask   = DEM_DCM_FILTER_CALC_MARKER_MASK(lEventId);
      lFilterMarkerValues = Dem_Dcm_FilterGetReportedEvents(lFilterMarkerIndex);

      /* Check if EventId was reported before */
      if (DEM_DCM_GET_FILTER_EVENT_MARKER(lFilterMarkerValues, lFilterMarkerMask) == 0)
      {
        /* EventId was not reported before, proceed */
        if (E_NOT_OK != Dem_Dcm_FilterForEventMatch(lEventId))
        {
          /* identified an Event which matches the filter criteria, mark event as reported */
          lFilterMarkerValues = DEM_DCM_SET_FILTER_EVENT_MARKER(lFilterMarkerValues, lFilterMarkerMask);
          Dem_Dcm_FilterSetReportedEvents(lFilterMarkerIndex, lFilterMarkerValues);
          /* lEventId holds the valid EventId */

          break;
        }
        else
        { /* No filter match, continue with loop */
          lEventId = DEM_EVENT_INVALID;
        }
      }
      else
      { /* EventId was reported before, continue with loop */
        lEventId = DEM_EVENT_INVALID;
      }
    }
  }

  /* If end of chrono stack is reached, switch to filter by event id */
  if (lChronoIndex == 0)
  {
    Dem_Dcm_FilterDtcSetEventIndex(MemoryInfo->FirstEvent);
    Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterMemoryByEvent);

    if (DEM_EVENT_INVALID == lEventId)
    { /* no valid match, proceed with filtering by EventId */
      lEventId = Dem_Dcm_FilterMemoryByEvent(MemoryInfo);                                                                        /* SBSW_DEM_POINTER_FORWARD_ARGUMENT */
    }
  }
  else
  {
    /* store current position of chrono stack */
    Dem_Dcm_FilterDtcSetChronoIndex(lChronoIndex);
  }

  return lEventId;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterForEventMatch
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_FilterForEventMatch(
  CONST(Dem_EventIdType, AUTOMATIC)  EventId
  )
{
  uint8    lEventStatus;
  uint8    lFilterCriteria;
  lFilterCriteria = Dem_Dcm_FilterGetCriteria();

  if (Dem_Cfg_EventUdsDtc(EventId) == DEM_CFG_DTC_UDS_INVALID)
  {
    return E_NOT_OK;
  }
# if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
  if (Dem_Util_DtcGetMasterEvent(EventId) != EventId)
  {
    return E_NOT_OK;
  }
# endif
  if (Dem_Cal_TestDtcSuppressed(EventId) == TRUE)
  {
    /* Suppressed DTCs are skipped */
    return E_NOT_OK;
  }

  lEventStatus = Dem_Util_DtcApplyExternalOnlyStatus(EventId, Dem_Util_DtcGetStatus(EventId));

  if ( (FALSE != DEM_DCM_TEST_FILTER_USESTATUSMASK(lFilterCriteria))
    && ((Dem_Dcm_FilterDtcGetStatusMask() & lEventStatus) == 0) )
  { /* Skip DTCs not matching the requested status mask */
    return E_NOT_OK;
  }

# if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
  if ( (FALSE != DEM_DCM_TEST_FILTER_USESEVERITY(lFilterCriteria))
    && ((Dem_Dcm_FilterDtcGetSeverityMask() & Dem_Cfg_EventSeverity(EventId)) == 0) )
  { /* Skip DTCs not matching the requested severity */
    return E_NOT_OK;
  }
# endif

  if (FALSE != DEM_DCM_TEST_FILTER_USEFDC(lFilterCriteria))
  {
    Std_ReturnType lGetFdcReturnValue;
    sint8 lFdc;

    lGetFdcReturnValue = Dem_Util_DtcGetFaultDetectionCounter(EventId, &lFdc);                                                   /* SBSW_DEM_POINTER_FORWARD_STACK */

    if (lGetFdcReturnValue != E_OK)
    { /* If FDC cannot be retrieved, the DTC does not match */
      return E_NOT_OK;
    }

    /* returned fault detection counter is valid, store it for later */
    Dem_Dcm_FilterDtcSetFdc(lFdc);

    if ( (lFdc <= 0)
      || (lFdc == 0x7f) )
    { /* skip passed, passing and qualified failed DTCs */
      return E_NOT_OK;
    }
  }

  /* If all tests pass, keep this DTC for processing */
  return E_OK;
}                                                                                                                                /* PRQA S 2006, 6010, 6030, 6050, 6080 */ /* MD_DEM_14.7, MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FindEventByDTCAndOrigin
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FindEventByDTCAndOrigin(
  CONST(uint32, AUTOMATIC)  DTC,
  CONST(Dem_DTCOriginType, AUTOMATIC)  DTCOrigin,
  CONSTP2VAR(uint8, AUTOMATIC, AUTOMATIC)  MemoryId
)
{
  Dem_EventIdType lEventId;

  lEventId = DEM_EVENT_INVALID;
  switch (DTCOrigin)
  {
  case DEM_DTC_ORIGIN_PRIMARY_MEMORY:
    *MemoryId = DEM_CFG_MEMORYID_PRIMARY;                                                                                        /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    break;
# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
  case DEM_DTC_ORIGIN_SECONDARY_MEMORY:
    *MemoryId = DEM_CFG_MEMORYID_SECONDARY;                                                                                      /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    break;
# endif
  default:
    *MemoryId = DEM_CFG_MEMORYID_INVALID;                                                                                        /* SBSW_DEM_POINTER_WRITE_ARGUMENT */
    break;
  }

  if (DEM_CFG_MEMORYID_INVALID != *MemoryId)
  {
    lEventId = Dem_Dcm_FindEventFromUdsDtc(DTC, *MemoryId, DEM_DCM_CLIENT_DCM);
    if (DEM_EVENT_INVALID != lEventId)
    {
      if (Dem_Cal_TestDtcSuppressed(lEventId) == TRUE)
      {
        lEventId = DEM_EVENT_INVALID;
      }
    }
  }

  return lEventId;
}
#endif

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  GLOBAL FUNCTIONS                                                                                              [API]
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                                /* Callbacks */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_NvM_InitAdminData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_InitAdminData(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (Dem_InitState >= DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    uint8 lCycleIterator;

    /* ----- Implementation ------------------------------------------------ */
    Dem_Cfg_AdminData.ImplementationVersion = Dem_Make16Bit(DEM_SW_MAJOR_VERSION, DEM_SW_MINOR_VERSION);
    Dem_Cfg_AdminData.ConfigurationId = Dem_Cfg_GlobalConfigurationId();

    for (lCycleIterator = 0U; lCycleIterator < Dem_Cfg_GlobalCycleCount(); ++lCycleIterator)
    {
      Dem_Mem_CycleSetCounter(lCycleIterator, 0U);
    }
#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
    Dem_Cfg_AdminData.MemoryOverflow = 0U;
#endif

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_ON)
    Dem_Cfg_AdminData.CycleState = 0x00U;
#endif
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_NVMINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  /* The DEM expects that the NVM by itself marks the NVRAM block as dirty */
  return E_OK;
}

/* ****************************************************************************
 % Dem_NvM_InitStatusData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_InitStatusData(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (Dem_InitState >= DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    Dem_EventIdType lEventId;

    /* ----- Implementation ------------------------------------------------ */
    for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
    {
      Dem_Mem_EventSetStatus(lEventId, DEM_UDS_STATUS_INITIALIZE);
#if (DEM_FEATURE_NEED_TRIPCOUNTER == STD_ON)
      Dem_Mem_EventSetTripCount(lEventId, 0);
#endif
    }

    Dem_Mem_SetFirstFailedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetFirstConfirmedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetMostRecentFailedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetMostRecentConfmdEvent(DEM_EVENT_INVALID);
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_NVMINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  /* The DEM expects that the NVM by itself marks the NVRAM block as dirty */
  return E_OK;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 % Dem_NvM_InitDebounceData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_InitDebounceData(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (Dem_InitState >= DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_MemSet(Dem_Cfg_DebounceData, 0x00, Dem_Cfg_GlobalDebounceStorageEventCount()*sizeof(uint16));                            /* PRQA S 0602, 3109, 0310 */ /* MD_DEM_20.2, MD_MSR_14.3, MD_DEM_11.4_cpy */ /* SBSW_DEM_MEMSET_DEBOUNCEDATA */
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_NVMINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  /* The DEM expects that the NVM by itself marks the NVRAM block as dirty */
  return E_OK;
}
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 % Dem_NvM_InitEventAvailableData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_InitEventAvailableData(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (Dem_InitState >= DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_MemSet(Dem_Cfg_EventAvailableData, 0x00, ((Dem_Cfg_GlobalEventCount() + 7) / 8) * sizeof(uint8));                        /* PRQA S 0310 */ /* MD_DEM_11.4_cpy */ /* SBSW_DEM_MEMSET_EVENTAVAILABLEDATA */
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_NVMINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  /* The DEM expects that the NVM by itself marks the NVRAM block as dirty */
  return E_OK;
}
#endif

#if ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_SUPPORT_NVM_POLLING != STD_ON))
/* ****************************************************************************
 % Dem_NvM_JobFinished
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_JobFinished(
  uint8  ServiceId,                                                                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  NvM_RequestResultType  JobResult                                                                                               /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(ServiceId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_ARGUMENT(JobResult)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
# if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
  if (Dem_Nvm_CommitData.WriteState == DEM_NVM_COMMIT_WRITING)
  {
    if (JobResult != NVM_REQ_OK)
    { /* Write request aborted or otherwise failed. */
      Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FAILED;
    }
    else
    {
      /* Continue with next block */
      Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FINISHED;
    }
  }
  /* else: the NvM has finished with some job,  e.g. restoring a block
     during ReadAll.
     We must ignore these notifications, since the value passed as
     ServiceId is not specified. */
# endif
  return E_OK;
}
#endif /* ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_SUPPORT_NVM_POLLING != STD_ON )) */

                                                             /* Version Info */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_VERSION_INFO == STD_ON)
/* ****************************************************************************
 % Dem_GetVersionInfo
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_GetVersionInfo(
  P2VAR(Std_VersionInfoType, AUTOMATIC, DEM_APPL_DATA)  versioninfo
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (versioninfo == NULL_PTR)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    versioninfo->vendorID = DEM_VENDOR_ID;                                                                                       /* SBSW_DEM_POINTER_WRITE_API */
    versioninfo->moduleID = DEM_MODULE_ID;                                                                                       /* SBSW_DEM_POINTER_WRITE_API */
    versioninfo->sw_major_version = DEM_SW_MAJOR_VERSION;                                                                        /* SBSW_DEM_POINTER_WRITE_API */
    versioninfo->sw_minor_version = DEM_SW_MINOR_VERSION;                                                                        /* SBSW_DEM_POINTER_WRITE_API */
    versioninfo->sw_patch_version = DEM_SW_PATCH_VERSION;                                                                        /* SBSW_DEM_POINTER_WRITE_API */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETVERSIONINFO_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif
}
#endif /* (DEM_CFG_SUPPORT_VERSION_INFO == STD_ON) */

                                                   /* Interface EcuM <-> Dem */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_InitMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_InitMemory(
  void
  )
{
  Dem_InitState = DEM_INIT_UNINITIALIZED;
}

/* ****************************************************************************
 % Dem_PreInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_PreInit(
  P2CONST(Dem_ConfigType, AUTOMATIC, DEM_INIT_DATA)  ConfigPtr                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  DEM_IGNORE_UNUSED_ARGUMENT(ConfigPtr)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_UNINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
#if (DEM_CFG_USE_INIT_POINTER == STD_ON)
    if (ConfigPtr == NULL_PTR)
    {
      Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
# if (DEM_CFG_VARIANT_POSTBUILD_LOADABLE == STD_ON)
      EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_NULLPTR);
# endif
    }
    else
# if (DEM_CFG_VARIANT_POSTBUILD_LOADABLE == STD_ON)
    if (Dem_Cfg_InitPtrFinalMagicNumber(ConfigPtr) != DEM_CFG_FINAL_MAGIC_NUMBER)                                                /* SBSW_DEM_POINTER_FORWARD_API */
    {
      EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_MAGICNUMBER);
    }
    else
    if (Dem_Cfg_InitPtrCompatibilityVersion(ConfigPtr) != DEM_CFG_GEN_COMPATIBILITY_VERSION)                                     /* SBSW_DEM_POINTER_FORWARD_API */
    {
      EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_COMPATIBILITYVERSION);
    }
    else
# endif
#endif
    {
      /* ----- Implementation ---------------------------------------------- */
#if (DEM_CFG_USE_INIT_POINTER == STD_ON)
      Dem_GlobalConfigPtr = ConfigPtr;
#endif
#if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
      Dem_LineOfRuntimeError = 0;
#endif
      Dem_Queue_PreInit();
      Dem_Mem_PreInit();
      Dem_Esm_PreInit();

      /* Initialize enable and storage conditions (all enabled due to init phase) */
      Dem_CurrentEnableConditionStates = 0xffffffffU;
#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = Dem_CurrentEnableConditionStates;
#endif

#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
      Dem_StorageConditionStates = 0xffffffffU;
#endif

      /* At this point:
       - BSW error reporting is enabled (Dem_ReportErrorStatus)
       - NvM has write access to RAM buffers (Dem may not access them!) */
      Dem_InitState = DEM_INIT_PREINITIALIZED;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_PREINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}

/* ****************************************************************************
 % Dem_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_Init(
  P2CONST(Dem_ConfigType, AUTOMATIC, DEM_INIT_DATA)  ConfigPtr                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  DEM_IGNORE_UNUSED_ARGUMENT(ConfigPtr)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if ((Dem_InitState != DEM_INIT_PREINITIALIZED) && (Dem_InitState != DEM_INIT_SHUTDOWN))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_USE_INIT_POINTER == STD_ON)
    if (ConfigPtr != NULL_PTR)
    {
# if (DEM_CFG_VARIANT_POSTBUILD_LOADABLE == STD_ON)
      if (Dem_Cfg_InitPtrFinalMagicNumber(ConfigPtr) != DEM_CFG_FINAL_MAGIC_NUMBER)                                              /* SBSW_DEM_POINTER_FORWARD_API */
      {
        EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_MAGICNUMBER);
      }
      else
      if (Dem_Cfg_InitPtrCompatibilityVersion(ConfigPtr) != DEM_CFG_GEN_COMPATIBILITY_VERSION)                                   /* SBSW_DEM_POINTER_FORWARD_API */
      {
        EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_COMPATIBILITYVERSION);
      }
      else
# endif
      {
        /* Replace preliminary with final configuration */
        Dem_GlobalConfigPtr = ConfigPtr;
      }
    }
#endif

  /* Initialize enable and storage conditions (based on configuration) */
    Dem_CurrentEnableConditionStates = Dem_Cfg_GlobalEnableCondInit();
#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
    Dem_NextEnableConditionStates = Dem_CurrentEnableConditionStates;
#endif
#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
    Dem_StorageConditionStates = Dem_Cfg_GlobalStorageCondInit();
#endif
    Dem_Queue_Init();
#if (DEM_CFG_USE_NVM == STD_ON)
    Dem_Nvm_Init();
#endif
    Dem_Mem_Init();
    Dem_Esm_Init();
    Dem_Dcm_Init();

#if (DEM_FEATURE_NEED_OBD == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED XF */
    Dem_Mem_Init_RestoreMemoryObd();
# if (DEM_CFG_SUPPORT_OBDII == STD_ON)
#  if (DEM_CFG_SUPPORT_PERMANENTDTC_ACTIVATION_DISTANCE == STD_ON)
    if (FALSE != Dem_Mem_GetPermanentActivationState())
#  endif
    {
      Dem_Data_PermanentEntryFillUp();
    }
# endif
#endif
    Dem_InitState = DEM_INIT_INITIALIZED;
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_INIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Shutdown
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_Shutdown(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
    boolean lPostRunRequested;
    lPostRunRequested = FALSE;
    (void)Dem_PostRunRequested(&lPostRunRequested);                                                                              /* SBSW_DEM_POINTER_FORWARD_STACK */
    if (FALSE != lPostRunRequested)
    { /* Only set the error, but perform the shutdown. We are not going to stop
       * the shutdown anyway, so rescue as much state as possible */
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    }
#endif

    Dem_InitState = DEM_INIT_SHUTDOWN;

    Dem_Queue_Shutdown();

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE != STD_ON) || (DEM_CFG_SUPPORT_OPCYCLE_AUTOMATIC_END == STD_ON)
    Dem_Esm_Shutdown();
#endif

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_ON)
    /* copy back cycle state for NVRAM storage */
    Dem_Cfg_AdminData.CycleState = Dem_Mem_CurrentCycleState;
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
    /* copy debounce values from debounce array to nvram mirror */
    Dem_Mem_CopyDataDebounceNv();
    Dem_Mem_DebounceSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
#endif

#if (DEM_CFG_USE_NVM == STD_ON)
    Dem_Nvm_Shutdown();
#endif
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SHUTDOWN_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

                                                              /* Cyclic task */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_ENGINE_RUN_TIME == STD_ON) || (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) /* COV_MSR_UNSUPPORTED TF xf tf */
/* ****************************************************************************
 % Dem_MainFunctionTimer
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_MAINFUNC_LINKAGE FUNC(void, DEM_CODE)
Dem_MainFunctionTimer(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState <= DEM_INIT_PREINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (Dem_InitState == DEM_INIT_INITIALIZED)
    {
# if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)                                                                                  /* COV_MSR_UNSUPPORTED TX */
      Dem_Esm_MainFunction();
# endif
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_MAINFUNCTION_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}
#endif

/* ****************************************************************************
 % Dem_MainFunctionWorker
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_MAINFUNC_LINKAGE FUNC(void, DEM_CODE)
Dem_MainFunctionWorker(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState <= DEM_INIT_PREINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (Dem_InitState == DEM_INIT_INITIALIZED)
    {
      Dem_Queue_MainFunction();
#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
      Dem_Nvm_MainFunction();
#endif
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_MAINFUNCTION_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}

#if (DEM_CFG_SUPPORT_SPLIT_TASKS == STD_OFF)                                                                                     /* COV_MSR_UNSUPPORTED TX */
/* ****************************************************************************
 % Dem_MainFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_MainFunction(
  void
  )
{
#if ( (DEM_FEATURE_NEED_ENGINE_RUN_TIME == STD_ON) \
   || (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) \
   || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON) )                                                                                 /* COV_MSR_UNSUPPORTED TF xf tf */
  Dem_MainFunctionTimer();
#endif
  Dem_MainFunctionWorker();
}
#endif

                                        /* Interface BSW/Cdd monitor <-> Dem */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_ReportErrorStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_ReportErrorStatus(
  Dem_EventIdType  EventId,
  Dem_EventStatusType  EventStatus
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState < DEM_INIT_PREINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_CFG_EVENT_KIND_BSW != Dem_Cfg_EventKind(EventId))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventStatus >= DEM_EVENT_STATUS_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# if (DEM_FEATURE_NEED_DEBOUNCE != STD_ON)
  if ((EventStatus != DEM_EVENT_STATUS_FAILED) && (EventStatus != DEM_EVENT_STATUS_PASSED))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
# if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
  if ((Dem_Cfg_EventSupportDebounceNv(EventId) != FALSE) && (Dem_InitState != DEM_INIT_INITIALIZED))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
# endif
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Mem_GetCycleStatus(Dem_Cfg_EventOperationCycle(EventId)) == DEM_QUEUE_CYCLE_STARTED)                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE)
     )
    {
#if (DEM_FEATURE_NEED_LATCHTESTFAILED == STD_ON)
      if ( (Dem_InitState != DEM_INIT_INITIALIZED)                                                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        || (Dem_Esm_TestLatchedTestFailed(EventId) == FALSE))
#endif
      {
        (void)Dem_Esm_EventUpdateAsync_Queued(EventId, EventStatus);
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_REPORTERRORSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

                                      /* Service Interface DiagnosticMonitor */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_SetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetEventStatus(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  Dem_EventStatusType  EventStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_CFG_EVENT_KIND_SWC != Dem_Cfg_EventKind(EventId))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventStatus >= DEM_EVENT_STATUS_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# if (DEM_FEATURE_NEED_DEBOUNCE != STD_ON)
  if ((EventStatus != DEM_EVENT_STATUS_FAILED) && (EventStatus != DEM_EVENT_STATUS_PASSED))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Mem_GetCycleStatus(Dem_Cfg_EventOperationCycle(EventId)) == DEM_QUEUE_CYCLE_STARTED)                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)
      && (Dem_Esm_TestLatchedTestFailed(EventId) == FALSE)
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE)
      )
    {
      if ( (Dem_Cfg_EventCombinedGroup(EventId) != DEM_CFG_COMBINED_GROUP_INVALID)                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        || (Dem_Cfg_EventDebounceType(EventId) == DEM_CFG_DEBOUNCETYPE_TIMER) )
      { /* Process Combined Events on task level */
        lReturnValue = Dem_Esm_EventUpdateAsync_Queued(EventId, EventStatus);
      }
      else
      {
        lReturnValue = Dem_Esm_EventUpdateAsync_Immediate(EventId, EventStatus);
      }
    }
    /* else: event status change ignored, notify by returning E_NOT_OK */
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETEVENTSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_ResetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_ResetEventStatus(
  Dem_EventIdType  EventId                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (FALSE != DEM_ESM_TEST_ENABLECONDITION(Dem_CurrentEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING))
    { /* DTC setting is enabled, proceed */
      {
        if ( (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)                                                                  /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE) )
        {
          lReturnValue = Dem_Esm_EventReset_Async(EventId);
        }
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_RESETEVENTSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_ResetEventDebounceStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_ResetEventDebounceStatus(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  Dem_DebounceResetStatusType  DebounceResetStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

#if ( (DEM_DEV_ERROR_DETECT == STD_ON) \
   || (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON) \
   || (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) )                                                                               /* COV_MSR_UNSUPPORTED TX tx tf tf */
  lReturnValue = E_NOT_OK;
#endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState < DEM_INIT_PREINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((EventId >= Dem_Cfg_GlobalEventCount()) || (EventId == DEM_EVENT_INVALID))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DebounceResetStatus >= DEM_DEBOUNCE_STATUS_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
  if ((Dem_Cfg_EventSupportDebounceNv(EventId) != FALSE) && (Dem_InitState != DEM_INIT_INITIALIZED))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
# endif
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE) )
    {
      Dem_Esm_EventResetDebounceState(EventId, DebounceResetStatus);
      lReturnValue = E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_RESETEVENTDEBOUNCESTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_PrestoreFreezeFrame
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_PrestoreFreezeFrame(
  Dem_EventIdType  EventId                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (DEM_CFG_DTC_UDS_INVALID != Dem_Cfg_EventUdsDtc(EventId))                                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
      && (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE)
      )
    { /* Only pre-store for externally visible Events that support prestorage */
      lReturnValue = Dem_Esm_EventPrestorageUpdate(EventId);
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_PRESTOREFREEZEFRAME_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_ClearPrestoredFreezeFrame
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_ClearPrestoredFreezeFrame(
  Dem_EventIdType  EventId                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE)
      )
    {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */

      lReturnValue = Dem_Esm_EventPrestorageClear(EventId);

      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_CLEARPRESTOREDFREEZEFRAME_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

                                         /* Service Interface DiagnosticInfo */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_GetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventStatus(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(Dem_EventStatusExtendedType, AUTOMATIC, DEM_APPL_DATA)  EventStatusExtended
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == EventStatusExtended)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE) )
    {
      *EventStatusExtended = Dem_Mem_EventGetStatus(EventId);                                                                    /* SBSW_DEM_POINTER_WRITE_API */

      lReturnValue = E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetEventFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventFailed(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  EventFailed
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == EventFailed)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE) )
    {
      if (FALSE != DEM_ESM_TEST_UDS_STATUS_TF(Dem_Mem_EventGetStatus(EventId)))
      {
        *EventFailed = TRUE;                                                                                                     /* SBSW_DEM_POINTER_WRITE_API */
      }
      else
      {
        *EventFailed = FALSE;                                                                                                    /* SBSW_DEM_POINTER_WRITE_API */
      }
      lReturnValue = E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTFAILED_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetEventTested
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventTested(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  EventTested
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == EventTested)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Mem_GetCycleStatus(Dem_Cfg_EventOperationCycle(EventId)) == DEM_QUEUE_CYCLE_STARTED)                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE)
      )
    {
      if (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(Dem_Mem_EventGetStatus(EventId)))
      {
        *EventTested = TRUE;                                                                                                     /* SBSW_DEM_POINTER_WRITE_API */
      }
      else
      {
        *EventTested = FALSE;                                                                                                    /* SBSW_DEM_POINTER_WRITE_API */
      }
      lReturnValue = E_OK;
    }
    /* else: with stopped cycle the bit value is undecided */
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTTESTED_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetDTCOfEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetDTCOfEvent(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  Dem_DTCFormatType  DTCFormat,
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA)  DTCOfEvent
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DTCFormat >= DEM_DTC_FORMAT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DTCOfEvent)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    uint32 lDtc;

    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE) )
    {
      /* Dispatch requested DTC format */
      switch (DTCFormat)
      {
      case DEM_DTC_FORMAT_UDS:
        lDtc = Dem_Cfg_EventUdsDtc(EventId);
        if (DEM_CFG_DTC_UDS_INVALID != lDtc)
        {
          *DTCOfEvent = lDtc;                                                                                                    /* SBSW_DEM_POINTER_WRITE_API */
          lReturnValue = E_OK;
        }
        else
        {
          lReturnValue = DEM_E_NO_DTC_AVAILABLE;
        }
        break;

      default:                                                                                                                   /* PRQA S 2018 */ /* MD_DEM_14.1 */
        /* MISRA case */
        break;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETDTCOFEVENT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetFaultDetectionCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetFaultDetectionCounter(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter                                                                  /* PRQA S 3673 */ /* MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == FaultDetectionCounter)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE) )
    {
      switch (Dem_Cfg_EventDebounceType(EventId))
      {
#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
      case DEM_CFG_DEBOUNCETYPE_COUNTER:
        *FaultDetectionCounter = Dem_Data_CalculateFDC_CounterBased(EventId,                                                     /* SBSW_DEM_POINTER_WRITE_API */
                                                                    Dem_Mem_EventGetDebounceValue(EventId));
        lReturnValue = E_OK;
        break;
#endif
#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
      case DEM_CFG_DEBOUNCETYPE_TIMER:
        *FaultDetectionCounter = Dem_Data_CalculateFDC_TimeBased(EventId,                                                        /* SBSW_DEM_POINTER_WRITE_API */
                                                                  Dem_Mem_EventGetDebounceValue(EventId),
                                                                  (uint8)Dem_Mem_GetDebounceStatus(Dem_Mem_EventGetInternalStatus(EventId)));
        lReturnValue = E_OK;
        break;
#endif
#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
      case DEM_CFG_DEBOUNCETYPE_EXTERNAL:
        if (Dem_Cfg_EventCbkGetFDC(EventId) != NULL_PTR)
        {
          sint8 lFdc;
          lReturnValue = (*Dem_Cfg_EventCbkGetFDC(EventId))(&lFdc);                                                              /* SBSW_DEM_EVENTCBKGETFDC_FPTR */
          if (lReturnValue == E_OK)
          {
            *FaultDetectionCounter = lFdc;                                                                                       /* SBSW_DEM_POINTER_WRITE_API */
          }
        }
        else
        {
          lReturnValue = DEM_E_NO_FDC_AVAILABLE;
        }
        break;
#endif
      default:
        break;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETFAULTDETECTIONCOUNTER_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetEventFreezeFrameData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventFreezeFrameData(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  uint8  RecordNumber,                                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  boolean  ReportTotalRecord,                                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint16  DataId,                                                                                                                /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE) )
    {
      if (RecordNumber == 0x00)
      {
        lReturnValue = DEM_E_WRONG_RECORDNUMBER;
      }
#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
      else
      {
        Dem_EventIdType lMasterEventId;

        lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);
        lReturnValue = Dem_Dcm_CopyDidFromSRec(lMasterEventId, RecordNumber, ReportTotalRecord, DataId, DestBuffer);             /* SBSW_DEM_POINTER_FORWARD_API */
      }
#else
      DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
      DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                   /* PRQA S 3112 */ /* MD_DEM_14.2 */
      DEM_IGNORE_UNUSED_ARGUMENT(ReportTotalRecord)                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
      DEM_IGNORE_UNUSED_ARGUMENT(DataId)                                                                                         /* PRQA S 3112 */ /* MD_DEM_14.2 */
      DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTFREEZEFRAMEDATA_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetEventExtendedDataRecord
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventExtendedDataRecord(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  uint8  RecordNumber,                                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

#if (DEM_DEV_ERROR_DETECT == STD_ON) || (DEM_CFG_SUPPORT_ERECS == STD_ON)
  lReturnValue = E_NOT_OK;
#endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_SUPPORT_ERECS == STD_ON)
    if ( (Dem_Cfg_EventAvailableByVariant(EventId) == TRUE)                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(EventId)) == FALSE) )
    {
      /* Find the Record number */
      Dem_EventIdType lMasterEventId;
      lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);
      lReturnValue = Dem_Dcm_CopyERecs(lMasterEventId, RecordNumber, DestBuffer);                                                /* SBSW_DEM_POINTER_FORWARD_API */
    }
#else /* (DEM_CFG_SUPPORT_ERECS == STD_ON) */
    DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    lReturnValue = E_NOT_OK;
#endif
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTEXTENDEDDATARECORD_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

                                         /* Service Interface IUMPRNumerator */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_RepIUMPRFaultDetect
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_RepIUMPRFaultDetect(
  Dem_RatioIdType  RatioID                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (RatioID >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (RatioID == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    Dem_RatioIdIndexType lRatioIndex;
    lRatioIndex = Dem_Cfg_EventRatioIdIdx(RatioID);

# if (DEM_DEV_ERROR_DETECT == STD_ON)
    if (DEM_CFG_RATIOINDEX_INVALID == lRatioIndex)
    {
      Dem_Det_ErrorRegisterSet(DEM_E_PARAM_CONFIG)
    }
    else
    if (DEM_RATIO_API != Dem_Cfg_ObdRatioIdType(lRatioIndex))
    { /* API only allowed for ratios with RatioIdType = API */
      Dem_Det_ErrorRegisterSet(DEM_E_PARAM_CONFIG)
    }
    else
# endif
    {
      /* ----- Implementation ---------------------------------------------- */
      if ( (Dem_Cfg_EventAvailableByVariant(RatioID) == TRUE)                                                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(RatioID)) == FALSE) )
      {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
        Dem_EnterCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */

        Dem_Esm_RatioQueueAsync(lRatioIndex);

        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
        lReturnValue = E_OK;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_REPIUMPRFAULTDETECT_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_IUMPR == STD_ON) */

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_IUMPRLockNumerators
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_IUMPRLockNumerators(
  void
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    uint8 lNumeratorsLocked;

    /* ----- Implementation ------------------------------------------------ */
    lNumeratorsLocked = Dem_Mem_GetGlobalNumeratorsLocked();
    lNumeratorsLocked = DEM_ESM_SET_IUMPR_NUMERATORS_LOCKED(lNumeratorsLocked);

    Dem_Mem_SetGlobalNumeratorsLocked(lNumeratorsLocked);
    Dem_Mem_IumprSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);

    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_IUMPRLOCKNUMERATORS_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_IUMPR == STD_ON) */

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_RepIUMPRDenLock
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_RepIUMPRDenLock(
  Dem_RatioIdType  RatioID                                                                                                       /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (RatioID >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (RatioID == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    Dem_RatioIdIndexType  lRatioIndex;
    lRatioIndex = Dem_Cfg_EventRatioIdIdx(RatioID);

# if (DEM_DEV_ERROR_DETECT == STD_ON)
    if (DEM_CFG_RATIOINDEX_INVALID == lRatioIndex)
    {
      Dem_Det_ErrorRegisterSet(DEM_E_PARAM_CONFIG)
    }
    else
    if (DEM_IUMPR_DEN_PHYS_API != Dem_Cfg_ObdIumprDenGroup(lRatioIndex))
    { /* API only allowed for ratios with IUMPR-Group = PHYS_API */
      Dem_Det_ErrorRegisterSet(DEM_E_PARAM_CONFIG)
    }
    else
# endif
    {
      /* ----- Implementation ---------------------------------------------- */
      if ( (Dem_Cfg_EventAvailableByVariant(RatioID) == TRUE)                                                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(RatioID)) == FALSE) )
      {
        uint8 lRatioStatus;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
        Dem_EnterCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* set locked state */
        lRatioStatus = Dem_Mem_GetIumprStatus(lRatioIndex);
        lRatioStatus = DEM_ESM_SET_IUMPR_DEN_LOCKED(lRatioStatus);
        Dem_Mem_SetIumprStatus(lRatioIndex, lRatioStatus);

        /* don't set pending flag --> ratio will not be incremented if lock is set */

        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

        lReturnValue = E_OK;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_REPIUMPRDENLOCK_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_IUMPR == STD_ON) */

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_RepIUMPRDenRelease
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_RepIUMPRDenRelease(
  Dem_RatioIdType  RatioID                                                                                                       /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (RatioID >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (RatioID == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    Dem_RatioIdIndexType  lRatioIndex;
    lRatioIndex = Dem_Cfg_EventRatioIdIdx(RatioID);

# if (DEM_DEV_ERROR_DETECT == STD_ON)
    if (DEM_CFG_RATIOINDEX_INVALID == lRatioIndex)
    {
      Dem_Det_ErrorRegisterSet(DEM_E_PARAM_CONFIG)
    }
    else
    if (DEM_IUMPR_DEN_PHYS_API != Dem_Cfg_ObdIumprDenGroup(lRatioIndex))
    { /* API only allowed for ratios with IUMPR-Group = PHYS_API */
      Dem_Det_ErrorRegisterSet(DEM_E_PARAM_CONFIG)
    }
    else
# endif
    {
      uint8 lRatioStatus;

      /* ----- Implementation ---------------------------------------------- */
      if ( (Dem_Cfg_EventAvailableByVariant(RatioID) == TRUE)                                                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        && (Dem_Mem_TestEventDisconnectedStatus(Dem_Mem_EventGetInternalStatus(RatioID)) == FALSE) )
      {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
        Dem_EnterCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* clear locked state */
        lRatioStatus = Dem_Mem_GetIumprStatus(lRatioIndex);
        lRatioStatus = DEM_ESM_RESET_IUMPR_DEN_LOCKED(lRatioStatus);
        Dem_Mem_SetIumprStatus(lRatioIndex, lRatioStatus);

        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

        if ( (FALSE != DEM_ESM_TEST_IUMPR_GENDEN_CONDITIONS_REACHED(Dem_Mem_GetGeneralDenominatorStatus()))
          && (FALSE == DEM_ESM_TEST_IUMPR_DEN_INCREMENTED(lRatioStatus)) )
        {
          /* conditions for increment seem to be fulfilled; set pending flag and increment on task level */
          Dem_Mem_IumprSetUpdatePending(lRatioIndex, TRUE);
          Dem_Queue_SetGlobalIumprUpdatePending();
        }

        lReturnValue = E_OK;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_REPIUMPRDENRELEASE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_IUMPR == STD_ON) */

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_SetIUMPRDenCondition
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetIUMPRDenCondition(
  Dem_IumprDenomCondIdType ConditionId,                                                                                          /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  Dem_IumprDenomCondStatusType ConditionStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;                                                                                                       /* PRQA S 3198 */ /* MD_DEM_3198_na */
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (0 == ConditionId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_IUMPR_DEN_COND_INVALID <= ConditionId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    uint8 lDenominatorGroup;
    uint8 lGenDenominatorStatus;

    lReturnValue = E_OK;
    lGenDenominatorStatus = Dem_Mem_GetGeneralDenominatorStatus();

    /* ----- Implementation ------------------------------------------------ */
    switch (ConditionId)
    {
    case DEM_IUMPR_GENERAL_DENOMINATOR:
      /* --- General Denominator Handling --- */
      if (DEM_IUMPR_DEN_STATUS_REACHED == ConditionStatus)
      {
        if (DEM_ESM_TEST_IUMPR_GENDEN_INCREMENTED(lGenDenominatorStatus) == FALSE)
        {
          /* general conditions fulfilled and denominator not yet incremented in this DCY */

          /* general denominator not yet incremented in this DCY */
          /* --> no overrun handling; value shall rollover and increment to zero  [CCR1968.2 (g)(5.2.1)(E)] */
          Dem_Mem_SetGeneralDenominator(Dem_Mem_GetGeneralDenominator()+1);
          lGenDenominatorStatus = DEM_ESM_SET_IUMPR_GENDEN_CONDITIONS_REACHED(lGenDenominatorStatus);
          lGenDenominatorStatus = DEM_ESM_SET_IUMPR_GENDEN_INCREMENTED(lGenDenominatorStatus);

          /* update NvM */
          Dem_Mem_SetGeneralDenominatorStatus(lGenDenominatorStatus);
          Dem_Mem_IumprSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
        }
      }
      else
      {
        /* general conditions not (yet) fulfilled */
        lGenDenominatorStatus = DEM_ESM_RESET_IUMPR_GENDEN_CONDITIONS_REACHED(lGenDenominatorStatus);

        if (DEM_IUMPR_DEN_STATUS_INHIBITED == ConditionStatus)
        {
          /* erroneous inputs: also set incremented flag to prevent, that general denominator is incremented in this DCY */
          lGenDenominatorStatus = DEM_ESM_SET_IUMPR_GENDEN_CONDITIONS_FAILED(lGenDenominatorStatus);
          lGenDenominatorStatus = DEM_ESM_SET_IUMPR_GENDEN_INCREMENTED(lGenDenominatorStatus);
        }

        /* update NvM */
        Dem_Mem_SetGeneralDenominatorStatus(lGenDenominatorStatus);
        Dem_Mem_IumprSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
      }
      lDenominatorGroup = DEM_IUMPR_DEN_NONE;
      break;

    case DEM_IUMPR_DEN_COND_COLDSTART:
      lDenominatorGroup = DEM_IUMPR_DEN_COLDSTART;
      break;

    case DEM_IUMPR_DEN_COND_EVAP:
      lDenominatorGroup = DEM_IUMPR_DEN_EVAP;
      break;

    case DEM_IUMPR_DEN_COND_500MI:
      lDenominatorGroup = DEM_IUMPR_DEN_500MI;
      break;

    default:                                                                                                                     /* PRQA S 2018 */ /* MD_DEM_14.1 */
      /* MISRA case */
      lDenominatorGroup = DEM_IUMPR_DEN_COND_INVALID;
      lReturnValue = E_NOT_OK;
      break;
    }

    if (
#if (DEM_DEV_ERROR_DETECT == STD_OFF)
      (lDenominatorGroup != DEM_IUMPR_DEN_COND_INVALID) &&
# endif
      (DEM_ESM_TEST_IUMPR_GENDEN_CONDITIONS_FAILED(Dem_Mem_GetGeneralDenominatorStatus()) == FALSE) )
    {
      /* Conditions for a denominator group have been changed and general conditions are not failed */
      Dem_Cfg_ObdRatioIdIterType lRatioIter;

      for (Dem_Cfg_ObdRatioIdIterInit(&lRatioIter);                                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
           Dem_Cfg_ObdRatioIdIterExists(&lRatioIter) == TRUE;                                                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
           Dem_Cfg_ObdRatioIdIterNext(&lRatioIter))                                                                              /* SBSW_DEM_CALL_ITERATOR_POINTER */
      {
        uint8 lRatioDenominator;

        /* depending on the configured ratio, either respect the general denominator or a
           specific denomitaor condition */
        lRatioDenominator = Dem_Cfg_ObdIumprDenGroup(Dem_Cfg_ObdRatioIdIterGet(&lRatioIter));                                    /* SBSW_DEM_CALL_ITERATOR_POINTER */
        if (lRatioDenominator == DEM_IUMPR_DEN_PHYS_API)
        {
          lRatioDenominator = DEM_IUMPR_DEN_NONE;
        }

        /* update ratio specific denominator condition flag for all ratios that belong to the respective group */
        /* the groups "NONE" and "PHYS_API" are updated together with general denominator */
        if (lRatioDenominator == lDenominatorGroup)
        {
          uint8 lRatioStatus;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
          Dem_EnterCritical_DiagMonitor();                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

          /* the denominator status of the current ratio is affected by new condition status */
          lRatioStatus = Dem_Mem_GetIumprStatus(Dem_Cfg_ObdRatioIdIterGet(&lRatioIter));                                         /* SBSW_DEM_CALL_ITERATOR_POINTER */

          if (DEM_IUMPR_DEN_STATUS_REACHED == ConditionStatus)
          {
            /* denominator conditions are fulfilled */
            lRatioStatus = DEM_ESM_SET_IUMPR_DEN_CONDITIONS_REACHED(lRatioStatus);

            if ( (FALSE != DEM_ESM_TEST_IUMPR_GENDEN_CONDITIONS_REACHED(Dem_Mem_GetGeneralDenominatorStatus()))
              && (FALSE == DEM_ESM_TEST_IUMPR_DEN_INCREMENTED(lRatioStatus)) )
            {
              /* conditions for increment seem to be fulfilled; set pending flag and increment on task level */
              Dem_Mem_IumprSetUpdatePending(Dem_Cfg_ObdRatioIdIterGet(&lRatioIter), TRUE);                                       /* SBSW_DEM_CALL_ITERATOR_POINTER */
              Dem_Queue_SetGlobalIumprUpdatePending();
            }
          }
          else
          {
            /* denominator conditions not fulfilled */
            lRatioStatus = DEM_ESM_RESET_IUMPR_DEN_CONDITIONS_REACHED(lRatioStatus);
            /* ratio will not be incremented, so pending flag need not be set */
          }

          Dem_Mem_SetIumprStatus(Dem_Cfg_ObdRatioIdIterGet(&lRatioIter), lRatioStatus);                                          /* SBSW_DEM_CALL_ITERATOR_POINTER */

          Dem_LeaveCritical_DiagMonitor();                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

          Dem_Mem_IumprSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
        }
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETIUMPRDENCONDITION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_IUMPR == STD_ON) */

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_GetIUMPRGeneralData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetIUMPRGeneralData(
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  NumberOfRatios,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  GeneralDenominator,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  IgnitionCycles,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  IgnitionCyclesHybrid
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == NumberOfRatios)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == GeneralDenominator)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == IgnitionCycles)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == IgnitionCyclesHybrid)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
# if (DEM_FEATURE_NEED_SUPPRESSION == STD_ON)
    {
      Dem_EventIdType lEventId;

      *NumberOfRatios = 0;                                                                                                       /* SBSW_DEM_POINTER_WRITE_API */

      for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
      {
        /* Skip suppressed or deactivated events. RatioId == EventId */
        /* Intentionally usage of Dem_Mem_EventGetInternalStatus() instead of
           Dem_Util_DtcGetInternalStatus() as each event tracks its own ratio */
        if ( (DEM_CFG_RATIOINDEX_INVALID != Dem_Cfg_EventRatioIdIdx(lEventId))                                                   /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          && (Dem_Cal_TestDtcSuppressed(lEventId) == FALSE)
          && (Dem_Cal_TestEventSuppressed(lEventId) == FALSE)
          )
        {
          ++(*NumberOfRatios);                                                                                                   /* SBSW_DEM_POINTER_WRITE_API */
        }
      }
    }
# else
    *NumberOfRatios = Dem_Cfg_ObdRatioIdCount();                                                                                 /* SBSW_DEM_POINTER_WRITE_API */
# endif
    *GeneralDenominator = Dem_Mem_GetGeneralDenominator();                                                                       /* SBSW_DEM_POINTER_WRITE_API */
    *IgnitionCycles = Dem_Mem_GetIgnitionCycleCounter();                                                                         /* SBSW_DEM_POINTER_WRITE_API */
# if (DEM_CFG_SUPPORT_CYCLE_IGNITION_HYBRID == STD_ON)
    *IgnitionCyclesHybrid = Dem_Mem_GetIgnitionCycleCounterHybrid();                                                             /* SBSW_DEM_POINTER_WRITE_API */
# else
    *IgnitionCyclesHybrid = 0;                                                                                                   /* SBSW_DEM_POINTER_WRITE_API */
# endif

    /* initialize event counter that is used when reading the ratios */
    Dem_Mem_IumprCurrentEvent = Dem_Cfg_GlobalEventCount();
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETIUMPRGENERALDATA_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_IUMPR == STD_ON) */

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_GetNextIUMPRRatioDataAndDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetNextIUMPRRatioDataAndDTC(
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA)  UdsDtcNumber,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  ObdDtcNumber,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  Denominator,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  Numerator
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == UdsDtcNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == ObdDtcNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Denominator)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Numerator)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Mem_IumprCurrentEvent != DEM_EVENT_INVALID) &&                                                                     /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
         (Dem_Mem_IumprCurrentEvent <= Dem_Cfg_GlobalEventCount()) )   /* initial counter value = number of events */
    {
      do
      {
        --Dem_Mem_IumprCurrentEvent;
      }
      while ( ( ( (DEM_CFG_RATIOINDEX_INVALID == Dem_Cfg_EventRatioIdIdx(Dem_Mem_IumprCurrentEvent))                             /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
               || (Dem_Cal_TestDtcSuppressed(Dem_Mem_IumprCurrentEvent) == TRUE)
               || (Dem_Cal_TestEventSuppressed(Dem_Mem_IumprCurrentEvent) == TRUE)
               )
             && (Dem_Mem_IumprCurrentEvent > 0)
             ) );

      if (Dem_Mem_IumprCurrentEvent != DEM_EVENT_INVALID)
      {
        /* event with ratio have been found; return found data */
        *UdsDtcNumber = Dem_Cfg_EventUdsDtc(Dem_Mem_IumprCurrentEvent);                                                          /* SBSW_DEM_POINTER_WRITE_API */
# if (DEM_CFG_SUPPORT_OBDII == STD_ON)
        *ObdDtcNumber = Dem_Cfg_EventObdDtc(Dem_Mem_IumprCurrentEvent);                                                          /* SBSW_DEM_POINTER_WRITE_API */
# else
        *ObdDtcNumber = 0;  /* Wwh Obd uses the UDS DTC number only */                                                           /* SBSW_DEM_POINTER_WRITE_API */
# endif
        *Denominator  = Dem_Mem_GetDenominator(Dem_Cfg_EventRatioIdIdx(Dem_Mem_IumprCurrentEvent));                              /* SBSW_DEM_POINTER_WRITE_API */
        *Numerator    = Dem_Mem_GetNumerator(Dem_Cfg_EventRatioIdIdx(Dem_Mem_IumprCurrentEvent));                                /* SBSW_DEM_POINTER_WRITE_API */

        lReturnValue = E_OK;
      }
      /* else: event table have been parsed completely and no event with referenced ratio found */
    }
    /* else: event counter 0 or > event count; either all events have been parsed or counter is not initialized */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETNEXTIUMPRRATIODATAANDDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_IUMPR == STD_ON) */

#if (DEM_FEATURE_NEED_IUMPR == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_GetCurrentIUMPRRatioDataAndDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetCurrentIUMPRRatioDataAndDTC(
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA)  UdsDtcNumber,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  ObdDtcNumber,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  Denominator,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  Numerator
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == UdsDtcNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == ObdDtcNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Denominator)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Numerator)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Mem_IumprCurrentEvent > 0) &&                                                                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
         (Dem_Mem_IumprCurrentEvent < Dem_Cfg_GlobalEventCount()) )   /* counter value must have been decremented at least once before reading current ratio */
    {
      /* event with ratio have been found; return found data */
      *UdsDtcNumber = Dem_Cfg_EventUdsDtc(Dem_Mem_IumprCurrentEvent);                                                            /* SBSW_DEM_POINTER_WRITE_API */
# if (DEM_CFG_SUPPORT_OBDII == STD_ON)
      *ObdDtcNumber = Dem_Cfg_EventObdDtc(Dem_Mem_IumprCurrentEvent);                                                            /* SBSW_DEM_POINTER_WRITE_API */
# else
      *ObdDtcNumber = 0;  /* Wwh Obd uses the UDS DTC number only */                                                             /* SBSW_DEM_POINTER_WRITE_API */
# endif
      *Denominator  = Dem_Mem_GetDenominator(Dem_Cfg_EventRatioIdIdx(Dem_Mem_IumprCurrentEvent));                                /* SBSW_DEM_POINTER_WRITE_API */
      *Numerator    = Dem_Mem_GetNumerator(Dem_Cfg_EventRatioIdIdx(Dem_Mem_IumprCurrentEvent));                                  /* SBSW_DEM_POINTER_WRITE_API */

      lReturnValue = E_OK;
    }
    /* else: event counter 0 or > event count; either all events have been parsed or counter is not initialized */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETCURRENTIUMPRRATIODATAANDDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_IUMPR == STD_ON) */

                                           /* Service Interface PowerTakeOff */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_OBD_PTO == STD_ON)                                                                                          /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_SetPtoStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetPtoStatus(
  boolean  PtoStatus                                                                                                             /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    DEM_IGNORE_UNUSED_ARGUMENT(PtoStatus)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETPTOSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return E_NOT_OK;
}
#endif

                                         /* Service Interface DTCSuppression */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_SetDTCSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetDTCSuppression(
  uint32  DTC,
  Dem_DTCFormatType  DTCFormat,
  boolean  SuppressionStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_FORMAT_INVALID <= DTCFormat)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < SuppressionStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if ((DEM_DTC_FORMAT_UDS == DTCFormat) && (DEM_CFG_DTC_UDS_INVALID == DTC))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    uint16 lEventId;

    /* ----- Implementation ------------------------------------------------ */
    if (DEM_DTC_FORMAT_UDS == DTCFormat)
    {
      lEventId = Dem_Cfg_FindEventFromUdsDtc(DTC, DEM_CFG_MEMORYID_PRIMARY);
# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
      if (DEM_EVENT_INVALID == lEventId)
      {
        lEventId = Dem_Cfg_FindEventFromUdsDtc(DTC, DEM_CFG_MEMORYID_SECONDARY);
      }
# endif
    }
    else
    {
      lEventId = DEM_EVENT_INVALID;
    }

    if (DEM_EVENT_INVALID != lEventId)
    {
      if (FALSE != SuppressionStatus)
      {
        Dem_Esm_EventSetDtcSuppression(lEventId);
      }
      else
      {
        Dem_Esm_EventResetDtcSuppression(lEventId);
      }
      lReturnValue = E_OK;
    }
    /* else: DTC not supported */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETDTCSUPPRESSION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

                                       /* Service Interface EventSuppression */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_SetEventSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetEventSuppression(
  uint16  EventId,
  boolean  SuppressionStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_PREINITIALIZED > Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < SuppressionStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (FALSE != SuppressionStatus)
    {
      Dem_Esm_EventSetSuppression(EventId);
    }
    else
    {
      Dem_Esm_EventResetSuppression(EventId);
    }
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETEVENTSUPPRESSION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

                                         /* Service Interface EventAvailable */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_SetEventAvailable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetEventAvailable(
  uint16  EventId,
  boolean  AvailableStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
#  if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
#  else
  if (DEM_INIT_PREINITIALIZED > Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
#  endif
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < AvailableStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (FALSE != AvailableStatus)
    {
      Dem_Esm_EventReconnect(EventId);
      lReturnValue = E_OK;
    }
    else
    {
      lReturnValue = Dem_Esm_EventDisconnect(EventId);
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETEVENTAVAILABLE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) */

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_GetEventAvailable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventAvailable(
  uint16  EventId,                                                                                                               /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  AvailableStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
#  if (DEM_FEATURE_NEED_EVENTAVAILABLE_NV == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
#  else
  if (DEM_INIT_PREINITIALIZED > Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
#  endif
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (AvailableStatus == NULL_PTR)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;

    /* ----- Implementation ------------------------------------------------ */
    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    *AvailableStatus = (boolean)(Dem_Mem_TestEventDisconnectedStatus(lInternalStatus) == FALSE);                                 /* SBSW_DEM_POINTER_WRITE_API */
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTAVAILABLE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) */

                                         /* Service Interface OperationCycle */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_SetOperationCycleState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetOperationCycleState(
  uint8  OperationCycleId,                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  Dem_OperationCycleStateType  CycleState
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = E_NOT_OK;
  }
  else
  if (Dem_Cfg_GlobalCycleCount() <= OperationCycleId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = E_NOT_OK;
  }
  else
  if (DEM_CYCLE_STATE_INVALID <= CycleState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = E_NOT_OK;
  }
  else
#endif
  {
    boolean lOldCycleStatus;

    /* ----- Implementation ------------------------------------------------ */
    lOldCycleStatus = Dem_Mem_GetCycleStatus(OperationCycleId);

    {
      if ( (lOldCycleStatus != DEM_QUEUE_CYCLE_STOPPED)
        || (CycleState != DEM_CYCLE_STATE_END) )
      {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
        Dem_EnterCritical_StateManager();                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */

        if (Dem_Queue_IsPendingCycle(OperationCycleId) == TRUE)
        {
          boolean lPendingCycleStatus;

          lPendingCycleStatus = Dem_Queue_GetPendingCycle(OperationCycleId);

          if (DEM_QUEUE_CYCLE_STOPPED == lPendingCycleStatus)
          { /* END->START through two calls to the function is accepted and queued */
            if (CycleState == DEM_CYCLE_STATE_START)
            {                                                                                                                    /* PRQA S 0715 */ /* MD_MSR_1.1_715 */
              Dem_Queue_SetPendingCycle(OperationCycleId, DEM_QUEUE_CYCLE_STARTED);
            }
          }
        }
        else
        {
          Dem_Queue_SetPendingCycle(OperationCycleId,
            ( (CycleState == DEM_CYCLE_STATE_START)
              ?DEM_QUEUE_CYCLE_STARTED
              :DEM_QUEUE_CYCLE_STOPPED)
            );
        }

        Dem_LeaveCritical_StateManager();                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETOPERATIONCYCLESTATE_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

                                             /* Service Interface AgingCycle */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_AGINGCYCLE_STATE_API == STD_ON)                                                                             /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_SetAgingCycleState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetAgingCycleState(
  uint8  AgingCycleId                                                                                                            /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    DEM_IGNORE_UNUSED_ARGUMENT(AgingCycleId)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETAGINGCYCLESTATE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return E_NOT_OK;
}
#endif

                                     /* Service Interface ExternalAgingCycle */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_AGINGCYCLE_COUNTER_API == STD_ON)                                                                           /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_SetAgingCycleCounterValue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetAgingCycleCounterValue(
  uint8  CounterValue                                                                                                            /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    DEM_IGNORE_UNUSED_ARGUMENT(CounterValue)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETAGINGCYCLECOUNTERVALUE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return E_NOT_OK;
}
#endif

                                                  /* Service Interface CddIf */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_ClearDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_ClearDTC(
  uint32  DTC,
  Dem_DTCFormatType  DTCFormat,
  Dem_DTCOriginType  DTCOrigin
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    lReturnValue = DEM_CLEAR_FAILED;
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_FORMAT_INVALID <= DTCFormat)
  {
    lReturnValue = DEM_CLEAR_WRONG_DTC;
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    lReturnValue = DEM_CLEAR_WRONG_DTCORIGIN;
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_Queue_ClearRequestType lClearRequest;

    lClearRequest.ClearFormat = DTCFormat;
    lClearRequest.ClearMemoryId = Dem_Dcm_MemoryIdFromOrigin(DTCOrigin);
    lClearRequest.ClearClient = DEM_DCM_CLIENT_APPLICATION;
    lReturnValue = Dem_Dcm_ClearDtc_Internal(DTC, &lClearRequest);                                                               /* SBSW_DEM_POINTER_FORWARD_STACK */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_CLEARDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}

                                        /* Service Interface EnableCondition */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_SetEnableCondition
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetEnableCondition(
  uint8  EnableCondition,                                                                                                        /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  boolean  ConditionFulfilled
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ( (EnableCondition == DEM_ENABLECONDITION_CONTROLDTCSETTING)                                                                /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    || (Dem_Cfg_GlobalEnableCondCount() < EnableCondition) )
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
    Dem_EnterCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Map the given enable condition state to bit array */
    if (FALSE == ConditionFulfilled)
    { /* clear enable condition */
# if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = DEM_ESM_RESET_ENABLECONDITION(Dem_NextEnableConditionStates, EnableCondition);
# endif
      Dem_CurrentEnableConditionStates = DEM_ESM_RESET_ENABLECONDITION(Dem_CurrentEnableConditionStates, EnableCondition);
    }
    else
    { /* set enable condition */
# if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = DEM_ESM_SET_ENABLECONDITION(Dem_NextEnableConditionStates, EnableCondition);
# else
      Dem_CurrentEnableConditionStates = DEM_ESM_SET_ENABLECONDITION(Dem_CurrentEnableConditionStates, EnableCondition);
# endif
    }

    Dem_LeaveCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETENABLECONDITION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_ENABLE_CONDITIONS == STD_ON) */

#if (DEM_CFG_SUPPORT_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_GetEventEnableCondition
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventEnableCondition(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  ConditionFulfilled
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((DEM_EVENT_INVALID == EventId) || (Dem_Cfg_GlobalEventCount() <= EventId))                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == ConditionFulfilled)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */

    /* Depeding on configuration, EventId is not used to select enable conditions */
    DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

    if (((Dem_CurrentEnableConditionStates | ((uint32)0x01U)) & Dem_Cfg_EventEnableConditions(EventId)) != Dem_Cfg_EventEnableConditions(EventId))
    { /* enable condition is not fulfilled (ignoring DTC setting) */
      *ConditionFulfilled = FALSE;                                                                                               /* SBSW_DEM_POINTER_WRITE_API */
    }
    else
    {
      *ConditionFulfilled = TRUE;                                                                                                /* SBSW_DEM_POINTER_WRITE_API */
    }
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETENABLECONDITION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_ENABLE_CONDITIONS == STD_ON) */

                                       /* Service Interface StorageCondition */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_SetStorageCondition
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetStorageCondition(
  uint8  StorageCondition,                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  boolean  ConditionFulfilled
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
#endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (Dem_Cfg_GlobalStorageCondCount() <= StorageCondition)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < ConditionFulfilled)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
    Dem_EnterCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Map the given enable condition state to bit array */
    if (FALSE == ConditionFulfilled)
    { /* clear enable condition */
      Dem_StorageConditionStates = Dem_StorageConditionStates & ((uint32)(~( (uint32)(((uint32)1u) << StorageCondition) )));
    }
    else
    { /* set enable condition */
      Dem_StorageConditionStates = Dem_StorageConditionStates | (uint32)( ((uint32)1u) << StorageCondition );
    }

    Dem_LeaveCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETSTORAGECONDITION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON) */

                                        /* Service Interface IndicatorStatus */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_GetIndicatorStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetIndicatorStatus(
  uint8  IndicatorId,                                                                                                            /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  P2VAR(Dem_IndicatorStatusType, AUTOMATIC, DEM_APPL_DATA)  IndicatorStatus                                                      /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

#if (DEM_DEV_ERROR_DETECT == STD_ON) || (DEM_FEATURE_NEED_INDICATORS != STD_ON)                                                  /* COV_MSR_UNSUPPORTED TX tx tf */
  lReturnValue = E_NOT_OK;
#endif
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)
#else
  /* There are no valid Indicator Ids with which to call this function */
  Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
#endif

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (Dem_Cfg_GlobalIndicatorCount() <= IndicatorId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == IndicatorStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_FEATURE_NEED_SPECIAL_INDICATORS == STD_ON)
    if ( (Dem_Cfg_GlobalMilIndicator() == IndicatorId)                                                                           /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      || (Dem_Cfg_GlobalRslIndicator() == IndicatorId)
      || (Dem_Cfg_GlobalAwlIndicator() == IndicatorId)
      || (Dem_Cfg_GlobalPlIndicator() == IndicatorId) )
    {
# if (DEM_CFG_SUPPORT_WWHOBD == STD_ON)
      *IndicatorStatus = Dem_Esm_GlobalIndicatorActivationMode();                                                                /* SBSW_DEM_POINTER_WRITE_API */
# else
      *IndicatorStatus = Dem_Util_GlobalSpecialIndicatorState(IndicatorId);                                                      /* SBSW_DEM_POINTER_WRITE_API */
# endif
    }
    else
#endif
    {
      Dem_IndicatorStatusType lIndicatorStatus;

      lIndicatorStatus = DEM_INDICATOR_OFF;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      {
        {
          if (Dem_Mem_IndicatorGetEventCountContinuous(IndicatorId, DEM_J1939_NODE_ID) > 0)
          {
            lIndicatorStatus = (uint8)(lIndicatorStatus | DEM_INDICATOR_CONTINUOUS);
          }
          if (Dem_Mem_IndicatorGetEventCountBlinking(IndicatorId, DEM_J1939_NODE_ID) > 0)
          {
            lIndicatorStatus = (uint8)(lIndicatorStatus | DEM_INDICATOR_BLINKING);
          }
        }
      }

      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

      *IndicatorStatus = lIndicatorStatus;                                                                                       /* SBSW_DEM_POINTER_WRITE_API */
    }
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
# if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
# endif
  {
    Dem_Det_ReportError(DEM_GETINDICATORSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

                                            /* Service Interface EventStatus */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 % Dem_SetWIRStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetWIRStatus(
  Dem_EventIdType EventId,                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  boolean WIRStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < WIRStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_Cfg_EventInternalStatusType lInternalStatus;

# if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR_DURING_CDTCS == STD_OFF)
    if (FALSE != DEM_ESM_TEST_ENABLECONDITION(Dem_CurrentEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING))
# endif
    {
      /* DTC setting is enabled, proceed */
      if (WIRStatus != Dem_Mem_TestUserControlledWirStatus(Dem_Mem_EventGetInternalStatus(EventId)))
      {
        uint8 lOldDtcStatus;
        uint8 lNewDtcStatus;
        /* override status has to be changed */
        lNewDtcStatus = Dem_Util_DtcGetStatus(EventId);
        lOldDtcStatus = Dem_Util_DtcApplyExternalOnlyStatus(EventId, lNewDtcStatus);
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
        Dem_EnterCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* update internal status bit */
        lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
        if (FALSE == WIRStatus)
        {
          lInternalStatus = Dem_Mem_ResetUserControlledWirStatus(lInternalStatus);
        }
        else
        {
          lInternalStatus = Dem_Mem_SetUserControlledWirStatus(lInternalStatus);
        }
        Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);

        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

        lNewDtcStatus = Dem_Util_DtcApplyExternalOnlyStatus(EventId, lNewDtcStatus);
        Dem_Cbk_DtcStatusChanged_Internal(EventId, lOldDtcStatus, lNewDtcStatus, DEM_CBK_USER_WIR);
      }

      lReturnValue = E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETWIRSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) */

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 % Dem_GetWIRStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetWIRStatus(
  Dem_EventIdType EventId,                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) WIRStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == WIRStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    *WIRStatus = (boolean)(Dem_Mem_TestUserControlledWirStatus(Dem_Mem_EventGetInternalStatus(EventId)));                        /* SBSW_DEM_POINTER_WRITE_API */
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETWIRSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) */

                                /* Service Interface EvMemOverflowIndication */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_OVFLIND_API == STD_ON)
/* ****************************************************************************
 % Dem_GetEventMemoryOverflow
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventMemoryOverflow(
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  OverflowIndication
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (0 == DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_DTC_ORIGIN_INVALID <= DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == OverflowIndication)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    switch (DTCOrigin)
    {
    case DEM_DTC_ORIGIN_PRIMARY_MEMORY:
      *OverflowIndication = Dem_Mem_GetOverflow(DEM_CFG_MEMORYID_PRIMARY);                                                       /* SBSW_DEM_POINTER_WRITE_API */
      lReturnValue = E_OK;
      break;

    case DEM_DTC_ORIGIN_SECONDARY_MEMORY:
# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
      *OverflowIndication = Dem_Mem_GetOverflow(DEM_CFG_MEMORYID_SECONDARY);                                                     /* SBSW_DEM_POINTER_WRITE_API */
# else
      *OverflowIndication = FALSE;                                                                                               /* SBSW_DEM_POINTER_WRITE_API */
# endif
      lReturnValue = E_OK;
      break;

    default:
      /* E_NOT_OK */
      break;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTMEMORYOVERFLOW_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_OVFLIND_API == STD_ON) */

#if (DEM_CFG_SUPPORT_OVFLIND_API == STD_ON)
/* ****************************************************************************
 % Dem_GetNumberOfEventMemoryEntries
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetNumberOfEventMemoryEntries(
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  NumberOfEventMemoryEntries
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (0 == DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_DTC_ORIGIN_INVALID <= DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == NumberOfEventMemoryEntries)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    switch (DTCOrigin)
    {
    case DEM_DTC_ORIGIN_PRIMARY_MEMORY:
      *NumberOfEventMemoryEntries = Dem_Mem_PrimaryCurrentCount;                                                                 /* SBSW_DEM_POINTER_WRITE_API */
      lReturnValue = E_OK;
      break;

# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
    case DEM_DTC_ORIGIN_SECONDARY_MEMORY:
      *NumberOfEventMemoryEntries = Dem_Mem_SecondaryCurrentCount;                                                               /* SBSW_DEM_POINTER_WRITE_API */
      lReturnValue = E_OK;
      break;
# endif

    default:
      /* E_NOT_OK */
      break;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETNUMBEROFEVENTMEMORYENTRIES_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_OVFLIND_API == STD_ON) */

                                         /* Dcm <-> Dem : Generic properties */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetTranslationType
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Dem_DTCTranslationFormatType, DEM_CODE)
Dem_DcmGetTranslationType(
  void
  )
{
  Dem_DTCTranslationFormatType lTranslationFormat;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    lTranslationFormat = Dem_Cfg_GlobalDtcFormat();
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETTRANSLATIONTYPE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lTranslationFormat;
}
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetDTCStatusAvailabilityMask
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DcmGetDTCStatusAvailabilityMask(
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCStatusMask
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTCStatusMask)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    *DTCStatusMask = Dem_Cfg_GlobalStatusMask();                                                                                 /* SBSW_DEM_POINTER_WRITE_API */
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETDTCSTATUSAVAILABILITYMASK_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif
                                             /* Dcm <-> Dem : DTC properties */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetStatusOfDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetStatusOfDTCType, DEM_CODE)
Dem_DcmGetStatusOfDTC(
  uint32  DTC,
  Dem_DTCOriginType  DTCOrigin,
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCStatus
  )
{
  Dem_ReturnGetStatusOfDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_STATUS_FAILED;
  }
  else
  if (0 == DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_STATUS_WRONG_DTCORIGIN;
  }
  else
  if (DEM_DTC_ORIGIN_INVALID <= DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_STATUS_WRONG_DTCORIGIN;
  }
  else
  if (NULL_PTR == DTCStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_STATUS_FAILED;
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_EventIdType lEventId;
    uint8 lMemoryId;

    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);                                                      /* SBSW_DEM_POINTER_FORWARD_STACK */
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_STATUS_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_STATUS_WRONG_DTC;
    }
    else
    {
      uint8 lEventStatus;
      lEventStatus = Dem_Util_DtcApplyExternalOnlyStatus(lEventId, Dem_Util_DtcGetStatus(lEventId));

      /* apply status availability mask */
      *DTCStatus = (uint8)(lEventStatus & Dem_Cfg_GlobalStatusMask());                                                           /* SBSW_DEM_POINTER_WRITE_API */
      lReturnValue = DEM_STATUS_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETSTATUSOFDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetSeverityOfDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetSeverityOfDTCType, DEM_CODE)
Dem_DcmGetSeverityOfDTC(
  uint32  DTC,
  P2VAR(Dem_DTCSeverityType, AUTOMATIC, DEM_DCM_DATA)  DTCSeverity                                                               /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetSeverityOfDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = DEM_GET_SEVERITYOFDTC_NOSEVERITY;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTCSeverity)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_EventIdType lEventId;

    lEventId = Dem_Dcm_FindEventFromUdsDtc(DTC, DEM_CFG_MEMORYID_PRIMARY, DEM_DCM_CLIENT_DCM);
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_GET_SEVERITYOFDTC_WRONG_DTC;
    }
    else
    {
      if (Dem_Cal_TestDtcSuppressed(lEventId) == TRUE)
      {
        lReturnValue = DEM_GET_SEVERITYOFDTC_WRONG_DTC;
      }
      else
# if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
      {
        {
          *DTCSeverity = Dem_Cfg_EventSeverity(lEventId);                                                                        /* SBSW_DEM_POINTER_WRITE_API */
          lReturnValue = DEM_GET_SEVERITYOFDTC_OK;
        }
      }
# else
      {
        DEM_IGNORE_UNUSED_ARGUMENT(DTCSeverity)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
        lReturnValue = DEM_GET_SEVERITYOFDTC_NOSEVERITY;
      }
# endif
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETSEVERITYOFDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetFunctionalUnitOfDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetFunctionalUnitOfDTCType, DEM_CODE)
Dem_DcmGetFunctionalUnitOfDTC(
  uint32  DTC,
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCFunctionalUnit
  )
{
  Dem_ReturnGetFunctionalUnitOfDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_GET_FUNCTIONALUNITOFDTC_WRONG_DTC;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTCFunctionalUnit)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_EventIdType lEventId;

    lEventId = Dem_Dcm_FindEventFromUdsDtc(DTC, DEM_CFG_MEMORYID_PRIMARY, DEM_DCM_CLIENT_DCM);
    if (DEM_EVENT_INVALID != lEventId)
    {
      if (Dem_Cal_TestDtcSuppressed(lEventId) == FALSE)
      {
        {
          *DTCFunctionalUnit = Dem_Cfg_EventFunctionalUnit(lEventId);                                                            /* SBSW_DEM_POINTER_WRITE_API */
          lReturnValue = DEM_GET_FUNCTIONALUNITOFDTC_OK;
        }
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETFUNCTIONALUNITOFDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif
                                                 /* Dcm <-> Dem : DTC filter */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmSetDTCFilter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnSetFilterType, DEM_CODE)
Dem_DcmSetDTCFilter(
  uint8  DTCStatusMask,
  Dem_DTCKindType  DTCKind,
  Dem_DTCFormatType  DTCFormat,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,
  Dem_FilterWithSeverityType  FilterWithSeverity,                                                                                /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCSeverityType  DTCSeverityMask,                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_FilterForFDCType  FilterForFaultDetectionCounter
  )
{
  Dem_ReturnSetFilterType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON) || (DEM_FEATURE_NEED_OBD != STD_ON)                                                        /* COV_MSR_UNSUPPORTED TX tx tx */
  lReturnValue = DEM_WRONG_FILTER;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_KIND_INVALID <= DTCKind)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if ((DEM_DTC_FORMAT_UDS != DTCFormat) && (DEM_DTC_FORMAT_OBD != DTCFormat))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_FILTER_WITH_SEVERITY_INVALID <= FilterWithSeverity)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_FILTER_FOR_FDC_INVALID <= FilterForFaultDetectionCounter)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SEVERITY != STD_ON)
    DEM_IGNORE_UNUSED_ARGUMENT(DTCSeverityMask)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(FilterWithSeverity)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
# endif

    if ( (DTCKind != DEM_DTC_KIND_EMISSION_REL_DTCS)
      && (DTCFormat != DEM_DTC_FORMAT_OBD)
      && (DTCOrigin != DEM_DTC_ORIGIN_PERMANENT_MEMORY) )
    {
      uint8 lFilterCriteria;

      lFilterCriteria = 0;
      lReturnValue = DEM_FILTER_ACCEPTED;

# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
      /* Clear list of identified and reported events */
      {
        uint16 lIter;
        uint16 lIterEnd;

        lIterEnd = DEM_DCM_FILTER_CALC_MARKER_SIZE(Dem_Cfg_GlobalEventCount());

        for(lIter = 0; lIter < lIterEnd; lIter++)
        {
          Dem_Dcm_FilterSetReportedEvents(lIter, 0 );
        }
      }
# endif

      /* Dispatch the Event target */
      switch (DTCOrigin)
      {
      case DEM_DTC_ORIGIN_PRIMARY_MEMORY:
        Dem_Dcm_FilterDtcSetMemoryId(DEM_CFG_MEMORYID_PRIMARY);
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
        if ( (DTCStatusMask == 0x04)
          || (DTCStatusMask == 0x08)
          || (DTCStatusMask == 0x0C) )
        { /* reporting shall be in chronological order */
          Dem_Dcm_FilterDtcSetEventIndex(DEM_EVENT_INVALID);
          Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterMemoryChrono);
        }
        else
# endif
        { /* report by event id, set first event index */
          Dem_Dcm_FilterDtcSetEventIndex(Dem_Cfg_GlobalPrimaryFirst());
          Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterMemoryByEvent);
        }
        break;

# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
      case DEM_DTC_ORIGIN_SECONDARY_MEMORY:
        Dem_Dcm_FilterDtcSetMemoryId(DEM_CFG_MEMORYID_SECONDARY);
#  if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
        if ( (DTCStatusMask == 0x04)
          || (DTCStatusMask == 0x08)
          || (DTCStatusMask == 0x0C) )
        { /* reporting shall be in chronological order */
          Dem_Dcm_FilterDtcSetEventIndex(DEM_EVENT_INVALID);
          Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterMemoryChrono);
        }
        else
#  endif
        { /* report by event id, set first event index */
          Dem_Dcm_FilterDtcSetEventIndex(Dem_Cfg_GlobalSecondaryFirst());
          Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterMemoryByEvent);
        }
        break;
# endif

      default:
        lReturnValue = DEM_WRONG_FILTER;
        break;
      }

      /* Check if filter shall ignore Dtc status or not */
      if (DTCStatusMask == 0x00)
      { /* status mask shall be ignored */
        lFilterCriteria = DEM_DCM_RESET_FILTER_USESTATUSMASK(lFilterCriteria);
      }
      else
      { /* status mask shall be taken into account, "AND" status mask with status availability mask */
        Dem_Dcm_FilterDtcSetStatusMask((uint8)(DTCStatusMask & Dem_Cfg_GlobalStatusMask()));
        lFilterCriteria = DEM_DCM_SET_FILTER_USESTATUSMASK(lFilterCriteria);
      }

      /* Check if filter shall use severity */
      if (DEM_FILTER_WITH_SEVERITY_YES == FilterWithSeverity)
      {
# if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
        lFilterCriteria = DEM_DCM_SET_FILTER_USESEVERITY(lFilterCriteria);
        Dem_Dcm_FilterDtcSetSeverityMask(DTCSeverityMask & Dem_Cfg_GlobalSeverityMask());
# else
        lReturnValue = DEM_WRONG_FILTER;
# endif
      }
      else
      {
        lFilterCriteria = DEM_DCM_RESET_FILTER_USESEVERITY(lFilterCriteria);
      }

      /* Check if filter shall use fault detection counter */
      if (DEM_FILTER_FOR_FDC_YES == FilterForFaultDetectionCounter)
      {
        lFilterCriteria = DEM_DCM_SET_FILTER_USEFDC(lFilterCriteria);
      }
      else
      {
        lFilterCriteria = DEM_DCM_RESET_FILTER_USEFDC(lFilterCriteria);
      }

      Dem_Dcm_FilterSetCriteria(lFilterCriteria);
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMSETDTCFILTER_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6060, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STPAR, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmSetFreezeFrameRecordFilter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnSetFilterType, DEM_CODE)
Dem_DcmSetFreezeFrameRecordFilter(
  Dem_DTCFormatType  DTCFormat,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  NumberOfFilteredRecords
  )
{
  Dem_ReturnSetFilterType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)                                                       /* COV_MSR_UNSUPPORTED TX tx tf */
  lReturnValue = DEM_WRONG_FILTER;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((DEM_DTC_FORMAT_UDS != DTCFormat) && (DEM_DTC_FORMAT_OBD != DTCFormat))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == NumberOfFilteredRecords)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)
    uint8 lFilterCriteria;

    lFilterCriteria = 0;
    if (DEM_DTC_FORMAT_OBD != DTCFormat)
    { /* Set filter for output format of DTCs to UDS */
      lFilterCriteria = DEM_DCM_RESET_FILTER_DTCFORMAT_OBD(lFilterCriteria);
      lReturnValue = DEM_FILTER_ACCEPTED;
    }

    if (DEM_FILTER_ACCEPTED == lReturnValue)
    {
      Dem_Mem_MemoryInfoPtrType lMemoryInfo;
      Dem_Cfg_MemoryIndexType lFirstIndex;
      uint16 lRecordCount;

      /* Count stored snapshot records in primary memory to prevent concurrent modification
         of the chrono index to have an effect on the iteration */
      lMemoryInfo = Dem_Mem_MemoryInfoInit(DEM_CFG_MEMORYID_PRIMARY);
      lFirstIndex = Dem_Mem_MemoryIter_Begin(lMemoryInfo);                                                                       /* SBSW_DEM_CALL_MEMORYINFO_POINTER */

      lRecordCount = Dem_Dcm_GetNumberOfSRec();

      Dem_Dcm_FilterSetCriteria(lFilterCriteria);
      Dem_Dcm_FilterRecordSetMemIndex(lFirstIndex);
      Dem_Dcm_FilterRecordSetSRecIndex(0);

      *NumberOfFilteredRecords = lRecordCount;                                                                                   /* SBSW_DEM_POINTER_WRITE_API */
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTCFormat)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    *NumberOfFilteredRecords = 0;                                                                                                /* SBSW_DEM_POINTER_WRITE_API */

    lReturnValue = DEM_FILTER_ACCEPTED;
# endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMSETFREEZEFRAMERECORDFILTER_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNumberOfFilteredDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetNumberOfFilteredDTCType, DEM_CODE)
Dem_DcmGetNumberOfFilteredDTC(
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  NumberOfFilteredDTC
  )
{
  Dem_ReturnGetNumberOfFilteredDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_NUMBER_FAILED;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == NumberOfFilteredDTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    /* get relevant event range dependent on the origin */
    switch (Dem_Dcm_FilterDtcGetMemoryId())
    {
    case DEM_CFG_MEMORYID_PRIMARY:
      *NumberOfFilteredDTC = Dem_Dcm_FilterNumberMemory();                                                                       /* SBSW_DEM_POINTER_WRITE_API */
      lReturnValue = DEM_NUMBER_OK;
      break;
# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
    case DEM_CFG_MEMORYID_SECONDARY:
      *NumberOfFilteredDTC = Dem_Dcm_FilterNumberMemory();                                                                       /* SBSW_DEM_POINTER_WRITE_API */
      lReturnValue = DEM_NUMBER_OK;
      break;
# endif
    default:
      break;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNUMBEROFFILTEREDDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNextFilteredDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE)
Dem_DcmGetNextFilteredDTC(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCStatus
  )
{
  Dem_ReturnGetNextFilteredElementType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_FILTERED_NO_MATCHING_ELEMENT;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Dem_Dcm_FilterDtcGetFunctionPtr())
  { /* Invalid state - call SetDTCFilter before calling this function */
    Dem_Det_ErrorRegisterSet(DEM_E_INCONSISTENT_STATE)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_EventIdType lEventId;

# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if ( (Dem_Dcm_FilterDtcGetFunctionPtr() != &Dem_Dcm_FilterMemoryByEvent)
#  if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
      && (Dem_Dcm_FilterDtcGetFunctionPtr() != &Dem_Dcm_FilterMemoryChrono)
#  endif
#  if (DEM_CFG_SUPPORT_OBDII == STD_ON)
      && (Dem_Dcm_FilterDtcGetFunctionPtr() != &Dem_Dcm_FilterPermanentByEvent)
#  endif
      )
    {
      Dem_RunTimeCheckFailed(__LINE__);
      lEventId = DEM_EVENT_INVALID;
    }
    else
# endif
    {
      lEventId = (*Dem_Dcm_FilterDtcGetFunctionPtr())(Dem_Mem_MemoryInfoInit(Dem_Dcm_FilterDtcGetMemoryId()));                   /* SBSW_DEM_CALL_DTCFILTER_FPTR */
    }

    if (lEventId != DEM_EVENT_INVALID)
    { /* Get return values only if valid EventId was returned */
      uint8 lEventStatus;
      { /* Only EventIds with a valid DTC number are processed here, so the EventId->DTC mapping will return always a valid DTC number */
        *DTC = Dem_Cfg_EventUdsDtc(lEventId);                                                                                    /* SBSW_DEM_POINTER_WRITE_API */
      }

      lEventStatus = Dem_Util_DtcApplyExternalOnlyStatus(lEventId, Dem_Util_DtcGetStatus(lEventId));

      /* apply status availability mask */
      *DTCStatus = (uint8)(lEventStatus & Dem_Cfg_GlobalStatusMask());                                                           /* SBSW_DEM_POINTER_WRITE_API */

      lReturnValue = DEM_FILTERED_OK;
    }
    /* else: No more matching DTCs */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNEXTFILTEREDDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetDTCByOccurrenceTime
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetDTCByOccurrenceTimeType, DEM_CODE)
Dem_DcmGetDTCByOccurrenceTime(
  Dem_DTCRequestType  DTCRequest,
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC
  )
{
  Dem_ReturnGetDTCByOccurrenceTimeType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_OCCURR_NOT_AVAILABLE;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_MOST_REC_DET_CONFIRMED_DTC < DTCRequest)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    Dem_EventIdType lEventId;

    /* ----- Implementation ------------------------------------------------ */
    lEventId = DEM_EVENT_INVALID;

    switch (DTCRequest)
    {
    case DEM_FIRST_FAILED_DTC:
      lEventId = Dem_Mem_GetFirstFailedEvent();
      break;
    case DEM_MOST_RECENT_FAILED_DTC:
      lEventId = Dem_Mem_GetMostRecentFailedEvent();
      break;
    case DEM_FIRST_DET_CONFIRMED_DTC:
      lEventId = Dem_Mem_GetFirstConfirmedEvent();
      break;
    case DEM_MOST_REC_DET_CONFIRMED_DTC:
      lEventId = Dem_Mem_GetMostRecentConfmdEvent();
      break;
    default:
      break;
    }

    if (lEventId != DEM_EVENT_INVALID)
    { /* Only EventIds with a valid DTC number should be stored in, so the EventId->DTC mapping will return always a valid DTC number */
      {
        *DTC = Dem_Cfg_EventUdsDtc(lEventId);                                                                                    /* SBSW_DEM_POINTER_WRITE_API */
        lReturnValue = DEM_OCCURR_OK;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETDTCBYOCCURRENCETIME_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNextFilteredRecord
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE)
Dem_DcmGetNextFilteredRecord(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,                                                                                   /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  RecordNumber                                                                            /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetNextFilteredElementType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_FILTERED_NO_MATCHING_ELEMENT;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == RecordNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON)
    if (Dem_Dcm_FilterSRec(DTC, RecordNumber) == TRUE)                                                                           /* SBSW_DEM_POINTER_FORWARD_API */
    {
      lReturnValue = DEM_FILTERED_OK;
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
# endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNEXTFILTEREDRECORD_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 2006, 6030, 6080 */ /* MD_DEM_14.7, MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNextFilteredDTCAndFDC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE)
Dem_DcmGetNextFilteredDTCAndFDC(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,
  P2VAR(sint8, AUTOMATIC, DEM_DCM_DATA)  DTCFaultDetectionCounter
  )
{
  Dem_ReturnGetNextFilteredElementType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_FILTERED_NO_MATCHING_ELEMENT;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCFaultDetectionCounter)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Dem_Dcm_FilterDtcGetFunctionPtr())
  {  /* Invalid state - call SetDTCFilter before calling this function */
    Dem_Det_ErrorRegisterSet(DEM_E_INCONSISTENT_STATE)
  }
  else
# endif
  {
    Dem_EventIdType lEventId;
    uint8 lRepeatProcessing;

    /* ----- Implementation ------------------------------------------------ */
    do
    {
      lRepeatProcessing = FALSE;

# if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
      if ( (Dem_Dcm_FilterDtcGetFunctionPtr() != &Dem_Dcm_FilterMemoryByEvent)
#  if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
        && (Dem_Dcm_FilterDtcGetFunctionPtr() != &Dem_Dcm_FilterMemoryChrono)
#  endif
        )
      {
        Dem_RunTimeCheckFailed(__LINE__);
        lEventId = DEM_EVENT_INVALID;
      }
      else
# endif
      {
        lEventId = (*Dem_Dcm_FilterDtcGetFunctionPtr())(Dem_Mem_MemoryInfoInit(Dem_Dcm_FilterDtcGetMemoryId()));                 /* SBSW_DEM_CALL_DTCFILTER_FPTR */
      }

      if (lEventId != DEM_EVENT_INVALID)
      { /* Get return values only if valid EventId was returned */
        uint8 lFilterCriteria;

        lFilterCriteria = Dem_Dcm_FilterGetCriteria();

        { /* Only EventIds with a valid DTC number are processed here, so the EventId->DTC mapping will return always a valid DTC number */
          *DTC = Dem_Cfg_EventUdsDtc(lEventId);                                                                                  /* SBSW_DEM_POINTER_WRITE_API */
        }

        if (FALSE != DEM_DCM_TEST_FILTER_USEFDC(lFilterCriteria))
        { /* FDC was already calculated during filtering */
          *DTCFaultDetectionCounter = Dem_Dcm_FilterDtcGetFdc();                                                                 /* SBSW_DEM_POINTER_WRITE_API */
          lReturnValue = DEM_FILTERED_OK;
        }
        else
        { /* Calculate FDC if filter criteria does not take FDC into account */

          Std_ReturnType lGetFdcReturnValue;
          sint8 lFdc;

          lGetFdcReturnValue = Dem_Util_DtcGetFaultDetectionCounter(lEventId, &lFdc);                                            /* SBSW_DEM_POINTER_FORWARD_STACK */

          if (lGetFdcReturnValue == E_OK)
          {
            *DTCFaultDetectionCounter = lFdc;                                                                                    /* SBSW_DEM_POINTER_WRITE_API */
            lReturnValue = DEM_FILTERED_OK;
          }
          else
          {
            /* no valid FDC, continue processing */
            lRepeatProcessing = TRUE;
          }
        }
      }
    } while (lRepeatProcessing != FALSE);
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNEXTFILTEREDDTCANDFDC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNextFilteredDTCAndSeverity
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE)
Dem_DcmGetNextFilteredDTCAndSeverity(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,                                                                                   /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCStatus,                                                                              /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(Dem_DTCSeverityType, AUTOMATIC, DEM_DCM_DATA)  DTCSeverity,                                                              /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCFunctionalUnit                                                                       /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetNextFilteredElementType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_FILTERED_NO_MATCHING_ELEMENT;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCSeverity)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCFunctionalUnit)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Dem_Dcm_FilterDtcGetFunctionPtr())
  {  /* Invalid state - call SetDTCFilter before calling this function */
    Dem_Det_ErrorRegisterSet(DEM_E_INCONSISTENT_STATE)
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
    Dem_EventIdType                      lEventId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
#  if (DEM_DEV_RUNTIME_CHECKS == STD_ON)
    if ( (Dem_Dcm_FilterDtcGetFunctionPtr() != &Dem_Dcm_FilterMemoryByEvent)
#   if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
      && (Dem_Dcm_FilterDtcGetFunctionPtr() != &Dem_Dcm_FilterMemoryChrono)
#   endif
      )
    {
      Dem_RunTimeCheckFailed(__LINE__);
      lEventId = DEM_EVENT_INVALID;
    }
    else
#  endif
    {
      lEventId = (*Dem_Dcm_FilterDtcGetFunctionPtr())(Dem_Mem_MemoryInfoInit(Dem_Dcm_FilterDtcGetMemoryId()));                   /* SBSW_DEM_CALL_DTCFILTER_FPTR */
    }

    if (lEventId != DEM_EVENT_INVALID)
    { /* Get return values only if valid EventId was returned */
      uint8 lEventStatus;
      { /* Only EventIds with a valid DTC number should be processed here, so the EventId->DTC mapping will return always a valid DTC number */
        *DTC = Dem_Cfg_EventUdsDtc(lEventId);                                                                                    /* SBSW_DEM_POINTER_WRITE_API */
      }

      lEventStatus = Dem_Util_DtcApplyExternalOnlyStatus(lEventId, Dem_Util_DtcGetStatus(lEventId));

      /* apply status availability mask */
      *DTCStatus = (uint8)(lEventStatus & Dem_Cfg_GlobalStatusMask());                                                           /* SBSW_DEM_POINTER_WRITE_API */

      *DTCSeverity       = Dem_Cfg_EventSeverity(lEventId);                                                                      /* SBSW_DEM_POINTER_WRITE_API */
      *DTCFunctionalUnit = Dem_Cfg_EventFunctionalUnit(lEventId);                                                                /* SBSW_DEM_POINTER_WRITE_API */

      lReturnValue = DEM_FILTERED_OK;
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCStatus)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCSeverity)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCFunctionalUnit)                                                                                /* PRQA S 3112 */ /* MD_DEM_14.2 */
# endif
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNEXTFILTEREDDTCANDSEVERITY_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif
                                            /* Dcm <-> Dem : data protection */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmDisableDTCRecordUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnDisableDTCRecordUpdateType, DEM_CODE)
Dem_DcmDisableDTCRecordUpdate(
  uint32  DTC,
  Dem_DTCOriginType  DTCOrigin
  )
{
  Dem_ReturnDisableDTCRecordUpdateType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_DISABLE_DTCRECUP_PENDING;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_DISABLE_DTCRECUP_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN;
  }
  else
# endif
  {
    Dem_EventIdType lEventId;
    uint8 lMemoryId;

    /* ----- Implementation ------------------------------------------------ */
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);                                                      /* SBSW_DEM_POINTER_FORWARD_STACK */
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_DISABLE_DTCRECUP_WRONG_DTC;
    }
    else
    {
      if ( (Dem_Dcm_FilterDataGetEventId() == lEventId)
        && (Dem_Dcm_FilterDataGetMemoryId() == lMemoryId))
      {
        if (DEM_DCM_FILTERDATA_READY == Dem_Dcm_FilterDataGetState())
        {
          lReturnValue = DEM_DISABLE_DTCRECUP_OK;
        }
        else
        {
          /* Polling call - return PENDING already set */
        }
      }
      else
      {
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
        if (DEM_DCM_FILTERDATA_READY == Dem_Dcm_FilterDataGetState())
        {
          Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
          (void)Dem_DcmEnableDTCRecordUpdate();
        }
# endif
      }

      if (DEM_DCM_FILTERDATA_IDLE == Dem_Dcm_FilterDataGetState())
      {
        Dem_Dcm_FilterDataSetEventId(lEventId);
        Dem_Dcm_FilterDataSetMemoryId(lMemoryId);
        Dem_Dcm_FilterDataSetState(DEM_DCM_FILTERDATA_PENDING);
        /* return PENDING already set */
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMDISABLEDTCRECORDUPDATE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmEnableDTCRecordUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DcmEnableDTCRecordUpdate(
  void
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (DEM_DCM_FILTERDATA_READY == Dem_Dcm_FilterDataGetState())
    {
      Dem_Dcm_FilterDataSetState(DEM_DCM_FILTERDATA_IDLE);
      Dem_Dcm_FilterDataSetEventId(DEM_EVENT_INVALID);

      lReturnValue = E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMENABLEDTCRECORDUPDATE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif
                                                   /* Dcm <-> Dem : DTC data */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetOBDFreezeFrameData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DcmGetOBDFreezeFrameData(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,                                                                                   /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  BufSize                                                                                /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

    /* ----- Implementation ------------------------------------------------ */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETOBDFREEZEFRAMEDATA_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetFreezeFrameDataByDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetFreezeFrameDataByDTCType, DEM_CODE)
Dem_DcmGetFreezeFrameDataByDTC(
  uint32  DTC,                                                                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  RecordNumber,                                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  BufSize                                                                                /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetFreezeFrameDataByDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTCORIGIN;
  }
  else
  if (0xffU == RecordNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
  }
  else
  if (DEM_DCM_FILTERDATA_READY != Dem_Dcm_FilterDataGetState())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_SRECS == STD_ON) \
  || ((DEM_CFG_SUPPORT_OBDII == STD_ON) && (DEM_CFG_SUPPORT_OBDII_FREEZEFRAME_IN_SVC19 == STD_ON)) \
  || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
  || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON)
    Dem_EventIdType lEventId;
    uint8 lMemoryId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON) \
    || ((DEM_CFG_SUPPORT_OBDII == STD_ON) && (DEM_CFG_SUPPORT_OBDII_FREEZEFRAME_IN_SVC19 == STD_ON)) \
    || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
    || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON)
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);                                                      /* SBSW_DEM_POINTER_FORWARD_STACK */
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
    }
    else
#  if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED TX */
    if ((lEventId != Dem_Dcm_FilterDataGetEventId()) && (DEM_EVENT_INVALID != Dem_Dcm_FilterDataGetEventId()))
    {
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
    }
    else
#  endif
    if (RecordNumber == 0x00)
    {
      {
        lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
      }
    }
    else
    {
#  if (DEM_CFG_SUPPORT_SRECS == STD_ON)                                                                                          /* COV_MSR_UNSUPPORTED TX */
      lReturnValue = Dem_Dcm_CopySRec(lEventId, RecordNumber, DestBuffer, BufSize);                                              /* SBSW_DEM_POINTER_FORWARD_API */
#  else
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
#  endif
    }

# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCOrigin)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
# endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETFREEZEFRAMEDATABYDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetSizeOfFreezeFrameByDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_DcmGetSizeOfFreezeFrameByDTC(
  uint32  DTC,                                                                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  RecordNumber,                                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  SizeOfFreezeFrame                                                                      /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetSizeOfDataByDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
  }
  else
  if (NULL_PTR == SizeOfFreezeFrame)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
  if (DEM_DCM_FILTERDATA_READY != Dem_Dcm_FilterDataGetState())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
# endif
  {
# if ( (DEM_CFG_SUPPORT_SRECS == STD_ON) \
    || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
    || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
    || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON))
    Dem_EventIdType lEventId;
    uint8 lMemoryId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if ( (DEM_CFG_SUPPORT_SRECS == STD_ON) \
    || (DEM_CFG_SUPPORT_OBDII == STD_ON) \
    || (DEM_CFG_SUPPORT_WWHOBD == STD_ON) \
    || (DEM_FEATURE_NEED_TIME_SERIES == STD_ON))
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);                                                      /* SBSW_DEM_POINTER_FORWARD_STACK */
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
    }
    else
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
    if ((lEventId != Dem_Dcm_FilterDataGetEventId()) && (DEM_EVENT_INVALID != Dem_Dcm_FilterDataGetEventId()))
    {
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
    }
    else
# endif
    if (RecordNumber == 0x00)
    {
      {
        lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
      }
    }
    else

    {
      lReturnValue = Dem_Dcm_GetSizeOfSRec(lEventId, RecordNumber, SizeOfFreezeFrame);                                           /* SBSW_DEM_POINTER_FORWARD_API */
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCOrigin)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(SizeOfFreezeFrame)                                                                                /* PRQA S 3112 */ /* MD_DEM_14.2 */

    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
# endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETSIZEOFFREEZEFRAMEBYDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetExtendedDataRecordByDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetExtendedDataRecordByDTCType, DEM_CODE)
Dem_DcmGetExtendedDataRecordByDTC(
  uint32  DTC,                                                                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  ExtendedDataNumber,                                                                                                     /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  BufSize                                                                                /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetExtendedDataRecordByDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_RECORD_WRONG_DTCORIGIN;
  }
  else
  if (0xfeU <= ExtendedDataNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
  if (DEM_DCM_FILTERDATA_READY != Dem_Dcm_FilterDataGetState())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_ERECS == STD_ON)
    Dem_EventIdType lEventId;
    uint8 lMemoryId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_ERECS == STD_ON)
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);                                                      /* SBSW_DEM_POINTER_FORWARD_STACK */
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_RECORD_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_RECORD_WRONG_DTC;
    }
    else
    if ((ExtendedDataNumber == 0x00U) || (ExtendedDataNumber >= 0xf0U))
    {
      lReturnValue = DEM_RECORD_WRONG_NUMBER;
    }
    else
#  if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED TX */
    if ((lEventId != Dem_Dcm_FilterDataGetEventId()) && (DEM_EVENT_INVALID != Dem_Dcm_FilterDataGetEventId()))
    {
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
      lReturnValue = DEM_RECORD_WRONG_DTC;
    }
    else
#  endif
    {
      lReturnValue = Dem_Dcm_CopyERec(lEventId, ExtendedDataNumber, DestBuffer, BufSize);                                        /* SBSW_DEM_POINTER_FORWARD_API */
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCOrigin)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(ExtendedDataNumber)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

    lReturnValue = DEM_RECORD_WRONG_NUMBER;
# endif /* if (DEM_CFG_SUPPORT_ERECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETEXTENDEDDATARECORDBYDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetSizeOfExtendedDataRecordByDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_DcmGetSizeOfExtendedDataRecordByDTC(
  uint32  DTC,                                                                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  ExtendedDataNumber,                                                                                                     /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  SizeOfExtendedDataRecord                                                               /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetSizeOfDataByDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
  }
  else
  if (NULL_PTR == SizeOfExtendedDataRecord)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
  if (DEM_DCM_FILTERDATA_READY != Dem_Dcm_FilterDataGetState())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_ERECS == STD_ON)
    Dem_EventIdType lEventId;
    uint8 lMemoryId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_ERECS == STD_ON)
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);                                                      /* SBSW_DEM_POINTER_FORWARD_STACK */
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
    }
    else
    if ( (ExtendedDataNumber == 0x00U)
      || ( (ExtendedDataNumber >= 0xf0U)
        && (ExtendedDataNumber <= 0xfeU)
       ) )
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
    }
    else
#  if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                           /* COV_MSR_UNSUPPORTED TX */
    if ((lEventId != Dem_Dcm_FilterDataGetEventId()) && (DEM_EVENT_INVALID != Dem_Dcm_FilterDataGetEventId()))
    {
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
    }
    else
#  endif
    {
      lReturnValue = Dem_Dcm_GetSizeOfERec(lEventId, ExtendedDataNumber, SizeOfExtendedDataRecord);                              /* SBSW_DEM_POINTER_FORWARD_API */
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCOrigin)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(ExtendedDataNumber)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(SizeOfExtendedDataRecord)                                                                         /* PRQA S 3112 */ /* MD_DEM_14.2 */

    lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
# endif /* if (DEM_CFG_SUPPORT_ERECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETSIZEOFEXTENDEDDATARECORDBYDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif
                                                  /* Dcm <-> Dem : Clear DTC */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmClearDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_DcmClearDTC(
  uint32  DTC,
  Dem_DTCFormatType  DTCFormat,
  Dem_DTCOriginType  DTCOrigin
  )
{
  Dem_ReturnClearDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_CLEAR_FAILED;
  }
  else
  if ((DEM_DTC_FORMAT_UDS != DTCFormat) && (DEM_DTC_FORMAT_OBD != DTCFormat))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_CLEAR_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
  }
  else
# endif
  {
    Dem_Queue_ClearRequestType lClearRequest;

    /* ----- Implementation ------------------------------------------------ */
    lClearRequest.ClearFormat = DTCFormat;
    lClearRequest.ClearMemoryId = Dem_Dcm_MemoryIdFromOrigin(DTCOrigin);
    lClearRequest.ClearClient = DEM_DCM_CLIENT_DCM;

    lReturnValue = Dem_Dcm_ClearDtc_Internal(DTC, &lClearRequest);                                                               /* SBSW_DEM_POINTER_FORWARD_STACK */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMCLEARDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif
                                       /* Dcm <-> Dem : Control DTC Settings */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmDisableDTCSetting
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnControlDTCSettingType, DEM_CODE)
Dem_DcmDisableDTCSetting(
  Dem_DTCGroupType DTCGroup,
  Dem_DTCKindType  DTCKind
  )
{
  Dem_ReturnControlDTCSettingType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_CONTROL_DTC_SETTING_N_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_KIND_INVALID <= DTCKind)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ((DEM_DTC_GROUP_ALL_DTCS == DTCGroup) && (DEM_DTC_KIND_ALL_DTCS == DTCKind))
    {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
      Dem_EnterCritical_StateManager();                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */

# if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = DEM_ESM_RESET_ENABLECONDITION(Dem_NextEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING);
# endif
      Dem_CurrentEnableConditionStates = DEM_ESM_RESET_ENABLECONDITION(Dem_CurrentEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING);

      Dem_LeaveCritical_StateManager();                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

      if (Dem_Cfg_GlobalCbkControlDtcSetting() != NULL_PTR)
      {
        (void)(Dem_Cfg_GlobalCbkControlDtcSetting()(FALSE));                                                                     /* SBSW_DEM_GLOBALCBKCONTROLDTCSETTING_FPTR */
      }

      lReturnValue = DEM_CONTROL_DTC_SETTING_OK;
    }
    else
    {
      lReturnValue = DEM_CONTROL_DTC_WRONG_DTCGROUP;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMDISABLEDTCSETTING_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmEnableDTCSetting
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Dem_ReturnControlDTCSettingType, DEM_CODE)
Dem_DcmEnableDTCSetting(
  Dem_DTCGroupType  DTCGroup,
  Dem_DTCKindType  DTCKind
  )
{
  Dem_ReturnControlDTCSettingType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_CONTROL_DTC_SETTING_N_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_KIND_INVALID <= DTCKind)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ((DEM_DTC_GROUP_ALL_DTCS == DTCGroup) && (DEM_DTC_KIND_ALL_DTCS == DTCKind))
    {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
      Dem_EnterCritical_StateManager();                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */

# if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = DEM_ESM_SET_ENABLECONDITION(Dem_NextEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING);
# else
      Dem_CurrentEnableConditionStates = DEM_ESM_SET_ENABLECONDITION(Dem_CurrentEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING);
# endif

      Dem_LeaveCritical_StateManager();                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */
      if (Dem_Cfg_GlobalCbkControlDtcSetting() != NULL_PTR)
      {
        (void)(Dem_Cfg_GlobalCbkControlDtcSetting()(TRUE));                                                                      /* SBSW_DEM_GLOBALCBKCONTROLDTCSETTING_FPTR */
      }

      lReturnValue = DEM_CONTROL_DTC_SETTING_OK;
    }
    else
    {
      lReturnValue = DEM_CONTROL_DTC_WRONG_DTCGROUP;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMENABLEDTCSETTING_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

                                   /* Dcm <-> Dem : Control DTC Notification */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmControlDTCStatusChangedNotification
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_DcmControlDTCStatusChangedNotification(
  boolean TriggerNotification                                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

#if (DEM_CFG_NOTIFY_DCM == STD_ON)
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)
#endif
  DEM_IGNORE_UNUSED_ARGUMENT(TriggerNotification)                                                                                /* PRQA S 3112 */ /* MD_DEM_14.2 */

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (TriggerNotification > TRUE)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_NOTIFY_DCM == STD_ON)
    Dem_Dcm_SetNotificationState(TriggerNotification);
# else
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_CONFIG)
# endif
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
# if (DEM_CFG_NOTIFY_DCM == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
# endif
  {
    Dem_Det_ReportError(DEM_DCMCONTROLDTCSTATUSCHANGEDNOTIFICATION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif
}
#endif

                                                   /* Dcm <-> Dem : OBD VIDs */
/* ------------------------------------------------------------------------- */
                                                   /* Dcm <-> Dem : OBD PIDs */
/* ------------------------------------------------------------------------- */
                                           /* Dcm <-> Dem : Cancel Operation */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmCancelOperation
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_DcmCancelOperation(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    uint8 lClearState;

    /* ----- Implementation ------------------------------------------------ */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
    Dem_EnterCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lClearState = Dem_Queue_GetClearState();
    if (DEM_QUEUE_CLEARSTATE_IDLE != lClearState)
    { /* clear is currently in progress */
      Dem_Queue_SetClearState(DEM_QUEUE_SETCLEARSTATE_CANCEL(lClearState));
    }

    if (DEM_DCM_FILTERDATA_IDLE != Dem_Dcm_FilterDataGetState())
    {
      Dem_Dcm_FilterSetCancelled();
    }

    Dem_LeaveCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DcmApi */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMCANCELOPERATION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif
}
#endif

                                             /* Permanent Storage Activation */
/* ------------------------------------------------------------------------- */
                                                               /* B1 Counter */
/* ------------------------------------------------------------------------- */
                                                                 /* PID Data */
/* ------------------------------------------------------------------------- */
                                                    /* Interface Dlt <-> Dem */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DLT == STD_ON)                                                                                              /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_DltGetMostRecentFreezeFrameRecordData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DltGetMostRecentFreezeFrameRecordData(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_DLT_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DLT_DATA)  BufSize                                                                                 /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((DEM_EVENT_INVALID == EventId) || (Dem_Cfg_GlobalEventCount() <= EventId))                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DLTGETMOSTRECENTFREEZEFRAMERECORDDATA_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_DLT == STD_ON)                                                                                              /* COV_MSR_UNSUPPORTED XF */
/* ****************************************************************************
 % Dem_DltGetAllExtendedDataRecords
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DltGetAllExtendedDataRecords(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_DLT_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DLT_DATA)  BufSize                                                                                 /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((DEM_EVENT_INVALID == EventId) || (Dem_Cfg_GlobalEventCount() <= EventId))                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DLTGETALLEXTENDEDDATARECORDS_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

                                                     /* Extension to Autosar */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_PostRunRequested
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_PostRunRequested(
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  IsRequested
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
#endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                             /* COV_MSR_UNSUPPORTED TX */
  if (NULL_PTR == IsRequested)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
    if ( (Dem_InitState == DEM_INIT_INITIALIZED)                                                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
      && (Dem_Nvm_CommitData.WriteState == DEM_NVM_COMMIT_WRITING)
      && (Dem_Nvm_GetBlockState(Dem_Nvm_CommitData.MemoryIndex) != DEM_NVM_BLOCKSTATE_UNMODIFIED) )
    { /* Currently waiting for NvM JobResult, and the same block is still in the process
         of committing a previous data set - we are not allowed to mark this block using
         NvM_SetRamBlockStatus -> return TRUE to request more time untile the situation
         has resulved itself */
      *IsRequested = TRUE;                                                                                                       /* SBSW_DEM_POINTER_WRITE_API */
    }
    else
    {
      *IsRequested = FALSE;                                                                                                      /* SBSW_DEM_POINTER_WRITE_API */
    }
    lReturnValue = E_OK;
#else
  /* No immediate Nv-Write is supported, always return false */
    *IsRequested = FALSE;                                                                                                        /* SBSW_DEM_POINTER_WRITE_API */
    lReturnValue = E_OK;
#endif
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_POSTRUNREQUESTED_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}

#if (DEM_CFG_SUPPORT_NVM_APPL_SYNCHRONIZE == STD_ON)
/* ****************************************************************************
 % Dem_RequestNvSynchronization
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_RequestNvSynchronization(
  void
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_DEV_ERROR_DETECT == STD_ON)                                                                                            /* COV_MSR_UNSUPPORTED TX */
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_USE_NVM == STD_ON)
    Dem_Nvm_SynchronizationRequest = TRUE;
    lReturnValue = E_OK;
# else
    lReturnValue = E_NOT_OK;
# endif
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_DEV_ERROR_REPORT == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_REQUESTNVSYNCHRONIZATION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Cfg_EventUdsDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(uint32, DEM_CODE)
Dem_Cfg_EventUdsDtc(
  Dem_EventIdType EventId
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */
#if (DEM_CFG_VARIANT_POSTBUILD_LOADABLE == STD_ON)
  return Dem_Cfg_GetUdsDtcOfDtcNumberTable(Dem_Cfg_GetDtcNumberTableIdxOfEventTable(EventId));
#else
  return Dem_Cfg_GetUdsDtcOfDtcTable(Dem_Cfg_GetDtcTableIdxOfEventTable(EventId));
#endif
}

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* module specific MISRA deviations:

   MD_DEM_1.1_612
     Description: Rule 1.1
                  All code shall conform to ISO 9899:1990 C programming language, ISO 9899, amended and corrected by
                  ISO/IEC 9899/COR1:1995, ISO/IEC 9899/AMD1:1995, and ISO/IEC 9899/COR2: 1996
     Reason:      Depending on the configuration size the generated tables can
                  exceed the C90 limit of 32767 bytes
     Risk:        Compilation error.
     Prevention:  Compiler compatibility must be tested during integration.

   MD_DEM_5.1:
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      Names result from naming scheme. The maintenance benefit is deemed higher than the risk of compiler
                  issues.
     Risk:        Compilation errors are possible.
     Prevention:  Compiler compatibility is tested during integration.

   MD_DEM_5.1_API
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      The API is standardized and a change would break compliance.
     Risk:        Compilation errors are possible.
     Prevention:  Compiler compatibility is tested during integration.

   MD_DEM_8.7:
     Description: Rule 8.7
                  Objects shall be defined at block scope if they are only accessed from within a single function.
     Reason:      Vector style guide prevents usage of static variables in function scope
     Risk:        None.
     Prevention:  None.

   MD_DEM_8.8_dcm:
     Description: Rule 8.8
                  An external object or function shall be declared in one and only one file.
     Reason:      MICROSAR Dcm generates all prototypes of functions used. This leads to duplicate definitions.
     Risk:        None.
     Prevention:  None.

   MD_DEM_11.1:
     Decription:  Rule 11.1
                  Conversions shall not be performed between a pointer to a function and any type other than an integral type.
     Reason:      Different types of callback functions need to be supported through a generic mechanism
     Risk:        Functions are cast to the wrong type before calling.
     Prevention:  The correct function type is indicated by type tagging. The correct cast is verified during code review.

   MD_DEM_11.4_cpy:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object
                  type.
     Reason:      Use of memcopy requires common pointer type.
     Risk:        Data corruption due to miscast.
     Prevention:  Covered by descriptive pointer types and code review for correct usage.

   MD_DEM_11.4_nvm:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object
                  type.
     Reason:      Mechanism for Nv handling requires common pointer type
     Risk:        None. Pointers are initially aligned and only cast due to common API later on.
     Prevention:  Covered by descriptive pointer types and code review for correct usage.

   MD_DEM_11.5:
     Description: Rule 11.5
                  A cast shall not be performed that removes any const or volatile qualification from the type
                  addressed by a pointer.
     Reason:      MemSet and MemCpy are defined as taking an unqualified pointer.
     Risk:        None.
     Prevention:  Safe access of shared data is verified during code review.

   MD_DEM_12.4_cs:
     Description: Rule 12.4
                  The right hand operand of a logical && or || operator shall not contain side effects
     Reason:      The function must be called in a critical section, so the access to volatile variables does not
                  apply as side effect.
     Risk:        Additional calls might be introduces later outside the critical section.
     Prevention:  Requirement for critical section is documented and compliance is assured during code review.

   MD_DEM_12.4_cf:
     Description: Rule 12.4
                  The right hand operand of a logical && or || operator shall not contain side effects
     Reason:      The function called on the right hand side has no side effects.
     Risk:        The function may introduce side effects at a later time.
     Prevention:  Code analysis (e.g. MISRA).

   MD_DEM_12.4_m:
     Description: Rule 12.4
                  The right hand operand of a logical && or || operator shall not contain side effects
     Reason:      The right hand operand may only be evaluated if the left hand operator is valid. This is more
                  maintainable than introducing additional levels of nesting, since nesting does reduce readibility
                  and does not reduce the risk of missing the order dependency of the two terms.
     Risk:        Later rework might miss the dependency and turn the order of checks around.
     Prevention:  Code analysis (e.g. MISRA) and review.

   MD_DEM_13.6:
     Description: Rule 13.6
                  Numeric variables being used within a for loop for iteration counting shall not be modified in the
                  body of the loop.
     Reason:      Efficiency, to prevent additional check for overflow.
     Risk:        Difficult to maintain.
     Prevention:  Correctness is ensured in test suite.

   MD_DEM_13.7:
     Description: Rule 13.7
                  Boolean operations whose results are invariant shall not be permitted.
     Reason:      The expression is not invariant. Depending on supported features invariant value is possible but
                  the resulting code modification will adversely affect maintainability of already complicated code
                  paths.
     Risk:        Compiler warnings or compiler errors depending on configuration.
     Prevention:  None.

   MD_DEM_14.1:
     Description: Rule 14.1
                  This switch default label is unreachable.
     Reason:      Switch default labels are mandatory due to mandatory MISRA rule 15.3 'The final clause of a switch
                  statement shall be the default clause.'.
     Risk:        Compiler warnings or compiler errors depending on configuration.
                  Default branch cannot be tested.
     Prevention:  None.

   MD_DEM_14.2:
     Description: Rule 14.2
                  All non-null statements shall either (i) have at least one side-effect however executed, or
                  (ii) cause control flow to change
     Reason:      This statement is used to avoid warnings caused by unused parameters. Parameters are defined by
                  standardized API requirements, and not needed in case a feature is disabled by configuration.
                  It is either impossible due to API standardization or necessary code duplication (severe maintenance
                  increase) to provide feature dependent APIs with different signatures.
     Risk:        Unavoidable compiler warning or error because of either unused statements or unused parameter.
     Prevention:  None.

   MD_DEM_14.5:
     Description: Rule 14.5
                  The continue statement shall not be used
     Reason:      The continue statement is used in a circumstance where a different approach would reduce efficiency
                  or maintainability due to increased complexity.
     Risk:        None.
     Prevention:  None.

   MD_DEM_14.6_err:
     Description: Rule 14.6
                  For any iteration statement there shall be at most one break statement used for loop termination.
     Reason:      The loop needs multiple exit points since error conditions cannot be verified prior to the loop.
     Risk:        None.
     Prevention:  None.

   MD_DEM_14.6_opt:
     Description: Rule 14.6
                  For any iteration statement there shall be at most one break statement used for loop termination.
     Reason:      Increased efficiency on the time critical path
     Risk:        Maintainability is adversely affected.
     Prevention:  The break statement is documented.

   MD_DEM_14.7:
     Description: Rule 14.7
                  A function shall have a single point of exit at the end of the function.
     Reason:      Due to maintainability problems the control flow through the function shall not be complicated even
                  further.
     Risk:        Maintainability is adversely affected.
     Prevention:  None.

   MD_DEM_15.2:
     Description: Rule 15.2
                  An unconditional break statement shall terminate every non-empty switch clause.
     Reason:      The fall-through is preferred to an if-else cascade to avoid code duplication in this particular
                  circumstance.
     Risk:        Adverse effect on maintainability.
     Prevention:  The fall-through is documented.

   MD_DEM_16.4_dcm:
     Description: Rule 16.4
                  The identifiers used in the declaration and definition of a function shall be identical
     Reason:      Dcm generates its own prototypes based on a generic algorithm.
     Risk:        Dcm prototypes can deviate from the implementation.
     Prevention:  Verify compatibility during integraton tests.

   MD_DEM_16.4_rte:
     Description: Rule 16.4
                  The identifiers used in the declaration and definition of a function shall be identical
     Reason:      Port-Defined arguments are not generated with the correct name. This can currently not be influenced
                  due to the RTE being a third party module.
     Risk:        None. The generated prototypes are never used directly but only from generated RTE code.
     Prevention:  None.

   MD_DEM_16.7:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API is standardized and a change would break compliance.
     Risk:        None.
     Prevention:  None.

   MD_DEM_16.7_False:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The data behind the pointer is modified, or modified in some configurations. This is a false positive.
     Risk:        None.
     Prevention:  None.

   MD_DEM_16.7_Internal:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API has to be compatible to a common prototype
     Risk:        None.
     Prevention:  None.

   MD_DEM_16.7_Design:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The function has write access to shared state. The caller may not rely on constancy. Even if the
                  current implementation does not need write access, this is allowed to change. A stable interface is
                  preferred to adhering to this rule.
     Risk:        None.
     Prevention:  None.

   MD_DEM_16.9_fp:
     Description: Rule 16.9
                  A function identifier shall only be used with either a preceding &, or with a parenthesised parameter
                  list, which may be empty.
     Reason:      There is a preceeding &, and the use as a function pointer is intended
     Risk:        None.
     Prevention:  None.

   MD_DEM_18.4:
     Description: Rule 18.4
                  Unions shall not be used
     Reason:      Data without shared lifetime is stored in a union for efficiency.
     Risk:        None due to no shared lifetime.
     Prevention:  None.

   MD_DEM_19.13:
     Description: Rule 19.13
                  K&R compilers do not support the ISO glue operator '##'.
     Reason:      This kind of implementation creates the least MISRA warnings.
     Risk:        K&R compilers will not work.
     Prevention:  Integration test using target compiler, error directives to detect evaluation errors.

   MD_DEM_19.15:
     Description: Rule 19.15
                  Precautions shall be taken in order to prevent the contents of a header file being included twice.
     Reason:      Precautions HAVE been taken, this violation is a false positive.
     Risk:        None.
     Prevention:  None.

   MD_DEM_20.2:
     Description: Rule 20.2
                  The names of standard library macros, objects and functions shall not be reused.
     Reason:      Included from vector standard library.
     Risk:        Name collision with different standard library.
     Prevention:  None.

   MD_DEM_3197_na:
     Description: Rule N/A
                  The initialiser for '%s' is always modified before being used.
     Reason:      Assignment is necessary for an inactive code branch. Reworking the code would have negative effects
                  on maintainability, which is deemed more important.
     Risk:        None.
     Prevention:  None.

   MD_DEM_3198_fp:
     Description: Rule N/A
                  The value assigned to '%s' is always modified before being used.
     Reason:      False positive.
     Risk:        None.
     Prevention:  None.

   MD_DEM_3198_na:
     Description: Rule N/A
                  The value assigned to '%s' is always modified before being used.
     Reason:      Assignment is necessary for an inactive code branch. Reworking the code would have negative effects
                  on maintainability, which is deemed more important.
     Risk:        None.
     Prevention:  None.

   MD_DEM_3206:
     Description: Rule N/A
                  The parameter '%s' is not used in this function.
     Reason:      API / Standardized API is not adapted based on configuration
     Risk:        None.
     Prevention:  None.

   MD_DEM_3305:
     Description: Rule N/A
                  Pointer cast to stricter alignment
     Reason:      Already aligned pointers are handled in a generic way.
     Risk:        None.
     Prevention:  None.

   MD_DEM_TEST:
     Description: Multiple rules
     Reason:      Test code does not respect MISRA coding standard
     Risk:        None.
     Prevention:  None.

 **********************************************************************************************************************
 COV_JUSTIFICATION_BEGIN

 \ID COV_DEM_ORGANI_COMMENT
   \REASON This section only contains commentaries that are removed from the source before delivery.

 \ID COV_DEM_TESTCODE
   \REASON This section only contains code to help test the software. It has no influence on the actual code. All such
           code is removed from the source before delivery.

 \COV_DEM_BITCALCULATION
   \REASON The coverage tool cannot evaluate the preprocessor coverage. The line coverage is sufficient to tell that
           all decisions have been covered.

 COV_JUSTIFICATION_END
 *********************************************************************************************************************/
/* SBSW_JUSTIFICATION_BEGIN

\ID SBSW_DEM_POINTER_WRITE_API
  \DESCRIPTION    In an API function, data is written through a pointer passed as function argument.
  \COUNTERMEASURE \N The caller ensures the pointers passed to this function are valid.

\ID SBSW_DEM_POINTER_WRITE_ARGUMENT
  \DESCRIPTION    In an internal function, data is written through a pointer passed as function argument.
  \COUNTERMEASURE \N The caller ensures the pointers passed to this function are valid.

\ID SBSW_DEM_POINTER_FORWARD_ARGUMENT
  \DESCRIPTION    A pointer parameter is received as argument and forwarded to another function expecting a valid
                  pointer. The called function does not store its pointer parameters.
  \COUNTERMEASURE \N The pointer is used unmodified, as such it is still valid.

\ID SBSW_DEM_POINTER_WRITE_ARGUMENT_BUFFER
  \DESCRIPTION    A pointer parameter and buffer size are received as argument. The function writes to the buffer,
                  or forwards the buffer and buffer size to another function which will write data to the buffer.
                  The called function will only write up to the number of bytes received as argument.
  \COUNTERMEASURE \R [CM_DEM_R_CHECK_REMAINING_BUFFER]

\ID SBSW_DEM_POINTER_FORWARD_STACK
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer. The called function does not store its
                  pointer parameter.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DEM_POINTER_FORWARD_GLOBAL
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DEM_POINTER_FORWARD_API
  \DESCRIPTION    One or multiple pointer(s) received in the API function are passed to a function expecting one or
                  more valid pointers.
  \COUNTERMEASURE \N The caller ensures that pointers passed to this function are valid.

\ID SBSW_DEM_NVM_WRITEBLOCK
  \DESCRIPTION    A NvMBlockId and a source pointer is passed to NvM_WriteBlock.
  \COUNTERMEASURE \R [CM_DEM_R_CHECK_NVBLOCKID]
                  \S [CM_DEM_S_CHECK_NVBLOCKID]
                  \S [CM_DEM_S_CHECK_NVBLOCK_LENGTH]

\ID SBSW_DEM_POINTER_WRITE_MEMORYENTRY
  \DESCRIPTION    In an internal function, data is written through a pointer to a memory entry, or the pointer is
                  passed to a function expecting a valid reference to a memory entry.
                  The memory entry pointer is initialized by Dem_Mem_MemoryGetEntry which will always return a pointer
                  to a valid memory entry.
  \COUNTERMEASURE \R [CM_DEM_R_MEMORY_GET_ENTRY]
                  \M [CM_DEM_M_MEMORYINDEX_LIMITS]
                  \M [CM_DEM_M_SIZEOF_MEMORYDATAPTR]
                  \S [CM_DEM_M_MEMORYINDEX_TYPE]

\ID SBSW_DEM_POINTER_MEMCPY_MEMORYENTRY
  \DESCRIPTION    In an internal function, a memory area is copied through a pointer to a memory entry. The entry
                  pointer is initialized by Dem_Mem_MemoryGetEntry which will always return a pointer to a valid memory
                  entry. The number of bytes copied is the size of the target buffer.
  \COUNTERMEASURE \R [CM_DEM_R_MEMORY_GET_ENTRY]
                  \M [CM_DEM_M_MEMORYINDEX_LIMITS]
                  \M [CM_DEM_M_SIZEOF_MEMORYDATAPTR]
                  \S [CM_DEM_M_MEMORYINDEX_TYPE]

\ID SBSW_DEM_POINTER_MEMCPY_TIMESERIESENTRY
  \DESCRIPTION    In an internal function, a memory area is copied through a pointer to a memory entry. The entry
                  pointer is initialized by Dem_Mem_TimeSeriesGetEntry which will always return a pointer to a valid memory
                  entry. The number of bytes copied is the size of the target buffer.
  \COUNTERMEASURE \R [CM_DEM_R_TIMESERIES_GET_ENTRY]
                  \M [CM_DEM_M_TIMESERIESINDEX_LIMITS]
                  \M [CM_DEM_M_SIZEOF_MEMORYDATAPTR]
                  \S [CM_DEM_M_TIMESERIESINDEX_TYPE]

\ID SBSW_DEM_POINTER_MEMCPY_READOUTBUFFER
  \DESCRIPTION    In an internal function, data is copied into the ReadoutBuffer using memcpy. Dem_Cfg_ReadoutBuffer
                  is a global variable, as such the pointer is always valid. The buffer size to copy is derived by sizeof.
  \COUNTERMEASURE \N The memory area is always valid.

\ID SBSW_DEM_POINTER_MEMCPY_TIMESERIESREADOUTBUFFER
  \DESCRIPTION    In an internal function, data is copied into the TimeSeriesReadoutBuffer using memcpy. Dem_Cfg_TimeSeriesReadoutBuffer
                  is a global variable, as such the pointer is always valid. The buffer size to copy is derived by sizeof.
  \COUNTERMEASURE \N The memory area is always valid.

\ID SBSW_DEM_CALL_FOREACH_FUNCPTR
  \DESCRIPTION    In an internal function, a pointer passed as function argument is called, with a pointer argument as argument.
  \COUNTERMEASURE \N The caller ensures that both pointers passed to this function are valid, and the argument pointer is a valid
                     argument for the function pointer.

\ID SBSW_DEM_CALL_ITERATOR_POINTER
  \DESCRIPTION    The iterator pattern works like this:
                  The functions Dem_Cfg_<X>IterInit, Dem_Cfg_<X>IterExists, Dem_Cfg_<X>IterNext, Dem_Cfg_<X>IterGet
                  receive a pointer to an iterator variable Dem_Cfg_<X>IterType.
                  The Dem_Cfg_<X>IterInit initializes the iterator variable, so it is valid to be used by the other three functions. Those
                  functions expect a reference to a valid iterator variable. The iterator variable is still valid when those
                  functions return.
  \COUNTERMEASURE \N The iterator variable is initialized using the appropriate Init function before passing its reference
                     to Dem_Cfg_<X>IterExists/Dem_Cfg_<X>IterNext/Dem_Cfg_<X>IterGet.

\ID SBSW_DEM_CALL_FUNCPTR_ITERATOR_POINTER
  \DESCRIPTION    The iterator pattern works like this:
                  The functions Dem_Cfg_<X>IterInit, Dem_Cfg_<X>IterExists, Dem_Cfg_<X>IterNext, Dem_Cfg_<X>IterGet
                  receive a pointer to an iterator variable Dem_Cfg_<X>IterType.
                  The Dem_Cfg_<X>IterInit initializes the iterator variable, so it is valid to be used by the other three
                  functions. Those functions expect a reference to a valid iterator variable. The iterator variable is still
                  valid when those functions return.
                  Dem_Cfg_<X>IterGet will verify the iterator is still in range of the target table to prevent
                  returning a table row with invalid pointer contents.
  \COUNTERMEASURE \R [CM_DEM_R_INIT_MONITOR_FOR_FUNCTION_INDEX]
                  \R [CM_DEM_R_EVENT_CBK_STATUS_INDEX]
                  \R [CM_DEM_R_DTC_CBK_STATUS_INDEX]

\ID SBSW_DEM_CLEARDTCTEST_ITERATOR
  \DESCRIPTION    The iterator pattern works like this:
                  The functions <X>IterInit, <X>IterExists, <X>IterNext, <X>IterGet receive a pointer to
                  a local stack variable of type <X>IterType.
                  The Dem_Cfg_<X>IterInit initializes the iterator variable, so it is valid to be used by the other three functions.
                  The iterator variable remains valid when these functions return.
                  This iterator guarantees that <X>IterGet will always return a valid function pointer, as long as the
                  iterator was initialized with <X>IterInit.
  \COUNTERMEASURE \R [CM_DEM_R_CLEARDTCTEST_ITERATOR]

\ID SBSW_DEM_CALL_MEMORYINFO_POINTER
  \DESCRIPTION    The memory info pointer is locally allocated and initialized using Dem_Mem_MemoryInfoInit.
  \COUNTERMEASURE \N The pointer is always valid.

\ID SBSW_DEM_CALL_DEBOUNCEINFO_INIT
  \DESCRIPTION    The debounce info pointer is locally allocated and passed to Dem_Esm_DebounceInfoInit for initialization.
  \COUNTERMEASURE \N The pointer is always valid.

\ID SBSW_DEM_CALL_DEBOUNCEINFO_POINTER
  \DESCRIPTION    A debounce info pointer is locally allocated and passed as argument to other functions.
                  As a reference to a local stack variable the pointer itself is always valid.
                  The pointer is initialized using Dem_Esm_DebounceInfoInit, which will always initialize it to point
                  to an existing debounce info struct.
  \COUNTERMEASURE \R [CM_DEM_R_DEBOUNCEINFO_INIT]

\ID SBSW_DEM_CALL_FUNCPTR_DEBOUNCEINFO_POINTER
  \DESCRIPTION    A debounce info pointer is locally allocated and passed as argument to a function pointer stored in
                  the debounce info.
                  As a reference to a local stack variable the pointer itself is always valid.
                  The pointer is initialized using Dem_Esm_DebounceInfoInit, which will always initialize it to point
                  to an existing debounce info struct. This also initializes the function pointer table, so the dereferenced
                  function pointer is always valid.
  \COUNTERMEASURE \R [CM_DEM_R_DEBOUNCEINFO_INIT]

\ID SBSW_DEM_POINTER_WRITE_DTC_CACHE
  \DESCRIPTION    In an internal function, data is written through a pointer to a dtc cache.
                  The DTC cache pointer is retrieved by Dem_Dcm_GetDtcCache which will always return a valid pointer.
  \COUNTERMEASURE \R [CM_DEM_R_GET_DTC_CACHE]

\ID SBSW_DEM_POINTER_LOCAL_COPYDIDINFO
  \DESCRIPTION    A pointer to a CopyDidInfo structure is passed to a function expecting a valid CopyDidInfo. The struct
                  fields are initialized with values that are expected to be valid:
                  The destination buffer pointer can be received via a *Dcm API. It is the responsibility of the Dcm
                  to pass a destination buffer and matching size.
                  The destination buffer pointer can alternatively be a pointer received from an application API without
                  size information. The application must ensure that the buffer is large enough to receive
                  MaxDataValueSize bytes of data.
                  The buffer size is initialized to the corresponding buffer size.
                  The remaining fields do not influence the write location by design.
                  The struct pointer passed to the called function points to a stack variable and is always valid.
  \COUNTERMEASURE \S [CM_DEM_S_SIZE_OF_RECORD_DATA_BUFFER]

\ID SBSW_DEM_POINTER_LOCAL_COLLECTDIDINFO
  \DESCRIPTION    A pointer to a CollectDidInfo structure is passed to a function expecting a valid CollectDidInfo.
                  The struct fields are initialized with values that are expected to be valid.
  \COUNTERMEASURE \N The caller ensures that the pointer and size information are valid. The struct pointer itself
                     points to a stack variable and is always valid.

\ID SBSW_DEM_POINTER_NORMAL_TIME_SERIES_COLLECTDIDINFO
  \DESCRIPTION    A pointer to a locally defined CollectDidInfo structure is passed to a function expecting a valid
                  CollectDidInfo.
                  The destination buffer pointer is initialized from Dem_Mem_RingBufferNormalRatePtr() which will always
                  return a valid pointer.
                  The buffer size is initialized to the corresponding buffer size.
  \COUNTERMEASURE \R [CM_DEM_R_RINGBUFFER_NORMALRATEPTR]
                  \M [CM_DEM_M_SIZEOF_NORMAL_RATE_RINGBUFFER]

\ID SBSW_DEM_POINTER_FAST_TIME_SERIES_COLLECTDIDINFO
  \DESCRIPTION    A pointer to a locally defined CollectDidInfo structure is passed to a function expecting a valid
                  CollectDidInfo.
                  The destination buffer pointer is initialized from Dem_Mem_RingBufferFastRatePtr() which will always
                  return a valid pointer.
                  The buffer size is initialized to the corresponding buffer size.
  \COUNTERMEASURE \R [CM_DEM_R_RINGBUFFER_FASTRATEPTR]
                  \M [CM_DEM_M_SIZEOF_FAST_RATE_RINGBUFFER]

\ID SBSW_DEM_WRITE_DIDINFO_DESTINATIONBUFFER
  \DESCRIPTION    An amount of data is written into the destination buffer pointer of a CollectDidInfo or CopyDidInfo.
                  The caller is responsible that buffer pointer and buffer length are correct (see also
                  SBSW_DEM_POINTER_LOCAL_COPYDIDINFO, SBSW_DEM_POINTER_LOCAL_COLLECTDIDINFO)
  \COUNTERMEASURE \R [CM_DEM_R_CHECK_REMAINING_BUFFER]

\ID SBSW_DEM_CALL_DIDINFO_DESTINATIONBUFFER
  \DESCRIPTION    An application callback is invoked to write data into the destination buffer pointer of a CollectDidInfo
                  or CopyDidInfo.
                  The caller is responsible that buffer pointer and buffer length are correct (see also
                  SBSW_DEM_POINTER_LOCAL_COPYDIDINFO, SBSW_DEM_POINTER_LOCAL_COLLECTDIDINFO).
  \COUNTERMEASURE \R [CM_DEM_R_CHECK_REMAINING_BUFFER]
                  \R [CM_DEM_R_SIZEOF_DATAELEMENT_TABLE]
                  \R [CM_DEM_R_CHECK_DATAELEMENT_TYPE]
                  \S [CM_DEM_S_DATA_CALLBACK_FPTR]
                  \S [CM_DEM_S_CALL_DESTINATIONBUFFER]

\ID SBSW_DEM_POINTER_EXTENDEDDATA_BUFFER
  \DESCRIPTION    A pointer to a locally defined CollectDidInfo structure is passed to a function expecting a valid
                  CollectDidInfo.
                  The destination buffer pointer is initialized from Dem_Mem_EntryGetERecDataPtr() which will always
                  return a valid pointer.
                  The buffer size is initialized to the corresponding buffer size.
  \COUNTERMEASURE \R [CM_DEM_R_MEMORY_GET_ERECDATAPTR]
                  \M [CM_DEM_M_SIZEOF_MEMORYENTRY_EXTENDEDDATA]

\ID SBSW_DEM_POINTER_SNAPSHOT_BUFFER
  \DESCRIPTION    A destination buffer pointer and buffer size is passed into a function that will write to the passed
                  memory area.
                  The pointer argument is returned from Dem_Mem_EntryGetSRecDataPtr() which will always return a valid
                  pointer.
                  The buffer size argument is set to the corresponding buffer size.
  \COUNTERMEASURE \R [CM_DEM_R_MEMORY_GET_SRECDATAPTR]
                  \M [CM_DEM_M_SIZEOF_MEMORYENTRY_SNAPSHOTDATA]

\ID SBSW_DEM_POINTER_WRITE_TIMESERIESENTRY
  \DESCRIPTION    In an internal function, data is written through a pointer to a time series entry, or the pointer is
                  passed to a function expecting a valid reference to a time series entry.
                  The memory entry pointer is initialized by Dem_Mem_TimeSeriesGetEntry which will always return a pointer
                  to a valid time series entry.
  \COUNTERMEASURE \R [CM_DEM_R_TIMESERIES_GET_ENTRY]
                  \M [CM_DEM_M_TIMESERIESINDEX_LIMITS]
                  \M [CM_DEM_M_SIZEOF_MEMORYDATAPTR]
                  \S [CM_DEM_M_TIMESERIESINDEX_TYPE]

\ID SBSW_DEM_POINTER_TIMESERIESENTRY_NORMALBUFFER
  \DESCRIPTION    A destination buffer pointer and buffer size is passed into a function that will write to the passed
                  memory area.
                  The pointer argument is returned from Dem_Mem_TimeSeriesEntryGetNormalDataPtr() which will always
                  return a valid pointer.
                  The buffer size is set to the corresponding buffer size.
  \COUNTERMEASURE \R [CM_DEM_R_TIMESERIES_GET_NORMALDATAPTR]
                  \M [CM_DEM_M_SIZEOF_SERIESENTRY_NORMAL_SNAPSHOTDATA]

\ID SBSW_DEM_POINTER_TIMESERIESENTRY_FASTBUFFER
  \DESCRIPTION    A destination buffer pointer and buffer size is passed into a function that will write to the passed
                  memory area.
                  The pointer argument is returned from Dem_Mem_TimeSeriesEntryGetFastDataPtr() which will always
                  return a valid pointer.
                  The buffer size is set to the corresponding buffer size.
  \COUNTERMEASURE \R [CM_DEM_R_TIMESERIES_GET_FASTDATAPTR]
                  \M [CM_DEM_M_SIZEOF_SERIESENTRY_FAST_SNAPSHOTDATA]

\ID SBSW_DEM_CALL_FOREACH_COMBINED_EVENT
  \DESCRIPTION    A function passes a function pointer and argument struct to Dem_Util_ForEachCombinedEvent. The function
                  is a function label, as such it is always valid. The argument struct is a reference to a local stack
                  variable.
  \COUNTERMEASURE \N The pointers are always valid.

\ID SBSW_DEM_CALL_DTCFILTER_FPTR
  \DESCRIPTION    A function dereferences the function pointer Dem_Dcm_FilterDtcGetFunctionPtr(). The dereferenced function
                  expects a valid pointer argument and does not store the passed pointer. The passed pointer is initialized
                  using Dem_Mem_MemoryInfoInit.
  \COUNTERMEASURE \R [CM_DEM_R_DTCFILTER_FPTR]

\ID SBSW_DEM_MEMCOPY_MEMORY_DATA
  \DESCRIPTION    A function copies data into Dem_Cfg_CommitBuffer using memcopy.
  \COUNTERMEASURE \R [CM_DEM_R_MEMORYDATA_INDEX]
                  \M [CM_DEM_M_SIZEOF_MEMORYDATAPTR]
                  \S [CM_DEM_M_SIZEOF_COMMIT_BUFFER]
                  \S [CM_DEM_S_CHECK_NVBLOCK_LENGTH]

\ID SBSW_DEM_ARRAY_WRITE_ADMINDATA_CYCLECOUNTER
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_AdminData.CycleCounter[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DEM_R_DEM_CFG_ADMINDATA_CYCLECOUNTER_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_ADMINDATA_CYCLECOUNTER]

\ID SBSW_DEM_ARRAY_WRITE_STATUSDATA_EVENTSTATUS
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_StatusData.EventStatus[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DEM_R_DEM_CFG_STATUSDATA_EVENTSTATUS_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_STATUSDATA_EVENTSTATUS]

\ID SBSW_DEM_ARRAY_WRITE_STATUSDATA_TRIPCOUNT
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_StatusData.TripCount[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DEM_R_DEM_CFG_STATUSDATA_TRIPCOUNT_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_STATUSDATA_TRIPCOUNT]

\ID SBSW_DEM_ARRAY_WRITE_EVENTINTERNALSTATUS
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_EventInternalStatus[] using a function argument as index.
  \COUNTERMEASURE \N Qualified use-case CSL02 of ComStackLib

\ID SBSW_DEM_MEMSET_EVENTINTERNALSTATUS
  \DESCRIPTION    Dem_Cfg_EventInternalStatus[] is initialized using memset. The array size is multiplied with the array base
                  size type to make sure the initialized memory area is correct.
  \COUNTERMEASURE \N Similar to CSL02: The ComStackLib guarantees that the array size is correctly returned by the GetSize access macro.

\ID SBSW_DEM_ARRAY_WRITE_EVENTDEBOUNCEVALUE
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_EventDebounceValue[] using a function argument as index.
  \COUNTERMEASURE \N Qualified use-case CSL02 of ComStackLib

\ID SBSW_DEM_ARRAY_WRITE_EVENTMAXDEBOUNCEVALUES
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_EventMaxDebounceValue[] using a function argument as index.
  \COUNTERMEASURE \N Qualified use-case CSL02 of ComStackLib

\ID SBSW_DEM_ARRAY_WRITE_COMBINEDGROUPSTATUS
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_CombinedGroupStatus[] using a function argument as index.
  \COUNTERMEASURE \N Qualified use-case CSL01 of ComStackLib

\ID SBSW_DEM_ARRAY_WRITE_COMBINEDGROUPINTERNALSTATUS
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_CombinedGroupInternalStatus[] using a function argument as index.
  \COUNTERMEASURE \N Qualified use-case CSL01 of ComStackLib

\ID SBSW_DEM_ARRAY_WRITE_DEBOUNCEDATA
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_DebounceData[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DEM_R_DEBOUNCEDATA_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_DEBOUNCEDATA]

\ID SBSW_DEM_MEMSET_DEBOUNCEDATA
  \DESCRIPTION    Dem_Cfg_DebounceData[] is initialized using memset. The array size is multiplied with the array base
                  size type to make sure the initialized memory area is correct.
  \COUNTERMEASURE \M [CM_DEM_M_SIZEOF_DEBOUNCEDATA]

\ID SBSW_DEM_ARRAY_WRITE_EVENTAVAILABLEDATA
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_EventAvailableData[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DEM_R_AVAILABLEDATA_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_EVENTAVAILABLEDATA]

\ID SBSW_DEM_MEMSET_EVENTAVAILABLEDATA
  \DESCRIPTION    Dem_Cfg_EventAvailableData[] is initialized using memset. The array size is multiplied with the array base
                  size type to make sure the initialized memory area is correct.
  \COUNTERMEASURE \M [CM_DEM_M_SIZEOF_EVENTAVAILABLEDATA]

\ID SBSW_DEM_ARRAY_WRITE_PRESTORAGEINDEX
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_PrestorageIndex[] using a configured index.
  \COUNTERMEASURE \R [CM_DEM_R_PRESTORAGE_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_PRESTORAGEINDEX]

\ID SBSW_DEM_MEMSET_PRESTORAGEINDEX
  \DESCRIPTION    Dem_Cfg_PrestorageIndex[] is initialized using memset. The array size is multiplied with the array base
                  size type to make sure the initialized memory area is correct.
  \COUNTERMEASURE \M [CM_DEM_M_SIZEOF_PRESTORAGEINDEX]

\ID SBSW_DEM_POINTER_WRITE_PRESTORAGEENTRY
  \DESCRIPTION    In an internal function, data is written through a pointer to a prestorage entry, or the pointer is
                  passed to a function expecting a valid reference to a prestorage entry.
                  The memory entry pointer is initialized by Dem_Mem_PrestorageGetEntry which will always return a pointer
                  to a valid memory entry.
  \COUNTERMEASURE \M [CM_DEM_M_SIZEOF_PRESTORAGE]
                  \R [CM_DEM_R_PRESTORAGE_GET_ENTRY]

\ID SBSW_DEM_ARRAY_WRITE_MEMORYCOMMITNUMBER
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_MemoryCommitNumber[] using a function argument as index.
  \COUNTERMEASURE \N Qualified use-case CSL01 of ComStackLib

\ID SBSW_DEM_MEMSET_MEMORYCOMMITNUMBER
  \DESCRIPTION    Dem_Cfg_MemoryCommitNumber[] is initialized using memset. The array size is multiplied with the array base
                  size type to make sure the initialized memory area is correct.
  \COUNTERMEASURE \M [CM_DEM_M_SIZEOF_MEMORYCOMMITNUMBER]

\ID SBSW_DEM_ARRAY_WRITE_MEMORYCHRONOLOGY
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_PrimaryChronology[], Dem_Cfg_SecondaryChronology[] or
                  Dem_Cfg_TimeSeriesChronology[] using a function argument as index. A valid MemoryInfo structure must
                  be provided by the caller.
  \COUNTERMEASURE \R [CM_DEM_R_MEMORYCHRONOLOGY_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_PRIMARYCHRONOLOGY]
                  \M [CM_DEM_M_SIZEOF_SECONDARYCHRONOLOGY]
                  \M [CM_DEM_M_SIZEOF_TIMESERIES_CHRONOLOGY]

\ID SBSW_DEM_ARRAY_WRITE_INDICATORCONTINUOUS
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_IndicatorContinuous[][] using function arguments as indices.
  \COUNTERMEASURE \R [CM_DEM_R_INDICATORCONTINUOUS_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_INDICATORCONTINUOUS]

\ID SBSW_DEM_ARRAY_WRITE_INDICATORBLINKING
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_IndicatorBlinking[][] using function arguments as indices.
  \COUNTERMEASURE \R [CM_DEM_R_INDICATORBLINKING_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_INDICATORBLINKING]

\ID SBSW_DEM_ARRAY_WRITE_MEMORYSTATUS
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_MemoryStatus[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DEM_R_MEMORYSTATUS_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_MEMORYSTATUS]

\ID SBSW_DEM_MEMSET_MEMORYSTATUS
  \DESCRIPTION    Dem_Cfg_MemoryStatus[] is initialized using memset. The array size is multiplied with the array base
                  size type to make sure the initialized memory area is correct.
  \COUNTERMEASURE \M [CM_DEM_M_SIZEOF_MEMORYSTATUS]

\ID SBSW_DEM_ARRAY_WRITE_EVENTQUEUE
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_EventQueue[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DEM_R_EVENTQUEUE_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_EVENTQUEUE]

\ID SBSW_DEM_ARRAY_WRITE_EVENTQUEUESTATUS
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_EventQueueStatus[] using a function argument as index.
  \COUNTERMEASURE \N Qualified use-case CSL02 of ComStackLib

\ID SBSW_DEM_ARRAY_WRITE_FILTERREPORTEDEVENTS
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_FilterReportedEvents[] using a function argument as index.
  \COUNTERMEASURE \N Qualified use-case CSL01 of ComStackLib

\ID SBSW_DEM_ARRAY_WRITE_MISSINGTIMESERIESNORMALRATE
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_MissingTimeSeriesNormalRate[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DEM_R_MISSINGTIMESERIESNORMALRATE_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_MISSINGTIMESERIESNORMALRATE]

\ID SBSW_DEM_MEMSET_MISSINGTIMESERIESNORMALRATE
  \DESCRIPTION    Dem_Cfg_MissingTimeSeriesNormalRate[] is initialized using memset. The array size is multiplied with the array base
                  size type to make sure the initialized memory area is correct.
  \COUNTERMEASURE \M [CM_DEM_M_SIZEOF_MISSINGTIMESERIESNORMALRATE]

\ID SBSW_DEM_ARRAY_WRITE_MISSINGTIMESERIESFASTRATE
  \DESCRIPTION    In a function, data is written to array Dem_Cfg_MissingTimeSeriesFastRate[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DEM_R_MISSINGTIMESERIESFASTRATE_INDEX_CHECK]
                  \M [CM_DEM_M_SIZEOF_MISSINGTIMESERIESFASTRATE]

\ID SBSW_DEM_MEMSET_MISSINGTIMESERIESFASTRATE
  \DESCRIPTION    Dem_Cfg_MissingTimeSeriesFastRate[] is initialized using memset. The array size is multiplied with the array base
                  size type to make sure the initialized memory area is correct.
  \COUNTERMEASURE \M [CM_DEM_M_SIZEOF_MISSINGTIMESERIESFASTRATE]

\ID SBSW_DEM_CLEARALLOWED_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced. The dereferenced function expects a valid
                  pointer argument and does not store the passed pointer. A pointer to a local stack variable is passed
                  to the dereferenced function, so the pointer argument is always valid.
  \COUNTERMEASURE \R [CM_DEM_R_CLEAR_EVENT_ALLOWED_INDEX]
                  \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_CLEAR_EVENT_ALLOWED_FPTR]

\ID SBSW_DEM_INITMONITORFOREVENT_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced.
  \COUNTERMEASURE \R [CM_DEM_R_INIT_MONITOR_FOR_EVENT_INDEX]
                  \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_INIT_MONITOR_FOR_EVENT_FPTR]

\ID SBSW_DEM_INITMONITORFORFUNCTION_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced.
  \COUNTERMEASURE \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_INIT_MONITOR_FOR_FUNCTION_FPTR]

\ID SBSW_DEM_GLOBALCBKDTCSTATUS_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced.
  \COUNTERMEASURE \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_GLOBAL_CBK_DTC_STATUS_FPTR]

\ID SBSW_DEM_EVENTCBKSTATUS_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced.
  \COUNTERMEASURE \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_EVENT_CBK_STATUS_FPTR]

\ID SBSW_DEM_EVENTCBKDATA_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced.
  \COUNTERMEASURE \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_EVENT_CBK_DATA_FPTR]

\ID SBSW_DEM_EVENTCBKGETFDC_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced. The dereferenced function expects a valid
                  pointer argument and does not store the passed pointer. A pointer to a local stack variable is passed
                  to the dereferenced function, so the pointer argument is always valid.
  \COUNTERMEASURE \R [CM_DEM_R_EVENT_CALLBACK_GET_FDC_INDEX]
                  \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_EVENT_CALLBACK_GET_FDC_FPTR]

\ID SBSW_DEM_GLOBALCBKEVENTSTATUS_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced.
  \COUNTERMEASURE \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_GLOBAL_CBK_EVENT_STATUS_FPTR]

\ID SBSW_DEM_GLOBALCBKEVENTDATA_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced.
  \COUNTERMEASURE \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_GLOBAL_CBK_EVENT_DATA_FPTR]

\ID SBSW_DEM_GLOBALCBKCONTROLDTCSETTING_FPTR
  \DESCRIPTION    In a function, a configured function pointer is dereferenced.
  \COUNTERMEASURE \R [CM_DEM_R_OPTIONAL_CALLBACK]
                  \S [CM_DEM_S_GLOBAL_CBK_CONTROL_DTC_SETTING_FPTR]

\ID SBSW_DEM_PRESTORED_SNAPSHOT
  \DESCRIPTION    In a function, the snapshot buffer of a prestored entry is passed into a function writing to the buffer.
                  The call includes the buffer size.
  \COUNTERMEASURE \M [CM_DEM_M_SIZEOF_PRESTORED_SNAPSHOT]

\ID SBSW_DEM_DCM_FILTERRECORD_ITERATOR_POINTER
  \DESCRIPTION    The iterator pattern works like this:
                  The functions Dem_Cfg_<X>IterInit, Dem_Cfg_<X>IterExists, Dem_Cfg_<X>IterNext, Dem_Cfg_<X>IterGet
                  receive a pointer to an iterator variable Dem_Cfg_<X>IterType.
                  The Dem_Cfg_<X>IterInit initializes the iterator variable, so it is valid to be used by the other three functions.
                  Those functions expect a reference to a valid iterator variable. The iterator variable is still valid
                  when those functions return.
                  Not all call paths initialize the iterator.
  \COUNTERMEASURE \N The iterator in this case is a global variable, as such the iterator pointer is always valid.
                  No other function accesses the same global variable (it could be function scope static but this is
                  not allowed due to coding guidelines).
                  As such it is not modified outside the function and it can be assumed that the iterator state remains valid in
                  between function calls.
                  Missing initialization cannot cause memory corruption.

SBSW_JUSTIFICATION_END */
/* ********************************************************************************************************************
 Silent BSW Countermeasures
 ----------------------------------------------------------------------------------------------------------------------
\CM CM_DEM_M_SIZEOF_ADMINDATA_CYCLECOUNTER
  Verify Dem_Cfg_AdminData.CycleCounter[] is defined for each index in range [0..DEM_CFG_GLOBAL_CYCLE_COUNT[ .

\CM CM_DEM_M_SIZEOF_STATUSDATA_EVENTSTATUS
  Verify Dem_Cfg_StatusData.EventStatus[] is defined for each index in the event table.

\CM CM_DEM_M_SIZEOF_STATUSDATA_TRIPCOUNT
  Verify Dem_Cfg_StatusData.TripCount[] is defined for each index in the event table.

\CM CM_DEM_M_SIZEOF_EVENTAVAILABLEDATA
  Verify Dem_Cfg_EventAvailableData[] is defined for each index in range [0..ceil(size of event table / 8)[ .

\CM CM_DEM_M_SIZEOF_DEBOUNCEDATA
  Verify Dem_Cfg_DebounceData[] is defined for each index in range [0..DEM_CFG_GLOBAL_DEBOUNCE_STORAGE_EVENT_COUNT[ .

\CM CM_DEM_M_SIZEOF_PRESTORAGE
  Verify Dem_Cfg_Prestorage[] is defined for each index in range [0..DEM_CFG_GLOBAL_PRESTORED_FF_SIZE] .

\CM CM_DEM_M_SIZEOF_PRESTORAGEINDEX
  Verify Dem_Cfg_PrestorageIndex[] is defined for each index in range [0..DEM_G_GLOBAL_PRESTORED_EVENT_COUNT[ .

\CM CM_DEM_M_SIZEOF_PRIMARYCHRONOLOGY
  Verify Dem_Cfg_PrimaryChronology[] is defined for each index in range [0..DEM_CFG_GLOBAL_PRIMARY_SIZE[ .

\CM CM_DEM_M_SIZEOF_SECONDARYCHRONOLOGY
  Verify Dem_Cfg_SecondaryChronology[] is defined for each index in range [0..DEM_CFG_GLOBAL_SECONDARY_SIZE[ .

\CM CM_DEM_M_SIZEOF_TIMESERIES_CHRONOLOGY
  Verify Dem_Cfg_TimeSeriesChronology[] is defined for each index in range [0..DEM_CFG_GLOBAL_TIMESERIES_SNAPSHOTS_SIZE[ .

\CM CM_DEM_M_SIZEOF_INDICATORCONTINUOUS
  Verify Dem_Cfg_IndicatorContinuous[] is defined for each index in range [0..DEM_CFG_GLOBAL_INDICATOR_COUNT[ .
  Verify Dem_Cfg_IndicatorContinuous[][] is defined for each index in range [0..max(1, DEM_G_MAX_NUMBER_J1939_NODES)[ .

\CM CM_DEM_M_SIZEOF_INDICATORBLINKING
  Verify Dem_Cfg_IndicatorBlinking[] is defined for each index in range [0..DEM_CFG_GLOBAL_INDICATOR_COUNT[ .
  Verify Dem_Cfg_IndicatorBlinking[][] is defined for each index in range [0..max(1, DEM_G_MAX_NUMBER_J1939_NODES)[ .

\CM CM_DEM_M_SIZEOF_MEMORYSTATUS
  Verify Dem_Cfg_MemoryStatus[] is defined for each index in range [0..DEM_CFG_GLOBAL_NV_BLOCK_COUNT[ .

\CM CM_DEM_M_SIZEOF_MEMORYCOMMITNUMBER
  Verify Dem_Cfg_MemoryCommitNumber[] is defined for each index in range [0..DEM_CFG_GLOBAL_NV_BLOCK_COUNT[ .

\CM CM_DEM_M_SIZEOF_MEMORYDATAPTR
  Verify Dem_Cfg_MemoryDataPtr[] is defined for each index in range [0..DEM_CFG_GLOBAL_NV_BLOCK_COUNT[ .

\CM CM_DEM_M_MEMORYINDEX_LIMITS
  Verify DEM_CFG_MEMORY_PRIMARY_INDEX + DEM_CFG_GLOBAL_PRIMARY_SIZE + DEM_CFG_GLOBAL_SECONDARY_SIZE <= DEM_CFG_GLOBAL_NV_BLOCK_COUNT,
  with DEM_CFG_GLOBAL_PRIMARY_SIZE > 0.

\CM CM_DEM_M_MEMORYINDEX_TYPE
  [SMI-2199] Verify that for each index in [DEM_CFG_MEMORY_PRIMARY_INDEX .. DEM_CFG_MEMORY_PRIMARY_INDEX + DEM_CFG_GLOBAL_PRIMARY_SIZE + DEM_CFG_GLOBAL_SECONDARY_SIZE[
  there is a memory entry pointer (Dem_Cfg_PrimaryEntry_XX / Dem_Cfg_SecondaryEntry_XX) configured in Dem_Cfg_MemoryDataPtr[index] .
  Reason for SMI: MSSV cannot evaluate function like macros - needed to get the type of the initializer

\CM CM_DEM_M_SIZEOF_MISSINGTIMESERIESNORMALRATE
  Verify Dem_Cfg_MissingTimeSeriesNormalRate[] is defined for each index in range [0..DEM_CFG_GLOBAL_TIMESERIES_SNAPSHOTS_SIZE[ .

\CM CM_DEM_M_SIZEOF_MISSINGTIMESERIESFASTRATE
  Verify Dem_Cfg_MissingTimeSeriesFastRate[] is defined for each index in range [0..DEM_CFG_GLOBAL_TIMESERIES_SNAPSHOTS_SIZE[ .

\CM CM_DEM_M_TIMESERIESINDEX_LIMITS
  Verify DEM_CFG_MEMORY_TIME_SERIES_INDEX + DEM_CFG_GLOBAL_TIMESERIES_SNAPSHOTS_SIZE <= DEM_CFG_GLOBAL_NV_BLOCK_COUNT, with
  DEM_CFG_GLOBAL_TIMESERIES_SNAPSHOTS_SIZE > 0.

\CM CM_DEM_M_TIMESERIESINDEX_TYPE
  [SMI-2200] Verify that for each index in [DEM_CFG_MEMORY_TIME_SERIES_INDEX .. DEM_CFG_MEMORY_TIME_SERIES_INDEX + DEM_CFG_GLOBAL_TIMESERIES_SNAPSHOTS_SIZE[
  there is a timeseries entry pointer (Dem_Cfg_TimeSeriesEntry_XX) configured in Dem_Cfg_MemoryDataPtr[index] .
  Reason for SMI: MSSV cannot evaluate function like macros - needed to get the type of the initializer

\CM CM_DEM_M_SIZEOF_EVENTQUEUE
  Verify Dem_Cfg_EventQueue[] is defined for each index in range [0..DEM_CFG_BSW_ERROR_BUFFER_SIZE[ .

\CM CM_DEM_M_SIZEOF_COMMIT_BUFFER
  [SMI-2201] Verify that Dem_Cfg_CommitBuffer is as large or larger than all entries in Dem_Cfg_MemoryDataSize.
  Reason for SMI: MSSV cannot evaluate sizeof(struct/union)

\CM CM_DEM_M_SIZEOF_PRESTORED_SNAPSHOT
  Verify that Dem_Cfg_PrestorageEntryType.SnapshotData[] has at least DEM_CFG_MAX_SIZE_SNAPSHOT elements.

\CM CM_DEM_M_SIZEOF_MEMORYENTRY_EXTENDEDDATA
  Verify that Dem_Cfg_PrimaryEntryType.ExtendedData[] is valid for values in range [0..DEM_CFG_MAX_NUM_EXT_RECORDS[ .
  Verify that Dem_Cfg_PrimaryEntryType.ExtendedData[][] has at least DEM_CFG_MAX_SIZE_EXT_RECORD elements .

\CM CM_DEM_M_SIZEOF_MEMORYENTRY_SNAPSHOTDATA
  Verify that Dem_Cfg_PrimaryEntryType.SnapshotData[] is valid for values in range [0..DEM_CFG_MAX_NUM_SNAPSHOTS[ .
  Verify that Dem_Cfg_PrimaryEntryType.SnapshotData[][] has at least DEM_CFG_MAX_SIZE_SNAPSHOT elements.

\CM CM_DEM_M_SIZEOF_NORMAL_RATE_RINGBUFFER
  Verify that Dem_Cfg_RingBufferNormalRateType.Buffer[] is valid for indices in range [0..max(1, DEM_CFG_TIMESERIES_NORMAL_PAST_SAMPLES)[ .
  Verify that Dem_Cfg_RingBufferNormalRateType.Buffer[][] is valid for indices in range [0..DEM_CFG_TIMESERIES_NORMAL_BUFFER_SIZE[ .

\CM CM_DEM_M_SIZEOF_FAST_RATE_RINGBUFFER
  Verify that Dem_Cfg_RingBufferFastRateType.Buffer[] is valid for indices in range [0..max(1, DEM_CFG_TIMESERIES_FAST_PAST_SAMPLES)[ .
  Verify that Dem_Cfg_RingBufferFastRateType.Buffer[][] is valid for indices in range [0..DEM_CFG_TIMESERIES_FAST_BUFFER_SIZE[ .

\CM CM_DEM_M_SIZEOF_SERIESENTRY_NORMAL_SNAPSHOTDATA
  Verify that Dem_Cfg_TimeSeriesEntryType.SnapshotData_NormalRate[] is valid for values in range [0..(DEM_CFG_TIMESERIES_NORMAL_FUTURE_SAMPLES + DEM_CFG_TIMESERIES_NORMAL_PAST_SAMPLES)[ .
  Verify that Dem_Cfg_TimeSeriesEntryType.SnapshotData_NormalRate[][] has at least DEM_CFG_MAX_SIZE_SNAPSHOT elements.

\CM CM_DEM_M_SIZEOF_SERIESENTRY_FAST_SNAPSHOTDATA
  Verify that Dem_Cfg_TimeSeriesEntryType.SnapshotData_FastRate[] is valid for values in range [0..(DEM_CFG_TIMESERIES_FAST_FUTURE_SAMPLES + DEM_CFG_TIMESERIES_FAST_PAST_SAMPLES)[ .
  Verify that Dem_Cfg_TimeSeriesEntryType.SnapshotData_FastRate[][] has at least DEM_CFG_MAX_SIZE_SNAPSHOT elements.

\CM CM_DEM_R_DEBOUNCEINFO_INIT
  Dem_Esm_DebounceInfoInit will always initialize the function pointer table with valid function pointers even when
  the passed event index is not a handle to an event, or the passed event does not have a valid debounce algorithm
  configured.

\CM CM_DEM_R_MEMORY_GET_ENTRY
  Dem_Mem_MemoryGetEntry will always return a valid memory entry even when the passed memory index is not a handle to a memory entry.

\CM CM_DEM_R_PRESTORAGE_GET_ENTRY
  Dem_Mem_PrestorageGetEntry will always return a valid prestorage entry even when the passed memory index is not a handle to a prestorage entry.

\CM CM_DEM_R_TIMESERIES_GET_ENTRY
  Dem_Mem_TimeSeriesGetEntry will always return a valid time series entry even when the passed memory index is not a handle to a time series entry.

\CM CM_DEM_R_GET_DTC_CACHE
  Dem_Dcm_GetDtcCache will always return a valid dtc cache pointer even when the passed client index is not in range.

\CM CM_DEM_R_OPTIONAL_CALLBACK
  Optional Callbacks can be NULL_PTR, so the code must explicitly verify that the function called is not NULL_PTR.

\CM CM_DEM_R_CLEARDTCTEST_ITERATOR
  As long as the iterator is initialized Dem_Dcm_ClearDtcTestIterGet will always return a function pointer of the correct type.

\CM CM_DEM_R_CHECK_NVBLOCKID
  Before passing an NV block ID to the NvM, verify that the Dem memory index is valid. This is necessary for SMI-22 and SMI-23.

\CM CM_DEM_R_SIZEOF_DATAELEMENT_TABLE
  Verify that the data element index used to access Dem_Cfg_DataElementTable is valid.

\CM CM_DEM_R_CHECK_DATAELEMENT_TYPE
  Verify that the function pointer called is configured to have the expected data element type.

\CM CM_DEM_R_MEMORY_GET_ERECDATAPTR
  Dem_Mem_EntryGetERecDataPtr will always return a valid pointer even when the passed record index is not valid.

\CM CM_DEM_R_MEMORY_GET_SRECDATAPTR
  Dem_Mem_EntryGetSRecDataPtr will always return a valid pointer even when the passed record index is not valid.

\CM CM_DEM_R_RINGBUFFER_NORMALRATEPTR
  Dem_Mem_RingBufferNormalRatePtr will always return a valid pointer even when the passed buffer index is not valid.

\CM CM_DEM_R_RINGBUFFER_FASTRATEPTR
  Dem_Mem_RingBufferFastRatePtr will always return a valid pointer even when the passed record index is not valid.

\CM CM_DEM_R_TIMESERIES_GET_NORMALDATAPTR
  Dem_Mem_TimeSeriesEntryGetNormalDataPtr will always return a valid pointer even when the passed series index is not valid.

\CM CM_DEM_R_TIMESERIES_GET_FASTDATAPTR
  Dem_Mem_TimeSeriesEntryGetFastDataPtr will always return a valid pointer even when the passed series index is not valid.

\CM CM_DEM_R_CHECK_REMAINING_BUFFER
  Before writing data to a buffer, check that the buffer is large enough for the data written to it.

\CM CM_DEM_R_DTCFILTER_FPTR
  Before calling the function pointer returned by Dem_Dcm_FilterDtcGetFunctionPtr() verify that it is one of the expected function pointers.

\CM CM_DEM_R_CLEAR_EVENT_ALLOWED_INDEX
  Verify that the table index is in range before accessing Dem_Cfg_CallbackClearEventAllowed.

\CM CM_DEM_R_INIT_MONITOR_FOR_EVENT_INDEX
  Verify that the table index is in range before accessing Dem_Cfg_InitMonitorForEvent.

\CM CM_DEM_R_INIT_MONITOR_FOR_FUNCTION_INDEX
  Verify that the table index is in range before accessing Dem_Cfg_InitMonitorsForFunc.

\CM CM_DEM_R_EVENT_CBK_STATUS_INDEX
  Verify that the table index is in range before accessing Dem_Cfg_EventStatusChanged.

\CM CM_DEM_R_DTC_CBK_STATUS_INDEX
  Verify that the table index is in range before accessing Dem_Cfg_CallbackDtcStatusChanged.

\CM CM_DEM_R_EVENT_CALLBACK_GET_FDC_INDEX
  Verify that the table index is in range before accessing Dem_Cfg_CallbackGetFdc.

\CM CM_DEM_R_MEMORYDATA_INDEX
  Verify that the table index is in range before accessing Dem_Cfg_MemoryDataPtr and Dem_Cfg_MemoryDataSize.

\CM CM_DEM_R_DEM_CFG_ADMINDATA_CYCLECOUNTER_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_AdminData.CycleCounter.

\CM CM_DEM_R_DEM_CFG_STATUSDATA_EVENTSTATUS_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_StatusData.EventStatus.

\CM CM_DEM_R_DEM_CFG_STATUSDATA_TRIPCOUNT_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_StatusData.TripCount.

\CM CM_DEM_R_DEBOUNCEDATA_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_DebounceData.

\CM CM_DEM_R_AVAILABLEDATA_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_EventAvailableData.

\CM CM_DEM_R_PRESTORAGE_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_PrestorageIndex.

\CM CM_DEM_R_MEMORYCHRONOLOGY_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_PrimaryChronology.
  Verify that the array index is in range before writing to Dem_Cfg_SecondaryChronology.
  Verify that the array index is in range before writing to Dem_Cfg_TimeSeriesChronology.

\CM CM_DEM_R_INDICATORCONTINUOUS_INDEX_CHECK
  Verify that all array indices are in range before writing to Dem_Cfg_IndicatorContinuous[][] .

\CM CM_DEM_R_INDICATORBLINKING_INDEX_CHECK
  Verify that all array indices are in range before writing to Dem_Cfg_IndicatorBlinking[][] .

\CM CM_DEM_R_MEMORYSTATUS_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_MemoryStatus.

\CM CM_DEM_R_EVENTQUEUE_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_EventQueue.

\CM CM_DEM_R_MISSINGTIMESERIESNORMALRATE_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_MissingTimeSeriesNormalRate.

\CM CM_DEM_R_MISSINGTIMESERIESFASTRATE_INDEX_CHECK
  Verify that the array index is in range before writing to Dem_Cfg_MissingTimeSeriesFastRate.

\CM CM_DEM_S_CLEAR_EVENT_ALLOWED_FPTR
  [SMI-2055] Verify that all function pointers stored in table Dem_Cfg_CallbackClearEventAllowed are compatible to
  Dem_ClearEventAllowedFPtrType. The value NULL_PTR is valid for this callback type.

\CM CM_DEM_S_INIT_MONITOR_FOR_EVENT_FPTR
  [SMI-2055] Verify that all function pointers stored in table Dem_Cfg_InitMonitorForEvent are compatible to
  Dem_InitMonitorForEventFPtrType. The value NULL_PTR is valid for this callback type.

\CM CM_DEM_S_INIT_MONITOR_FOR_FUNCTION_FPTR
  [SMI-2055] Verify that all function pointers stored in table Dem_Cfg_InitMonitorsForFunc are compatible to
  Dem_InitMonitorForFuncFPtrType. The value NULL_PTR is valid for this callback type.

\CM CM_DEM_S_GLOBAL_CBK_DTC_STATUS_FPTR
  [SMI-2055] Verify that all function pointers stored in table Dem_Cfg_CallbackDtcStatusChanged are compatible to
  Dem_DtcStatusChangedFPtrType. The value NULL_PTR is valid for this callback type.

\CM CM_DEM_S_EVENT_CBK_STATUS_FPTR
  [SMI-2055] Verify that all function pointers stored in table Dem_Cfg_EventStatusChanged are compatible to
  Dem_EventStatusChangedFPtrType. The value NULL_PTR is valid for this callback type.

\CM CM_DEM_S_EVENT_CBK_DATA_FPTR
  [SMI-2055] Verify that all function pointers stored in table Dem_Cfg_EventDataChanged are compatible to
  Dem_EventDataChangedFPtrType. The value NULL_PTR is valid for this callback type.

\CM CM_DEM_S_EVENT_CALLBACK_GET_FDC_FPTR
  [SMI-2055] Verify that all function pointers stored in table Dem_Cfg_CallbackGetFdc are compatible to
  Dem_GetFDCFPtrType. The value NULL_PTR is valid for this callback type.

\CM CM_DEM_S_GLOBAL_CBK_EVENT_STATUS_FPTR
  [SMI-2207] Verify that the function pointer defined as macro DEM_CFG_GLOBALCBKSTATUS_FUNC is compatible to
  Dem_GlobalStatusChangedFPtrType. The value NULL_PTR is valid for this callback.

\CM CM_DEM_S_GLOBAL_CBK_EVENT_DATA_FPTR
  [SMI-2207] Verify that the function pointer defined as macro DEM_CFG_GLOBALCBKDATA_FUNC is compatible to
  Dem_GlobalDataChangedFPtrType. The value NULL_PTR is valid for this callback.

\CM CM_DEM_S_GLOBAL_CBK_CONTROL_DTC_SETTING_FPTR
  [SMI-2207] Verify that the function pointer defined as macro DEM_CFG_GLOBALCBKCONTROLDTCSETTING_FUNC is compatible to
  Dem_ControlDtcSettingChangedFPtrType. The value NULL_PTR is valid for this callback.

\CM CM_DEM_S_DATA_CALLBACK_FPTR
  [SMI-2194] The user of MICROSAR Safe shall verify for all function pointers stored in table Dem_Cfg_DataElementTable:
  - If ElementKind is DEM_CFG_DATA_FROM_CBK_STORED, verify that the callback function ReadDataFunc is compatible to
    Dem_ReadDataStandardFPtrType.
  - If ElementKind is DEM_CFG_DATA_FROM_CBK_CURRENT, verify that the callback function ReadDataFunc is compatible to
    Dem_ReadDataStandardFPtrType.
  - If ElementKind is DEM_CFG_DATA_FROM_CBK_STORED_WITH_EVENTID, verify that the callback function ReadDataFunc is
    compatible to Dem_ReadDataExtendedFPtrType.
  - If ElementKind is DEM_CFG_DATA_FROM_CBK_CURRENT_WITH_EVENTID, verify that the callback function ReadDataFunc is
    compatible to Dem_ReadDataExtendedFPtrType.
  - Verify that all other callback functions ReadDataFunc in the table are set to NULL_PTR.
  The function pointer types are defined in Dem_Types.h. The table is generated into Dem_Lcfg.c.

\CM CM_DEM_S_CALL_DESTINATIONBUFFER
  [SMI-2195] The user of MICROSAR Safe shall verify that all function callbacks configured in table
  Dem_Cfg_DataElementTable write at most ElementSize bytes.
  E.g. for a line {  DEM_CFG_DATA_FROM_CBK_STORED, 4U, (Dem_ReadDataFPtrType)Rte_Call_CBReadData_DemDataElementClass_ReadData }
  verify that the application runnable triggered by the Rte when the Dem invokes operation 'ReadData' on PortPrototype
  'DemDataElementClass' will at most write 4 bytes.
  The table is generated into Dem_Lcfg.c.

\CM CM_DEM_S_CHECK_NVBLOCKID
  [SMI-2196] The user of MICROSAR Safe shall verify that the NV Block IDs listed in table Dem_Cfg_MemoryBlockId are
  intended to be used exclusively by Dem. This is required for SMI-22.
  The table is generated into Dem_Lcfg.c.

\CM CM_DEM_S_CHECK_NVBLOCK_LENGTH
  [SMI-2197] The user of MICROSAR Safe shall verify that the configured NvM block size of the NV blocks referenced
  in table Dem_Cfg_MemoryBlockId is equal to the data size in table Dem_Cfg_MemoryDataSize for the same index.
  The user of MICROSAR Safe shall verify that the NV block is also configured to use the RAM buffer referenced in
  Dem_Cfg_MemoryDataPtr for the same index. This is required for SMI-23.
  E.g. Verify that the NvM block descriptor referenced in Dem_Cfg_MemoryBlockId[1] is configured with data length
  Dem_Cfg_MemoryDataSize[1] and RAM buffer Dem_Cfg_MemoryDataPtr[1].
  The tables Dem_Cfg_MemoryBlockId, Dem_Cfg_MemoryDataSize and Dem_Cfg_MemoryDataPtr are generated into Dem_Lcfg.c.
  Refer to the NvM for the location of the tables generated by the NvM to verify the correct configuration.

\CM CM_DEM_S_SIZE_OF_RECORD_DATA_BUFFER
  [SMI-2198] The user of MICROSAR Safe shall verify that when calling Dem_GetEventExtendedDataRecord or
  Dem_GetEventFreezeFrameData, either directly or by RTE operation GetExtendedDataRecord or GetFreezeFrameData of port
  interfaces DiagnosticInfo, GeneralDiagnosticInfo or DiagnosticMonitor:
  - The DestBuffer parameter shall point to a memory area which can receive at least sizeof(Dem_MaxDataValueSize) bytes.
  If an RTE is used, the type Dem_MaxDataValueSize is defined in Rte_Type.h.
  If no RTE is used, the value of DEM_CFG_SIZEOF_MAX_DATA_VALUE_TYPE corresponds to the expected buffer size.
  This macro is defined in Dem_Lcfg.h.

*/
/* ********************************************************************************************************************
 *  END OF FILE: DEM.C
 *********************************************************************************************************************/
