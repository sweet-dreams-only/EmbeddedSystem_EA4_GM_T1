/* -----------------------------------------------------------------------------
  Filename:    appdesc.c
  Description: Implementation example for the proper usage with CANdesc.
                
                Manufacturer: General Motors
                EcuDocFile:   C:\Hari\Work\SynergyProjects\T1xx_Synergy\BuildPrep\07.02.01_Work\Z_Work_2_6561_8807\GM_T1XX_EPS_RH850\tools\GENy\EPS_T1XX_Nxtr_19.0.4_60.cdd
                Variant:      CommonDiagnostics

  Generated by CANdelaGen, Tue Feb 07 17:36:22 2017
 
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2001-2013 by Vctr Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vctr Informatik 
  GmbH.
  
  Vctr Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vctr Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    &&&~ History
 ----------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------------
  Please note, that the demo and example programs only show special aspects of 
  the software. With regard to the fact that these programs are meant for 
  demonstration purposes only, Vctr Informatik´s liability shall be expressly 
  excluded in cases of ordinary negligence, to the extent admissible by law or 
  statute.
  ---------------------------------------------------------------------------- */

/* 
------------------------------------------------------------------------------------------------------------------------
                                             A U T H O R   I D E N T I T Y                                              
------------------------------------------------------------------------------------------------------------------------
Initials   Name                  Company                                                                                
---------- --------------------- ---------------------------------------------------------------------------------------
Ktw        Katrin Thurow         Vctr Informatik GmbH                                                                 
Mhe        Matthias Heil         Vctr Informatik GmbH                                                                 
Rpk        Patrick Rieder        Vctr Informatik GmbH                                                                 
Sa         Mishel Shishmanyan    Vctr Informatik GmbH                                                                 
------------------------------------------------------------------------------------------------------------------------
                                            R E V I S I O N   H I S T O R Y                                             
------------------------------------------------------------------------------------------------------------------------
Date       Version  Author Modification type Issue Id      Affects                        Description                    
---------- -------- ------ ----------------- ------------- ------------------------------ -------------------------------
2009-09-10  6.00.00
                    Sa     Fixed             ESCAN00022820 General Motors(KWP2000)        Compile error in desc.c function DescSetCommState
                    Sa     Fixed             ESCAN00037297 General Motors(KWP2000)        Periodic DPID scheduler overwritten if the new request
                    Sa     Fixed             ESCAN00033091 General Motors(KWP2000)        Unused signal handler generated
                    Sa     Fixed             ESCAN00037724 KWP2000                        Compiler warning for assignment of type array of vuint8* to vuint8*
                    Sa     Fixed             ESCAN00037724 KWP2000                        Compiler warning for assignment of type array of vuint8* to vuint8*
                    Sa     Fixed             ESCAN00028409 All                            No response on request         
                    Sa     Modified          ESCAN00029770 All                            Compiler warning for enumeration item with value 0xFF on enum-type = char
                    Sa     Added             ESCAN00030116 All                            Provide IsoTp-Callback prototypes in desc.h/danisisotp.h
                    Sa     Added             ESCAN00030087 All                            Support of internal diagnostic requests over IsoTP
                    Sa     Fixed             ESCAN00030981 All                            Switch to suppress multitiple addressing check
                    Sa     Fixed             ESCAN00029915 All                            CANdesc files can not be written
                    Sa     Modified          ESCAN00031158 All                            Ring-buffer feature enabled for non-ISO-TP DANIS drivers
                    Sa     Added             ESCAN00031156 All                            Added DANIS abstraction for testerId and comChannel
                    Ktw    Fixed             ESCAN00031533 All                            Compiler Warning: Unused variable tpTxChannel
                    Sa     Fixed             ESCAN00027182 All                            Compiler Warning: variable "svcInstFailedBytePosMask" is possibly uninitialized
                    Sa     Fixed             ESCAN00034934 All                            Wrong null-terminated and leading size byte string data object total length calculation
                    Ktw    Fixed             ESCAN00035554 All                            Null pointer access in DanisBoschTp
                    Sa     Modified          ESCAN00036996 All                            Switching between ANSI C and hardware optimized bit-type
                    Ktw    Added             ESCAN00037874 All                            Support multi identity mode - VSG
2009-01-11  6.01.00
                    Sa     Fixed             ESCAN00038468 General Motors(KWP2000)        UUDT data improperly copied for TMS320
                    Sa     Fixed             ESCAN00038825 KWP2000                        Compiler warning/error for wrong parameter passed
                    Ktw    Modified          ESCAN00040135 All                            CanChannelIdentityAssignment is generated in RAM section
2010-03-18  6.02.00
                    Ktw    Modified          ESCAN00039608 General Motors(KWP2000)        Remove duplicate generated macro kDescUudtConfirmTimeoutTicks
                    Ktw    Fixed             ESCAN00041576 All                            Compiler warning for constant expression in DescDispatcher
2010-05-07  6.03.00
                    Ktw    Fixed             ESCAN00042963 All                            DescCopyToCan API does not support CAN message buffers located in the gpage
2010-26-07  6.03.01
                    Ktw    Fixed             ESCAN00043315 General Motors(KWP2000)        Periodic reading data timing settings in GENtool are not used in CANdesc
                    Ktw    Fixed             ESCAN00044050 All                            Compiler warning: condition is always false
                    Ktw    Fixed             ESCAN00044118 All                            CANdesc task period not changeable
                    Ktw    Fixed             ESCAN00043273 All                            Unexpected generation error occurs
                    Ktw    Fixed             ESCAN00044197 All                            Not all buffers used in DANIS can be located in far RAM
2010-08-16  6.04.00
                    Ktw    Fixed             ESCAN00044528 All                            Compile errors in DanisIsoTp communication adapter
                    Ktw    Fixed             ESCAN00044371 All                            v_inc.h is not included in the generated DANIS adapter template
2011-01-11  6.05.00
                    Ktw    Fixed             ESCAN00045932 All                            Compile error on each usage of DescInterruptDisable/-Restore internal API
                    Ktw    Fixed             ESCAN00047741 All                            Adapt CANdesc TMS320 support for GENy enabled CANdriver
                    Ktw    Fixed             ESCAN00047355 All                            Memory mapping of FAR buffer support use incomplete description for paged memory µC
                    Ktw    Fixed             ESCAN00046410 All                            After ECU reset the diagnostic response is not transmitted after the function DescSendPosRespFBL has been called
2011-04-11  6.06.00
                    Mhe    Fixed             ESCAN00044281 General Motors(KWP2000)        Compile error for missing constant kDescOemNrcParamIdNotSupportedInSession
                    Mhe    Fixed             ESCAN00044333 General Motors(KWP2000)        Scheduler Timings does not fit (0xAA) to requirements
                    Mhe    Fixed             ESCAN00045711 General Motors(KWP2000)        CANdesc overwrites memory after redefining a dynamic DPID
                    Mhe    Fixed             ESCAN00045731 General Motors(KWP2000)        Service 0xA9 0x80/0x81 can not be executed immediately after the EndOfDtcReport UUDT message
                    Mhe    Fixed             ESCAN00045902 General Motors(KWP2000)        Service 0x22 (ReadDataById) will be rejected with NRC 0x31 by mistake, in case a secured DID is included
                    Mhe    Fixed             ESCAN00047431 General Motors(KWP2000)        Compiler warning: static symbol 'DescOemPostStartDisableAllDTCs' unused
                    Mhe    Added             ESCAN00044127 General Motors(KWP2000)        Service handlers for $10 $02 and $10 $03 must exist only if the corresponding service is enabled
                    Mhe    Added             ESCAN00050033 General Motors(KWP2000)        Support for GMW3110 v1.6       
                    Mhe    Modified          ESCAN00036927 All                            Allow parallel OBD support if only the TPMC DANIS adapter is available
                    Mhe    Added             ESCAN00044127 All                            Support for DANIS adapter specific available buffer size information to the application
                    Mhe    Added             ESCAN00048157 All                            Add Danis adapter for LinTp    
                    Ktw    Fixed             ESCAN00048636 All                            Error message references non-existent file 'ApplDesc.h'
2011-08-12  6.07.00
                    Ktw    Modified          ESCAN00051315 All                            API DescGetCurrentBusInfo should be usable for periodic transmission
                    Ktw    Added             ESCAN00052870 All                            Support Multiple Addressing (combination Normal and Extended Addressing)
2011-09-01  6.07.01
                    Ktw    Fixed             ESCAN00053204 General Motors(KWP2000)        Compile error: Wrong function name used  to Get NM status
                    Ktw    Fixed             ESCAN00053205 All                            Wrong function is called to get addressing type
2011-09-06  6.08.00
                    -      -                 -             -                              No relevant changes available in this version.
2011-09-24  6.08.01
                    Ktw    Fixed             ESCAN00053847 All                            No response is sent to a physical request
                    Ktw    Fixed             ESCAN00053042 All                            CANdesc sends UUDT responses with CAN IDs from other identities
2011-10-04  6.08.02
                    Ktw    Fixed             ESCAN00054014 General Motors(KWP2000)        Generator crash: Service 0x2a activated and no UUDT messages
                    Ktw    Added             ESCAN00054105 All                            Move some configuration defines of Service 0x2c and 0x2a to the header file
2011-10-25  6.09.00
                    -      -                 -             -                              No relevant changes available in this version.
2011-12-09  6.10.00
                    Ktw    Fixed             ESCAN00055282 General Motors(KWP2000)        Compile error: Too few arguments in call of IlNwmGetStatus
2011-12-29  6.10.01
                    Ktw    Fixed             ESCAN00055782 General Motors(KWP2000)        Compiler error:  unresolved external symbol _ApplDescSpontaneousResponseConfirmation
2012-01-13  6.10.02
                    -      -                 -             -                              No relevant changes available in this version.
2012-02-09  6.10.03
                    -      -                 -             -                              No relevant changes available in this version.
2012-02-23  6.11.00
                    Ktw    Fixed             ESCAN00057280 General Motors(KWP2000)        Compiler error: redeclaration of DescGetHiSpeedMode
                    Ktw    Added             ESCAN00057614 All                            Better error message if an Oem is not supported by CANdesc but supported in the datamodel
2012-04-18  6.11.01
                    -      -                 -             -                              No relevant changes available in this version.
2012-07-02  6.11.02
                    Ktw    Fixed             ESCAN00058439 General Motors(KWP2000)        Unneeded callbacks are generated in appdesc.c
2012-07-27  6.12.00
                    -      -                 -             -                              No relevant changes available in this version.
2012-10-27  6.12.01
                    Ktw    Modified          ESCAN00062366 All                            CANDesc on multiple channels: Support more than 4 channels 
2012-11-12  6.13.00
                    Ktw    Fixed             ESCAN00066330 General Motors(KWP2000)        Unsupported service $A5 subfunction results in NRC 0x12 when programming mode is active
2013-06-04  6.14.00
                    Rpk    Fixed             ESCAN00067274 General Motors(KWP2000)        On a S1 timeout in programming mode no reset is performed
2013-09-05  6.14.01
                    -      -                 -             -                              No relevant changes available in this version.
2013-09-27  6.15.00
                    Rpk    Fixed             ESCAN00067765 General Motors(KWP2000)        Compiler warning: unused variable g_descProgMode
                    Rpk    Fixed             ESCAN00068911 General Motors(KWP2000)        Compiler warning: DescHandleInternRcrRp was declared but never referenced
                    Rpk    Fixed             ESCAN00067422 KWP2000                        Compile error: DescCheckResponseRequiredOnFunc expects near pointer as parameter
2013-11-29  6.15.01
                    -      -                 -             -                              No relevant changes available in this version.
2014-01-10  6.15.02
                    Rpk    Fixed             ESCAN00072464 General Motors(KWP2000)        Infinite RCR-RP for service $AA with dynamically defined DPID on Tester Present timeout
                    Rpk    Fixed             ESCAN00072875 General Motors(KWP2000)        Response $60 is sent twice on tester present timeout if a $AA request was pending
2014-03-11  6.15.03
                    Rpk    Fixed             ESCAN00073862 General Motors(KWP2000)        Positive response instead of NRC 0x31 after requesting 0x2C service with supported and unsupported PIDs
                    Rpk    Fixed             ESCAN00074177 General Motors(KWP2000)        Service 0x2C: Requesting a DPID with a secured PID not allowed in the current security state leads to undefined behavior
------------------------------------------------------------------------------------------------------------------------
 */

/**********************************************************************************************************************
* Copyright 2015 Nxtr
* Nxtr Confidential
*
* Module File Name  : appdesc.c
* Module Description: Diagnostic service support
* Project           : T1XX
* Author            : kzdyfh
***********************************************************************************************************************
* Version Control:
* %version:          42 %
* %derived_by:       nz2654 %
*---------------------------------------------------------------------------------------------------------------------
* Date      Rev      Author    Change Description                                                             SCR #
* --------  -------  --------  -----------------------------------------------------------------------------  -------
* 03/16/15   1       Lucas     Initial Version
* 04/30/15   2       Shameel   Implemented diagnostic support for reprogramming                               EA4#543
* 04/30/15   3       Shameel   Added CanStop functionality in $34 service                                     EA4#543
* 05/01/15   4       JWJ       Updates for Common Manufacturing Service                                       EA4#544
* 05/03/15   5       LWW       Updated for datatype name and enueration value changes                         EA4#566
* 05/07/15   6       LWW       Updated service IDs F194 and F195                                              EA4#566
* 06/22/15   7       LWW       Added type 22 services to support 1b build                                     EA4#884
* 08/14/15   9       MS        Added DIDs for part numbers                                                   EA4#1326
* 02/29/16   16      JWJ       Added DIDs for initial version of SoH software                                 EA4#4026
* 05/06/16   20      JWJ       Added new DID for SoH updates                                                  EA4#5668
* 05/06/16   21      JWJ       Corrected signal in local functions for SoH changes                            EA4#5668
* 05/27/16   22      JWJ       Commented out DTC enable/disable functions for cust. delivery (MPU violation)  EA4#6471
* 06/30/16   23      JWJ       Turned enable/disable DTC DEM calls into non-trusted functions calls           EA4#6471
* 07/15/16   24      JWJ       Updated to GM CDD version 19.0.0_60                                            EA4#5827
* 08/12/16   25      JWJ       Numerous updates for multiple anomalies including rationality checks           EA4#6843
* 09/01/16   26      JWJ       Updates to security access services and to 0xA9 for history bit                EA4#6843
* 09/16/16   27      JWJ       Corrected rationality for service $28 to allow when VehSpd is invalid          EA4#7626
* 10/07/16   28      JWJ       EA4#6871: Fix for service 0x12 0x02 delayed response                           EA4#7927
*                              EA4#7089: Removed support for unsupported fault status bits                    EA4#7927
*                              EA4#6919: Added support for SF007A and SF015A SoH signals                      EA4#7927
*                              EA4#7861: NRC 0x12 to service 0x27 0x03 when CMEC == 0 and seed == FFFFFFFFFF  EA4#7927
* 11/22/16   31      HM        EA4#8133: NRC 0x12 to service 0x27 0x03 when CMEC == 0 and Key == FFFFFFFFFF   EA4#8522
* 12/01/16   32      HM        EA4#8030: Fixed service 0x12 0x02 response length                              EA4#8730
* 12/07/16   33      HM        EA4#8749: Updated rationality for CPID FD                                      EA4#8847
* 12/15/16   34      HM        EA4#6720: Replaced Dem_Cfg_GlobalDtcCount, Dem_Cfg_GlobalStatusMask functions
*                                        with DEM_CFG_GLOBAL_DTC_COUNT, DEM_CFG_GLOBAL_STATUS_MASK constants  EA4#8935
* 12/15/16   35      HM        EA4#8204: Updated rationality conditions for services 0x04 and 0x28.           EA4#8958
*                              EA4#8105: MfgOvrlDi is set when DVT Security Access is UNLOCKED.               EA4#8958
* 12/22/16   36      JWJ       Updates for new shutdown sequence for reprogramming requests                   EA4#9036
* 02/07/17   37      HM        EA4#6561: Updated rationality for CPID 02                                      EA4#9707
* 02/07/17   38      HM        EA4#8807: Updated to CDD version 19.0.4_60, generated function templates       EA4#9717
* 02/07/17   39      HM        EA4#8807: Updated rationality for DIDs 0x02, 0x90, 0x98, 0x99                  EA4#9718
* 02/09/17   40      HM        EA4#8807: Added PIDs 0x4303, 0x4304 for Maximum Hand Wheel Angle Traveled      EA4#9783
* 02/12/17   41      HM        EA4#8807: Added DID 0xA1                                                       EA4#9817
* 02/13/17   42      HM        EA4#8807: Changed Scaling Factor, Offset for PIDs 0x4303, 0x4304               EA4#9783
**********************************************************************************************************************/

/* -----------------------------------------------------------------------------
    &&&~ Includes
 ----------------------------------------------------------------------------- */

/* Physical layer specific API */
#include "v_inc.h"
/* Check if CCL is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCL)
# include "ccl_cfg.h"
#endif

/* Check if CCLcom is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCLCOM)
# include "cclcom_cfg.h"
#endif

/* Make all CANdesc specific typedefs available */
#include "desc.h"
/* Include the implementation prototypes for prototype checks */
#include "appdesc.h"
#include "BswM.h"
#include "fbl_def.h"
#include "fbl_cfg.h"
#include "gmheader.h"
#include "Os.h"
#include "ram_regs.h"
#include "NxtrMcuSuprtLib.h"
#include "Rte_CustDiagc.h"
#include "NxtrMath.h"
#include "NxtrFixdPt.h"
#include "ArchGlbPrm.h"
#include "DiagcMgr.h"
#include "Dem_Dcm.h"
#include "gmnmdef.h"


/* This definition is not defined in DiagcMgr.h so it was added locally. */
#define WARNINGIND_CNT_U08  0x80u


/* Extended negative response codes used by CPID environmental checks */
#define NOERR_CNT_U16            0x0000U   /* No error */
#define VEHSPDFLTDETD_CNT_U16    0x0402U   /* Vehicle speed fault detected extra byte */
#define ENGSPDNOTZERO_CNT_U16    0x0201U   /* Engine speed not zero extra byte */
#define FLTDETD_CNT_U16          0x0308U   /* Fault detected extra byte */
#define HWTQABVCAL_CNT_U16       0x804BU   /* Handwheel torque is above calibrated value. */
#define VEHSPDABVCAL_CNT_U16     0x2801U   /* Vehcile speed above maximum. */
#define SECUCODFCTLOCKD_CNT_U16  0xFE03U   /* Security Code Function Locked */

/* Test enable bits for CPID environmental checks */
#define TESTVEHSPD_CNT_U08                      0x01U
#define TESTMISSMSG0C9ORENGRUN_CNT_U08          0x02U
#define TESTENGRUN_CNT_U08                      0x04U
#define TESTSECUACS_CNT_U08                     0x08U
#define TESTHWTQ_CNT_U08                        0x10U


/* Return buffer variable */
#define CMNMFGSRV_START_SEC_VAR_NOINIT_8GS
#include "CmnMfgSrv_NxtrMemMap.h"
VAR(uint8, CmnMfgSrv_VAR) CustDiagcRetBuf_G;
#define CMNMFGSRV_STOP_SEC_VAR_NOINIT_8GS
#include "CmnMfgSrv_NxtrMemMap.h"


/* Function Prototypes */
STATIC FUNC(uint16, AUTOMATIC) EnvtlChk(VAR(vuint8, AUTOMATIC) TestMask_Cnt_T_b08, VAR(float32, AUTOMATIC) VehSpdThd_Kph_T_f32);
STATIC FUNC(Std_ReturnType, AUTOMATIC) GetStHlthStcMin(VAR(StHlthMonSig2, AUTOMATIC) Sig_Cnt_T_enum, P2VAR(uint8, AUTOMATIC, AUTOMATIC) Min_Ptr_T_u08);
STATIC FUNC(Std_ReturnType, AUTOMATIC) GetStHlthStcPrsnt(VAR(StHlthMonSig2, AUTOMATIC) Sig_Cnt_T_enum, P2VAR(uint8, AUTOMATIC, AUTOMATIC) Prsnt_Ptr_T_u08);


/* -----------------------------------------------------------------------------
    &&&~ Implementation
 ----------------------------------------------------------------------------- */

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# if defined (CCL_ENABLE_ERROR_HOOK) || defined (CCLCOM_ENABLE_ERROR_HOOK)
/* CCL takes care about this function */
# else
/* ********************************************************************************
 * Function name:ApplDescFatalError
 * Description: This function will be called each time while the debug mode is active a
 * CANdesc fault has been detected. If you reach this function it makes no sence to continue the tests since CANdesc
 * will not operate properly until next start of the ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - errorCode:
 *       - The assert code text equivalent can be found in desc.h (kDescAssert....).
 *       - Access type: read
 *   - lineNumber:
 *       - Since the same fault could be cales on many places the line number shows where exactly it occured.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - Set a break point at this place to know during the ECU development if you ran onto it.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescFatalError(vuint8 errorCode, vuint16 lineNumber)
{
	/* Avoid warnings */
	DESC_IGNORE_UNREF_PARAM(errorCode);
	DESC_IGNORE_UNREF_PARAM(lineNumber);

	/* When fatal error occurs, cause an ECU hang up at this point.
	* Please set break point at this line to investigate both parameter values. */
	for(;;);
}
# endif
#endif

/*  ********************************************************************************
 * Function name:ApplDescRcrRpConfirmation
 * Description:Will be called only if "DescForceRcrRpResponse" has been previously called.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 *   - status:
 *       - Current RCR-RP transmission status (kDescOk/kDescFailed).
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may be called to close the service processing.
 *   - The function "DescSetNegResponse" may be called to set a negative response.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRcrRpConfirmation(vuint8 iContext, vuint8 status)
{
	/* Avoid warnings */
	DESC_CONTEXT_PARAM_DUMMY_USE;

	/* Check the transmission status */
	if(status == kDescOk)
	{
		/* "Response Pending" was just successfully sent, you can perform any further action knowing that
		 * from now on the tester has restarted its response timeout timer and set the next time to P2* (P2Ex)
		 */
	}
	else
	{
		/* There was some transmission error and the tester didn't received the RCR-RP response. You can decide to go on
		 * or to reset the application activity you have started and wait for a new request from the tester.
		 */
	}
}


/*  ********************************************************************************
 * Function name:ApplDescOnTransitionSecurity_Access
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionSecurity_Access(DescStateGroup newState, DescStateGroup formerState)
{
	/* Avoids warnings */
	DESC_IGNORE_UNREF_PARAM(newState);
	DESC_IGNORE_UNREF_PARAM(formerState);
}


/*  ********************************************************************************
 * Function name:ApplDescOnTransitionProgrammingMode
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionProgrammingMode(DescStateGroup newState, DescStateGroup formerState)
{
  /* Avoids warnings */
  DESC_IGNORE_UNREF_PARAM(newState);
  DESC_IGNORE_UNREF_PARAM(formerState);
}


/* Diagnostic application state management */
/* ********************************************************************************
 * Function name:ApplDescOnDiagActive
 * Description: Application notification that since the VNDiagnostic has been disable this is the first request.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnDiagActive(void)
{
	/* Nothing to do here */
}

/* ********************************************************************************
 * Function name:ApplDescOnDiagInactive
 * Description: Application notification that the VNDiagnostic has timed out.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnDiagInactive(void)
{
	/* Nothing to do here */
}

#if defined (DESC_ENABLE_SERVICE_10_02)
/* ********************************************************************************
 * Function name:ApplDescOnDisableAllDtc
 * Description: Application notification that "DisableAllDTC" operation mode was just requested.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnDisableAllDtc(void)
{
	(void)CallNonTrustedFunction(NtWrapS_CustDiagc_DemDcmDisableDTCSetting, NULL_PTR);
}
#endif

#if defined (DESC_ENABLE_SERVICE_10_03)
/* ********************************************************************************
 * Function name:ApplDescOnEnableDtcsDuringDevCntrl
 * Description: Application notification that "DTCMayChangeDuringDeviceControlMode" operation mode was just requested.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnEnableDtcsDuringDevCntrl(void)
{
	(void)CallNonTrustedFunction(NtWrapS_CustDiagc_DemDcmEnableDTCSetting, NULL_PTR);
}
#endif

/* ********************************************************************************
 * Function name:ApplDescOnReturnToNormalMode
 * Description: Application notification that the ECU must deactivate all diagnostics.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnReturnToNormalMode(void)
{
	/* Reset any attempts at security access forcing the user to start the process over */
	*Rte_Pim_CustDiagcProgmSessionSeedReqd() = FALSE;
	*Rte_Pim_CustDiagcCtrlPidSeedReqd() = FALSE;

	ApplDescOnEnableNormalComm();
}

/* ********************************************************************************
 * Function name:ApplDescOnDisableNormalComm
 * Description: Application notification that the communication was disabled.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnDisableNormalComm(void)
{
	(void)Rte_Write_SerlComDi_Logl(TRUE);
	IlNwmNormalCommHalted(kCanChannel_HS);
}

/* ********************************************************************************
 * Function name:ApplDescOnEnableNormalComm
 * Description: Application notification that the communication was restored.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnEnableNormalComm(void)
{
	(void)Rte_Write_SerlComDi_Logl(FALSE);

	IlNwmReturnToNormalMode(kCanChannel_HS);

	/* Reactivate all virtual networks */
	IlNwmActivateVN(kCanChannel_HS, VN_SLHSSharedDiagnostic);
	IlNwmActivateVN(kCanChannel_HS, VN_AllNodes);
	IlNwmActivateVN(kCanChannel_HS, VN_SLHS_VNReq);
}

#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
/* ********************************************************************************
 * Function name:ApplDescForceEcuReset
 * Description: Application notification that the ECU must be reseted now.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescForceEcuReset(void)
{
	/* TODO: Support ECU reset once resets are setup */
}
#endif

/*  ********************************************************************************
 * Function name:ApplDescClearDiagnosticInformation (Service request header:$4 )
 * Description:The DTCs listed in this section (and corresponding FTBs) are required for AVG and
 * Service and Parts Operations to perform assembly plant testing, flash
 * programming, configuration, diagnosis and repair of vehicles.
 * 
 * DTC assignments shall conform to the General Motors Body/Chassis/Network
 * Communication (BCNC) Common Diagnostic Trouble Codes Specification
 * <http://spo.gm.com/dept/eng/service/general/index.shtml>
 * 
 * FTB assignments shall conform to the GMLAN Enhanced Diagnostic Test Mode
 * Specification (GMW 3110).
 * 
 * Failure Records
 * A failure record is a collection of parameters pertaining to system operation at
 * the time a DTC is detected (status bit 1, Current DTC = True).  Failure record
 * numbering will range from $01 to N (N = maximum number of failure records
 * supported).  EPS failure records will have PID based data (see Failure Record
 * Content below).  The number of failure records supported will be determined
 * during the diagnostic review.  At minimum, 10 failure records shall be
 * supported.
 * Determine Failure Record To Use 
 * This process is activated only when a failure has been reported.  This process
 * shall examine the previously stored Failure Records to see if any of the
 * Diagnostic Trouble Codes (DTCs) already captured match the DTC that is currently
 * failing.  If a matching DTC is found, the data contained within that failure
 * record will be updated.  If no matching DTC record is found among the DTC records
 * stored in the failure record buffer, then the DTC and data shall be stored in the
 * next failure record position within the buffer. If the buffer is full, then the
 * oldest data will be overwritten with the current failing DTC.  Only one failure
 * record update shall occur per ignition cycle or VN activation.
 * Clearing of Failure Record
 * All DTCs with corresponding DTC Status and Failure Type information shall be
 * cleared after 40 consecutive ignition on/off cycles with at least one test pass
 * and no test fail result for any DTCs in each ignition cycle.  If Failure Records
 * have been stored, the content of the failure records shall be cleared and made
 * available for a new failure record storage by any DTC.  The expected behavior of
 * the ECU is exactly the same if a scan tool "Clear Codes" command was received
 * except there shall not be a diagnostic response message generated.
 * Another way to clear failure record is via a scan tool "Clear Codes" command
 * (Service $04).
 * Failure Record Content
 * At minimum following PIDs shall be captured in a failure record.  Any additional
 * information will be determined during the diagnostic review.
 * PID #	PID Description
 * 4016:	Ignition Cycle Counter
 * 401B:	ECU Internal Temperature
 * 4074:	Steering Wheel Angle
 * 40AC:	Steering Input Torque
 * 40AD:	EPS Motor Overload Protection Incidents
 * 40BC:	Engine Speed
 * 40BD:	Vehicle Speed
 * 41D3:	Electric Power Steering Motor Current Commanded
 * 41D4:	Electric Power Steering Motor Current Feedback
 * 41D5:	Electric Power Steering Torque Overlay Status
 * 41D6:	Electric Power Steering Angle Overlay Status
 * 41D7:	Electric Power Steering Torque Overlay Requested
 * 41D8:	Electric Power Steering Angle Overlay Requested
 * 41D9:	Steering Output Torque
 * 43D0:	Electric Power Steering Stop Start Status
 * 8002:	System Power Mode
 * 8078:	Battery Voltage ECU Monitored
 * C000:	Supplier Internal DTC Info
 * C050:	Time Since Ignition On
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescClearDiagnosticInformation(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) RespCod_Cnt_T_u16;
	
	RespCod_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08, 3.0f);

	/* Perform clear operation under following conditions:                      */
	/* - if vehicle speed is considered missing or invalid                      */
	/* - if vehicle speed is valid and vehicle speed is less than the threshold */
	if ((VEHSPDFLTDETD_CNT_U16 == RespCod_Cnt_T_u16) || (NOERR_CNT_U16 == RespCod_Cnt_T_u16))
	{
		CallNonTrustedFunction(NtWrapS_CustDiagc_ClrAllDiagc, NULL_PTR);
		(void)Rte_Call_ClrTrigStsAry_Oper();
	}
	else
	{
		/* Failed rationality check -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadFailureRecordData (Service request header:$12 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request byte after the Sid.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response after the Sid.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the service request length, excluding Sid byte only.
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the total service response length, excluding the Sid only.
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadFailureRecordData(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Idx_Cnt_T_u08;
	VAR(uint8, AUTOMATIC) Cnt_Cnt_T_u08;
	VAR(uint8, AUTOMATIC) UdsSts_Cnt_T_u08;
	VAR(uint32, AUTOMATIC) DtcNr_Cnt_T_u32;

	pMsgContext->resData[0U] = pMsgContext->reqData[0U];
	pMsgContext->resDataLen = 1U;

	if (pMsgContext->reqData[0U] == 0x01U)
	{
		/* 0x00 = PID response */
		pMsgContext->resData[1U] = 0x00U;
		pMsgContext->resDataLen += 1U;
		Cnt_Cnt_T_u08 = 0U;

		/* Loop through each CTC */
		for (Idx_Cnt_T_u08 = 1U; Idx_Cnt_T_u08 <= DEM_CFG_GLOBAL_DTC_COUNT; Idx_Cnt_T_u08 += 1U)
		{
			/* Fetch DTC status */
			(void)Dem_GetEventStatus(Idx_Cnt_T_u08, &UdsSts_Cnt_T_u08);

			/* If this DTC is FAILED */
			if ((UdsSts_Cnt_T_u08 & (DEM_UDS_STATUS_TF | DEM_UDS_STATUS_CDTC)) != 0U)
			{
				/* Add it to the response */
				(void)Dem_GetDTCOfEvent(Idx_Cnt_T_u08, DEM_DTC_KIND_ALL_DTCS, &DtcNr_Cnt_T_u32);
				pMsgContext->resData[(Cnt_Cnt_T_u08 * 4U) + 2U] = Cnt_Cnt_T_u08;
				pMsgContext->resData[(Cnt_Cnt_T_u08 * 4U) + 3U] = (uint8)((DtcNr_Cnt_T_u32 >> 16U) & 0xFFU);
				pMsgContext->resData[(Cnt_Cnt_T_u08 * 4U) + 4U] = (uint8)((DtcNr_Cnt_T_u32 >> 8U) & 0xFFU);
				pMsgContext->resData[(Cnt_Cnt_T_u08 * 4U) + 5U] = (uint8)((DtcNr_Cnt_T_u32) & 0xFFU);
				pMsgContext->resDataLen += 4U;
				Cnt_Cnt_T_u08 += 1U;
			}
		}
		DescProcessingDone(pMsgContext->iContext);
	}
	else if (pMsgContext->reqData[0U] == 0x02)
	{
		DtcNr_Cnt_T_u32 = (((uint32)pMsgContext->reqData[2U] << 16U) |
		                   ((uint32)pMsgContext->reqData[3U] << 8U) |
		                    (uint32)pMsgContext->reqData[4U]);

		pMsgContext->resData[1U] = pMsgContext->reqData[1U];
		pMsgContext->resData[2U] = pMsgContext->reqData[2U];
		pMsgContext->resData[3U] = pMsgContext->reqData[3U];
		pMsgContext->resData[4U] = pMsgContext->reqData[4U];
		pMsgContext->resDataLen += 4U;


		CallNonTrustedFunction(NtWrapS_CustDiagc_DiDtcRecUpd, &DtcNr_Cnt_T_u32);
		*Rte_Pim_DtcNr() = DtcNr_Cnt_T_u32;
		*Rte_Pim_MsgCntxt() = (uint32)(void*)pMsgContext;
		*Rte_Pim_Srv12LoopCntr() = 2U;
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, kDescNrcSubfunctionNotSupported);
		DescProcessingDone(pMsgContext->iContext);
	}
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_02_Calibration_Programmed_Status (Service request header:$1A $2 )
 * Description:This DID contains a flag to determine if the calibration files have been
 * programmed.  The default value for this DID is $AA.  After the calibration files
 * have been programmed, the utility file will write this DID to be a value of $55,
 * indicating that programming of the calibration files has been successfully
 * completed.  
 * 
 * This DID shall not be written unless the following conditions are met:
 * Vehicle Speed < 3 km/h
 * Vehicle Speed Validity = Valid
 * Propulsion System Active = FALSE
 * When Service $28 (Disable Normal Communication) is active, signals for
 * rationalitly will hold the last known values of Vehicle Speed, Vehicle Speed
 * Validity, and Propulsion System Active.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_02_Calibration_Programmed_Status(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrCalProgdStsRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_90_Vehicle_Identification_Number (Service request header:$1A $90 )
 * Description:This DID contains the Vehicle Identification Number.  The data content shall be
 * specified by the vehicle manufacturer.  If the VIN has not yet been programmed
 * into the ECU's permanent memory, those locations shall be either '$00' or '$FF'. 
 * All 17 digits must be programmed in order for the ECU to use this DID.  If the
 * ECU does not store all 17 digits, then the ECU shall use an application specific
 * DID to store the VIN digits.  
 * 
 * This DID shall not be written unless the following conditions are met:
 * Vehicle Speed < 3 km/h
 * Vehicle Speed Validity = Valid
 * Propulsion System Active = FALSE
 * When Service $28 (Disable Normal Communication) is active, signals for
 * rationalitly will hold the last known values of Vehicle Speed, Vehicle Speed
 * Validity, and Propulsion System Active.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_90_Vehicle_Identification_Number(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrVinDataRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 17U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_97_System_Name_Or_Engine_Type (Service request header:$1A $97 )
 * Description:This DID contains the System Name or Engine Type which identifies the electronic
 * system name (e.g. Automatic Transmission with 2.0 L engine: GS820 X20XEV) or
 * engine type (X30XE) installed.  The data shall always be of type ASCII.  The
 * length is variable (depends on length of string) but shall not exceed 20
 * characters.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_97_System_Name_Or_Engine_Type(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrSysNameRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 20U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_98_Repair_Shop_Code_Or_Tester_Serial_Number (Service request header:$1A $98 )
 * Description:This DID contains the Repair Shop Code Or Tester Serial Number which identifies
 * the dealers code or the testers serial number.  This ASCII string is programmed
 * into the ECUs memory via the Utility File during the last programming session
 * (SPS) at the dealer site.
 * 
 * This DID shall not be written unless the following conditions are met:
 * Vehicle Speed < 3 km/h
 * Vehicle Speed Validity = Valid
 * Propulsion System Active = FALSE
 * When Service $28 (Disable Normal Communication) is active, signals for
 * rationalitly will hold the last known values of Vehicle Speed, Vehicle Speed
 * Validity, and Propulsion System Active.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_98_Repair_Shop_Code_Or_Tester_Serial_Number(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrLstRepairShopCodRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 10U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_99_Programming_Date (Service request header:$1A $99 )
 * Description:This DID contains the Programming Date of the last programming event (SPS) at the
 * dealer site.  This BCD value is programmed into the ECUs memory via the Utility
 * File during the last programming session (SPS).
 * Example: January 22, 2000 would be encoded as $20 $00 $01 $22.
 * 
 * This DID shall not be written unless the following conditions are met:
 * Vehicle Speed < 3 km/h
 * Vehicle Speed Validity = Valid
 * Propulsion System Active = FALSE
 * When Service $28 (Disable Normal Communication) is active, signals for
 * rationalitly will hold the last known values of Vehicle Speed, Vehicle Speed
 * Validity, and Propulsion System Active.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_99_Programming_Date(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrProgmDateRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 4U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_9F_Previous_Stored_Repair_Shop_Code_Or_Tester_Serial_Number (Service request header:$1A $9F )
 * Description:This DID contains the Previous Stored Repair Shop Code Or Tester Serial Numbers. 
 * This data provides a mechanism for a tool user to identify up to the last two
 * dealer codes or tester serial numbers programmed into DID $98.
 * 
 * Last Stored Repair Shop Code or Tester Serial Number
 * When a test tool writes a dealer code or tester serial number into DID $98, the
 * data previously stored in DID $98 is copied (without additional tester
 * intervention) into the module memory housing byte positions 0 through 9 of this
 * DID.
 * 
 * Second from Last Stored Repair Shop Code or Tester Serial Number
 * When a test tool writes a dealer code or tester serial number into DID $98, the
 * data previously in byte positions 0 through 9 of this DID are moved to positions
 * 10 through 19.  The data previously stored in DID $98 are then copied into this
 * DID in byte positions 0 through 9.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_9F_Previous_Stored_Repair_Shop_Code_Or_Tester_Serial_Number(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrRepairShopCodRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 20U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_A0_Manufacturers_Enable_Counter (Service request header:$1A $A0 )
 * Description:This DID contains the MEC which is used when determining the current status of
 * ECU security and/or as an in assembly plant mode indication.  Assembly Plant
 * Mode is a state of the ECU where normal operation is modified in order to
 * facilitate the manufacturing process.
 * Supplier shall set the MEC to $FE when shipped to GM vehicle assembly or to a $00
 * when shipped to GM service. It is the responsibility of GM manufacturing to set
 * the MEC to zero at the end of assembly process.
 * 
 * A node shall not allow the value of the MEC to change once it becomes $00.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_A0_Manufacturers_Enable_Counter(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrCustMfgEnaCntrRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_A1_ECU_Configuration_Data (Service request header:$1A $A1 )
 * Description:This DID contains information regarding the enable and disable status for
 * advanced EPS features which have been calibrated on/off via data contained in the
 * System Calibration File.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_A1_ECU_Configuration_Data(DescMsgContext* pMsgContext)
{
    VAR(uint8, AUTOMATIC) EcuCfgData_Cnt_T_u08 = 0u;

    /* Bit 0: 12V Start Stop Enabled */
    if (TRUE == Rte_Prm_GmStrtStopEna_Logl())
    {
        EcuCfgData_Cnt_T_u08 |= (uint8)(1U << 0U);
    }

    /* Bit 1: Lane Keep Assist Enabled */
    if (TRUE == Rte_Prm_GmOvrlStMgrLkaMfgEna_Logl())
    {
        EcuCfgData_Cnt_T_u08 |= (uint8)(1U << 1U);
    }

    /* Bit 2: Advanced Park Assist Enabled */
    if (TRUE == Rte_Prm_GmOvrlStMgrApaMfgEna_Logl())
    {
        EcuCfgData_Cnt_T_u08 |= (uint8)(1U << 2U);
    }

    /* Bit 3: Smooth Road Shake Enabled */
    if (TRUE == Rte_Prm_WhlImbRejctnFctEna_Logl())
    {
        EcuCfgData_Cnt_T_u08 |= (uint8)(1U << 3U);
    }

    /* Bit 4: Brake Pulse Compensation Enabled */
    if (TRUE == Rte_Prm_InertiaCmpVelDecelGainEnaCal_Logl())
    {
        EcuCfgData_Cnt_T_u08 |= (uint8)(1U << 4U);
    }

    /* Bit 5: Lead / Pull Compensation Enabled */
    if (TRUE == Rte_Prm_PullCmpActvEna_Logl())
    {
        EcuCfgData_Cnt_T_u08 |= (uint8)(1U << 5U);
    }

    /* Bit 6 (Not Supported): Torque Steer Mitigation Enabled */

    /* Bit 7: ECBM Torque Overlay Enabled */
    if (TRUE == Rte_Prm_GmOvrlStMgrEscMfgEna_Logl())
    {
        EcuCfgData_Cnt_T_u08 |= (uint8)(1U << 7U);
    }

    pMsgContext->resData[0U] = EcuCfgData_Cnt_T_u08;
    pMsgContext->resDataLen = 1U;

    DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDid_DID_AB_Compressed_Vehicle_Partitioning_and_Product_Structure_CVPPS (Service request header:$1A $AB )
 * Description:This DID contains the data necessary to meet the component traceability
 * requirements as specified in GMW4710 and GMW15862.  This DID contains the
 * compressed VPPS assigned to the component.  The first 13 characters are used for
 * the compressed VPPS and the last character is used in the event two components
 * have the same VPPS.  The periods (dots) in the VPPS shall not be encoded in this
 * DID (see example).  This field is populated at the time of component
 * manufacturing by the manufacturer.  If less than 13 characters are required to
 * uniquely identify an VPPS, then the trailing characters shall be filled with
 * zeroes ($30).  The last character shall be set to a value per the table below.
 * The default value for the last character shall be X
 * 
 * Example
 * VPPS = 739.98
 * DID $AB = $37 $33 $39 $39 $38 $30 $30 $30 $30 $30 $30 $30 $30 $30 $58
 * 
 * Vehicle Partitioning and Product Structure (VPPS) 
 * The Vehicle Partitioning and Product Structure (VPPS) is a globally consistent
 * means for describing vehicle content
 * (http://gmna1.gm.com/eng/grc/vpps/index.html).  VPPS is a hierarchical structure
 * that has consistency across major vehicle areas (Powertrain, Chassis, etc.). 
 * VPPS is a mechanism that allows data sharing/comparing across systems globally
 * (GMNA, GME, GMLAAM, GMAP, etc.). VPPS is a standard global product breakdown
 * structure approved by GEDOC (NOA 002) and GADVC (NOA 012). Changes are managed
 * via the global process. Contact KCDS for assistance. 
 * 
 * Table C1: Codes for Least Significant Character Position of the Compressed VPPS
 * to Signify Vehicle Mounting Location - Default is X
 * 
 * Character	Definition 			Character 	Definition 	
 * A 			reserved 				N 			Neither 	
 * B 			reserved 				O 			Do Not Use
 * C 			reserved 				P 			reserved
 * D 			reserved 				Q 			Do Not Use
 * E 			Roof Left Rear			R 			Right
 * F 			Roof Left Front 		S 			reserved
 * G 			Roof Right Rear		T 			Left Rear
 * H 			Roof Right Front		U 			Left Front
 * I 			Do Not Use			V 			Right Rear
 * J 			reserved 				W 			Right Front
 * K 			Roof Rear 			X 			DEFAULT
 * L 			Left 					Y 			Front
 * 
 * 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDid_DID_AB_Compressed_Vehicle_Partitioning_and_Product_Structure_CVPPS(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrCmpdVehPartnProdtStructRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 14U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_B0_ECU_Diagnostic_Address (Service request header:$1A $B0 )
 * Description:This DID contains the diagnostic address of an ECU.  This DID shall be supported
 * by all ECUs when executing operational software and by SPS_TYPE_B ECUs when
 * executing boot software.
 * 
 * SPS_TYPE_B and SPS_TYPE_C ECUs are programmable ECUs that are missing some
 * element of their full combination of operational software and calibrations, or
 * are executing boot software due to a memory error.  An SPS_TYPE_B ECU meets the
 * above criteria and has its permanent diagnostic CAN Ids preprogrammed. An
 * SPS_TYPE_C ECU meets the above criteria and does not have its permanent
 * diagnostic CAN Ids preprogrammed.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_B0_ECU_Diagnostic_Address(DescMsgContext* pMsgContext)
{
	/* Diagnostic Address according to SER */
	pMsgContext->resData[0U] = 0x31U;
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_B3_Data_Universal_Numbering_System_Identification_DUNS (Service request header:$1A $B3 )
 * Description:This DID contains the data necessary to meet the component traceability
 * requirements as specified in GMW4710 and GMW15862.  This DID contains the DUNS Id
 * assigned to the component suppliers manufacturing site. 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_B3_Data_Universal_Numbering_System_Identification_DUNS(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrDataUniversalNrSysIdRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 9U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_B4_Manufacturing_Traceability_Characters (Service request header:$1A $B4 )
 * Description:This DID contains the data necessary to meet the component traceability
 * requirements as specified in GMW4710 and GMW15862.  The length of this DID is
 * variable but shall not exceed 16 characters.  These fields are populated at the
 * time of component manufacturing by the manufacturer.  The ECU specific CTS or
 * supplemental diagnostic specification referenced by the CTS or SSTS must document
 * how the fields are to be populated.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_B4_Manufacturing_Traceability_Characters(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrNxtrMfgTrakgRd_Oper(pMsgContext->resData);
	(void)Rte_Call_PartNrCcaMfgTrakgRd_Oper(&pMsgContext->resData[7U]);
	pMsgContext->resDataLen = 16U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_C0_Boot_Software_Part_Number (Service request header:$1A $C0 )
 * Description:A 4 byte USN representation of the 8 digit GM part number assigned to the boot
 * software of the ECU.
 * If an Alpha Code is used, then the Alpha Code associated with this part number
 * shall be stored in DID $D0.
 * * See Note 1 at the beginning of this section.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_C0_Boot_Software_Part_Number(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0U] = GetFblSWMI0();
	pMsgContext->resData[1U] = GetFblSWMI1();
	pMsgContext->resData[2U] = GetFblSWMI2();
	pMsgContext->resData[3U] = GetFblSWMI3();
	pMsgContext->resDataLen = 4U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_C1_Software_Module_Identifier_1_Operational_Application_Soft (Service request header:$1A $C1 )
 * Description:DIDs ranging from $C1 to $CA contain Software Module Identifier (SWMI)
 * information (a 4 byte USN representation of the 8 digit GM part number) used to
 * uniquely identify a given software or calibration module. The SWMI shall be
 * included in each software module that can be separately programmed into the ECUs
 * permanent memory via the SPS. Individual software modules can contain Operational
 * software or Calibration data.
 * If an Alpha Code (or Design Level Suffix) corresponding to this Software Module
 * Identifier is supported, then this information shall be stored in DID $D1.
 * * See Note 1 at the beginning of this section.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_C1_Software_Module_Identifier_1_Operational_Application_Soft(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0U] = DescGetHiByte(SwapEndianess_m(GM_ApplHeader.PART_NO[0U]));
	pMsgContext->resData[1U] = DescGetLoByte(SwapEndianess_m(GM_ApplHeader.PART_NO[0U]));
	pMsgContext->resData[2U] = DescGetHiByte(SwapEndianess_m(GM_ApplHeader.PART_NO[1U]));
	pMsgContext->resData[3U] = DescGetLoByte(SwapEndianess_m(GM_ApplHeader.PART_NO[1U]));
	pMsgContext->resDataLen = 4U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_C2_Software_Module_Identifier_2_Performance_Calibration (Service request header:$1A $C2 )
 * Description:Reference DID $C1 for a description of this DID's usage.
 * If an Alpha Code (or Design Level Suffix) corresponding to this Software Module
 * Identifier is supported, then this information shall be stored in DID $D2.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_C2_Software_Module_Identifier_2_Performance_Calibration(DescMsgContext* pMsgContext)
{
	/* This DID reads the "performance" cals stored in region 3 */
	pMsgContext->resData[0U] = DescGetHiByte(SwapEndianess_m(GM_Cal3Header.PART_NO[0U]));
	pMsgContext->resData[1U] = DescGetLoByte(SwapEndianess_m(GM_Cal3Header.PART_NO[0U]));
	pMsgContext->resData[2U] = DescGetHiByte(SwapEndianess_m(GM_Cal3Header.PART_NO[1U]));
	pMsgContext->resData[3U] = DescGetLoByte(SwapEndianess_m(GM_Cal3Header.PART_NO[1U]));
	pMsgContext->resDataLen = 4U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_C3_Software_Module_Identifier_3_Feature_Enable_Disable_Calib (Service request header:$1A $C3 )
 * Description:Reference DID $C1 for a description of this DID's usage.
 * If an Alpha Code corresponding to this Software Module Identifier is supported,
 * then this information shall be stored in DID $D3.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_C3_Software_Module_Identifier_3_Feature_Enable_Disable_Calib(DescMsgContext* pMsgContext)
{
	/* This DID reads the "System Cal" cals stored in region 1 */
	pMsgContext->resData[0U] = DescGetHiByte(SwapEndianess_m(GM_Cal2Header.PART_NO[0U]));
	pMsgContext->resData[1U] = DescGetLoByte(SwapEndianess_m(GM_Cal2Header.PART_NO[0U]));
	pMsgContext->resData[2U] = DescGetHiByte(SwapEndianess_m(GM_Cal2Header.PART_NO[1U]));
	pMsgContext->resData[3U] = DescGetLoByte(SwapEndianess_m(GM_Cal2Header.PART_NO[1U]));
	pMsgContext->resDataLen = 4U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_C4_Software_Module_Identifier_4_Non_Variant_Calibration (Service request header:$1A $C4 )
 * Description:Reference DID $C1 for a description of this DID's usage.
 * If an Alpha Code corresponding to this Software Module Identifier is supported,
 * then this information shall be stored in DID $D4.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_C4_Software_Module_Identifier_4_Non_Variant_Calibration(DescMsgContext* pMsgContext)
{
	/* This DID reads the "System Cal 2" cals, also known as feature cals, stored in region 2 */
	pMsgContext->resData[0U] = DescGetHiByte(SwapEndianess_m(GM_Cal1Header.PART_NO[0U]));
	pMsgContext->resData[1U] = DescGetLoByte(SwapEndianess_m(GM_Cal1Header.PART_NO[0U]));
	pMsgContext->resData[2U] = DescGetHiByte(SwapEndianess_m(GM_Cal1Header.PART_NO[1U]));
	pMsgContext->resData[3U] = DescGetLoByte(SwapEndianess_m(GM_Cal1Header.PART_NO[1U]));
	pMsgContext->resDataLen = 4U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_CB_End_Model_Part_Number (Service request header:$1A $CB )
 * Description:As used by EPS, this number represents the End Model Part Number of the ECU and
 * the specific steering gear installed.
 * This DID is used to identify the part number that represents the combination of
 * hardware / software / calibrations present in the ECU as it is received in the
 * vehicle assembly plant.  This part number is also used in service to uniquely
 * identify the combination of hardware / software / calibrations programmed into
 * the ECU at the time the part is ordered.
 * If an Alpha Code is used, then the Alpha Code associated with this part number
 * shall be stored in DID $DB.
 * * See Note 1 at the beginning of this section.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_CB_End_Model_Part_Number(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrEndMdlPartNrRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 4U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_CC_Base_Model_Part_Number (Service request header:$1A $CC )
 * Description:As used by EPS, this number represents the End Model Part Number of the ECU
 * only.
 * This DID is used to identify the part number that represents the unique
 * combination of ECU hardware and all non-reprogrammable software (e.g. Boot
 * software) which is used during SPS programming. The BMPN must be stored in the
 * ECU in a non-erasable memory area (e.g. boot sector of flash, or EEPROM). It
 * shall not be possible to change the BMPN as part of a programming session or
 * through diagnostic services when a programming session is not active. The BMPN of
 * a service replacement ECU shall be identical to that of a Production ECU if
 * both ECUs have the same hardware and non-reprogrammable software.
 * If an Alpha Code is used, then the Alpha Code associated with this part number
 * shall be stored in DID $DC.
 * * See Note 1 at the beginning of this section.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_CC_Base_Model_Part_Number(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrBasMdlPartNrRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 4U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_D0_Boot_Software_Part_Number_Alpha_Code (Service request header:$1A $D0 )
 * Description:This DID contains a 2 character ASCII representation of the Alpha Code associated
 * with the Boot Software Part Number (stored in DID $C0). The Alpha Code consists
 * of a Design Level Suffix (DLS) and a Process Level Suffix (PLS).
 * Byte 1 (DLS)
 * This byte is contains an ASCII value that represents the major software release.
 * This value shall initially be set to A and incremented as appropriate.
 * Byte 2 (PLS)
 * This byte is contains an ASCII value that represents the minor software revision.
 * This value shall initially be set to A and incremented as appropriate.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_D0_Boot_Software_Part_Number_Alpha_Code(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0U] = GetFblDLS0();
	pMsgContext->resData[1U] = GetFblDLS1();
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_D1_Software_Module_Identifier_1_Alpha_Code (Service request header:$1A $D1 )
 * Description:This DID contains a 2 character ASCII representation of the Alpha Code for the
 * corresponding Software Module Identifier (SWMI). The SWMIs occupy the DID range
 * $C1 to $CA. The Alpha Code consists of a Design Level Suffix (DLS) and a Process
 * Level Suffix (PLS).
 * Byte 1 (DLS)
 * This byte is contains an ASCII value that represents the major software release.
 * This value shall initially be set to A and incremented as appropriate.
 * Byte 2 (PLS)
 * This byte is contains an ASCII value that represents the minor software revision.
 * This value shall initially be set to A and incremented as appropriate.
 * 
 * This DID corresponds with DID $C1.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_D1_Software_Module_Identifier_1_Alpha_Code(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0U] = DescGetHiByte(SwapEndianess_m(GM_ApplHeader.DLS));
	pMsgContext->resData[1U] = DescGetLoByte(SwapEndianess_m(GM_ApplHeader.DLS));
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_D2_Software_Module_Identifier_2_Alpha_Code (Service request header:$1A $D2 )
 * Description:Reference DID $D1 for a description of this DID's usage.
 * This DID corresponds with DID $C2.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_D2_Software_Module_Identifier_2_Alpha_Code(DescMsgContext* pMsgContext)
{
	/* This DID reads the "performance" cals stored in region 3 */
	pMsgContext->resData[0U] = DescGetHiByte(SwapEndianess_m(GM_Cal3Header.DLS));
	pMsgContext->resData[1U] = DescGetLoByte(SwapEndianess_m(GM_Cal3Header.DLS));
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_D3_Software_Module_Identifier_3_Alpha_Code (Service request header:$1A $D3 )
 * Description:Reference DID $D1 for a description of this DID's usage.
 * This DID corresponds with DID $C3.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_D3_Software_Module_Identifier_3_Alpha_Code(DescMsgContext* pMsgContext)
{
	/* This DID reads the "System Cal" cals stored in region 1 */
	pMsgContext->resData[0U] = DescGetHiByte(SwapEndianess_m(GM_Cal2Header.DLS));
	pMsgContext->resData[1U] = DescGetLoByte(SwapEndianess_m(GM_Cal2Header.DLS));
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_D4_Software_Module_Identifier_4_Alpha_Code (Service request header:$1A $D4 )
 * Description:Reference DID $D1 for a description of this DID's usage.
 * This DID corresponds with DID $C4.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_D4_Software_Module_Identifier_4_Alpha_Code(DescMsgContext* pMsgContext)
{
	/* This DID reads the "System Cal 2" cals, also known as feature cals, stored in region 2 */
	pMsgContext->resData[0U] = DescGetHiByte(SwapEndianess_m(GM_Cal1Header.DLS));
	pMsgContext->resData[1U] = DescGetLoByte(SwapEndianess_m(GM_Cal1Header.DLS));
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_DB_End_Model_Part_Number_Alpha_Code (Service request header:$1A $DB )
 * Description:This DID contains the 2 character ASCII representation of the Alpha Code
 * associated with the End Model Part Number (stored in DID $CB).  The Alpha Code
 * consists of a Design Level Suffix (DLS) and a Process Level Suffix (PLS).
 * Byte 1 (DLS)
 * This byte is contains an ASCII value that represents the hardware release.  This
 * value shall initially be set to A and incremented for a hardware revision.
 * Byte 2 (PLS)
 * This byte is contains an ASCII value that represents the software release.  This
 * value shall initially be set to A and incremented for a software revision.
 * 
 * This DID may or may not be updated at the conclusion of a programming event based
 * on divisional practices.  This DID is not required to be writeable if divisional
 * practices do not require this part number to be updated after module programming.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_DB_End_Model_Part_Number_Alpha_Code(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrEndMdlPartNrAlphaCodRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_DC_Base_Model_Part_Number_Alpha_Code (Service request header:$1A $DC )
 * Description:This DID contains the 2 character ASCII representation of the Alpha Code
 * associated with the Base Model Part Number (stored in DID $CC). The Alpha Code
 * consists of a Design Level Suffix (DLS) and a Process Level Suffix (PLS).
 * Byte 1 (DLS)
 * This byte is contains an ASCII value that represents the hardware release. This
 * value shall initially be set to A and incremented for a hardware revision.
 * Byte 2 (PLS)
 * This byte is contains an ASCII value that represents the software release. This
 * value shall initially be set to A and incremented for a software revision.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_DC_Base_Model_Part_Number_Alpha_Code(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrBasMdlPartNrAlphaCodRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_DE_GMLAN_Identification_Data (Service request header:$1A $DE )
 * Description:This DID contains a 1 byte Bus Type, a 2 byte GMLAN Kernel, and a 3 byte value
 * that represents the revision level of the GM serial data database file
 * implemented on the specified network. This information shall be repeated for each
 * GMLAN network to which the controller is connected. The length of the DID will be
 * determined by the number of connected GMLAN networks, i.e. length is equal to 6 *
 * n, where n is the number of connected GMLAN networks.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_DE_GMLAN_Identification_Data(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrGmLanIdRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 12U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_F0_Programmed_State_Indicator_PSI (Service request header:$1A $F0 )
 * Description:This DID contains the Programmed State Indicator.  The Programmed State Indicator
 * (PSI) has a variable length from 2 to 512 bytes determined by the number of
 * calibration partitions supported.  The Programmed State Indicator (PSI) data
 * identifier provides a reliable mechanism for a Tester to determine if a logical
 * partition is programmed with a valid content (i.e. application software or
 * calibration data).  Each logical partition has a dedicated PSI that can be read
 * using this DID. This means that there exists a PSI for the application software
 * partition and a PSI per calibration partition.  The Programmed State Indicator is
 * a reserved cell (the last two bytes) in a flash partition that indicates the
 * validity of the content for that partition.  Each partition has a dedicated PSI
 * that can be read using this DID.
 * 
 * The first byte of the PSI DID denotes the partition number for the PSI that is
 * being requested.
 * $00 = Partition 0 = Application software partition
 * $01 = Partition 1 = First calibration partition*
 * $02 = Partition 2 = Second calibration partition* 	
 * 
 * $FF = Partition 255 = 255th calibration partition*
 * * a calibration partition may contain more than one calibration module
 * 
 * The second byte of the PSI DID denotes the programmed state of the partition.
 * $00 = Valid programming present - The Programmed state indicates that the
 * logical partition has been programmed with a valid and authorized content.  The
 * flash executive shall set the PSI to Programmed state after it concludes that
 * all modules were successfully programed for that partition.
 * $01 = programming has been revoked - The PSI is set to a Revoked state to
 * indicate that the content of the logical partition is going to be replaced and
 * shall be treated as invalid.  The flash executive shall set the PSI state to
 * Revoked before it attempts to erase the logical partition.  The Revoked state
 * is primarily introduced to improve the reprogramming reliability in case the
 * programming event is disrupted (e.g. Loss of power or communication with the
 * diagnostic tool).  Upon power up or power on reset, the ECU shall remain in boot
 * if the PSI is equal to revoked.
 * $02 = programming is invalid - The Invalid state indicates that the logical
 * partition contains invalid content.  This could be due to a failed programming
 * attempt (e.g. did not pass the security check) or a disruption to the programming
 * event (e.g. loss of power or communication).  In this state, the content of the
 * flash partition could be erased, partially programmed, or contains invalid
 * content).  The value assigned to this state shall be the same as the default
 * erased value of the flash memory.  After the flash executive invalidates the
 * logical partition content (i.e. set the PSI to Revoked) it attempts to erase
 * the logical partition.  Because the PSI resides in the same logical partition as
 * the content itself, an attempt to erase the logical partition will cause the PSI
 * to be erased as well and implicitly set the PSI value to Invalid.
 * $03 - $FF = Reserved
 * 
 * Subsequent groups of two bytes denote next calibration partition and the
 * programmed state of the partition respectively.  This pattern sequentially
 * repeats for next partition and programmed state until 255th partition and its
 * programmed state.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_F0_Programmed_State_Indicator_PSI(DescMsgContext* pMsgContext)
{
	/* All information for this DID is hard coded */
	pMsgContext->resData[0U] = 0x01U;  /* Application Partition */
	pMsgContext->resData[1U] = 0x00U;  /* Application Partition PSI - Valid */
	pMsgContext->resData[2U] = 0x02U;  /* Enable/Disable Calibration Partition */
	pMsgContext->resData[3U] = 0x00U;  /* Enable/Disable Calibration PSI - Valid */
	pMsgContext->resData[4U] = 0x03U;  /* Non-Variant Calibration Partition */
	pMsgContext->resData[5U] = 0x00U;  /* Non-Variant Calibration PSI - Valid */
	pMsgContext->resData[6U] = 0x04U;  /* Performance Calibration Present */
	pMsgContext->resData[7U] = 0x00U;  /* Performance Calibration PSI - Valid */
	pMsgContext->resDataLen = 8U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_F3_ECU_ID (Service request header:$1A $F3 )
 * Description:The ECU_ID is a 16 byte, secure static memory, unsigned string which stores a
 * controller specific unique number which is a concatenation of a 4 byte sequence
 * number, a 4 byte base model part number, a 5 byte FNA (Functional Name Address)
 * code and 3 byte UPC (Uniform Parts Code).  This value is used to uniquely
 * identify each ECU.  
 * 
 * Refer to Security ECU_ID Controller Requirements for more detail.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_F3_ECU_ID(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrEcuIdRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 16U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_F4_Signature_Bypass_Authorization_Ticket (Service request header:$1A $F4 )
 * Description:This DID contains the Signature Bypass Authorization (SBA) Ticket, a special file
 * intended for an ECU with a given ECU ID.  The SBA ticket provides necessary
 * information to enable the signature bypass flag in the Bootloader. The presence
 * and validity of SBA ticket allows the Bootloader to bypass the signature for both
 * the Application Software and Calibration Data files.
 * 
 * Refer to Global Bootloader Specification for complete detail of all the data
 * contained in this DID.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_F4_Signature_Bypass_Authorization_Ticket(DescMsgContext* pMsgContext)
{
	(void)Rte_Call_PartNrSecuBypAuthnRd_Oper(pMsgContext->resData);
	pMsgContext->resDataLen = 822U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDID_F6_Boot_Info_Block_Subject_Name_and_ECU_Name (Service request header:$1A $F6 )
 * Description:Subject Name is an ECU family name. It is a 16 byte hexadecimal value that
 * identifies the group of ECUs for which the Signer Info is applicable. It is used
 * during the programming process to determine if the Signer Info is compatible with
 * the target. Example: Powertrain, Infotainment, Telematics etc.
 * 
 *  ECU Name is an 8 byte ASCII representation of the ECU Name.
 * 
 * Refer to SubjectNameGA.xlsx file for definitions. This file is being maintained
 * by Cybersecurity Group. 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDID_F6_Boot_Info_Block_Subject_Name_and_ECU_Name(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Idx_Cnt_T_u08;

	/* Copy 16 bytes for Subject Name */
	for (Idx_Cnt_T_u08 = 0U; Idx_Cnt_T_u08 < 16U; Idx_Cnt_T_u08 += 1U)
	{
		pMsgContext->resData[Idx_Cnt_T_u08] = GetFblSubjNameAddr()[Idx_Cnt_T_u08];
	}

	/* Copy 8 bytes for ECU Name starting at end of Subject Name (16 bytes from start of buffer) */
	for (Idx_Cnt_T_u08 = 0U; Idx_Cnt_T_u08 < 8U; Idx_Cnt_T_u08 += 1U)
	{
		pMsgContext->resData[Idx_Cnt_T_u08 + 16U] = GetFblEcuNameAddr()[Idx_Cnt_T_u08 + 16U];
	}

	pMsgContext->resDataLen = 24U;
  DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadMemory (Service request header:$23 )
 * Description:Memory address shall be in the range of 2 Bytes and 4 Bytes.
 * Size of memory block is allowed to be at maximum 4090 Bytes.
 * 
 * Note:- 
 * The ReadMemoryByAddress service shall never permit access to the following
 * restricted data types. 
 * 1. Executable Code 
 * 2. Operating System/Software 
 * 3. Security Parameters1 
 * 4. Memory Mapped I/O 
 * 5. Stack 
 * 6. Heap 
 * 
 * Any calls to ReadMemoryByAddress (not including enumerated excluded items above)
 * shall only be available for access if it is unlocked via SPS levels of security
 * access.
 * An ECU may also restrict the testers ability to read specific addresses or
 * ranges of addresses e.g. customer Personal Data. If any of the addresses (that
 * fall in the range of the request message) have security restrictions then the
 * request shall be rejected. 
 * This service requires successful security access (reference pseudo code flag
 * Security_Access_Unlocked = TRUE) prior to positively responding to any request.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadMemory(DescMsgContext* pMsgContext)
{
	/* TODO: Implement memory read function */
	/* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
	if(pMsgContext->reqData[0] < 0xFF)
	{
		pMsgContext->resData[0] = 0xFF;
		pMsgContext->resDataLen = 1;
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, kDescNrcRequestOutOfRange);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescGetSeedSPS_Seed (Service request header:$27 $1 )
 * Description:This is the requestSeed level used for ECU programming via the SPS system.
 * 
 * The security encryption data shall be provided to the supplier by the GM Service
 * Organization.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescGetSeedSPS_Seed(DescMsgContext* pMsgContext)
{
	VAR(MfgEnaSt1, AUTOMATIC) CustMfgEnaSt_Cnt_T_enum;
	VAR(uint8, AUTOMATIC) Idx_Cnt_T_u08;
	VAR(uint32, AUTOMATIC) ElpdTi_100uS_T_u32;
	VAR(uint32, AUTOMATIC) ElpdTi_mS_T_u32;

	(void)Rte_Read_CustMfgEnaSt_Val(&CustMfgEnaSt_Cnt_T_enum);

	/* Squash seed request for CPID access if previously requested */
	*Rte_Pim_CustDiagcCtrlPidSeedReqd() = FALSE;

	if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessUnlock_SPS)
	{
		/* Determine how long it has been since the user last failed entry */
		(void)Rte_Call_GetTiSpan100MicroSec32bit_Oper(*Rte_Pim_CustDiagcProgmSessionSeedKeyTmr(), &ElpdTi_100uS_T_u32);
		ElpdTi_mS_T_u32 = ElpdTi_100uS_T_u32 / 10U;

		/* If access has not been locked down by failed attempts OR the timer has elapsed */
		if ((*Rte_Pim_CustDiagcProgmSessionSeedTmrActvd() == FALSE) ||
			(ElpdTi_mS_T_u32 > 10000U))
		{
			/* If MEC indicates production mode */
			if (CustMfgEnaSt_Cnt_T_enum == MFGENAST_MFGMOD)
			{
				/* Send a seed of all zeros */
				for (Idx_Cnt_T_u08 = 0U; Idx_Cnt_T_u08 < 5U; Idx_Cnt_T_u08 += 1U)
				{
					pMsgContext->resData[Idx_Cnt_T_u08] = 0x00U;
				}

				/* Unlock the controller for SPS */
				DescSetStateSecurity_Access(kDescStateSecurity_AccessUnlock_SPS);
			}
			else
			{
				/* Otherwise, send the real seed from NvM */
				(void)Rte_Call_PartNrProgmSessionSeedRd_Oper(pMsgContext->resData);
				*Rte_Pim_CustDiagcProgmSessionSeedReqd() = TRUE;
				*Rte_Pim_CustDiagcProgmSessionSeedTmrActvd() = FALSE;
			}

			/* Both cases here produce a data payload (seed value) of 5 bytes */
			pMsgContext->resDataLen = 5U;
		}
		else
		{
			/* After repeated failed attempts, the user has not waited long enough to try again -> NRC 0x37 */
			DescSetNegResponse(pMsgContext->iContext, kDescNrcTimeDelayNotExpired);
		}
	}
	else
	{
		/* Send a seed of all zeros because we're already unlocked for SPS */
		for (Idx_Cnt_T_u08 = 0U; Idx_Cnt_T_u08 < 5U; Idx_Cnt_T_u08 += 1U)
		{
			pMsgContext->resData[Idx_Cnt_T_u08] = 0x00U;
		}
		pMsgContext->resDataLen = 5U;

		DescActivateS1Timer(); /* Reset the P2* timer */
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescSendKeySPS_Key (Service request header:$27 $2 )
 * Description:This is the sendKey level used for ECU programming via the SPS system.
 * 
 * The security encryption data shall be provided to the supplier by the GM Service
 * Organization.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescSendKeySPS_Key(DescMsgContext* pMsgContext)
{
	/* Ensure that seed was requested before execution of this service */
	if (*Rte_Pim_CustDiagcProgmSessionSeedReqd() == TRUE)
	{
		/* Reset the seed flag - even if the key check fails, the user must re-request the seed */
		*Rte_Pim_CustDiagcProgmSessionSeedReqd() = FALSE;

		/* Check the key against that stored in NvM */
		if (Rte_Call_PartNrProgmSessionKeyChk_Oper(pMsgContext->reqData) == RTE_E_OK)
		{
			/* Success! - Unlock SPS mode */
			DescSetStateSecurity_Access(kDescStateSecurity_AccessUnlock_SPS);
			DescActivateS1Timer();
			*Rte_Pim_CustDiagcProgmSessionKeyAtmptCntr() = 0U;
			*Rte_Pim_CustDiagcProgmSessionSeedTmrActvd() = FALSE;
		}
		else
		{
			/* Failed!  Increment fail counter */
			*Rte_Pim_CustDiagcProgmSessionKeyAtmptCntr() += 1U;

			/* If this failed attempt surpasses the number of bad attempts before forcing security... */
			if (*Rte_Pim_CustDiagcProgmSessionKeyAtmptCntr() > 2U)
			{
				/* Enable the seed request timer to force the user to wait a period of time before next seed request */
				*Rte_Pim_CustDiagcProgmSessionSeedTmrActvd() = TRUE;
				(void)Rte_Call_GetRefTmr100MicroSec32bit_Oper(Rte_Pim_CustDiagcProgmSessionSeedKeyTmr());

				/* Failed, and exceeded number of attempts -> NRC 0x3^ */
				DescSetNegResponse(pMsgContext->iContext, kDescNrcExceedNumOfAttempts);
			}
			else
			{
				/* Otherwise it's just a bad key, try again -> NRC 0x35 */
				DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidKey);
			}
		}
	}
	else
	{
		/* The user has not yet requested the seed -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcRequestSequenceError);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescGetSeedDevice_Control_Seed (Service request header:$27 $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescGetSeedDevice_Control_Seed(DescMsgContext* pMsgContext)
{
	VAR(uint32, AUTOMATIC) ElpdTi_100uS_T_u32;
	VAR(uint32, AUTOMATIC) ElpdTi_mS_T_u32;
	VAR(uint8, AUTOMATIC) Idx_Cnt_T_u08;
	VAR(MfgEnaSt1, AUTOMATIC) CustMfgEnaSt_Cnt_T_enum;
	VAR(uint8, AUTOMATIC) KeyChk_Cnt_T_u08[5] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

	(void)Rte_Read_CustMfgEnaSt_Val(&CustMfgEnaSt_Cnt_T_enum);

	/* Squash seed request for CPID access if previously requested */
	*Rte_Pim_CustDiagcProgmSessionSeedReqd() = FALSE;

	/* CPID must not be active already */
	if (*Rte_Pim_CpidActv() == FALSE)
	{
		/* Determine how long it has been since the user last failed entry */
		(void)Rte_Call_GetTiSpan100MicroSec32bit_Oper(*Rte_Pim_CustDiagcCtrlPidSeedKeyTmr(), &ElpdTi_100uS_T_u32);
		ElpdTi_mS_T_u32 = ElpdTi_100uS_T_u32 / 10U;

		/* If access has not been locked down by failed attempts OR the timer has elapsed */
		if ((*Rte_Pim_CustDiagcCtrlPidSeedTmrActvd() == FALSE) ||
			(ElpdTi_mS_T_u32 > 10000U))
		{
			if ((CustMfgEnaSt_Cnt_T_enum == MFGENAST_MFGMOD) ||
			    (DescGetStateSecurity_Access() != kDescStateSecurity_AccessUnlock_Device_Control))
			{
				/* Unlike SPS, always send the CPID seed when requested in manufacturing mode */
				(void)Rte_Call_PartNrCtrlPidSeedRd_Oper(pMsgContext->resData);

				if ((CustMfgEnaSt_Cnt_T_enum == MFGENAST_MFGMOD) ||
					(Rte_Call_PartNrCtrlPidKeyChk_Oper(KeyChk_Cnt_T_u08) != RTE_E_OK))
				{
					pMsgContext->resDataLen = 5U;
					*Rte_Pim_CustDiagcCtrlPidSeedReqd() = TRUE;
					*Rte_Pim_CustDiagcCtrlPidSeedTmrActvd() = FALSE;
				}
				else
				{
					DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidFormat);
				}
			}
			else
			{
				/* Send a seed of all zeros because we're already unlocked for CPID */
				for (Idx_Cnt_T_u08 = 0U; Idx_Cnt_T_u08 < 5U; Idx_Cnt_T_u08 += 1U)
				{
					pMsgContext->resData[Idx_Cnt_T_u08] = 0x00U;
				}
				pMsgContext->resDataLen = 5U;

				DescActivateS1Timer(); /* Reset the P2* timer */
			}
		}
		else
		{
			/* After repeated failed attempts, the user has not waited long enough to try again -> NRC 0x37 */
			DescSetNegResponse(pMsgContext->iContext, kDescNrcTimeDelayNotExpired);
		}
	}
	else
	{
		/* CPID is active -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescSendKeyDevice_Control_Key (Service request header:$27 $4 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescSendKeyDevice_Control_Key(DescMsgContext* pMsgContext)
{
	VAR(MfgEnaSt1, AUTOMATIC) CustMfgEnaSt_Cnt_T_enum;

	(void)Rte_Read_CustMfgEnaSt_Val(&CustMfgEnaSt_Cnt_T_enum);

	/* Ensure that seed was requested before execution of this service */
	if (*Rte_Pim_CustDiagcCtrlPidSeedReqd() == TRUE)
	{
		/* Reset the seed flag - even if the key check fails, the user must re-request the seed */
		*Rte_Pim_CustDiagcCtrlPidSeedReqd() = FALSE;

		if (CustMfgEnaSt_Cnt_T_enum == MFGENAST_MFGMOD)
		{
			/* When in production mode, accept any key value and write it to NvM */
			Rte_Call_PartNrCtrlPidKeyWr_Oper(pMsgContext->reqData);
			DescSetStateSecurity_Access(kDescStateSecurity_AccessUnlock_Device_Control);
			DescActivateS1Timer();
			(void)Rte_Write_MfgOvrlDi_Logl(TRUE);
		}
		else
		{
			/* Check the key against that stored in NvM */
			if (Rte_Call_PartNrCtrlPidKeyChk_Oper(pMsgContext->reqData) == RTE_E_OK)
			{
				/* Success! - Unlock CPID mode */
				DescSetStateSecurity_Access(kDescStateSecurity_AccessUnlock_Device_Control);
				DescActivateS1Timer();
				*Rte_Pim_CustDiagcCtrlPidKeyAtmptCntr() = 0U;
				*Rte_Pim_CustDiagcCtrlPidSeedTmrActvd() = FALSE;
				(void)Rte_Write_MfgOvrlDi_Logl(TRUE);
			}
			else
			{
				/* Failed!  Increment fail counter */
				*Rte_Pim_CustDiagcCtrlPidKeyAtmptCntr() += 1U;

				/* If this failed attempt surpasses the number of bad attempts before forcing security... */
				if (*Rte_Pim_CustDiagcCtrlPidKeyAtmptCntr() > 2U)
				{
					/* Enable the seed request timer to force the user to wait a period of time before next seed request */
					*Rte_Pim_CustDiagcCtrlPidSeedTmrActvd() = TRUE;
					(void)Rte_Call_GetRefTmr100MicroSec32bit_Oper(Rte_Pim_CustDiagcCtrlPidSeedKeyTmr());

					/* Failed, and exceeded number of attempts -> NRC 0x3^ */
					DescSetNegResponse(pMsgContext->iContext, kDescNrcExceedNumOfAttempts);
				}
				else
				{
					/* Otherwise it's just a bad key, try again -> NRC 0x35 */
					DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidKey);
				}
			}
		}
	}
	else
	{
		/* The user has not yet requested the seed -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcRequestSequenceError);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRequestDownload (Service request header:$34 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRequestDownload(DescMsgContext* pMsgContext)
{
	VAR(uint32, AUTOMATIC) Length_Cnt_T_u32;
	VAR(uint16, AUTOMATIC) RstType_Cnt_T_u16 = BSWM_GENERICVALUE_BswM_PrepShutdownStatesDef_PREPSHUTDOWN_REPROGRAM;

	/* Download memory size to be stored in RAM backup register to retain the value for Boot loader after RESET */
	Length_Cnt_T_u32 = ((vuint32)pMsgContext->reqData[1] << 24u) |
				((vuint32)pMsgContext->reqData[2] << 16u) |
				((vuint32)pMsgContext->reqData[3] << 8u) |
				((vuint32)pMsgContext->reqData[4]);

	/* Set flash programming request as the reset cause but also set the length parameter as additional data as input
	 * to the bootloader.  Length will be stored in BRAMDAT0 by SetMcuDiagcIdnData.
	 */
	SetMcuDiagcIdnData(MCUDIAGC_FLSPROGMREQ, Length_Cnt_T_u32);

	/* BswM request mode to initiate a RESET as result of a reprogramming request */
	CallNonTrustedFunction(NtWrapS_BswM_RequestMode, (void *)&RstType_Cnt_T_u16);
}


/*  ********************************************************************************
 * Function name:ApplDescTransferDataDownload (Service request header:$36 $0 )
 * Description:Starting address shall be in the range of 2 Bytes and 4 Bytes.
 * Size of memory block is allowed to be at maximum 4090 Bytes.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescTransferDataDownload(DescMsgContext* pMsgContext)
{
    /* Negative Response: Sub Function Not Supported */
    DescSetNegResponse(pMsgContext->iContext, kDescNrcSubfunctionNotSupported);
    DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWriteDidDID_02_Calibration_Programmed_Status (Service request header:$3B $2 )
 * Description:This DID contains a flag to determine if the calibration files have been
 * programmed.  The default value for this DID is $AA.  After the calibration files
 * have been programmed, the utility file will write this DID to be a value of $55,
 * indicating that programming of the calibration files has been successfully
 * completed.  
 * 
 * This DID shall not be written unless the following conditions are met:
 * Vehicle Speed < 3 km/h
 * Vehicle Speed Validity = Valid
 * Propulsion System Active = FALSE
 * When Service $28 (Disable Normal Communication) is active, signals for
 * rationalitly will hold the last known values of Vehicle Speed, Vehicle Speed
 * Validity, and Propulsion System Active.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteDidDID_02_Calibration_Programmed_Status(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) RespCodVehSpd_Cnt_T_u16;

	RespCodVehSpd_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08, 3.0f);

	if ((NOERR_CNT_U16 == EnvtlChk(TESTSECUACS_CNT_U08, 0.0f)) ||
        (( (VEHSPDFLTDETD_CNT_U16 == RespCodVehSpd_Cnt_T_u16) || (NOERR_CNT_U16 == RespCodVehSpd_Cnt_T_u16) ) &&
         (NOERR_CNT_U16 == EnvtlChk(TESTMISSMSG0C9ORENGRUN_CNT_U08, 0.0f))))
	{
		if (Rte_Call_PartNrCalProgdStsWr_Oper(pMsgContext->reqData[0U]) != RTE_E_OK)
		{
			DescSetNegResponse(pMsgContext->iContext, kDescNrcRequestOutOfRange);
		}
	}
	else
	{
		/* Failed rationality check -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWriteDidDID_90_Vehicle_Identification_Number (Service request header:$3B $90 )
 * Description:This DID contains the Vehicle Identification Number.  The data content shall be
 * specified by the vehicle manufacturer.  If the VIN has not yet been programmed
 * into the ECU's permanent memory, those locations shall be either '$00' or '$FF'. 
 * All 17 digits must be programmed in order for the ECU to use this DID.  If the
 * ECU does not store all 17 digits, then the ECU shall use an application specific
 * DID to store the VIN digits.  
 * 
 * This DID shall not be written unless the following conditions are met:
 * Vehicle Speed < 3 km/h
 * Vehicle Speed Validity = Valid
 * Propulsion System Active = FALSE
 * When Service $28 (Disable Normal Communication) is active, signals for
 * rationalitly will hold the last known values of Vehicle Speed, Vehicle Speed
 * Validity, and Propulsion System Active.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteDidDID_90_Vehicle_Identification_Number(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) RespCodVehSpd_Cnt_T_u16;

	RespCodVehSpd_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08, 3.0f);

	if ((NOERR_CNT_U16 == EnvtlChk(TESTSECUACS_CNT_U08, 0.0f)) ||
        (( (VEHSPDFLTDETD_CNT_U16 == RespCodVehSpd_Cnt_T_u16) || (NOERR_CNT_U16 == RespCodVehSpd_Cnt_T_u16) ) &&
         (NOERR_CNT_U16 == EnvtlChk(TESTMISSMSG0C9ORENGRUN_CNT_U08, 0.0f))))
	{
		(void)Rte_Call_PartNrVinDataWr_Oper(pMsgContext->reqData);
	}
	else
	{
		/* Failed rationality check -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWriteDidDID_97_System_Name_Or_Engine_Type (Service request header:$3B $97 )
 * Description:This DID contains the System Name or Engine Type which identifies the electronic
 * system name (e.g. Automatic Transmission with 2.0 L engine: GS820 X20XEV) or
 * engine type (X30XE) installed.  The data shall always be of type ASCII.  The
 * length is variable (depends on length of string) but shall not exceed 20
 * characters.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteDidDID_97_System_Name_Or_Engine_Type(DescMsgContext* pMsgContext)
{
	if ((NOERR_CNT_U16 == EnvtlChk(TESTSECUACS_CNT_U08, 0.0f)) ||
		(NOERR_CNT_U16 == EnvtlChk(TESTVEHSPD_CNT_U08 | TESTENGRUN_CNT_U08, 3.0f)))
	{
		if (pMsgContext->reqDataLen == 20)
		{
			(void)Rte_Call_PartNrSysNameWr_Oper(pMsgContext->reqData);
		}
		else
		{
			/* Request length invalid - send negative response! */
			DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidFormat);
		}
	}
	else
	{
		/* Failed rationality check -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWriteDidDID_98_Repair_Shop_Code_Or_Tester_Serial_Number (Service request header:$3B $98 )
 * Description:This DID contains the Repair Shop Code Or Tester Serial Number which identifies
 * the dealers code or the testers serial number.  This ASCII string is programmed
 * into the ECUs memory via the Utility File during the last programming session
 * (SPS) at the dealer site.
 * 
 * This DID shall not be written unless the following conditions are met:
 * Vehicle Speed < 3 km/h
 * Vehicle Speed Validity = Valid
 * Propulsion System Active = FALSE
 * When Service $28 (Disable Normal Communication) is active, signals for
 * rationalitly will hold the last known values of Vehicle Speed, Vehicle Speed
 * Validity, and Propulsion System Active.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteDidDID_98_Repair_Shop_Code_Or_Tester_Serial_Number(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) RespCodVehSpd_Cnt_T_u16;

	RespCodVehSpd_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08, 3.0f);

	if ((NOERR_CNT_U16 == EnvtlChk(TESTSECUACS_CNT_U08, 0.0f)) ||
        (( (VEHSPDFLTDETD_CNT_U16 == RespCodVehSpd_Cnt_T_u16) || (NOERR_CNT_U16 == RespCodVehSpd_Cnt_T_u16) ) &&
         (NOERR_CNT_U16 == EnvtlChk(TESTMISSMSG0C9ORENGRUN_CNT_U08, 0.0f))))
	{
		(void)Rte_Call_PartNrRepairShopCodWr_Oper(pMsgContext->reqData);
	}
	else
	{
		/* Failed rationality check -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWriteDidDID_99_Programming_Date (Service request header:$3B $99 )
 * Description:This DID contains the Programming Date of the last programming event (SPS) at the
 * dealer site.  This BCD value is programmed into the ECUs memory via the Utility
 * File during the last programming session (SPS).
 * Example: January 22, 2000 would be encoded as $20 $00 $01 $22.
 * 
 * This DID shall not be written unless the following conditions are met:
 * Vehicle Speed < 3 km/h
 * Vehicle Speed Validity = Valid
 * Propulsion System Active = FALSE
 * When Service $28 (Disable Normal Communication) is active, signals for
 * rationalitly will hold the last known values of Vehicle Speed, Vehicle Speed
 * Validity, and Propulsion System Active.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteDidDID_99_Programming_Date(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) RespCodVehSpd_Cnt_T_u16;

	RespCodVehSpd_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08, 3.0f);

	if ((NOERR_CNT_U16 == EnvtlChk(TESTSECUACS_CNT_U08, 0.0f)) ||
        (( (VEHSPDFLTDETD_CNT_U16 == RespCodVehSpd_Cnt_T_u16) || (NOERR_CNT_U16 == RespCodVehSpd_Cnt_T_u16) ) &&
         (NOERR_CNT_U16 == EnvtlChk(TESTMISSMSG0C9ORENGRUN_CNT_U08, 0.0f))))
	{
		if (Rte_Call_PartNrProgmDateWr_Oper(pMsgContext->reqData) != RTE_E_OK)
		{
			DescSetNegResponse(pMsgContext->iContext, kDescNrcRequestOutOfRange);
		}
	}
	else
	{
		/* Failed rationality check -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWriteDidDID_9A_Diagnostic_Data_Identifier (Service request header:$3B $9A )
 * Description:This DID contains the Diagnostic Data Identifier which identifies a supplier and
 * system specific diagnostic data stream and shall be used by diagnostic testers to
 * interpret a diagnostic data stream. The data format of the DDI is defined as two
 * (2) bytes where the most significant byte of the DDI identifies the system by a
 * system code and the least significant byte identifies the system data stream
 * version number.
 * 
 * System Code (DDI high byte) shall be used to distinguish between the following
 * cases:
 * Different ECU systems, where the ECU uses the same Diagnostic Address (see DID
 * $B0).
 * Different system suppliers of the same component.
 * Non-compatible ECU hardware and/or non-compatible software.
 * 
 * Version Number (DDI low byte) shall be incremented when:
 * The diagnostic implementation is changed and the changes affect
 * Service/Aftersales and/or Manufacturing diagnostic test tools.
 * A bug fix is implemented in the node, which affect the implementation of the
 * Service/Aftersales and/or Manufacturing diagnostic tester tools.
 * 
 * Diagnostic Data Identifier shall be a part if the application software, i.e. the
 * Diagnostic Data Identifier shall be updated when SPS programming the node, if the
 * updated software contains a change that requires a DDI update.  Therefore, SPS
 * security is required for writing this DID.
 * 
 * For an SPS_TYPE_B or SPS_TYPE_C ECU, the value of the least significant byte of
 * the DDI shall always be $00 (provided that the DID is supported in a node which
 * is not completely programmed).
 * 
 * The choice of Diagnostic Data Identifier shall be reviewed, assigned, and
 * approved by GM Service/Aftersales Engineers.
 * 
 * This DID shall not be written unless the following conditions are met:
 * Vehicle Speed < 3 km/h
 * Vehicle Speed Validity = Valid
 * Propulsion System Active = FALSE
 * When Service $28 (Disable Normal Communication) is active, signals for
 * rationalitly will hold the last known values of Vehicle Speed, Vehicle Speed
 * Validity, and Propulsion System Active.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteDidDID_9A_Diagnostic_Data_Identifier(DescMsgContext* pMsgContext)
{
	if ((NOERR_CNT_U16 == EnvtlChk(TESTSECUACS_CNT_U08, 0.0f)) ||
		(NOERR_CNT_U16 == EnvtlChk(TESTVEHSPD_CNT_U08 | TESTENGRUN_CNT_U08, 3.0f)))
	{
		(void)Rte_Call_PartNrSysCodVersNrWr_Oper(pMsgContext->reqData);
	}
	else
	{
		/* Failed rationality check -> NRC 0x22 */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWriteDidDID_A0_Manufacturers_Enable_Counter (Service request header:$3B $A0 )
 * Description:This DID contains the MEC which is used when determining the current status of
 * ECU security and/or as an in assembly plant mode indication.  Assembly Plant
 * Mode is a state of the ECU where normal operation is modified in order to
 * facilitate the manufacturing process.
 * Supplier shall set the MEC to $FE when shipped to GM vehicle assembly or to a $00
 * when shipped to GM service. It is the responsibility of GM manufacturing to set
 * the MEC to zero at the end of assembly process.
 * 
 * A node shall not allow the value of the MEC to change once it becomes $00.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteDidDID_A0_Manufacturers_Enable_Counter(DescMsgContext* pMsgContext)
{
	if (Rte_Call_PartNrCustMfgEnaCntrWr_Oper(pMsgContext->reqData[0U]) != RTE_E_OK)
	{
		DescSetNegResponse(pMsgContext->iContext, kDescNrcRequestOutOfRange);
	}
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWriteDidDID_F4_Signature_Bypass_Authorization_Ticket (Service request header:$3B $F4 )
 * Description:This DID contains the Signature Bypass Authorization (SBA) Ticket, a special file
 * intended for an ECU with a given ECU ID.  The SBA ticket provides necessary
 * information to enable the signature bypass flag in the Bootloader. The presence
 * and validity of SBA ticket allows the Bootloader to bypass the signature for both
 * the Application Software and Calibration Data files.
 * 
 * Refer to Global Bootloader Specification for complete detail of all the data
 * contained in this DID.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteDidDID_F4_Signature_Bypass_Authorization_Ticket(DescMsgContext* pMsgContext)
{
	if (pMsgContext->reqDataLen == 822U)
	{
		(void)Rte_Call_PartNrSecuBypAuthnWr_Oper(pMsgContext->reqData);
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidFormat);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWriteDidDID_F5_DVT_Access_KeyTable_Index_Change_KTIC (Service request header:$3B $F5 )
 * Description:ECUs will be shipped from suppliers with a SecurityAccess ($27) sub-function
 * ($03) written into controller Secure Static NVM.  This DID provides GM
 * Manufacturing the ability to overwrite byte 5 of the SecurityAccess ($27)
 * sub-function ($03) Challenge only when the 4 MSB of the ($04) Response are $FF
 * and the MEC > $00.  Although the initial default value Challenge for KTI_03 is
 * 0x01, the supplier can be directed to increment this value at the discretion of
 * GM.
 * The controller shall respond to a DID 0xF5, $3B write request with NRC ($22)
 * Conditions Not Correct when the MEC = $00. 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteDidDID_F5_DVT_Access_KeyTable_Index_Change_KTIC(DescMsgContext* pMsgContext)
{
	if (Rte_Call_PartNrCtrlPidSeedUpprByteWr_Oper(pMsgContext->reqData[0]) != RTE_E_OK)
	{
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReportProgrammedState (Service request header:$A2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReportProgrammedState(DescMsgContext* pMsgContext)
{
	/* Always report "programmed" from the application */
	pMsgContext->resData[0] = 0x00u;
	pMsgContext->resDataLen = 1u;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescControlCancelAll (Service request header:$AE $0 )
 * Description:A $00 in place of the CPID number in the request message is used to completely
 * cancel all active device controls.  There are no data bytes used for Cancel All
 * Active Device Controls.
 * 
 * CYS Required Rationality:
 * None
 * 
 * CYS SecurityAccess $03 Rationality:
 * None
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCancelAll(DescMsgContext* pMsgContext)
{
	ApplDescOnReturnToNormalMode();
	*Rte_Pim_SysStReqEnaOvrdCust() = FALSE;
	DescProcessingDone(pMsgContext->iContext);
	*Rte_Pim_CpidActv() = FALSE;
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_02_Steering_Assist_Control (Service request header:$AE $2 )
 * Description:At End-Of-Line, the worker drives the car into the wheel alignment station,
 * switches off the vehicle's engine, and connects the MFT/J-Link to the car.  After
 * the connection of the MFT/J-Link, the worker starts the wheel alignment process. 
 * During the wheel alignment, the engine is not running. When the combustion engine
 * is off, EPS disables the EPS motor, i.e. no servo steering is available.  This
 * CPID allows manual enabling of the servo steering even if the combustion engine
 * is off, in order to simplify the wheel alignment process.
 * 
 * The following must be true before this CPID can be successfully executed:
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Engine Run Active = FALSE ($0)
 * 3.	Vehicle Speed < 10 km/h
 * 4.	Vehicle Speed Validity = Valid
 * 
 * The controller shall send the negative response $E3 with the following additional
 * 2 byte reason codes if the rationality conditions are not met:
 * $02 $01: Engine is Running.
 * $03 $08: DTC Present.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * $FE $03 - Security Code Function Locked
 * 
 * Power Assist Mode Control
 * This device control shall allow for manual activation of the servo steering even
 * if the combustion engine is not running and the vehicle is not moving.  This
 * control should switch to 100% full assist, as long as the Stop Start Control Byte
 * is not active and requesting a different mode with reduced power assist.
 * 
 * Stop Start Control
 * This device control shall allow for manual modification of the state machine
 * added for 12V stop start.  The current control state is available in PID $43D0. 
 * The stop start control is only effective if the EPS Power Assist Mode is active
 * (Drive Up).  
 * This might be triggered by the combustion engine is running OR by using the Power
 * Assist Control which is part of this CPID.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_02_Steering_Assist_Control(DescMsgContext* pMsgContext)
{
	/* If Power Assist Enable bit is set */
	if ((pMsgContext->reqData[0U] & 0x01U) != 0U)
	{
		/* If Power Assist Mode bit is set */
		if ((pMsgContext->reqData[1U] & 0x01U) != 0U)
		{
			/* Enable assist */
			*Rte_Pim_SysStReqEnaOvrdCust() = TRUE;
		}
		else
		{
			/* Disable assist */
			*Rte_Pim_SysStReqEnaOvrdCust() = FALSE;
		}
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidFormat);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_03_Steering_Angle_Sensor_Calibration (Service request header:$AE $3 )
 * Description:This CPID is used to learn the center position of the internal steering angle
 * sensor.
 * 
 * This CPID shall not be executed unless the following conditions are met:
 * 
 * 1.	Steering Wheel Torque Input < 3 Nm
 * 2.	Vehicle Speed < 3 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 4.	Propulsion System Active = FALSE ($0)
 * 5.	No Active Steering Angle Sensor faults
 * -	OR - 
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Vehicle Speed < 10 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 4.	No Active Steering Angle Sensor faults
 * 
 * Executing the CPID to Calibrate the SAS shall change the SAS Calibration status
 * from UNKNOWN ($0) to CALIBRATED ($2).  If the CPID is executed to Calibrate the
 * SAS when SAS Calibration status = CALIBRATED ($2), the software shall overwrite
 * the old learned value with the new learned value and provide a positive response
 * to the CPID command.
 * 
 * Device Limits Exceeded Codes 
 * $03 $08: DTC Present.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * $80 $4B: Steering Wheel Position Sensor Voltage Exceeds Autolearn Center Limits
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_03_Steering_Angle_Sensor_Calibration(DescMsgContext* pMsgContext)
{
	/* If Angle Sensor Cal Bit is set */
	if ((0x01U & pMsgContext->reqData[0]) != 0U)
	{
		/* We only care about the first two bits of data for this check */
		switch (pMsgContext->reqData[1] & 0x03U)
		{
			case 0x01U:
				/* Trim handwheel angle sensors */
				CustDiagcRetBuf_G = 0U;
				CallNonTrustedFunction(NtWrapS_CustDiagc_UpdHwAgTrimVal, &CustDiagcRetBuf_G);
				if (CustDiagcRetBuf_G != 0U)
				{
					DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
				}
				break;
			case 0x00U:
				/* Clear angle sensor trims */
				CallNonTrustedFunction(NtWrapS_CustDiagc_ClrHwAgTrimVal, NULL_PTR);
				break;
			default:
				DescSetNegResponse(pMsgContext->iContext, kDescNrcSubfunctionNotSupported);
				break;
		}
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidFormat);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_04_Reset_Adaptive_Data (Service request header:$AE $4 )
 * Description:This CPID resets adaptive data / learned values back to their default values (not
 * calibrated / not learned).
 * Yaw Rate Offset Learn
 * Lateral Acceleration Offset Learn
 * Torque Sensor Offset Learn
 * LTC = Steering Angle Long Term Correction
 * SES = Soft End Stop range and offset
 * 	
 * This CPID shall not be executed unless the following conditions are met:
 * 
 * 1.	Vehicle Speed < 3 km/h
 * 2.	Vehicle Speed Validity = Valid
 * 3.	Propulsion System Active = FALSE ($0)
 * -	OR - 
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Vehicle Speed < 10 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 
 * The controller shall send the negative response $E3 with the following additional
 * 2 byte reason codes if the rationality conditions are not met:
 * 
 * $02 $01: Engine is Running.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_04_Reset_Adaptive_Data(DescMsgContext* pMsgContext)
{
	/* Check Reset Adaptive Data Bit is set */
	if ((pMsgContext->reqData[0] & 0x01U) != 0U)
	{
		switch (pMsgContext->reqData[1])
		{
			case 0x01U:
				/* Reset all */
				/* TODO: Reset active pull compensation - requires non-trusted function call */
				/* TODO: Reset learned end of travel - requires non-trusted function call */
				/* TODO: Reset Torque Steer Mitigation gain - requires non-trusted function call */
				break;
			case 0x02U:
				/* Reset Pull Compensation */
				/* TODO: Reset active pull compensation - requires non-trusted function call */
				break;
			case 0x03U:
				/* Reset End Of Travel */
				/* TODO: Reset learned end of travel - requires non-trusted function call */
				break;
			case 0x04U:
				/* Reset Torque Steer Mitigation */
				/* TODO: Reset Torque Steer Mitigation gain - requires non-trusted function call */
				break;
			default:
				/* Do nothing */
				break;
		}
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidFormat);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_05_Feature_Control (Service request header:$AE $5 )
 * Description:This CPID is used to disable the following enhanced steering features for 1
 * ignition cycle for service technician to diagnose vehicle issue.
 * 
 * Lead and Pull Compensation
 * Brake Pulsation Mitigation
 * Smooth Road Shake Mitigation
 * 
 * This CPID shall not be executed unless the following conditions are met:
 * 
 * 1.	Vehicle Speed < 3 km/h
 * 2.	Vehicle Speed Validity = Valid
 * 3.	Propulsion System Active = FALSE ($0)
 * -	OR - 
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Vehicle Speed < 10 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 
 * 
 * The controller shall send the negative response $E3 with the following additional
 * 2 byte reason codes if the rationality conditions are not met:
 * $02 $01: Engine is Running.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * 
 * The following steering sequence shall be executed within a short time period (15
 * s, calibrateable) after CPID $05 is received.  Otherwise, CPID command shall not
 * be executed.
 * 1.	Turn the steering wheel to full left rack end stop position and hold for > 1
 * s
 * 2.	Turn the steering wheel to full right rack end stop position and hold for > 1
 * s
 * 3.	Turn the steering wheel to the straight ahead position (+/- 5 deg) for > 2 s
 * with handwheel torque < 1 Nm
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_05_Feature_Control(DescMsgContext* pMsgContext)
{
	if (pMsgContext->reqData[1] == 0x01U)
	{
		if ((pMsgContext->reqData[0] & 0x01U) == 0x00U)
		{
			/* This is an invalid condition, an ignition cycle is required to deactivate this CPID */
			DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidFormat);
			DescProcessingDone(pMsgContext->iContext);
		}
		else
		{
			/* Run the CPID */
			*Rte_Pim_GmDiCtrlPidTstRunng() = TRUE;
			*Rte_Pim_SrvCntxt() = pMsgContext->iContext;
			(void)CallNonTrustedFunction(NtWrapS_CustDiagc_GmFctDiReq, NULL_PTR);

			/* Do NOT call DescProcessingDone from this path, it will be called from CustDiagcPer1 after CF025A
			 * finishes processing the lock-to-lock steering maneuver that the driver must complete to execute this
			 * CPID.  It will return a positive response on success or NRC 0x22 if the driver fails to complete the
			 * prescribed maneuver in time.  NRC 0x78 is automatically periodically returned by desc. */
		}
	}
	else
	{
		/* Do nothing in this case - the second parameter must be equal to one to perform any action */
		/* Positively respond though as the tool hasn't done anything wrong */
		DescProcessingDone(pMsgContext->iContext);
	}
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_FD_System_Basic_Functions (Service request header:$AE $FD )
 * Description:This CPID shall not be executed unless the following conditions are met:
 * 
 * 1.	A successful Security Access Seed ($27 $01) and Key ($27 $02) has been
 * performed
 * 2.	Vehicle Speed < 3 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 4.	Propulsion System Active = FALSE ($0)
 * -	OR - 
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Vehicle Speed < 3 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 
 * The controller shall send the negative response $E3 with the following additional
 * 2 byte reason codes if the rationality conditions are not met:
 * $02 $01: Engine is Running.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * 
 * CPID $FD shall require periodic Tester Present ($3E) messages to remain in
 * effect.
 * 
 * Disable All System Outputs
 * This device control allows a tool user to deactivate all output devices of an ECU
 * simultaneously or, if this is not possible, freeze the output(s) at its (their)
 * current value.  This prevents random behavior or periodic switching of loads
 * during a current measurement.  When this device control is active, all device
 * controls assigned in other CPIDs for that ECU can be activated/deactivated
 * independently by the other CPID (overrides CPID $FD for that output).
 * 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_FD_System_Basic_Functions(DescMsgContext* pMsgContext)
{
	/* Bit 7, and only bit 7, of request byte shall be set - otherwise NRC is returned */
	if (pMsgContext->reqData[0] != 0x80U)
	{
		DescSetNegResponse(pMsgContext->iContext, kDescNrcInvalidFormat);
	}
	else
	{
		/* Nothing needs to be done as part of a positive response for this service.
		 * The criteria needed to request the service already put EPS into the state requested by the service.
		 * Simply respond positively and be happy. */
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescPreDisableNormalCommunication (Service request header:$28 )
 * Description:Inhibited Conditions:
 * 1. Programming of the ECU should not be started when vehicle is running.
 * 2. Programming of the ECU should not be started when it is performing primary
 * function.
 * But if ECU does not have way to detect vehicle running status then it can be wait
 * till Propulsion System Active signal from serial data is available.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPreDisableNormalCommunication(vuint8 iContext)
{
	VAR(boolean, AUTOMATIC) VehSpdVld_Cnt_T_logl;
	VAR(float32, AUTOMATIC) VehSpd_Kph_T_f32;
	VAR(boolean, AUTOMATIC) EngRunActv_Cnt_T_logl;
	VAR(boolean, AUTOMATIC) MissMsg0C9_Cnt_T_logl;

	(void)Rte_Read_VehSpdVld_Logl(&VehSpdVld_Cnt_T_logl);
	(void)Rte_Read_VehSpd_Val(&VehSpd_Kph_T_f32);
	(void)Rte_Read_EngRunActv_Logl(&EngRunActv_Cnt_T_logl);
	(void)Rte_Read_MissMsg0C9_Logl(&MissMsg0C9_Cnt_T_logl);

	/* Perform disable normal communication rationality check */
	if ( ((MissMsg0C9_Cnt_T_logl == TRUE) || (EngRunActv_Cnt_T_logl == FALSE)) && ((VehSpdVld_Cnt_T_logl == FALSE) || (VehSpd_Kph_T_f32 < 3.0f)) )
	{
		/* Allow service to be executed */
	}
	else
	{
		/* Failed rationality check -> NRC 0x22 */
		DescSetNegResponse(iContext, kDescNrcConditionsNotCorrect);
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPreRequestProgrammingMode (Service request header:$A5 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPreRequestProgrammingMode(vuint8 iContext)
{
	VAR(boolean, AUTOMATIC) EngRunActv_Cnt_T_logl;
	VAR(boolean, AUTOMATIC) VehSpdVld_Cnt_T_logl;
	VAR(float32, AUTOMATIC) VehSpd_Kph_T_f32;
	VAR(float32, AUTOMATIC) BattVltg_Volt_T_f32;

	(void)Rte_Read_EngRunActv_Logl(&EngRunActv_Cnt_T_logl);
	(void)Rte_Read_VehSpdVld_Logl(&VehSpdVld_Cnt_T_logl);
	(void)Rte_Read_VehSpd_Val(&VehSpd_Kph_T_f32);
	(void)Rte_Read_BattVltg_Val(&BattVltg_Volt_T_f32);

	/* All of the following result in a failure to reprogram, and subsequent NRC 0x22 */
	if (EngRunActv_Cnt_T_logl == TRUE)
	{
		/* Engine is running */
		DescSetNegResponse(iContext, kDescNrcConditionsNotCorrect);
	}
	else if ((VehSpdVld_Cnt_T_logl == TRUE) && (VehSpd_Kph_T_f32 > 3.0f))
	{
		/* Vehicle speed is valid and greater than 3 KPH */
		DescSetNegResponse(iContext, kDescNrcConditionsNotCorrect);
	}
	else if ((BattVltg_Volt_T_f32 < 6.0f) || (BattVltg_Volt_T_f32 > 18.0f))
	{
		/* Battery voltage out of range (6V >= BattVltg >= 18V) */
		DescSetNegResponse(iContext, kDescNrcConditionsNotCorrect);
	}
	else
	{
		/* It's all good, lets program! */
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPreControlCPID_02_Steering_Assist_Control (Service request header:$AE $2 )
 * Description:At End-Of-Line, the worker drives the car into the wheel alignment station,
 * switches off the vehicle's engine, and connects the MFT/J-Link to the car.  After
 * the connection of the MFT/J-Link, the worker starts the wheel alignment process. 
 * During the wheel alignment, the engine is not running. When the combustion engine
 * is off, EPS disables the EPS motor, i.e. no servo steering is available.  This
 * CPID allows manual enabling of the servo steering even if the combustion engine
 * is off, in order to simplify the wheel alignment process.
 * 
 * The following must be true before this CPID can be successfully executed:
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Engine Run Active = FALSE ($0)
 * 3.	Vehicle Speed < 10 km/h
 * 4.	Vehicle Speed Validity = Valid
 * 
 * The controller shall send the negative response $E3 with the following additional
 * 2 byte reason codes if the rationality conditions are not met:
 * $02 $01: Engine is Running.
 * $03 $08: DTC Present.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * $FE $03 - Security Code Function Locked
 * 
 * Power Assist Mode Control
 * This device control shall allow for manual activation of the servo steering even
 * if the combustion engine is not running and the vehicle is not moving.  This
 * control should switch to 100% full assist, as long as the Stop Start Control Byte
 * is not active and requesting a different mode with reduced power assist.
 * 
 * Stop Start Control
 * This device control shall allow for manual modification of the state machine
 * added for 12V stop start.  The current control state is available in PID $43D0. 
 * The stop start control is only effective if the EPS Power Assist Mode is active
 * (Drive Up).  
 * This might be triggered by the combustion engine is running OR by using the Power
 * Assist Control which is part of this CPID.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPreControlCPID_02_Steering_Assist_Control(vuint8 iContext)
{
	VAR(uint16, AUTOMATIC) RespCod_Cnt_T_u16;

	RespCod_Cnt_T_u16 = EnvtlChk(TESTHWTQ_CNT_U08 | TESTSECUACS_CNT_U08 | TESTVEHSPD_CNT_U08 | TESTENGRUN_CNT_U08, 10.0f);

	if (RespCod_Cnt_T_u16 != NOERR_CNT_U16)
	{
		DescSetExtNegResponse(iContext, kDescNrcDeviceControlLimitExceeded, RespCod_Cnt_T_u16);
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPreControlCPID_03_Steering_Angle_Sensor_Calibration (Service request header:$AE $3 )
 * Description:This CPID is used to learn the center position of the internal steering angle
 * sensor.
 * 
 * This CPID shall not be executed unless the following conditions are met:
 * 
 * 1.	Steering Wheel Torque Input < 3 Nm
 * 2.	Vehicle Speed < 3 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 4.	Propulsion System Active = FALSE ($0)
 * 5.	No Active Steering Angle Sensor faults
 * -	OR - 
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Vehicle Speed < 10 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 4.	No Active Steering Angle Sensor faults
 * 
 * Executing the CPID to Calibrate the SAS shall change the SAS Calibration status
 * from UNKNOWN ($0) to CALIBRATED ($2).  If the CPID is executed to Calibrate the
 * SAS when SAS Calibration status = CALIBRATED ($2), the software shall overwrite
 * the old learned value with the new learned value and provide a positive response
 * to the CPID command.
 * 
 * Device Limits Exceeded Codes 
 * $03 $08: DTC Present.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * $80 $4B: Steering Wheel Position Sensor Voltage Exceeds Autolearn Center Limits
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPreControlCPID_03_Steering_Angle_Sensor_Calibration(vuint8 iContext)
{
	VAR(uint16, AUTOMATIC) RespCod_Cnt_T_u16;

	/* Test is different when CPID access is unlocked */
	if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessUnlock_Device_Control)
	{
		/* Currently locked */
		RespCod_Cnt_T_u16 = EnvtlChk(TESTHWTQ_CNT_U08 | TESTVEHSPD_CNT_U08 | TESTENGRUN_CNT_U08, 3.0f);
	}
	else
	{
		/* Currently unlocked */
		RespCod_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08, 10.0f);
	}

	/* Set NRC if a test failed */
	if (RespCod_Cnt_T_u16 != NOERR_CNT_U16)
	{
		DescSetExtNegResponse(iContext, kDescNrcDeviceControlLimitExceeded, RespCod_Cnt_T_u16);
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPreControlCPID_04_Reset_Adaptive_Data (Service request header:$AE $4 )
 * Description:This CPID resets adaptive data / learned values back to their default values (not
 * calibrated / not learned).
 * Yaw Rate Offset Learn
 * Lateral Acceleration Offset Learn
 * Torque Sensor Offset Learn
 * LTC = Steering Angle Long Term Correction
 * SES = Soft End Stop range and offset
 * 	
 * This CPID shall not be executed unless the following conditions are met:
 * 
 * 1.	Vehicle Speed < 3 km/h
 * 2.	Vehicle Speed Validity = Valid
 * 3.	Propulsion System Active = FALSE ($0)
 * -	OR - 
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Vehicle Speed < 10 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 
 * The controller shall send the negative response $E3 with the following additional
 * 2 byte reason codes if the rationality conditions are not met:
 * 
 * $02 $01: Engine is Running.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPreControlCPID_04_Reset_Adaptive_Data(vuint8 iContext)
{
	VAR(uint16, AUTOMATIC) RespCod_Cnt_T_u16;

	/* Test is different when CPID access is unlocked */
	if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessUnlock_Device_Control)
	{
		/* Currently locked */
		RespCod_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08 | TESTENGRUN_CNT_U08, 3.0f);
	}
	else
	{
		/* Currently unlocked */
		RespCod_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08, 3.0f);
	}

	/* Set NRC if a test failed */
	if (RespCod_Cnt_T_u16 != NOERR_CNT_U16)
	{
		DescSetExtNegResponse(iContext, kDescNrcDeviceControlLimitExceeded, RespCod_Cnt_T_u16);
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPreControlCPID_05_Feature_Control (Service request header:$AE $5 )
 * Description:This CPID is used to disable the following enhanced steering features for 1
 * ignition cycle for service technician to diagnose vehicle issue.
 * 
 * Lead and Pull Compensation
 * Brake Pulsation Mitigation
 * Smooth Road Shake Mitigation
 * 
 * This CPID shall not be executed unless the following conditions are met:
 * 
 * 1.	Vehicle Speed < 3 km/h
 * 2.	Vehicle Speed Validity = Valid
 * 3.	Propulsion System Active = FALSE ($0)
 * -	OR - 
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Vehicle Speed < 10 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 
 * 
 * The controller shall send the negative response $E3 with the following additional
 * 2 byte reason codes if the rationality conditions are not met:
 * $02 $01: Engine is Running.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * 
 * The following steering sequence shall be executed within a short time period (15
 * s, calibrateable) after CPID $05 is received.  Otherwise, CPID command shall not
 * be executed.
 * 1.	Turn the steering wheel to full left rack end stop position and hold for > 1
 * s
 * 2.	Turn the steering wheel to full right rack end stop position and hold for > 1
 * s
 * 3.	Turn the steering wheel to the straight ahead position (+/- 5 deg) for > 2 s
 * with handwheel torque < 1 Nm
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPreControlCPID_05_Feature_Control(vuint8 iContext)
{
	VAR(uint16, AUTOMATIC) RespCod_Cnt_T_u16;

	/* Test is different when CPID access is unlocked */
	if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessUnlock_Device_Control)
	{
		/* Currently locked */
		RespCod_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08 | TESTENGRUN_CNT_U08, 3.0f);
	}
	else
	{
		/* Currently unlocked */
		RespCod_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08, 10.0f);
	}

	/* Set NRC if a test failed */
	if (RespCod_Cnt_T_u16 != NOERR_CNT_U16)
	{
		DescSetExtNegResponse(iContext, kDescNrcDeviceControlLimitExceeded, RespCod_Cnt_T_u16);
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPreControlCPID_FD_System_Basic_Functions (Service request header:$AE $FD )
 * Description:This CPID shall not be executed unless the following conditions are met:
 * 
 * 1.	A successful Security Access Seed ($27 $01) and Key ($27 $02) has been
 * performed
 * 2.	Vehicle Speed < 3 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 4.	Propulsion System Active = FALSE ($0)
 * -	OR - 
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Vehicle Speed < 3 km/h
 * 3.	Vehicle Speed Validity = Valid
 * 
 * The controller shall send the negative response $E3 with the following additional
 * 2 byte reason codes if the rationality conditions are not met:
 * $02 $01: Engine is Running.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * 
 * CPID $FD shall require periodic Tester Present ($3E) messages to remain in
 * effect.
 * 
 * Disable All System Outputs
 * This device control allows a tool user to deactivate all output devices of an ECU
 * simultaneously or, if this is not possible, freeze the output(s) at its (their)
 * current value.  This prevents random behavior or periodic switching of loads
 * during a current measurement.  When this device control is active, all device
 * controls assigned in other CPIDs for that ECU can be activated/deactivated
 * independently by the other CPID (overrides CPID $FD for that output).
 * 
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPreControlCPID_FD_System_Basic_Functions(vuint8 iContext)
{
	VAR(uint16, AUTOMATIC) RespCod_Cnt_T_u16;

	/* Test is different when SPS access is unlocked */
	if (DescGetStateSecurity_Access() == kDescStateSecurity_AccessUnlock_SPS)
	{
		/* Currently SPS unlocked */
		RespCod_Cnt_T_u16 = EnvtlChk(TESTVEHSPD_CNT_U08 | TESTENGRUN_CNT_U08, 3.0f);
	}
	else
	{
		/* Currently not SPS unlocked */
		RespCod_Cnt_T_u16 = EnvtlChk(TESTSECUACS_CNT_U08 | TESTVEHSPD_CNT_U08, 3.0f);
	}

	/* Set NRC if a test failed */
	if (RespCod_Cnt_T_u16 != NOERR_CNT_U16)
	{
		DescSetExtNegResponse(iContext, kDescNrcDeviceControlLimitExceeded, RespCod_Cnt_T_u16);
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPostApplDescGenericPostControlCPID (Service request header:$AE $2 )
 * Description:At End-Of-Line, the worker drives the car into the wheel alignment station,
 * switches off the vehicle's engine, and connects the MFT/J-Link to the car.  After
 * the connection of the MFT/J-Link, the worker starts the wheel alignment process. 
 * During the wheel alignment, the engine is not running. When the combustion engine
 * is off, EPS disables the EPS motor, i.e. no servo steering is available.  This
 * CPID allows manual enabling of the servo steering even if the combustion engine
 * is off, in order to simplify the wheel alignment process.
 * 
 * The following must be true before this CPID can be successfully executed:
 * 1.	A successful Security Access Seed ($27 $03) and Key ($27 $04) has been
 * performed.
 * 2.	Engine Run Active = FALSE ($0)
 * 3.	Vehicle Speed < 10 km/h
 * 4.	Vehicle Speed Validity = Valid
 * 
 * The controller shall send the negative response $E3 with the following additional
 * 2 byte reason codes if the rationality conditions are not met:
 * $02 $01: Engine is Running.
 * $03 $08: DTC Present.
 * $04 $02: Vehicle Speed DTC Present.
 * $28 $01: Vehicle Speed Too High.
 * $FE $03 - Security Code Function Locked
 * 
 * Power Assist Mode Control
 * This device control shall allow for manual activation of the servo steering even
 * if the combustion engine is not running and the vehicle is not moving.  This
 * control should switch to 100% full assist, as long as the Stop Start Control Byte
 * is not active and requesting a different mode with reduced power assist.
 * 
 * Stop Start Control
 * This device control shall allow for manual modification of the state machine
 * added for 12V stop start.  The current control state is available in PID $43D0. 
 * The stop start control is only effective if the EPS Power Assist Mode is active
 * (Drive Up).  
 * This might be triggered by the combustion engine is running OR by using the Power
 * Assist Control which is part of this CPID.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPostApplDescGenericPostControlCPID(vuint8 iContext, vuint8 status)
{
	/* If the CPID executed successfully... */
	if (status == kDescPostHandlerStateOk)
	{
		/* start/reset the tester present timer */
		DescActivateS1Timer();
		*Rte_Pim_CpidActv() = TRUE;
	}
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDATADID_9A_Diagnostic_Data_Identifier
 * Description: Reads a signal.
 * Returns: signal value
 * Parameter(s): none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
vuint8 DESC_API_CALLBACK_TYPE ApplDescReadDidDATADID_9A_Diagnostic_Data_Identifier(void)
{
	VAR(uint8, AUTOMATIC) Buffer_Cnt_T_u08[2U];
	(void)Rte_Call_PartNrSysCodVersNrRd_Oper(Buffer_Cnt_T_u08);
	return Buffer_Cnt_T_u08[0U];
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidVersion_CodeDID_9A_Diagnostic_Data_Identifier
 * Description: Reads a signal.
 * Returns: signal value
 * Parameter(s): none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
vuint8 DESC_API_CALLBACK_TYPE ApplDescReadDidVersion_CodeDID_9A_Diagnostic_Data_Identifier(void)
{
	VAR(uint8, AUTOMATIC) Buffer_Cnt_T_u08[2U];
	(void)Rte_Call_PartNrSysCodVersNrRd_Oper(Buffer_Cnt_T_u08);
	return Buffer_Cnt_T_u08[1U];
}


#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
# if defined (DESC_ENABLE_FLASHABLE_ECU)
/* ---- $A5 sub function $03 ---- */
/* ********************************************************************************
 * Function name:ApplDescOnEnterProgMode
 * Description: Notification called once the whole "enter in programming mode" has been successfully accomplished.
 * Returns: nothing
 * Parameter(s): none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnEnterProgMode(void)
{
	/* Nothing to do here */
}
# endif
#endif

/* ********************************************************************************
 * Function name:ApplDescGetDtcStatusByMask 
 * Description: Look up function for DTC having at least one bit of the given status mask.
 * Returns:  nothing
 * Parameter(s):
 *   - iterPos:
 *       - The star position of the DTC iteration (assumed your FaultMemory is orginized in a list).
 *       - Access type: read
 *   - statusMask:
 *       - The search mask form which a DTC shall have at least one bit set (OR-ed).
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 *   - Call "DescRdiDtcStatusByMaskFound" (from this function or later) if you found such a DTC.
 *   - Call "DescRdiDtcStatusByMaskNotFound" (from this function or later) if you DIDN'T found (any more) such a DTC.
 ******************************************************************************** */
void ApplDescGetDtcStatusByMask(vuint16 iterPos, vuint8 statusMask)
{
	VAR(DescRdiDtcRecord, AUTOMATIC) DtcReport_Cnt_T_sruct;
	VAR(uint8, AUTOMATIC) UdsSts_Cnt_T_u08;
	VAR(uint8, AUTOMATIC) GmSts_Cnt_T_u08;
	VAR(boolean, AUTOMATIC) StsFound_Cnt_T_lgc = FALSE;
	VAR(uint8, AUTOMATIC) Idx_Cnt_T_u08;
	VAR(uint32, AUTOMATIC) DemDtcNum_Cnt_T_u32;

	for (Idx_Cnt_T_u08 = (uint8)(iterPos + 1U);
		((Idx_Cnt_T_u08 < DEM_CFG_GLOBAL_DTC_COUNT) && (FALSE == StsFound_Cnt_T_lgc));
		Idx_Cnt_T_u08 += 1U)
	{
		(void)Dem_GetEventStatus(Idx_Cnt_T_u08, &UdsSts_Cnt_T_u08);

		/* DTC supported by calibration [Bit 0] */
		GmSts_Cnt_T_u08 = 0x01U; /* Always supported */

		/* Current DTC [Bit 1] */
		if (0U != (UdsSts_Cnt_T_u08 & DEM_UDS_STATUS_TF))
		{
			GmSts_Cnt_T_u08 |= 0x02U;
		}

		/* Test not PASSED since DTC cleared [Bit 2] - Not Supported
		 * UDS status is "Test not *COMPLETE* since DTC cleared" which means we cannot support this GM status bit */

		/* Test failed since DTC cleared [Bit 3] */
		if (0U != (UdsSts_Cnt_T_u08 & DEM_UDS_STATUS_TFSLC))
		{
			GmSts_Cnt_T_u08 |= 0x08U;
		}

		/* History DTC [Bit 4] */
		if (0U != (UdsSts_Cnt_T_u08 & DEM_UDS_STATUS_CDTC))
		{
			GmSts_Cnt_T_u08 |= 0x10U;
		}

		/* Test not PASSED since current power up [Bit 5] - Not Supported
		 * UDS status is "Test not *COMPLETE* since current power up" which means we cannot support this GM status bit */

		/* Current DTC since power up [Bit 6] */
		if (0U != (UdsSts_Cnt_T_u08 & DEM_UDS_STATUS_TFTOC))
		{
			GmSts_Cnt_T_u08 |= 0x40U;
		}

		/* Warning indicator requested state [Bit 7] */
		if (0U != (UdsSts_Cnt_T_u08 & DEM_UDS_STATUS_WIR))
		{
			GmSts_Cnt_T_u08 |= 0x80U;
		}

		if (0U != (GmSts_Cnt_T_u08 & statusMask))
		{
			StsFound_Cnt_T_lgc = TRUE;
		}
	}

	if (TRUE == StsFound_Cnt_T_lgc)
	{
		Idx_Cnt_T_u08 -= 1U;

		(void)Dem_GetDTCOfEvent(Idx_Cnt_T_u08, DEM_DTC_KIND_ALL_DTCS, &DemDtcNum_Cnt_T_u32);
		DtcReport_Cnt_T_sruct.dtcNum = (uint16)((DemDtcNum_Cnt_T_u32 >> 8U) & 0xFFFFU);
		DtcReport_Cnt_T_sruct.failureTypeByte = (uint8)((DemDtcNum_Cnt_T_u32) & 0xFFU);
		DtcReport_Cnt_T_sruct.statusByte = GmSts_Cnt_T_u08;
		DtcReport_Cnt_T_sruct.nextIterPos = Idx_Cnt_T_u08;

		DescRdiDtcStatusByMaskFound(&DtcReport_Cnt_T_sruct);
	}
	else
	{
		DescRdiDtcStatusByMaskNotFound(DEM_CFG_GLOBAL_STATUS_MASK);
	}
}

/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4016_Ignition_Cycle_Counter (Service request header:$22 $40 $16 )
 * Description:The Ignition Cycle Counter shall be incremented each time the Comm Enable line
 * transitions from ON to OFF.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4016_Ignition_Cycle_Counter(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_IgnCycCntr_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_401B_ECU_Internal_Temperature (Service request header:$22 $40 $1B )
 * Description:The thermistor is external to the micro (located on the Main circuit board), so
 * the temperature has to be calculated from the main ADC of the ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_401B_ECU_Internal_Temperature(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EcuIntT_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4074_Steering_Wheel_Angle (Service request header:$22 $40 $74 )
 * Description:The value of the Steering Wheel Angle shall follow ISO 8855 (i.e., Steering Wheel
 * Angle is positive when rotated counterclockwise).
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4074_Steering_Wheel_Angle(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_SteerWhlAg_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_40AC_Steering_Input_Torque (Service request header:$22 $40 $AC )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_40AC_Steering_Input_Torque(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_SteerInpTq_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_40AD_Steering_Motor_Overload_Protection_Incidents (Service request header:$22 $40 $AD )
 * Description:The EPS Motor Overload Protection Incidents shall be incremented each time
 * conditions force the system to reduce system performance noticeably; i.e., each
 * time performance levels are reduced to 90% of nominal. Once started, the incident
 * lasts until KEY OFF.
 * If no Overload Protection Incident has occurred in the last 50 Ignition Cycles,
 * the EPS Motor Overload Protection Incidents shall be set to 0.
 * 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_40AD_Steering_Motor_Overload_Protection_Incidents(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EpdMotOvldProtnCntr_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_40AE_Calculated_System_Temperature (Service request header:$22 $40 $AE )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_40AE_Calculated_System_Temperature(DescMsgContext* pMsgContext)
{
	VAR(float32, AUTOMATIC) EcuT_DegC_T_f32;
	VAR(sint16, AUTOMATIC) EcuT_DegC_T_s8p7;

	(void)Rte_Read_EcuTFild_Val(&EcuT_DegC_T_f32);

	EcuT_DegC_T_f32 = Lim_f32(EcuT_DegC_T_f32, -256.0f, 255.9921875f);
	EcuT_DegC_T_s8p7 = FloatToFixdWithRound_s16_f32(EcuT_DegC_T_f32, NXTRFIXDPT_FLOATTOP7_ULS_F32);

	pMsgContext->resData[0U] = DescGetHiByte((uint16)EcuT_DegC_T_s8p7);
	pMsgContext->resData[1U] = DescGetLoByte((uint16)EcuT_DegC_T_s8p7);
	pMsgContext->resDataLen = 2U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_40AF_EPS_System_Status (Service request header:$22 $40 $AF )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_40AF_EPS_System_Status(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) VehSpdVld_Cnt_T_logl;
	VAR(SysSt1, AUTOMATIC) SysSt_Cnt_T_enum;
	VAR(float32, AUTOMATIC) PinionAgConf_Uls_T_f32;

	VAR(uint8, AUTOMATIC) EpsSts_Cnt_T_b08 = 0U;

	(void)Rte_Read_VehSpdVld_Logl(&VehSpdVld_Cnt_T_logl);
	(void)Rte_Read_SysSt_Val(&SysSt_Cnt_T_enum);
	(void)Rte_Read_PinionAgConf_Val(&PinionAgConf_Uls_T_f32);

	/* Bit 7: Vehicle Speed Validity */
	if (VehSpdVld_Cnt_T_logl == FALSE)
	{
		EpsSts_Cnt_T_b08 |= (uint8)(1U << 7U);
	}

	/* Bit 6: EPS Calibration Complete */
	/* Hard coded to 1 */
	EpsSts_Cnt_T_b08 |= (uint8)(1U << 6U);

	/* Bit 5: EPS Setup Procedure Complete */
	if (SysSt_Cnt_T_enum == SYSST_ENA)
	{
		EpsSts_Cnt_T_b08 |= (uint8)(1U << 5U);
	}

	/* Bit 4: EPS Mechanical Center Found */
	if (PinionAgConf_Uls_T_f32 >= 1.0f)
	{
		EpsSts_Cnt_T_b08 |= (uint8)(1U << 4U);
	}

	/* Bit 3: EPS Center Value Stored */
	/* -> Not supported by PSCM, hard coded to zero (default) */

	/* Bit 0-2: Reserved */

	pMsgContext->resData[0] = EpsSts_Cnt_T_b08;

	pMsgContext->resDataLen = 1u;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_40BC_Engine_Speed (Service request header:$22 $40 $BC )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_40BC_Engine_Speed(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EngSpd_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_40BD_Vehicle_Speed_Low_Resolution (Service request header:$22 $40 $BD )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_40BD_Vehicle_Speed_Low_Resolution(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_VehSpd_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_41D1_Advanced_Park_Assist_Mode_Status (Service request header:$22 $41 $D1 )
 * Description:The purpose of this PID is to display information about the status of the
 * Advanced Park Assist (APA) feature.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_41D1_Advanced_Park_Assist_Mode_Status(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) ApaSt_State_T_u08;
	VAR(uint8, AUTOMATIC) ApaFltSt_Cnt_T_b08;

	(void)Rte_Read_ApaSt_Val(&ApaSt_State_T_u08);
	/* TODO: Implement APA fault state information */

	ApaFltSt_Cnt_T_b08 = 0U;
	/* Byte 1, Bit 0: EPS APA Fault State: Speed */

	/* Byte 1, Bit 1: EPS APA Fault State: Driver Interference */

	/* Byte 1, Bit 2: EPS APA Fault State: Assist Level Too Low */

	/* Byte 1, Bit 3: EPS APA Fault State: Critical Error */


	pMsgContext->resData[0U] = ApaSt_State_T_u08;
	pMsgContext->resData[1U] = ApaFltSt_Cnt_T_b08;
	pMsgContext->resDataLen = 2U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_41D2_Electric_Power_Steering_Driver_Mode_Control_State (Service request header:$22 $41 $D2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_41D2_Electric_Power_Steering_Driver_Mode_Control_State(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) DesRtIdx_Cnt_T_u08;

	(void)Rte_Read_DesRtIdx_Val(&DesRtIdx_Cnt_T_u08);

	DesRtIdx_Cnt_T_u08 = Lim_u08(DesRtIdx_Cnt_T_u08, 0U, 7U);

	pMsgContext->resData[0U] = DesRtIdx_Cnt_T_u08;
	pMsgContext->resDataLen = 1U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_41D3_Electric_Power_Steering_Motor_Current_Commanded (Service request header:$22 $41 $D3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_41D3_Electric_Power_Steering_Motor_Current_Commanded(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EpsMotCurr_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_41D4_Electric_Power_Steering_Motor_Current_Feedback (Service request header:$22 $41 $D4 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_41D4_Electric_Power_Steering_Motor_Current_Feedback(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EpsMotCurrFb_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_41D5_Electric_Power_Steering_Torque_Overlay_Status (Service request header:$22 $41 $D5 )
 * Description:This PID is only appropriate for systems which include features using Torque
 * Overlay (e.g., Stability Control Enhancement, Lane Keeping Assist and Lane
 * Centering Control).
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_41D5_Electric_Power_Steering_Torque_Overlay_Status(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EpsTqOvrlSts_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_41D6_Electric_Power_Steering_Angle_Overlay_Status (Service request header:$22 $41 $D6 )
 * Description:This PID is only appropriate for systems which include features using Angle
 * Overlay (e.g., Advanced Park Assist).
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_41D6_Electric_Power_Steering_Angle_Overlay_Status(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EpsAgOvrlSts_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_41D7_Electric_Power_Steering_Torque_Overlay_Requested (Service request header:$22 $41 $D7 )
 * Description:This PID is only appropriate for systems which include features using Torque
 * Overlay (e.g., Stability Control Enhancement, Lane Keeping Assist and Lane
 * Centering Control).
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_41D7_Electric_Power_Steering_Torque_Overlay_Requested(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EpsTqOvrlReq_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_41D9_Steering_Ouput_Torque (Service request header:$22 $41 $D9 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_41D9_Steering_Ouput_Torque(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_SteerOutpTq_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4303_Counterclockwise_Handwheel_Angle_Traveled_Maximum (Service request header:$22 $43 $3 )
 * Description:The maximum CCW angle ever reached during the life of the steering gear.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4303_Counterclockwise_Handwheel_Angle_Traveled_Maximum(DescMsgContext* pMsgContext)
{
    VAR(float32, AUTOMATIC) HwAgCcwMax_HwDeg_T_f32;
    VAR(float32, AUTOMATIC) HwAgCwMax_HwDeg_T_f32;
    VAR(uint32, AUTOMATIC) HwAgCcwMax_HwDeg_T_u32;

    if (E_OK == Rte_Call_RtnMaxHwAgCwAndCcw_Oper(&HwAgCcwMax_HwDeg_T_f32, &HwAgCwMax_HwDeg_T_f32))
    {
        HwAgCcwMax_HwDeg_T_u32 =  FloatToFixd_s32_f32(HwAgCcwMax_HwDeg_T_f32, NXTRFIXDPT_FLOATTOP4_ULS_F32);
        pMsgContext->resData[0U] = DescGetHiHiByte(HwAgCcwMax_HwDeg_T_u32);
        pMsgContext->resData[1U] = DescGetHiLoByte(HwAgCcwMax_HwDeg_T_u32);
        pMsgContext->resData[2U] = DescGetLoHiByte(HwAgCcwMax_HwDeg_T_u32);
        pMsgContext->resData[3U] = DescGetLoLoByte(HwAgCcwMax_HwDeg_T_u32);
        pMsgContext->resDataLen = 4U;
    }
    else
    {
        /* Negative Response: Conditions Not Correct */
        DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
    }
    DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4304_Clockwise_Handwheel_Angle_Traveled_Maximum (Service request header:$22 $43 $4 )
 * Description:The maximum CW angle ever reached during the life of the steering gear.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4304_Clockwise_Handwheel_Angle_Traveled_Maximum(DescMsgContext* pMsgContext)
{
    VAR(float32, AUTOMATIC) HwAgCcwMax_HwDeg_T_f32;
    VAR(float32, AUTOMATIC) HwAgCwMax_HwDeg_T_f32;
    VAR(uint32, AUTOMATIC) HwAgCwMax_HwDeg_T_u32;

    if (E_OK == Rte_Call_RtnMaxHwAgCwAndCcw_Oper(&HwAgCcwMax_HwDeg_T_f32, &HwAgCwMax_HwDeg_T_f32))
    {
        HwAgCwMax_HwDeg_T_u32 = FloatToFixd_s32_f32(HwAgCwMax_HwDeg_T_f32, NXTRFIXDPT_FLOATTOP4_ULS_F32);
        pMsgContext->resData[0U] = DescGetHiHiByte(HwAgCwMax_HwDeg_T_u32);
        pMsgContext->resData[1U] = DescGetHiLoByte(HwAgCwMax_HwDeg_T_u32);
        pMsgContext->resData[2U] = DescGetLoHiByte(HwAgCwMax_HwDeg_T_u32);
        pMsgContext->resData[3U] = DescGetLoLoByte(HwAgCwMax_HwDeg_T_u32);
        pMsgContext->resDataLen = 4U;
    }
    else
    {
        /* Negative Response: Conditions Not Correct */
        DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
    }
    DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_43AD_Mechanical_Steering_Stops_Position_Learn_Status (Service request header:$22 $43 $AD )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_43AD_Mechanical_Steering_Stops_Position_Learn_Status(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) CwDetd_Cnt_T_logl;
	VAR(boolean, AUTOMATIC) CcwDetd_Cnt_T_logl;
	VAR(float32, AUTOMATIC) CwAg_HwDeg_T_f32;
	VAR(float32, AUTOMATIC) CcwAg_HwDeg_T_f32;
	VAR(float32, AUTOMATIC) HwAg_HwDeg_T_f32;
	VAR(boolean, AUTOMATIC) TrimCmpl_Cnt_T_logl;

	VAR(uint8, AUTOMATIC) LrnSts_Cnt_T_u08;
	VAR(uint8, AUTOMATIC) LrnErr_Cnt_T_u08;

	(void)Rte_Read_HwAgCwDetd_Logl(&CwDetd_Cnt_T_logl);
	(void)Rte_Read_HwAgCcwDetd_Logl(&CcwDetd_Cnt_T_logl);
	(void)Rte_Read_HwAgEotCw_Val(&CwAg_HwDeg_T_f32);
	(void)Rte_Read_HwAgEotCcw_Val(&CcwAg_HwDeg_T_f32);
	(void)Rte_Read_PinionAg_Val(&HwAg_HwDeg_T_f32);
	(void)Rte_Read_HwAgTrimPrfmd_Logl(&TrimCmpl_Cnt_T_logl);

	if ((CcwDetd_Cnt_T_logl == TRUE) && (CwDetd_Cnt_T_logl == TRUE))
	{
		/* Left and right fully learned */
		LrnSts_Cnt_T_u08 = 8U;
	}
	else if ((CcwAg_HwDeg_T_f32 < -Rte_Prm_EotLrngRackTrvlMin_Val()) &&
	         (CcwDetd_Cnt_T_logl == FALSE) &&
	         (CwAg_HwDeg_T_f32 > Rte_Prm_EotLrngRackTrvlMin_Val()) &&
	         (CwDetd_Cnt_T_logl == FALSE))
	{
		/* Left and right partially learned */
		LrnSts_Cnt_T_u08 = 7U;
	}
	else if ((CwAg_HwDeg_T_f32 > Rte_Prm_EotLrngRackTrvlMin_Val()) &&
	         (CwDetd_Cnt_T_logl == FALSE) &&
	         (CcwDetd_Cnt_T_logl == TRUE))
	{
		/* Right partially learned and left fully learned */
		LrnSts_Cnt_T_u08 = 6U;
	}
	else if ((CcwAg_HwDeg_T_f32 < -Rte_Prm_EotLrngRackTrvlMin_Val()) &&
	         (CcwDetd_Cnt_T_logl == FALSE) &&
	         (CwDetd_Cnt_T_logl == TRUE))
	{
		/* Left partially learned and right fully learned */
		LrnSts_Cnt_T_u08 = 5U;
	}
	else if ((CwDetd_Cnt_T_logl == TRUE) &&
	         (Abslt_f32_f32(CcwAg_HwDeg_T_f32 + Rte_Prm_EotLrngRackTrvlMin_Val()) < ARCHGLBPRM_FLOATZEROTHD_ULS_F32))
	{
		/* Right fully learned */
		LrnSts_Cnt_T_u08 = 4U;
	}
	else if ((CwAg_HwDeg_T_f32 > Rte_Prm_EotLrngRackTrvlMin_Val()) &&
	         (CwDetd_Cnt_T_logl == FALSE) &&
	         (Abslt_f32_f32(CcwAg_HwDeg_T_f32 + Rte_Prm_EotLrngRackTrvlMin_Val()) < ARCHGLBPRM_FLOATZEROTHD_ULS_F32))
	{
		/* Right partially learned */
		LrnSts_Cnt_T_u08 = 3U;
	}
	else if ((CcwDetd_Cnt_T_logl == TRUE) &&
	         (Abslt_f32_f32(CwAg_HwDeg_T_f32 - Rte_Prm_EotLrngRackTrvlMin_Val()) < ARCHGLBPRM_FLOATZEROTHD_ULS_F32))
	{
		/* Left fully learned */
		LrnSts_Cnt_T_u08 = 2U;
	}
	else if ((CcwAg_HwDeg_T_f32 < -Rte_Prm_EotLrngRackTrvlMin_Val()) &&
	         (CcwDetd_Cnt_T_logl == FALSE) &&
	         (Abslt_f32_f32(CwAg_HwDeg_T_f32 - Rte_Prm_EotLrngRackTrvlMin_Val()) < ARCHGLBPRM_FLOATZEROTHD_ULS_F32))
	{
		/* Left partially learned */
		LrnSts_Cnt_T_u08 = 1U;
	}
	else
	{
		/* Not learned (Default) */
		LrnSts_Cnt_T_u08 = 0U;
	}

	if (TrimCmpl_Cnt_T_logl == FALSE)
	{
		LrnErr_Cnt_T_u08 = 2U;
	}
	else if (Abslt_f32_f32(HwAg_HwDeg_T_f32) < ARCHGLBPRM_FLOATZEROTHD_ULS_F32)
	{
		LrnErr_Cnt_T_u08 = 3U;
	}
	else
	{
		LrnErr_Cnt_T_u08 = 0U;
	}

	pMsgContext->resData[0U] = LrnSts_Cnt_T_u08;
	pMsgContext->resData[1U] = LrnErr_Cnt_T_u08;
	pMsgContext->resDataLen = 2U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_43D0_Electric_Power_Steering_Stop_Start_Status (Service request header:$22 $43 $D0 )
 * Description:This PID shall provide read access to the state machine added for 12V stop start.
 *  This PID is only appropriate for systems on vehicles which use Auto Stop /
 * Start.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_43D0_Electric_Power_Steering_Stop_Start_Status(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EpsStopStrtSts_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_446F_Electric_Power_Steering_APA_Angle_Overlay_Requested (Service request header:$22 $44 $6F )
 * Description:This PID is only appropriate for systems which include features using Angle
 * Overlay (i.e., Advanced Park Assist).
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_446F_Electric_Power_Steering_APA_Angle_Overlay_Requested(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_EpsApaAgOvrlReq_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_44EA_Calculated_Rack_Travel (Service request header:$22 $44 $EA )
 * Description:This PID is used to show the actual steering rack travel calculated by the EPS
 * system.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_44EA_Calculated_Rack_Travel(DescMsgContext* pMsgContext)
{
	VAR(float32, AUTOMATIC) CwAg_HwDeg_T_f32;
	VAR(float32, AUTOMATIC) CcwAg_HwDeg_T_f32;

	VAR(float32, AUTOMATIC) RackTrvl_Mm_T_f32;
	VAR(uint16, AUTOMATIC) RackTrvl_Mm_T_u8p8;

	(void)Rte_Read_HwAgEotCw_Val(&CwAg_HwDeg_T_f32);
	(void)Rte_Read_HwAgEotCcw_Val(&CcwAg_HwDeg_T_f32);

	/* TODO: Multiply this result by the gear C factor (cal?) */
	RackTrvl_Mm_T_f32 = ((Abslt_f32_f32(CwAg_HwDeg_T_f32) + Abslt_f32_f32(CcwAg_HwDeg_T_f32)) / 360.0);
	RackTrvl_Mm_T_u8p8 = FloatToFixdWithRound_u16_f32(RackTrvl_Mm_T_f32, NXTRFIXDPT_FLOATTOP8_ULS_F32);

	pMsgContext->resData[0U] = DescGetHiByte(RackTrvl_Mm_T_u8p8);
	pMsgContext->resData[1U] = DescGetLoByte(RackTrvl_Mm_T_u8p8);
	pMsgContext->resDataLen = 2U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_464D_Steering_Friction_State_Of_Health (Service request header:$22 $46 $4D )
 * Description:This PID provides the estimated amount of friction in the steering system scaled
 * to a calibrateable maximum allowable system friction.  0 indicates maximum
 * allowable system friction or greater and 100 indicates a minimal or 0 friction
 * estimate.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_464D_Steering_Friction_State_Of_Health(DescMsgContext* pMsgContext)
{
	if (GetStHlthStcMin(STHLTHMONSIG_FRICESTIMN, pMsgContext->resData) != E_OK)
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_464E_Smooth_Road_Shake_SRS_Maximum_Compensation_State_of_Hea (Service request header:$22 $46 $4E )
 * Description:Smooth Road Shake (SRS) measures the oscillation frequency of the road wheel and
 * provides a counter-action intended to compensate for the oscillation so it does
 * not transfer to the steering wheel and thus, will not be felt by the driver. 
 * This PID provides the amount of Smooth Road Shake (SRS)  compensation scaled to a
 * calibrateable maximum allowable value.  0 indicates maximum allowable SRS
 * compensation or greater and 100 indicates a minimal or no SRS compensation.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_464E_Smooth_Road_Shake_SRS_Maximum_Compensation_State_of_Hea(DescMsgContext* pMsgContext)
{
	if (GetStHlthStcMin(STHLTHMONSIG_WHLIMBREJCTN, pMsgContext->resData) != E_OK)
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_464F_Controller_Temperature_State_of_Health (Service request header:$22 $46 $4F )
 * Description:This PID provides the State of Health of the controller based on the temperature
 * of the controller. 100 indicates the temperature is normal (within calibratable
 * range). 1 to 99 indicates controller temperature has passed a calibratable
 * threshold.  0 indicates that the temperature has passed a minimum or maximum
 * threshold allowed. The Out of Range byte is to notifiy which thresholds have been
 * exceeded within the ignition cycle.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_464F_Controller_Temperature_State_of_Health(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) CtrlrTRng_Cnt_T_u08;

	(void)Rte_Read_CtrlrTRng_Val(&CtrlrTRng_Cnt_T_u08);

	if (GetStHlthStcMin(STHLTHMONSIG_ECUTFILTD, &pMsgContext->resData[0U]) != E_OK)
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}
	else
	{
		pMsgContext->resData[1U] = CtrlrTRng_Cnt_T_u08;
	}

	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4650_Controller_Supply_Voltage_State_of_Health (Service request header:$22 $46 $50 )
 * Description:This PID provides the State of Health of the controller based on the supply
 * voltage of the controller. 100 indicates the voltage is normal (within
 * calibratable range).  1 to 99 indicates controller voltage has passed a
 * calibratable threshold.  0 indicates that the supply voltage has passes min/max
 * threshold allowed. Out of Range byte is to notifiy which thresholds have been
 * exceeded within the ignition cycle.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4650_Controller_Supply_Voltage_State_of_Health(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) VltgRng_Cnt_T_u08;

	(void)Rte_Read_VltgRng_Val(&VltgRng_Cnt_T_u08);

	if (GetStHlthStcMin(STHLTHMONSIG_ASSIDUETOVLTG, &pMsgContext->resData[0U]) != E_OK)
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}
	else
	{
		pMsgContext->resData[1U] = VltgRng_Cnt_T_u08;
	}

	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4651_Digital_Torque_Signal_State_of_Health (Service request header:$22 $46 $51 )
 * Description:This PID provides the state of health for Digital Torque Sensors A and B along
 * with the number of independent torque signals.  For Digital Torque Sensors A and
 * B State of Health,  0 indicates ??? Digital Torque Sensor (A & B) State of Health
 * is a percentage calculated, based on the error of the torque signal.  0 indicates
 * error threshold has been exceeded, 100 indicates no error with signal.   Digital
 * Torque Signal State of Health is a percentage calculated, based of number of
 * torque signals available, 0 indicates no signals available and 100 indicates
 * maximum number of signals available.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4651_Digital_Torque_Signal_State_of_Health(DescMsgContext* pMsgContext)
{
	if ((GetStHlthStcMin(STHLTHMONSIG_DIGTQSNSRA, &pMsgContext->resData[0U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_DIGTQSNSRB, &pMsgContext->resData[1U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_DIGTQIDPTSIG, &pMsgContext->resData[2U]) != E_OK))
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 3U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4652_EPS_Motor_Duty_Cycle_State_of_Health (Service request header:$22 $46 $52 )
 * Description:This PID provides the EPS Motor Duty Cycle relative to calibratable thresholds.
 * 100 indicates that none of the thresholds are exceeded, while 0 indicates that
 * the highest threshold has been exceeded.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4652_EPS_Motor_Duty_Cycle_State_of_Health(DescMsgContext* pMsgContext)
{
	if (GetStHlthStcMin(STHLTHMONSIG_DUTYCYC, pMsgContext->resData) != E_OK)
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4653_End_Of_Travel_Impact_State_of_Health (Service request header:$22 $46 $53 )
 * Description:This PID provides the end of travel impact count scaled to a calibrateable
 * maximum allowable value.  0 indicates the maximum allowable number of impacts
 * have occurred and 100 indicates no end of travel impacts have occurred.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4653_End_Of_Travel_Impact_State_of_Health(DescMsgContext* pMsgContext)
{
	if (GetStHlthStcPrsnt(STHLTHMONSIG_EOTIMPCT, pMsgContext->resData) != E_OK)
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4654_Analog_Motor_Position_State_of_Health (Service request header:$22 $46 $54 )
 * Description:This PID provides the analog motor position sensor state of health based upon
 * calibratable limits.  0 indicates that the sensor output has passed the minimum
 * or maximum diagnostic threshold allowed.  100 indicates the sensor output remains
 * in the the normal operating range.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4654_Analog_Motor_Position_State_of_Health(DescMsgContext* pMsgContext)
{
	if (GetStHlthStcMin(STHLTHMONSIG_MOTPOS, pMsgContext->resData) != E_OK)
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4655_EPS_Motor_Position_State_of_Health (Service request header:$22 $46 $55 )
 * Description:This PID provides the difference between the position indicated by each of three
 * sensors scaled to a calibrateable maximum allowable value.  0 indicates maximum
 * allowable position difference or greater and 100 indicates a minimal or no
 * position difference.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4655_EPS_Motor_Position_State_of_Health(DescMsgContext* pMsgContext)
{
	if ((GetStHlthStcMin(STHLTHMONSIG_MOTPOSABDIFF, &pMsgContext->resData[0U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_MOTPOSACDIFF, &pMsgContext->resData[1U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_MOTPOSBCDIFF, &pMsgContext->resData[2U]) != E_OK))
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 3U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4656_EPS_Motor_Current_State_of_Health (Service request header:$22 $46 $56 )
 * Description:This PID provides the difference between the sum of phase currents and 0 for two
 * 3-phase groups, scaled to a maximum allowable value.  0 indicates maximum
 * allowable current difference or greater and 100 indicates minimal or no current
 * difference.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4656_EPS_Motor_Current_State_of_Health(DescMsgContext* pMsgContext)
{
	if ((GetStHlthStcMin(STHLTHMONSIG_CURRMOTSUMABC, &pMsgContext->resData[0U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_CURRMOTSUMDEF, &pMsgContext->resData[1U]) != E_OK))
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4657_EPS_Motor_Phase_Voltage_State_of_Health (Service request header:$22 $46 $57 )
 * Description:This PID provides the difference between the commanded voltage and the measured
 * voltage for each phase in two 3-phase groups, scaled to a maximum allowable
 * value.  0 indicates maximum allowable voltage difference or greater and 100
 * indicates minimal or no voltage difference.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4657_EPS_Motor_Phase_Voltage_State_of_Health(DescMsgContext* pMsgContext)
{
	if ((GetStHlthStcMin(STHLTHMONSIG_MOTPOSPHASEA, &pMsgContext->resData[0U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_MOTPOSPHASEB, &pMsgContext->resData[1U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_MOTPOSPHASEC, &pMsgContext->resData[2U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_MOTPOSPHASED, &pMsgContext->resData[3U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_MOTPOSPHASEE, &pMsgContext->resData[4U]) != E_OK) ||
	    (GetStHlthStcMin(STHLTHMONSIG_MOTPOSPHASEF, &pMsgContext->resData[5U]) != E_OK))
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 6U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_4658_Random_Access_Memory_RAM_Error_Correction_Circuit_ECC_S (Service request header:$22 $46 $58 )
 * Description:This PID provides the error correction count scaled to a calibratable maximum
 * allowable value.  0 indicates the maximum allowable number of corrections or
 * greater have occurred and 100 indicates no error corrections have occurred.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_4658_Random_Access_Memory_RAM_Error_Correction_Circuit_ECC_S(DescMsgContext* pMsgContext)
{
	if (GetStHlthStcPrsnt(STHLTHMONSIG_BITCORRN, &pMsgContext->resData[0U]) != E_OK)
	{
		/* Conditions not correct to perform read */
		DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
	}

	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_8002_System_Power_Mode (Service request header:$22 $80 $2 )
 * Description:EPS shall use HS Message $1F1 SysPwrMd. If message is missing it shall default to
 * off.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_8002_System_Power_Mode(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_SysPwrMod_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_8078_Battery_Voltage_ECU_Monitored (Service request header:$22 $80 $78 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_8078_Battery_Voltage_ECU_Monitored(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_BattVltgEcu_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_819D_Vehicle_Speed_Medium_Resolution (Service request header:$22 $81 $9D )
 * Description:Speed used in EPS Control Algorithms.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_819D_Vehicle_Speed_Medium_Resolution(DescMsgContext* pMsgContext)
{
	VAR(float32, AUTOMATIC) VehSpd_Kph_T_f32;
	VAR(uint16, AUTOMATIC) VehSpd_Kph_T_u10p6;

	(void)Rte_Read_VehSpd_Val(&VehSpd_Kph_T_f32);

	VehSpd_Kph_T_f32 = Lim_f32(VehSpd_Kph_T_f32, 0.0f, 1023.984375f);
	VehSpd_Kph_T_u10p6 = FloatToFixdWithRound_u16_f32(VehSpd_Kph_T_f32, NXTRFIXDPT_FLOATTOP6_ULS_F32);

	pMsgContext->resData[0U] = DescGetHiByte(VehSpd_Kph_T_u10p6);
	pMsgContext->resData[1U] = DescGetLoByte(VehSpd_Kph_T_u10p6);
	pMsgContext->resDataLen = 2U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_82C1_Engine_Running_Status (Service request header:$22 $82 $C1 )
 * Description:EPS shall use message $C9 Engine General Status message (EngRunAtv) and the
 * Engine Run Active Signal for Byte 0, bit 1.  If message is missing EPS shall
 * default to false. 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_82C1_Engine_Running_Status(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) EngRunActv_Cnt_T_logl;
	VAR(uint8, AUTOMATIC) EngRunSts_Cnt_T_u08;

	(void)Rte_Read_EngRunActv_Logl(&EngRunActv_Cnt_T_logl);

	EngRunSts_Cnt_T_u08 = EngRunActv_Cnt_T_logl << 1U;

	pMsgContext->resData[0U] = EngRunSts_Cnt_T_u08;
	pMsgContext->resDataLen = 1U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_C000_Supplier_Internal_DTC_and_Failure_Type (Service request header:$22 $C0 $0 )
 * Description:The purpose of this PID is to record the relevant internal fault code in the
 * fault block of each recorded DTC, to be retrieved with a Read by PID ($12)
 * request.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_C000_Supplier_Internal_DTC_and_Failure_Type(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	CSDataServices_SplrIntDtcInfo_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 4U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_C010_Time_Since_Ignition_On_1 (Service request header:$22 $C0 $10 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_C010_Time_Since_Ignition_On_1(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) TrimCmpl_Cnt_T_logl;
	VAR(float32, AUTOMATIC) SasLongLermCorrn_Deg_T_f32;
	VAR(boolean, AUTOMATIC) SasInitCmpl_Cnt_T_logl;
	VAR(float32, AUTOMATIC) SasCentrOffs_Cnt_T_f32;

	VAR(sint16, AUTOMATIC) SasLongLermCorrn_Deg_T_s16;
	VAR(sint16, AUTOMATIC) SasCentrOffs_Cnt_T_s16;

	(void)Rte_Read_HwAgTrimPrfmd_Logl(&TrimCmpl_Cnt_T_logl);
	SasLongLermCorrn_Deg_T_f32 = 0.0f; /* TODO: Can this come from SF051A? */
	SasInitCmpl_Cnt_T_logl = TRUE;
	SasCentrOffs_Cnt_T_f32 = 0.0f; /* TODO: Could this come from SF053A? */

	SasLongLermCorrn_Deg_T_f32 = Lim_f32(SasLongLermCorrn_Deg_T_f32, -2048.0f, 2047.94f);
	SasLongLermCorrn_Deg_T_s16 = (sint16)(SasLongLermCorrn_Deg_T_f32 * 34.133f);
	SasCentrOffs_Cnt_T_f32 = Lim_f32(SasCentrOffs_Cnt_T_f32, -2048.0f, 2047.94f);
	SasCentrOffs_Cnt_T_s16 = (sint16)(SasCentrOffs_Cnt_T_f32 * 34.133f);

	pMsgContext->resData[0U] = DescGetHiByte(SasLongLermCorrn_Deg_T_s16);
	pMsgContext->resData[1U] = DescGetLoByte(SasLongLermCorrn_Deg_T_s16);
	pMsgContext->resData[2U] = SasInitCmpl_Cnt_T_logl;
	pMsgContext->resData[3U] = (TrimCmpl_Cnt_T_logl == TRUE) ? 1U : 0U;
	pMsgContext->resData[4U] = DescGetHiByte(SasCentrOffs_Cnt_T_s16);
	pMsgContext->resData[5U] = DescGetLoByte(SasCentrOffs_Cnt_T_s16);
	pMsgContext->resDataLen = 6U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadPidPID_C050_Time_Since_Ignition_On (Service request header:$22 $C0 $50 )
 * Description:The purpose of this PID is to record the amount of time (in milliseconds) since
 * COMM ENABLE went high.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPidPID_C050_Time_Since_Ignition_On(DescMsgContext* pMsgContext)
{
	/* PID is shared with DEM and is defined in CustDiagc.c */
	(void)CSDataServices_TiIgnOn_ReadData(pMsgContext->resData);
	pMsgContext->resDataLen = 5U;
	DescProcessingDone(pMsgContext->iContext);
}


/***************************************************************************************
 * Function name: NtWrapS_BswM_RequestMode
 * Description: Calls the function to request a mode change to BswM for flash programming
 * Returns:  None
 * Parameter(s): Mode request value.
 ***************************************************************************************/
void NONTRUSTED_NtWrapS_BswM_RequestMode(NonTrustedFunctionIndexType index, NonTrustedFunctionParameterRefType par)
{
  BswM_RequestMode(BSWM_GENERIC_BswM_PrepShutdownStatesDef, *((uint16 *)par));
} 

#if defined (DESC_ENABLE_MULTI_CFG_SUPPORT)
/* ********************************************************************************
 * Function name:ApplDescIsDataIdSupported
 * Description: Additionaly reject a supported PID (multi ECU configuration)
 * Returns:  kDescTrue - if still supported, kDescFalse - if not supported
 * Parameter(s):The PID number
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
DescBool ApplDescIsDataIdSupported(vuint16 pid)
{
  return kDescTrue;
}
#endif

/***********************************************************************************************************************
 *** Nxtr Added Local Functions ***
 **********************************************************************************************************************/

/***********************************************************************************************************************
  * Name:         EnvtlChk
  * Description:  Perform a Cyber Security environmental variable check.  Typically used before service execution.
  * Inputs:       TestMask_Cnt_T_b08: Bit field indicating which environmental checks to perform.  Differs by service.
  * Outputs:      RespCod_Cnt_T_u16: Error code upon test failure or NOERR if all tests passed.
  * Usage Notes:  None
  *********************************************************************************************************************/
STATIC FUNC(uint16, AUTOMATIC) EnvtlChk(
		VAR(vuint8, AUTOMATIC) TestMask_Cnt_T_b08,
		VAR(float32, AUTOMATIC) VehSpdThd_Kph_T_f32)
{
	VAR(boolean, AUTOMATIC) VehSpdVld_Cnt_T_logl;
	VAR(float32, AUTOMATIC) VehSpd_Kph_T_f32;
	VAR(boolean, AUTOMATIC) EngRunActv_Cnt_T_logl;
	VAR(boolean, AUTOMATIC) MissMsg0C9_Cnt_T_logl;
	VAR(float32, AUTOMATIC) HwTq_HwNm_T_f32;
	VAR(uint8, AUTOMATIC) HwTqIdptSig_Cnt_T_u08;

	VAR(uint16, AUTOMATIC) RespCod_Cnt_T_u16;

	(void)Rte_Read_VehSpdVld_Logl(&VehSpdVld_Cnt_T_logl);
	(void)Rte_Read_VehSpd_Val(&VehSpd_Kph_T_f32);
	(void)Rte_Read_EngRunActv_Logl(&EngRunActv_Cnt_T_logl);
	(void)Rte_Read_HwTq_Val(&HwTq_HwNm_T_f32);
	(void)Rte_Read_HwTqIdptSig_Val(&HwTqIdptSig_Cnt_T_u08);
	(void)Rte_Read_MissMsg0C9_Logl(&MissMsg0C9_Cnt_T_logl);

	if (((TestMask_Cnt_T_b08 & TESTSECUACS_CNT_U08) != 0x00U) &&
	     (DescGetStateSecurity_Access() != kDescStateSecurity_AccessUnlock_Device_Control))
	{
		/* Security access not "CPID_Unlock" */
		RespCod_Cnt_T_u16 = SECUCODFCTLOCKD_CNT_U16;
	}
	else if (((TestMask_Cnt_T_b08 & TESTVEHSPD_CNT_U08) != 0x00U) &&
	         (VehSpdVld_Cnt_T_logl == FALSE))
	{
		/* Vehicle speed invalid */
		RespCod_Cnt_T_u16 = VEHSPDFLTDETD_CNT_U16;
	}
	else if (((TestMask_Cnt_T_b08 & TESTVEHSPD_CNT_U08) != 0x00U) &&
	         (VehSpd_Kph_T_f32 >= VehSpdThd_Kph_T_f32))
	{
		/* Vehicle speed too high */
		RespCod_Cnt_T_u16 = VEHSPDABVCAL_CNT_U16;
	}
	else if (((TestMask_Cnt_T_b08 & TESTENGRUN_CNT_U08) != 0x00U) &&
	         (EngRunActv_Cnt_T_logl == TRUE))
	{
		/* Engine not stopped */
		RespCod_Cnt_T_u16 = ENGSPDNOTZERO_CNT_U16;
	}
	else if (((TestMask_Cnt_T_b08 & TESTMISSMSG0C9ORENGRUN_CNT_U08) != 0x00U) &&
	         (MissMsg0C9_Cnt_T_logl == FALSE) &&
	         (EngRunActv_Cnt_T_logl == TRUE))
	{
		/* Engine not stopped */
		RespCod_Cnt_T_u16 = ENGSPDNOTZERO_CNT_U16;
	}
	else if (((TestMask_Cnt_T_b08 & TESTHWTQ_CNT_U08) != 0x00U) &&
	         (HwTqIdptSig_Cnt_T_u08 == 0U))
	{
		/* Handwheel torque sensors invalid */
		RespCod_Cnt_T_u16 = FLTDETD_CNT_U16;
	}
	else if (((TestMask_Cnt_T_b08 & TESTHWTQ_CNT_U08) != 0x00U) &&
	        (Abslt_f32_f32(HwTq_HwNm_T_f32) > 3.0f))
	{
		/* Handweel torque too high */
		RespCod_Cnt_T_u16 = HWTQABVCAL_CNT_U16;
	}
	else
	{
		/* No errors found */
		RespCod_Cnt_T_u16 = NOERR_CNT_U16;
	}

	return RespCod_Cnt_T_u16;
}


/***********************************************************************************************************************
  * Name:         GetStHlthStcMin
  * Description:  Helper function to fetch minimum statistic value from state of health for a given signal.
  * Inputs:       Sig: The SoH signal enumeration for which the minimum value shall be returned.
  * Outputs:      Min: Minimum observed value from SoH [0..100]
  * Usage Notes:  None
  *********************************************************************************************************************/
STATIC FUNC(Std_ReturnType, AUTOMATIC) GetStHlthStcMin(
		VAR(StHlthMonSig2, AUTOMATIC) Sig_Cnt_T_enum,
		P2VAR(uint8, AUTOMATIC, AUTOMATIC) Min_Ptr_T_u08
)
{
	VAR(uint32, AUTOMATIC) TmpBuf_Cnt_T_u32[3U] = {0U, 0U, 0U};
	P2VAR(uint8, AUTOMATIC, AUTOMATIC) TmpBuf_Ptr_T_u08;
	VAR(Std_ReturnType, AUTOMATIC) RtnCod_Cnt_T_u08 = E_OK;

	TmpBuf_Ptr_T_u08 = (uint8*)&TmpBuf_Cnt_T_u32[0];

	if (Rte_Call_GetSigStcHlthData_Oper(Sig_Cnt_T_enum, TmpBuf_Cnt_T_u32) == E_OK)
	{
		/* Byte index 2 of TmpBuf (when accessed as a byte buffer) is the minimum value in the range (0, 100) */
		*Min_Ptr_T_u08 = TmpBuf_Ptr_T_u08[2U];
	}
	else
	{
		RtnCod_Cnt_T_u08 = E_NOT_OK;
		*Min_Ptr_T_u08 = 0x00U;
	}

	return RtnCod_Cnt_T_u08;
}


/***********************************************************************************************************************
  * Name:         GetStHlthStcPrsnt
  * Description:  Helper function to fetch current statistic value from state of health for a given signal.
  * Inputs:       Sig: The SoH signal enumeration for which the current value shall be returned.
  * Outputs:      Prsnt: Currently present signal value from SoH [0..100]
  * Usage Notes:  None
  *********************************************************************************************************************/
STATIC FUNC(Std_ReturnType, AUTOMATIC) GetStHlthStcPrsnt(
		VAR(StHlthMonSig2, AUTOMATIC) Sig_Cnt_T_enum,
		P2VAR(uint8, AUTOMATIC, AUTOMATIC) Prsnt_Ptr_T_u08
)
{
	VAR(uint32, AUTOMATIC) TmpBuf_Cnt_T_u32[3U] = {0U, 0U, 0U};
	P2VAR(uint8, AUTOMATIC, AUTOMATIC) TmpBuf_Ptr_T_u08;
	VAR(Std_ReturnType, AUTOMATIC) RtnCod_Cnt_T_u08 = E_OK;

	TmpBuf_Ptr_T_u08 = (uint8*)&TmpBuf_Cnt_T_u32[0];

	if (Rte_Call_GetSigStcHlthData_Oper(Sig_Cnt_T_enum, TmpBuf_Cnt_T_u32) == E_OK)
	{
		/* Byte index 0 of TmpBuf (when accessed as a byte buffer) is the "present" value in the range (0, 100) */
		*Prsnt_Ptr_T_u08 = TmpBuf_Ptr_T_u08[0U];
	}
	else
	{
		RtnCod_Cnt_T_u08 = E_NOT_OK;
		*Prsnt_Ptr_T_u08 = 0x00U;
	}

	return RtnCod_Cnt_T_u08;
}
