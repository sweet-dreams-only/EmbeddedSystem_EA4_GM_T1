/* -----------------------------------------------------------------------------
  Filename:    desc.c
  Description: Implementation of CANdesc.
                
                Manufacturer: General Motors
                EcuDocFile:   C:\Hari\Work\SynergyProjects\T1xx_Synergy\BuildPrep\07.02.01_Work\Z_Work_2_6561_8807\GM_T1XX_EPS_RH850\tools\GENy\EPS_T1XX_Nxtr_19.0.4_60.cdd
                Variant:      CommonDiagnostics

  Generated by CANdelaGen, Tue Feb 07 17:36:22 2017
 
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2001-2013 by Vctr Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vctr Informatik 
  GmbH.
  
  Vctr Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vctr Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    &&&~ Includes
 ----------------------------------------------------------------------------- */

/* Physical layer specific API */
#include "v_inc.h"
/* -- V_NULL Definition -- */
#if !defined(V_NULL)
# define V_NULL                                                      0
#endif

#include "desc.h"
#include "appdesc.h"

/*lint -function(exit,ApplDescFatalError)*/

#if defined (VGEN_ENABLE_NM_BASIC)
/* no IL APIs required on this type of NM */
#else
# include "il_inc.h"
#endif

#if defined (NM_TYPE_IVLAN)
# include "apif1c1.h"
#else /* NM_TYPE_GMLAN*/
/* nothing to include - il_inc.h includes the gmnmdef.h */
#endif

#if defined (DESC_ENABLE_DOBT_SUPPORT)
/* include of DOBT (Diagnostic Onboard Tester) prototypes */
# include "dobt.h"
#endif

#include "drv_par.h"


/* -----------------------------------------------------------------------------
    &&&~ Configuration switches
 ----------------------------------------------------------------------------- */

/* Default settings */
#if !defined(DESC_ENABLE_EXTERNAL_CHECK_TA) && \
    !defined(DESC_DISABLE_EXTERNAL_CHECK_TA)
# define DESC_DISABLE_EXTERNAL_CHECK_TA
#endif

#if defined (DESC_USDTNET_ENABLE_TX_LOCK_DESCICN) || \
    defined (DESC_USDTNET_ENABLE_RING_BUFFER)
# define DESC_USDTNET_ENABLE_DESCICN_STATE
#else
# define DESC_USDTNET_DISABLE_DESCICN_STATE
#endif

#if ( defined (C_COMP_TI_TMS320) && \
    !defined (DESC_ENABLE_GENTOOL_GENY) )
# define DESC_UUDTNET_ENABLE_PACKED_DATA
#endif

#if (kDescUudtNetQueueSize != kDescUudtNetNumCanMsgs) || \
    defined (DESC_UUDTNET_ENABLE_DATA_QUEUE)
# define DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF
#else
# define DESC_DISABLE_DYN_RESOURCE_TO_CAN_MSG_REF
#endif

#if !defined(DESC_UUDTNET_ENABLE_PACKED_DATA)
# define DESC_UUDTNET_DISABLE_PACKED_DATA
#endif

#if defined(DESC_UUDTNET_ENABLE_PACKED_DATA) || \
    defined(DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
# define DESC_UUDTNET_ENABLE_DATA_BUFFERS
#else
# define DESC_UUDTNET_DISABLE_DATA_BUFFERS
#endif

#if defined (C_ENABLE_TRANSMIT_QUEUE) && \
    defined (DESC_DISABLE_DYN_RESOURCE_TO_CAN_MSG_REF) && \
    !defined (DESC_UUDTNET_ENABLE_TX_FAILED_SIM)
# define DESC_UUDTNET_DISABLE_MSG_RETRANSMIT
#else
# define DESC_UUDTNET_ENABLE_MSG_RETRANSMIT
#endif

/* Enable this client support */
#define DESC_ENABLE_DYN_DEFINED_DPID_CLIENT



/* -----------------------------------------------------------------------------
    &&&~ Preprocessor constants (defines)
 ----------------------------------------------------------------------------- */

#define DESC_MAIN_VERSION                                            0x06
#define DESC_SUB_VERSION                                             0x15
#define DESC_BUGFIX_VERSION                                          0x03
/* Compatibility for older versions */
#if !defined(VSTDLIB__COREHLL_VERSION)
# define VSTDLIB__COREHLL_VERSION                                    0x00
#endif

#if (VSTDLIB__COREHLL_VERSION >= 0x216) && \
    defined (VSTD_ENABLE_INTCTRL_HANDLING)
/* VStdLib will be used */
# define DescInterruptDisable()                                      VStdSuspendAllInterrupts()
# define DescInterruptRestore()                                      VStdResumeAllInterrupts()
#else
# define DescInterruptDisable()                                      (CanGlobalInterruptDisable())
# define DescInterruptRestore()                                      (CanGlobalInterruptRestore())
#endif

#ifndef V_BOOL_EXPR
# define V_BOOL_EXPR(exp)                                            ((DescBool)((exp)?kDescTrue:kDescFalse))
#endif

/* This magic number provides inter CANdesc generation process consistency check.All CANdesc files must have the same one. */
#define DESC_IMPLEMENTATION_MAGIC_NUMBER                             22066

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# define kDescDebugPatternLen                                        2
#else
# define kDescDebugPatternLen                                        0
#endif

/* patterns for owerwrite tests */
#define kDescAssertBufferLenPattern0                                 (vuint8)0xbe
#define kDescAssertBufferLenPattern1                                 (vuint8)0xda

/* Generation consitency check */
#if (DESC_PUBLIC_INTERFACE_MAGIC_NUMBER != DESC_IMPLEMENTATION_MAGIC_NUMBER)
# error "Desc.h doesn't match the Desc.c generation time!"
#endif

#if (DESC_APPLICATION_INTERFACE_MAGIC_NUMBER != DESC_IMPLEMENTATION_MAGIC_NUMBER)
# error "AppDesc.h doesn't match the Desc.c generation time!"
#endif

#if defined(VGEN_ENABLE_VSTDLIB) || defined(V_ENABLE_VSTDLIB)
/* VStdLib is available */
#else
# error "Error in File v_cfg.h: V_ENABLE_VSTDLIB (VGEN_ENABLE_VSTDLIB) must be defined!"
#endif

#if defined(DESC_ENABLE_PID_NRC_ALL_ON_WRONG_SESSION) && \
    !defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION)
# error "Required switch DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION not set!"
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define kDescTpNumContexts                                          2
#else
# define kDescTpNumContexts                                          1
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define DESC_TPCONTEXT_PARAM_TYPE_ONLY                              vuint8
# define DESC_TPCONTEXT_PARAM_TYPE_FIRST                             vuint8,
# define DESC_TPCONTEXT_PARAM_VALUE                                  tpContext
# define DESC_TPCONTEXT_PARAM_ONLY                                   tpContext
# define DESC_TPCONTEXT_PARAM_FIRST                                  tpContext,
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY                        DESC_TPCONTEXT_PARAM_TYPE_ONLY DESC_TPCONTEXT_PARAM_ONLY
# define DESC_TPCONTEXT_PARAM_DEF_LOCAL                              DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY;
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_FIRST                       DESC_TPCONTEXT_PARAM_TYPE_ONLY DESC_TPCONTEXT_PARAM_ONLY,
# define DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(contextConst)             contextConst
# define DESC_TPCONTEXT_PARAM_WRAPPER_FIRST(contextConst)            contextConst,
# define DESC_TPCONTEXT_PARAM_WRAPPER_INDEX(contextConst)            contextConst
# define DESC_TPCONTEXT_PARAM_DUMMY_USE                              DESC_IGNORE_UNREF_PARAM(DESC_TPCONTEXT_PARAM_ONLY)
#else
# define DESC_TPCONTEXT_PARAM_TYPE_ONLY                              void
# define DESC_TPCONTEXT_PARAM_TYPE_FIRST
# define DESC_TPCONTEXT_PARAM_VALUE                                  ((vuint8)0)
# define DESC_TPCONTEXT_PARAM_ONLY
# define DESC_TPCONTEXT_PARAM_FIRST
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY                        void
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_FIRST
# define DESC_TPCONTEXT_PARAM_DEF_LOCAL
# define DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(contextConst)
# define DESC_TPCONTEXT_PARAM_WRAPPER_FIRST(contextConst)
# define DESC_TPCONTEXT_PARAM_WRAPPER_INDEX(contextConst)            0
# define DESC_TPCONTEXT_PARAM_DUMMY_USE
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
# define kDescDebugNeedTpRxChannel_BusyRepReq                        1
# define kDescDebugNeedTpTxChannel_BusyRepReq                        1
#else
# define kDescDebugNeedTpRxChannel_BusyRepReq                        0
# define kDescDebugNeedTpTxChannel_BusyRepReq                        0
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define kDescDebugNeedTpRxChannel_ParallelObd                       1
# define kDescDebugNeedTpTxChannel_ParallelObd                       1
#else
# define kDescDebugNeedTpRxChannel_ParallelObd                       0
# define kDescDebugNeedTpTxChannel_ParallelObd                       0
#endif

/* Check if TP has enough communication channels */
#define kDescNeededRxTpChannels                                      (kDescDebugNeedTpRxChannel_BusyRepReq + kDescDebugNeedTpRxChannel_ParallelObd + 1)
#define kDescNeededTxTpChannels                                      (kDescDebugNeedTpTxChannel_BusyRepReq + kDescDebugNeedTpTxChannel_ParallelObd + 1)

/* Use defaults */
/* CAN channel to TP-channel mapping */
#if !defined(kDescCan2TpChannel_0)
# define kDescCan2TpChannel_0                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_1)
# define kDescCan2TpChannel_1                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_2)
# define kDescCan2TpChannel_2                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_3)
# define kDescCan2TpChannel_3                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_4)
# define kDescCan2TpChannel_4                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_5)
# define kDescCan2TpChannel_5                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_6)
# define kDescCan2TpChannel_6                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_7)
# define kDescCan2TpChannel_7                                        kTpNoChannel
#endif


#if defined (TP_ECU_NUMBER)
# define kDescEcuNumber                                              TP_ECU_NUMBER /* Use the simple macro */
#else
# define kDescEcuNumber                                              (TP_RX_ECU_NR(0))
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define kDescUsdtNetFuncInfPoolRef                                  (vuintx)(kTpRxChannelCount)
#else
# define kDescUsdtNetFuncInfPoolRef                                  kDescPrimContext
#endif
#define kDescUsdtNetSecInfoPool                                      (vuintx)(kDescNumContexts - 1)

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define DescGetConnectionOfContext(tpContext)                       (g_descDescConnections[tpContext])
#else
# define DescGetConnectionOfContext(tpContext)                       kDescDiagConnection
#endif

#if defined (DESC_ENABLE_DOBT_SUPPORT)
# define DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_NAME, dataPtr, dataLen) (DOBTTransmit(TP_CHANNEL_TX_PARAM_FIRST (dataPtr), (dataLen)))
#else
# define DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_NAME, dataPtr, dataLen) (TpTransmit(TP_CHANNEL_TX_PARAM_FIRST (dataPtr), (dataLen)))
#endif

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# define TP_CHANNEL_RX_PARAM_VALUE                                   TP_CHANNEL_RX_PARAM_NAME
# define TP_CHANNEL_RX_PARAM_ONLY                                    TP_CHANNEL_RX_PARAM_NAME
# define TP_CHANNEL_RX_PARAM_FIRST                                   TP_CHANNEL_RX_PARAM_NAME,

# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
#  define TP_CHANNEL_TX_PARAM_VALUE                                  TP_CHANNEL_TX_PARAM_NAME
#  define TP_CHANNEL_TX_PARAM_ONLY                                   TP_CHANNEL_TX_PARAM_NAME
#  define TP_CHANNEL_TX_PARAM_FIRST                                  TP_CHANNEL_TX_PARAM_NAME,
# else
#  if defined(DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
#   define TP_CHANNEL_TX_PARAM_VALUE                                 TP_CHANNEL_TX_PARAM_NAME
#  else
#   define TP_CHANNEL_TX_PARAM_VALUE                                 0
#  endif
#  define TP_CHANNEL_TX_PARAM_ONLY                                   TP_CHANNEL_TX_PARAM_VALUE
#  define TP_CHANNEL_TX_PARAM_FIRST                                  TP_CHANNEL_TX_PARAM_VALUE,
# endif
#else
# define TP_CHANNEL_RX_PARAM_VALUE                                   0
# define TP_CHANNEL_RX_PARAM_ONLY
# define TP_CHANNEL_RX_PARAM_FIRST
# define TP_CHANNEL_TX_PARAM_VALUE                                   0
# define TP_CHANNEL_TX_PARAM_ONLY
# define TP_CHANNEL_TX_PARAM_FIRST
# define tpTxChannel                                                 0
# define tpRxChannel                                                 0
#endif
/* check TPMC settings */
#if defined (VGEN_ENABLE_TP_ISO_MC)
# if (kTpRxChannelCount < kDescNeededRxTpChannels)
#  error "Not enough TP channels, please increase the number of Rx channels under TP Options!"
# endif

# if (kTpTxChannelCount < kDescNeededTxTpChannels)
#  error "Not enough TP channels, please increase the number of Tx channels under TP Options!"
# endif
#endif

#if defined (TP_ENABLE_EXTENDED_ADDRESSING) && !defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
# error "Extended Addressing requires the a newer version of TPMC in combination with a newer GenTool"
#endif

#if defined( DESC_ENABLE_OVERRIDE_TP_MA_CHECK)
#else
# if defined(TP_ENABLE_MULTIPLE_ADDRESSING)
#  if(defined(TP_ENABLE_MIXED_11_ADDRESSING) && \
     defined(TP_ENABLE_NORMAL_ADDRESSING))  || \
     (defined(TP_ENABLE_EXTENDED_ADDRESSING) && \
     defined(TP_ENABLE_NORMAL_ADDRESSING))
/* OK */
#  else
#   error "Not supported yet!"
#  endif
# endif
#endif

#if defined(DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND) && defined (DESC_ENABLE_PARALLEL_OBD)
# error "Multi CAN workaround can not be used together with parallel OBD feature!"
#endif

#if defined(DESC_ENABLE_BUSY_REPEAT_RESPONDER)
# if (defined(TP_ENABLE_DYNAMIC_CHANNELS) && \
      defined(DESC_USDTNET_ENABLE_MULTI_TP) && \
     (defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
      defined (TP_ENABLE_NORMAL_ADDRESSING)))
/* OK */
# else
#  error "BusyRepeatRequest only allowed with Dynamic Normal Addressing Multi TP or Dynamic Normal Fixed Addressing Multi TP"
# endif
#endif

#define kDescSecBufferLen                                            7

/* Only one channel needed */
#define kDescICNChannelCount                                         1
#define kDescICNBufferLen                                            10 /* Used worse case (1Byte(SID) + 2Byte(PID) + 7Byte(Data)*/

#define kDescICNTempBufferLen                                        (vuint8_least)8

#define kDescICNDataCopyTimeout                                      100 /*ms*/
#define kDescICNDataCopyTimeoutTicks                                 (kDescICNDataCopyTimeout/(kDescCallCycleUs / 1000))

#if defined (DESC_USDTNET_ENABLE_MULTI_DESCICN)
# define DICN_CHANNEL_PARAM_TYPE_ONLY                                vuint8_least
# define DICN_CHANNEL_PARAM_TYPE_FIRST                               vuint8_least,
# define DICN_CHANNEL_PARAM_VALUE                                    busHandle
# define DICN_CHANNEL_PARAM_ONLY                                     busHandle
# define DICN_CHANNEL_PARAM_FIRST                                    busHandle,
# define DICN_CHANNEL_INFOPOOL_PARAM_VALUE                           (infoPool->busHandle)
# define DICN_CHANNEL_INFOPOOL_PARAM_ONLY                            (infoPool->busHandle)
# define DICN_CHANNEL_INFOPOOL_PARAM_FIRST                           (infoPool->busHandle),
# define DICN_CHANNEL_FORMAL_PARAM_DEF_ONLY                          DICN_CHANNEL_PARAM_TYPE_ONLY busHandle
# define DICN_CHANNEL_PARAM_DEF_LOCAL                                DICN_CHANNEL_FORMAL_PARAM_DEF_ONLY;
# define DICN_CHANNEL_FORMAL_PARAM_DEF_FIRST                         DICN_CHANNEL_PARAM_TYPE_ONLY busHandle,

#else
# define DICN_CHANNEL_PARAM_TYPE_ONLY                                void
# define DICN_CHANNEL_PARAM_TYPE_FIRST
# define DICN_CHANNEL_INFOPOOL_PARAM_VALUE                           0
# define DICN_CHANNEL_INFOPOOL_PARAM_ONLY
# define DICN_CHANNEL_INFOPOOL_PARAM_FIRST
# define DICN_CHANNEL_PARAM_VALUE                                    0
# define DICN_CHANNEL_PARAM_ONLY
# define DICN_CHANNEL_PARAM_FIRST
# define DICN_CHANNEL_FORMAL_PARAM_DEF_ONLY                          void
# define DICN_CHANNEL_PARAM_DEF_LOCAL
# define DICN_CHANNEL_FORMAL_PARAM_DEF_FIRST
#endif


/* All functions are internal - generate the static declarator. */
#define DESCNET_USDT_STATIC                                          static
/* Used for additional information about each network */
#define kDescUsdtNetInvalidDescContext                               (t_descHandle)(0xFF)

#define kDescUudtNetPaddingByte                                      (vuint8) 0x00
#define DESCNET_UUDT_STATIC                                          static
#if defined (DESC_OVERRIDE_UUDT_CONFIRMATION_NAME)
/* Used in case of dispatching between GGDA and CANdesc channel sharing */
# define DescUudtConfirmation                                        DescRealUudtConfirmation
#endif

#define DESCNET_CAN_IGNORE_UNREF_PARAM(paramName)                    ((void)paramName)

#if (kDescUudtNetQueueSize > 1)
# define RESOURCE_ITER_TYPE_ONLY                                     t_descUudtNetQueueIter
# define RESOURCE_ITER_TYPE_FIRST                                    t_descUudtNetQueueIter
# define RESOURCE_ITER_VALUE                                         queueIter
# define RESOURCE_ITER_ONLY                                          RESOURCE_ITER_VALUE
# define RESOURCE_ITER_FIRST                                         RESOURCE_ITER_VALUE,
# define RESOURCE_ITER_DEF_LOCAL                                     RESOURCE_FORMAL_ITER_DEF_ONLY;
# define RESOURCE_ITER_VALUE_DECREMENT                               RESOURCE_ITER_VALUE--
# define RESOURCE_ITER_VALUE_INCREMENT                               RESOURCE_ITER_VALUE++
# define RESOURCE_ITER_USAGE_ONLY(iter)                              iter
# define RESOURCE_ITER_USAGE_FIRST(iter)                             (iter),
#else
# define RESOURCE_ITER_TYPE_ONLY                                     void
# define RESOURCE_ITER_TYPE_FIRST
# define RESOURCE_ITER_VALUE                                         0
# define RESOURCE_ITER_ONLY
# define RESOURCE_ITER_FIRST
# define RESOURCE_ITER_DEF_LOCAL
# define RESOURCE_ITER_VALUE_DECREMENT
# define RESOURCE_ITER_VALUE_INCREMENT
# define RESOURCE_ITER_USAGE_ONLY(iter)
# define RESOURCE_ITER_USAGE_FIRST(iter)
#endif

#if (kDescUudtNetQueueSize > 1)
# define RESOURCE_PARAM_TYPE_ONLY                                    t_descUudtNetQueueIter
# define RESOURCE_PARAM_TYPE_FIRST                                   t_descUudtNetQueueIter
# define RESOURCE_PARAM_VALUE                                        queueParam
# define RESOURCE_PARAM_ONLY                                         RESOURCE_PARAM_VALUE
# define RESOURCE_PARAM_FIRST                                        RESOURCE_PARAM_VALUE,
# define RESOURCE_PARAM_DEF_LOCAL                                    RESOURCE_FORMAL_PARAM_DEF_ONLY;
# define RESOURCE_PARAM_VALUE_DECREMENT                              RESOURCE_PARAM_VALUE--
# define RESOURCE_PARAM_VALUE_INCREMENT                              RESOURCE_PARAM_VALUE++
# define RESOURCE_PARAM_USAGE(param)                                 param
#else
# define RESOURCE_PARAM_TYPE_ONLY                                    void
# define RESOURCE_PARAM_TYPE_FIRST
# define RESOURCE_PARAM_VALUE                                        0
# define RESOURCE_PARAM_ONLY
# define RESOURCE_PARAM_FIRST
# define RESOURCE_PARAM_DEF_LOCAL
# define RESOURCE_PARAM_VALUE_DECREMENT
# define RESOURCE_PARAM_VALUE_INCREMENT
# define RESOURCE_PARAM_USAGE(iter)
#endif


/* Common defines */
#define RESOURCE_FORMAL_ITER_DEF_ONLY                                RESOURCE_ITER_TYPE_ONLY RESOURCE_ITER_ONLY
#define RESOURCE_FORMAL_ITER_DEF_FIRST                               RESOURCE_ITER_TYPE_FIRST RESOURCE_ITER_FIRST

#define RESOURCE_FORMAL_PARAM_DEF_ONLY                               RESOURCE_PARAM_TYPE_ONLY RESOURCE_PARAM_ONLY
#define RESOURCE_FORMAL_PARAM_DEF_FIRST                              RESOURCE_PARAM_TYPE_FIRST RESOURCE_PARAM_FIRST


#if (kDescUudtNetNumCanMsgs > 1)
# define CAN_MSG_ITER_TYPE_ONLY                                      t_descUudtNetCanMsgIter
# define CAN_MSG_ITER_TYPE_FIRST                                     t_descUudtNetCanMsgIter
# define CAN_MSG_ITER_VALUE                                          canMsgIter
# define CAN_MSG_ITER_ONLY                                           CAN_MSG_ITER_VALUE
# define CAN_MSG_ITER_FIRST                                          CAN_MSG_ITER_VALUE,
# define CAN_MSG_ITER_DEF_LOCAL                                      CAN_MSG_ITER_TYPE_ONLY CAN_MSG_ITER_ONLY;
# define CAN_MSG_ITER_VALUE_DECREMENT                                CAN_MSG_ITER_VALUE--
# define CAN_MSG_ITER_USAGE(iter)                                    iter
#else
# define CAN_MSG_ITER_TYPE_ONLY                                      void
# define CAN_MSG_ITER_TYPE_FIRST
# define CAN_MSG_ITER_VALUE                                          0
# define CAN_MSG_ITER_ONLY
# define CAN_MSG_ITER_FIRST
# define CAN_MSG_ITER_DEF_LOCAL
# define CAN_MSG_ITER_VALUE_DECREMENT
# define CAN_MSG_ITER_USAGE(iter)
#endif

#if (kDescUudtNetNumCanMsgs > 1)
# define CAN_MSG_PARAM_TYPE_ONLY                                     t_descUudtNetCanMsgIter
# define CAN_MSG_PARAM_TYPE_FIRST                                    t_descUudtNetCanMsgIter
# define CAN_MSG_PARAM_VALUE                                         canMsgParam
# define CAN_MSG_PARAM_ONLY                                          CAN_MSG_PARAM_VALUE
# define CAN_MSG_PARAM_FIRST                                         CAN_MSG_PARAM_VALUE,
#else
# define CAN_MSG_PARAM_TYPE_ONLY                                     void
# define CAN_MSG_PARAM_TYPE_FIRST
# define CAN_MSG_PARAM_VALUE                                         0
# define CAN_MSG_PARAM_ONLY
# define CAN_MSG_PARAM_FIRST
#endif

#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
# define CAN_MSG_ITER_RESOURCE_VALUE                                 CAN_MSG_ITER_VALUE
#else
# define CAN_MSG_ITER_RESOURCE_VALUE                                 RESOURCE_PARAM_VALUE
#endif

/* Common defines */
#define CAN_MSG_FORMAL_PARAM_DEF_ONLY                                CAN_MSG_PARAM_TYPE_ONLY CAN_MSG_PARAM_ONLY
#define CAN_MSG_FORMAL_PARAM_DEF_FIRST                               CAN_MSG_PARAM_TYPE_FIRST CAN_MSG_PARAM_FIRST

/* number of bytes of a message frame */
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
/* Once CAN frame + one byte for the PIDs HiByte */
# define kDescUudtCanDataOffset                                      1
# define kDescUudtNetFrameLen                                        9
#else
# define kDescUudtCanDataOffset                                      0
# define kDescUudtNetFrameLen                                        8
#endif

#define kDescUudtNetConfTimeoutTicks                                 (kDescUudtNetConfTimeout/kDescUudtNetCycleCallTime)

/* Maximum 254 queue elements can be used */
#define kDescUudtNetBusHandleInvalid                                 (t_descUudtNetBusHandle)0xff
#define kDescUudtNetMsgRefInvalid                                    (t_descUudtNetCanMsgIter)0xff

#define kDescUudtNetCanResEngineIdle                                 (t_descUudtNetResourceState)0x00
#define kDescUudtNetCanResEngineLocked                               (t_descUudtNetResourceState)0x01
#define kDescUudtNetCanResEngineResend                               (t_descUudtNetResourceState)0x02
#define kDescUudtNetCanResEngineWaitForConf                          (t_descUudtNetResourceState)0x04
#define kDescUudtNetCanResEngineSent                                 (t_descUudtNetResourceState)0x08
#define kDescUudtNetCanResEngineDoSend                               (t_descUudtNetResourceState)0x10

#define DescUudtNetLL_MsgHandleType                                  CanTransmitHandle
#define DescUudtNetLL_MsgPtrType                                     TxDataPtr
#define DescUudtNetLL_TxStatusType                                   vuint8

#define kDescUudtNetLL_TxFailed                                      kCanTxFailed
#define kDescUudtNetLL_TxOk                                          kCanTxOk

/* Default setting for "response on request" (phys - yes, func - no) */
#define kDescDefaultResOnReq                                         0x01
#define kDescResOnAllReq                                             0x03

/* TP wrapper states */
#define kDescMainReception                                           0x01
#define kDescMainTransmission                                        0x02
#define kDescAddReception                                            0x03
#define kDescAddTransmission                                         0x04


/* Current transfer mode */
#define kDescTxModeIdle                                              0x00
#define kDescTxModeRegularRes                                        0x01
#define kDescTxModeSpecialRes                                        0x02
#define kDescTxModeRcrRpRes                                          0x04
#define kDescTxModePeriodicRes                                       0x08
#define kDescTxModeRoeResponder                                      0x10

/* RCR-RP response descriptor */
#define kDescForcedRcrRpIdle                                         0x00
#define kDescForcedRcrRpCharged                                      0x01

/* Use the worst case for the first frame length (nromal addressing with 6Byte payload) */
#define kDescFirstFrameDataLength                                    6

/* Single frame length calculation (needed for the CopyToCan assertion check)*/
/* The FF has one byte for TP usage more, 
* so the data for SF are with one byte more */
#define kDescSingleFrameDataLength                                   ((vuint8)(kDescFirstFrameDataLength + 1))

#define kDescNumPhysReqParallel                                      1
#define kDescNumFuncReqContexts                                      1
#define kDescNumPhysReqContexts                                      1
/* Transport layer abstract transmission statuses */
#define kDescTxSuccess                                               ((vuint8)kDescUsdtNetworkOk)

#define kDescP2InitValue                                             kDescP2Ticks
#define kDescP2ReloadValue                                           kDescP3maxTicks

#define kDescNrcRejectStateSecurity_Access                           kDescNrcRequestOutOfRange
#define kDescNrcRejectStateProgrammingMode                           kDescNrcConditionsNotCorrect
#define kDescStateGroupNumTransition                                  6
#define kDescStateNoTransition                                       ((DescSetStateIndex)kDescStateGroupNumTransition)

#if !defined(VN_Diagnostics)
/* The diagnsotic VN is always zero */
# define VN_Diagnostics                                              0
#endif

#define kDescNumSvcHeadConstGapBits                                  1
#define kDescNumSvcHeadSessionGapBits                                0
/* The biggest hexadecimal digit as a SID configured for this ECU. */
#define kDescMaxReqSid                                               0xAE
/* The size of the index search table. */
#define kDescSvcIdMapSize                                            111
/* SvcHead table size. */
#define kDescSvcHeadNumItems                                         19
/* SvcInst table size. */
#define kDescSvcInstNumItems                                         70
/* SvcInstHeadEx table size. */
#define kDescSvcInstHeadExtNumItems                                  60
/* Context modes */
#define kDescContextModeNormal                                       0x00
#define kDescContextModePidList                                      0x01
#define kDescContextModePeriodic                                     0x02
#define kDescContextModeRoutineControl                               0x03
#define kDescContextModeMemByAddr                                    0x04


#define kDescInvalidSvcHandle                                        (DescSvcHeadIndex)kDescSvcHeadNumItems
#define kDescInvalidSvcInstHandle                                    (DescSvcInstIndex)kDescSvcInstNumItems

/*  Negative response service ID */
#define kDescNegResSId                                               0x7F

/* Default settings for the bit structure */
#if defined(kDescNumStateSession)
#else
# define kDescNumStateSession                                        0
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# define DescExtractReqExtHeadLen(reqExtHeadLen)                     (reqExtHeadLen)
# define DescExtractResExtHeadLen(resExtHeadLen)                     (resExtHeadLen)
#else
# define DescExtractReqExtHeadLen(reqExtHeadLen)                     0
# define DescExtractResExtHeadLen(resExtHeadLen)                     0
#endif

#if !defined (kDescOemNrcParamIdNotSupportedInSession)
# define kDescOemNrcParamIdNotSupportedInSession                     kDescNrcRequestOutOfRange
#endif

#if !defined (kDescOemNrcParamIdNotSupportedInSecurityState)
# define kDescOemNrcParamIdNotSupportedInSecurityState               kDescNrcAccessDenied
#endif


/*  Length of negative response message */
#define kDescNegResLen                                               ((DescMsgLen)3)
/*  Positive response service ID offset */
#define kDescPosResIdOffset                                          ((vuint8)0x40)

#define kDescNumPreHandlers                                          9
#define kDescNumPostHandlers                                         8
/* Stores the reference of the SvcInstTable entry for the service which stops sessions (starts default session). */
#define kDescDefaultSessionSvcInstEntry                              34
/* Assign error codes to certain error situations */
#define kDescOemNrcSvcNotFound                                       kDescNrcServiceNotSupported
#define kDescOemNrcUnexpectedId                                      kDescNrcRequestOutOfRange
#define kDescOemNrcUnexpectedSubFunction                             kDescNrcSubfunctionNotSupported
#define kDescOemNrcInvalidAddrMethod                                 kDescNrcConditionsNotCorrect
#define kDescOemNrcReqLengthNotMatched                               kDescNrcInvalidFormat
#define kDescOemNrcSessionNotMatched                                 kDescNrcServiceNotSupportedInActiveMode
#define kDescOemNrcFaultTypeNotFound                                 kDescNrcRequestOutOfRange
/* No NRCs additionally suppressed */
#define DESC_OEM_SUPPRESSED_FUNC_NRC                                 /* Fall through */

#define kDescOemNrcApplAlreadyInProgMode                             kDescNrcConditionsNotCorrect
#define kDescOemNrcApplMayNotEnterProgMode                           kDescNrcConditionsNotCorrect
#define kDescOemNrcApplMayNotSetHiSpeedMode                          kDescNrcConditionsNotCorrect
#define kDescOemNrcApplProgSequenceError                             kDescNrcConditionsNotCorrect

/* GM specific negative response codes */
#define kDescOemNrcRdiAlreadyActive                                  kDescNrcConditionsNotCorrect
#define kDescOemNrcFtcNotFound                                       kDescNrcRequestOutOfRange
/* temp buffer lengths */
#define kDescBufferLen                                               5

#define kDescRdiMode80                                               0x01
#define kDescRdiMode81                                               0x02
#define kDescRdiMode82                                               0x04

/* Precalculated mask to avoid compiler warnings on clearing negated state */
#define kDescRdiModeMask                                             (kDescRdiMode80 | kDescRdiMode81 | kDescRdiMode82 )

/* Determine if the UUDt buffer switch is necessary */
#if defined(DESC_ENABLE_SERVICE_A9_82_SUPPORT)   && \
    (defined (DESC_ENABLE_SERVICE_A9_80_SUPPORT) || \
    defined (DESC_ENABLE_SERVICE_A9_81_SUPPORT))
# define DESC_ENABLE_RDI_UUDT_BUFFER_SWITCH
#else
# define DESC_DISABLE_RDI_UUDT_BUFFER_SWITCH
#endif

/* CAN channel usage signals */
#define kDescRdiUser_80                                              (vuint8_least)(0x01)
#define kDescRdiUser_81                                              (vuint8_least)(0x02)
#define kDescRdiUser_82                                              (vuint8_least)(0x04)

#define kDescRdiUserMask                                             (vuint8_least)(kDescRdiUser_80|kDescRdiUser_81|kDescRdiUser_82)

#define kDescNumPids                                                 42
/* Invalid handle after PID lookup */
#define kDescInvalidPidHandle                                        ((DescMemPidInstIndex)kDescNumPids)

#define kDescRdpiDpidSchedulingFast                                  0
#define kDescRdpiDpidSchedulingMedium                                1
#define kDescRdpiDpidSchedulingSlow                                  2
#define kDescNumOfPeriodicTimers                                     3
#define kDescRdpiDpidSchedulingOnce                                  3
#define kDescNumOfRdpiTimers                                         4
#define kDescOemNrcSchedulerFull                                     kDescNrcSchedulerFull
#define kDescOemNrcZeroLength                                        kDescNrcInvalidFormat
#define kDescOemNrcDpidNotSupported                                  kDescNrcRequestOutOfRange
#define kDescOemNrcReqTooLongForScheduled                            kDescNrcInvalidFormat
#if (kDescNumOfPeriodicTimers > 0)
# define DESC_RDPI_LAST_TIMER                                        g_descRdpiStateCtrl.lastTimer
# define DESC_RDPI_LAST_TIMER_INC                                    do{g_descRdpiStateCtrl.lastTimer++; if(g_descRdpiStateCtrl.lastTimer == kDescNumOfRdpiTimers){g_descRdpiStateCtrl.lastTimer = 0;}}while(0)
#else
# define DESC_RDPI_LAST_TIMER                                        0
# define DESC_RDPI_LAST_TIMER_INC                                    /* Not used */
#endif

#if (kDescNumOfPeriodicTimers > 0)
# define DESC_RDPI_CONTEXT_PARAM_TYPE_ONLY                           vuint8_least
# define DESC_RDPI_CONTEXT_PARAM_VALUE                               schedContext
# define DESC_RDPI_CONTEXT_PARAM_ONLY                                schedContext
# define DESC_RDPI_CONTEXT_FORMAL_PARAM_DEF_ONLY                     DESC_RDPI_CONTEXT_PARAM_TYPE_ONLY DESC_RDPI_CONTEXT_PARAM_ONLY
# define DESC_RDPI_CONTEXT_PARAM_DEF_LOCAL                           DESC_RDPI_CONTEXT_FORMAL_PARAM_DEF_ONLY;
# define DESC_RDPI_CONTEXT_PARAM_VALUE_DEC                           DESC_RDPI_CONTEXT_PARAM_VALUE--;
# define DESC_RDPI_CONTEXT_PARAM_USAGE(schedContext)                 (schedContext)
# define DESC_RDPI_CONTEXT_PARAM_VALUE_SET(value)                    (DESC_RDPI_CONTEXT_PARAM_VALUE = (value));
#else
# define DESC_RDPI_CONTEXT_PARAM_TYPE_ONLY                           void
# define DESC_RDPI_CONTEXT_PARAM_VALUE                               ((vuint8_least)0)
# define DESC_RDPI_CONTEXT_PARAM_ONLY
# define DESC_RDPI_CONTEXT_FORMAL_PARAM_DEF_ONLY                     void
# define DESC_RDPI_CONTEXT_PARAM_DEF_LOCAL
# define DESC_RDPI_CONTEXT_PARAM_VALUE_DEC
# define DESC_RDPI_CONTEXT_PARAM_USAGE(schedContext)
# define DESC_RDPI_CONTEXT_PARAM_VALUE_SET(value)
#endif


#if (kDescNumOfPeriodicTimers > 1)
# define DESC_RDPI_TIMER_PARAM_TYPE_ONLY                             vuint8_least
# define DESC_RDPI_TIMER_PARAM_TYPE_FIRST                            DESC_RDPI_TIMER_PARAM_TYPE_ONLY,
# define DESC_RDPI_TIMER_PARAM_VALUE                                 timer
# define DESC_RDPI_TIMER_PARAM_ONLY                                  timer
# define DESC_RDPI_TIMER_PARAM_FIRST                                 timer,
# define DESC_RDPI_TIMER_FORMAL_PARAM_DEF_ONLY                       DESC_RDPI_TIMER_PARAM_TYPE_ONLY DESC_RDPI_TIMER_PARAM_ONLY
# define DESC_RDPI_TIMER_PARAM_DEF_LOCAL                             DESC_RDPI_TIMER_FORMAL_PARAM_DEF_ONLY;
# define DESC_RDPI_TIMER_FORMAL_PARAM_DEF_FIRST                      DESC_RDPI_TIMER_PARAM_TYPE_ONLY DESC_RDPI_TIMER_PARAM_ONLY,

# define DESC_RDPI_TIMER_ITER_TYPE_ONLY                              DESC_RDPI_TIMER_PARAM_TYPE_ONLY
# define DESC_RDPI_TIMER_ITER_VALUE                                  timerIter
# define DESC_RDPI_TIMER_ITER_ONLY                                   timerIter
# define DESC_RDPI_TIMER_FORMAL_ITER_DEF_ONLY                        DESC_RDPI_TIMER_ITER_TYPE_ONLY DESC_RDPI_TIMER_ITER_ONLY
# define DESC_RDPI_TIMER_ITER_DEF_LOCAL                              DESC_RDPI_TIMER_FORMAL_ITER_DEF_ONLY;
# define DESC_RDPI_TIMER_ITER_VALUE_DEC                              DESC_RDPI_TIMER_ITER_VALUE--;
#else
# define DESC_RDPI_TIMER_PARAM_TYPE_ONLY                             void
# define DESC_RDPI_TIMER_PARAM_TYPE_FIRST
# define DESC_RDPI_TIMER_PARAM_VALUE                                 ((vuint8_least)0)
# define DESC_RDPI_TIMER_PARAM_ONLY
# define DESC_RDPI_TIMER_PARAM_FIRST
# define DESC_RDPI_TIMER_FORMAL_PARAM_DEF_ONLY                       void
# define DESC_RDPI_TIMER_PARAM_DEF_LOCAL
# define DESC_RDPI_TIMER_FORMAL_PARAM_DEF_FIRST

# define DESC_RDPI_TIMER_ITER_TYPE_ONLY                              DESC_RDPI_TIMER_PARAM_TYPE_ONLY
# define DESC_RDPI_TIMER_ITER_VALUE                                  ((vuint8_least)0)
# define DESC_RDPI_TIMER_ITER_ONLY
# define DESC_RDPI_TIMER_FORMAL_ITER_DEF_ONLY                        void
# define DESC_RDPI_TIMER_ITER_DEF_LOCAL
# define DESC_RDPI_TIMER_ITER_VALUE_DEC
#endif
/* CAN channel usage signals */
#define kDescRdpiUserSendOnce                                        (vuint8_least)(0x01)
#define kDescRdpiUserSendPeriodic                                    (vuint8_least)(0x02)
#define kDescRdpiUserStopPeriodic                                    (vuint8_least)(0x04)

#define kDescRdpiUserMask                                            (vuint8_least)(kDescRdpiUserSendOnce|kDescRdpiUserSendPeriodic|kDescRdpiUserStopPeriodic)

#define kDescRdpiInvalidNewDpidPos                                   (vuint8)(0xFF)

/* Multiple PIDs processing specific NRC on too many PID in single request. */
#define kDescOemNrcTooManyPIDs                                       kDescNrcInvalidFormat
/* Multiple PIDs processing specific NRC on too long response. */
#define kDescOemNrcResponseTooLong                                   kDescNrcRequestOutOfRange
/* Precalculated bit field length (in bytes)*/
#define kDescNumPostHdlrQueueBytes                                   (((kDescNumMaxPidList - 1)/ 8) + 1)
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
/* Do not hide the PID */
# define kDescReservedBytesForPid                                    0
#else
/* Do hide the PID */
# define kDescReservedBytesForPid                                    2
#endif

#define kDescDynDpidMaxNumElements                                   7
#define kDescNumDynDefinedDpids                                      5


/* -----------------------------------------------------------------------------
    &&&~ Datatype definitions
 ----------------------------------------------------------------------------- */

/*-- TP information types  --*/
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
typedef struct
{
  vuint8 resBuffer[3];
  vuint8 tpRxChannel;
} DescAddResBuffer;

typedef union
{
  vuint8           reqBuffer[7];
  DescAddResBuffer res;
} DescAddBuffer;

typedef struct
{
  vuint8        status;
  DescAddBuffer buffers;
} DescAddChannel;

typedef struct
{
  vuint8         count;
  DescAddChannel channel[kDescNumAddRequestChannels];
} DescAddChannelCtrl;

#endif /* defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)*/

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
typedef struct
{
  DescBitType type:4;
  DescBitType info:4;
} DescTpMemberCtrl;

typedef struct
{
  DescTpMemberCtrl rxPath[kTpRxChannelCount];
  DescTpMemberCtrl txPath[kTpTxChannelCount];
} DescTpCtrl;
#endif /* defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER) */

typedef struct
{
  vuint16 beginIdx;
  vuint16 endIdx;
  DescUsdtNetMsg pDestination;
}DescICNRxDataListener;

/* Find optimal timer size */
typedef vuint16  DescICNConfTimer;

#if defined (DESC_USDTNET_ENABLE_DESCICN_STATE)
typedef struct
{
# if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
  vuint16            rdIdx;
  vuint16            wrIdx;
  DescBool           doRetryDataCopy;
  DescICNConfTimer   timer;
# endif
# if defined (DESC_USDTNET_ENABLE_TX_LOCK_DESCICN)
  DescBool           isLocked;
# endif
}DescICNState;
#endif

/* forward declaration of t_descUsdtNetInfoPool */
typedef struct t_descUsdtNetInfoPoolTag t_descUsdtNetInfoPool;
typedef struct t_descUsdtNetInfoPoolTag* t_descUsdtNetInfoPoolPtr;
/* Network dependent data type */
struct t_descUsdtNetInfoPoolTag
{
  t_descUsdtNetBus        busInfo;
  t_descUsdtNetReqType    reqType;
  t_descUsdtNetResType    resType;
  t_descUsdtNetBusHandle  busHandle;
  t_descHandle            descHandle;
  vuint16                 dataLength;

  DescUsdtNetMsg          reqDataPtr;
  DescUsdtNetMsg          resDataPtr;
};

/* forward declaration of uudt net specific data types */
typedef struct t_descUudtNetInfoPoolTag t_descUudtNetInfoPool;
typedef struct t_descUudtNetInfoPoolTag* t_descUudtNetInfoPoolPtr;

typedef struct t_descUudtNetBusInfoTag t_descUudtNetBusInfo;
typedef struct t_descUudtNetBusInfoTag* t_descUudtNetBusInfoPtr;

typedef struct t_BusPropertyCANTag
{
  /* Even in the static channel fall, declare it to avoid compiler error with empty struct */
  vuint8 canChannel;
} t_busPropertyCAN;

typedef enum
{
  kDescUudtNetBusTypeNone,
  kDescUudtNetBusTypeCAN
} t_descUudtNetBusType; /* used in DescUudtNet.h */

typedef union t_descUudtNetBusPropertyTag
{
  t_busPropertyCAN  can;/* declared in DescUudtNetCan.h */
}t_descUudtNetBusProperty; /* used in DescUudtNet.h */


/* UUDT Net result return type */
typedef enum
{
  kDescUudtNetworkOk = 0,
  kDescUudtNetworkFailed = 1
} t_descUudtNetResult;

/* UUDT Net bus handle type */
typedef vuint8 t_descUudtNetBusHandle;

typedef enum
{
  kDescLifeTimeTemporary,
  kDescLifeTimePermanent
} t_descUudtNetResourceLifeTime;


typedef enum
{
  kDescClientNone,
  kDescClientRdi,
  kDescClientScheduler
} t_descUudtNetClient;

struct t_descUudtNetBusInfoTag
{
#if defined(DESC_UUDTNET_ENABLE_MULTI_BUS_SUPPORT) || \
    defined(DESC_UUDTNET_ENABLE_DYN_LIFETIME_SUPPORT) || \
    defined(DESC_UUDTNET_ENABLE_MULTI_CLIENT) || \
    defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
  /* At least one item available */
# if defined(DESC_UUDTNET_ENABLE_MULTI_BUS_SUPPORT)
  t_descUudtNetBusType          busType;        /* from DescUudtNetDispatcher.h */
# endif
# if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT) || \
     defined(DESC_UUDTNET_ENABLE_MULTI_BUS_SUPPORT)
  t_descUudtNetBusProperty      busProperty;    /* from DescUudtNetDispatcher.h */
# endif
# if defined(DESC_UUDTNET_ENABLE_DYN_LIFETIME_SUPPORT)
  t_descUudtNetResourceLifeTime lifeTime;       /* Specify the poolLifeTime */
# endif
# if defined(DESC_UUDTNET_ENABLE_MULTI_CLIENT)
  t_descUudtNetClient           client;         /* client application: GM: ReadDataPacket($AA) or ReadDataInfo ($A9) */
# endif
#else
  /* Use dummy */
  vuintx dummy;
#endif
};

struct t_descUudtNetInfoPoolTag
{
  t_descUudtNetBusInfo          busInfo;    /* Bus type: CAN, CANProperties: - msgHandle, canChannel..., lifeTime of the busResource, client*/
  t_descUudtNetBusHandle        busHandle;  /* Bus handle: internal queue engine handle */
#if defined (DESC_UUDTNET_ENABLE_DATALENGTH_USAGE)
  vuint8                        dataLength; /* The length of the data */
#endif
  vuint8*                       resDataPtr; /* Response data which has to be sent */
};

typedef vuint16 t_descUudtNetConfTimer;
typedef vuint8  t_descUudtNetResourceState;
/* Remap the busHandle type to the queue iterator type since the queue index is actually the busHandle for CAN net */
typedef vuint8_least t_descUudtNetQueueIter;
/* Index of the CANmessage state manager */
typedef vuint8_least t_descUudtNetCanMsgIter;
/* CANmsg instanced state machine */
typedef struct
{
  t_descUudtNetConfTimer    timer;
#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
  t_descUudtNetBusHandle    busHandle;
#endif
}t_descUudtNetCANTxManager;

typedef struct
{
#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
  t_descUudtNetCanMsgIter    canMsgManagerRef;
#endif
  t_descUudtNetResourceState engine;
}t_descUudtNetResourceManager;

typedef struct
{
  DescUudtNetLL_MsgHandleType  msgHandle;
  DescUudtNetLL_MsgPtrType     msgBuffer;
#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
  vuint8                       commChannel;
#endif
}t_descUudtNetMsgInfoStruct;

/* ---- Buffer management state machine ---- */
typedef struct
{
  t_descUsdtNetResult txState;/* Tp ErrorCode */
  DescBitType         contextMode                :2;/* 0x00 - Normal, 0x01 - PIDListProcess */
  DescBitType         isApplError                :1;/* 0x00 - CANdesc NR, 0x01 - APPL NR */
  DescBitType         isTransmitSingleFrameReady :1;
} DescContextCtrl;

/* ---- Interrupt context management state machine ---- */
typedef struct
{
  t_descUsdtNetInfoPoolPtr infoPoolPtr;
  vuint8             activity                 ;/* 0x00 - Idle, 0x01 - ActiveRx, 0x02 - ActiveProcess, 0x04 - ActiveTxSingleResponse ,0x08 - ActiveTxPeriodicRes, 0x10 - ActiveTxRoeResponder */
#if defined (DESC_ENABLE_FORCE_RCR_RP)
  DescBitType        forcedRcrRpState       :2;/* 0x00 - Idle, 0x01 - Charged, 0x02 - WaitConfirmation */
#endif
#if defined(DESC_ENABLE_ALL_RES_AFTER_RCRRP)
  DescBitType        rcrRpSent              :1;/* 0x00 - not sent, 0x01 - sent */
#endif
  DescBitType        isContextLocked        :1;
} DescInterruptContextCtrl;

/* ---  Timer definitions with 8 Bit CPU optimization  --- */
/* Time T2: */
/* if at least 16 bit CPU - use always 16 bit variables */
/* Time S1: */
typedef vuint16 DescS1Timer;
/* Time T2: */
typedef vuint16 DescT2Timer;

#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT) || defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
/* type definition for Response pending limit timer */
typedef vuint16 DescRcrrpLimitTimer;
#endif

typedef struct DescStateInfoTag
{
  DescStateGroup stateProgrammingMode : 4;
  DescStateGroup stateSecurity_Access : 4;
} DescStateInfo;
#if (kDescStateGroupNumTransition > 255)
  typedef vuint16    DescSetStateIndex;
#else
  typedef vuint8     DescSetStateIndex;
#endif

typedef struct
{
  DescBitType canChannel             :3; /* 0-7 */
  DescBitType isCanActive            :1; /* 0x00: No       0x01: Yes                        */
  DescBitType isUudtProcessSuspended :1; /* Set: if a stop session is waiting for confirmation */
  DescBitType dummy                  :3; /* fill 8 boundary */
} DescOemStateCtrl;

typedef vuint8 DescSvcHeadIndex; /* Typedef for the SvcHead table indexes- 8/16Bit depeding on its size. */
typedef vuint8_least DescSvcInstIndex; /* Type definition for the SvcInstTable indexes, depending on the SvcInstTable size. */
typedef vuint8 DescMemSvcInstIndex; /* Type definition for the DescMemSvcInstIndex indexes, depending on the SvcInstTable size. */
typedef vuint8 DescPreHandlerIndex; /* Type definition for the Pre-handler reference table, depending on its size. */
typedef vuint8 DescPostHandlerIndex; /* Type definition for the Post-handler reference table, depending on its size. */
typedef vuint8_least DescSvcInstHeadExtIndex; /* Type definition for the SvcInstHeadExtTable indexes, depending on the SvcInstTable size. */
typedef vuint8 DescMemSvcInstHeadExtIndex; /* Type definition for the DescMemSvcInstHeadExtIndex indexes, depending on the SvcInstTable size. */
/* Application callbacks (main handler is already defiend in  the desc.h (because of MSCall)) */
typedef void DESC_API_CALL_TYPE (*DescPreHandler)      (DESC_CONTEXT_PARAM_TYPE_ONLY);
typedef void DESC_API_CALL_TYPE (*DescPostHandler)     (DESC_CONTEXT_PARAM_TYPE_FIRST vuint8);

typedef struct
{
  DescBitType                reqHeadByteSpec   :8; /* Each bit represents sub-function/identifier - 0: identifier; 1: any subfunction */
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
  DescBitType                reqHeadExLen      :4; /* Request HeadEx length up to 7 Byte  */
  DescBitType                resHeadExLen      :4; /* Response HeadEx length up to 7 Byte */
#endif
#if defined (DESC_ENABLE_ADDR_METHOD_CHECK)
  DescBitType             reqType           :2; /* 0x01: Phys 0x02: Func */
  DescBitType             resOnReq          :2; /* 0x01: Phys 0x02: Func */
#endif
  DescBitType             suppPosRes        :1; /* 0x00: No   0x01: Yes  */
  DescBitType             isReqHeadExtEchoed:1; /* 0x00: No   0x01: Yes  */
  DescBitType             hasSubFunction    :1; /* 0x00: No   0x01: Yes  */
#if (kDescNumSvcHeadConstGapBits > 0)
  DescBitType             svcHeadPlaceHolder:kDescNumSvcHeadConstGapBits; /* Gap holder  */
#endif
#if defined (DESC_ENABLE_AUTO_STATES)
# if defined (DESC_ENABLE_ALL_STATEGROUPS_SID_CHECK)
  DescStateInfo           checkState;
# else
#  if (kDescNumStateSession > 0)
  DescStateGroup          checkSessionState :kDescNumStateSession;/* State group Session on SId level */
#   if (kDescNumSvcHeadSessionGapBits > 0)
  DescBitType             sessionPlaceHolder:kDescNumSvcHeadSessionGapBits; /* Gap holder  */
#   endif
#  endif
# endif
#endif
#if defined (DESC_ENABLE_MIN_REQ_LEN_CHECK) && \
    defined (DESC_ENABLE_SUB_SVC_USAGE)
  vuint8                  minReqLength;
#endif
#if defined (DESC_ENABLE_MULTI_VARIANT)
  DescVariantMask         variantMask;
#endif
/* First item in Service Instance table */
  DescMemSvcInstIndex        svcInstFirstItem;
  DescMemSvcInstHeadExtIndex svcInstHeadExtFirstItem;
} DescSvcHead;

typedef struct
{
  DescMsgLen             reqLen;
#if defined (DESC_ENABLE_ADDR_METHOD_CHECK)
  DescMsgAddInfo         msgAddInfo;
#endif
#if defined (DESC_ENABLE_AUTO_STATES)
  DescStateInfo          checkState;
# if (kDescStateGroupNumTransition > 0)
  DescSetStateIndex      setStateIndex;
# endif
#endif /* DESC_ENABLE_AUTO_STATES */
#if defined (DESC_ENABLE_MULTI_VARIANT)
  DescVariantMask        variantMask;
#endif
#if defined (DESC_ENABLE_PREHANDLER_USAGE)
  DescPreHandlerIndex    preHandlerRef;
#endif
#if defined (DESC_ENABLE_POSTHANDLER_USAGE)
  DescPostHandlerIndex   postHandlerRef;
#endif
  DescMainHandler        mainHandler;
} DescSvcInst;

typedef struct
{
  DescBitType  reqMode       :3;/* 0x00 - none, 0x01 - $80, 0x02 - $81, 0x04 - $82 */
  DescBitType  isLastDtcFound:1;/* 0x00 - No, 0x01 - Yes,  */
  DescBitType  isFirstAnswer :3;/* 0x00 - None, 0x01 - for $80, 0x02 - for $81, 0x04 - for $82, */
  DescBitType  is81ModeActive:1;/* 0x00 - No, 0x01 - Yes,  */
  DescBitType  answerMode    :3;/* 0x00 - none, 0x01 - $80, 0x02 - $81, 0x04 - $82 */
  DescBitType  is82ModeActive:1;/* 0x00 - No, 0x01 - Yes,  */
}DescRdiStateCtrl;

typedef vuint8_least DescPidInstIndex;
typedef vuint8 DescMemPidInstIndex;
typedef enum
{
  pmAnalyseReasonNone = 0,
  pmAnalyseReasonSession,
  pmAnalyseReasonSecurityState,
  pmAnalyseReasonOther
}DescPidAnalyseFailureReason;

typedef enum
{
  pmClientReadOnce = 0,
  pmClientReadCycle,
  pmClientDynDefine
}DescPidClient;

typedef struct
{
#if defined (DESC_ENABLE_AUTO_STATES)
  DescStateInfo        checkState;
#endif /* DESC_ENABLE_AUTO_STATES */
#if defined (DESC_ENABLE_PID_PREHANDLER_USAGE)
  DescPreHandlerIndex  preHandlerRef;
#endif
  DescMsgAddInfo       msgAddInfo;
#if defined (DESC_ENABLE_MULTI_VARIANT)
  DescVariantMask      variantMask;
#endif
}DescPidTinyInfo;

typedef struct
{
  DescMemPidInstIndex  pidHandle;
  DescPidTinyInfo      tinyInfo;
}DescPidClientInfo;

typedef struct
{
  vuint16              reqPid;
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || \
    defined(DESC_ENABLE_PID_LIST_MODE)        || \
    defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
  DescMsgLen           resDataLen;
#endif
  DescPidTinyInfo      tinyInfo;
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
  DescPostHandlerIndex postHandlerRef;
#endif
  DescMainHandler      mainHandler;
} DescPidInst;

/* function type of the application DPID handlers */
typedef void (*DescDpidHandler)(DescMsg);
typedef vuint16 DescSchedulerTimer;

/* state machine for each type of DPID scheduling (fast, medium, slow, single shot) */
typedef struct
{
  vuint8      count;
  vuint8      currentListPos;
  vuint8      newItems1stPos;
  DescBitType isTimeExpired   : 1;
  DescBitType isTimeOverrun   : 1;
  DescBitType dummy           : 2;
} DescSchedulerState;


/* component state machine */
typedef struct
{
  DescBitType lastTimer        :8;
  DescBitType activeTimers     :8;
  DescBitType isPending1stAck  :4; /* Bit map which timer awaits a first acknowledge */
  DescBitType isWaitingResUudt :1;
  DescBitType dummy            :3;
} DescRdpiStateCtrl;

typedef struct
{
  DescBitType    pidCount            :8;
  DescBitType    curPid              :8;
  DescBitType    isPidReady          :1;
  DescBitType    isPidProcessed      :1;
  DescBitType    dummyGap            :6;
}DescPidProcessorState;

typedef struct
{
  DescMemPidInstIndex  pids[kDescDynDpidMaxNumElements];
  vuint8               numOfItems;
  vuint8               resDataLength;
}DescDynDpidInfo;


typedef struct
{
  vuint8             currentItem;
  vuint8             currentItemLen;
  vuint8             lastUsedDpidHandle;
  vuint8             definedDpidHandle;
  vuint8             currentDpidLen;
  DescBitType        doProcessNextItem  : 1;
  DescBitType        isDataExtractActive: 1;
  DescMsg            uudtResPtr;
}DescDefDynDpidContextState;



/* -----------------------------------------------------------------------------
    &&&~ Function prototypes
 ----------------------------------------------------------------------------- */

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
static void CheckTableConsistency(void);
#endif
#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
static void DescDebugIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif

DESCNET_USDT_STATIC void DescUsdtNetIsoTpInitPowerOn(void);
DESCNET_USDT_STATIC void DescUsdtNetIsoTpInit(void);

DESCNET_USDT_STATIC void DescUsdtNetIsoTpStateTask(void);

DESCNET_USDT_STATIC void DescUsdtNetIsoTpPrepareResponse(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void DescUsdtNetIsoTpTransmitResponse(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void DescUsdtNetIsoTpReleaseInfoPool(t_descUsdtNetInfoPoolPtr infoPool);

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC vuint16 DescUsdtNetIsoTpGetRingBuffTxMinLen(t_descUsdtNetInfoPoolPtr infoPool);
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
static void DescBusyResponseHandler(void);
#endif
#if defined (DESC_ENABLE_PARALLEL_OBD)
static vuint8 DescDispatchServiceContext(vuint8 sid);
#endif
static void DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescUsdtNetIsoTpCopyToCan(TpCopyToCanInfoStructPtr infoStruct);

#if defined (TP_FUNC_ENABLE_RECEPTION) && \
    defined (DESC_ENABLE_RES_ON_FUNC_REQUEST) && \
    (kDescNumFuncReqContexts > 0)
/* Generic check funtion prototype */
static DescBool DescCheckResponseRequiredOnFunc(DescMsg reqData, DescMsgLen dataLength);
#endif
/* perform an adress check in case of functional requests with extended addressing */
#if defined (DESC_ENABLE_FUNCREQ_TA_CHECK)
static DescBool DescIsTAAcceptable(vuint8 targetAddress);
#endif

DESCNET_USDT_STATIC void DescUsdtNetDescICNInitPowerOn(void);
DESCNET_USDT_STATIC void DescUsdtNetDescICNInit(void);
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC void DescUsdtNetDescICNStateTask(void);
DESCNET_USDT_STATIC void DescUsdtNetDescICNTimerTask(void);
#endif
DESCNET_USDT_STATIC void DescUsdtNetDescICNPrepareResponse(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void DescUsdtNetDescICNTransmitResponse(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void DescUsdtNetDescICNReleaseInfoPool(t_descUsdtNetInfoPoolPtr infoPool);

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC vuint16 DescUsdtNetDescICNGetRingBuffTxMinLen(t_descUsdtNetInfoPoolPtr infoPool);
#endif
/* API call to DescICN */
DESCNET_USDT_STATIC t_descUsdtNetInfoPoolPtr  DescICNAllocateTxResource(const t_AddrInfoDescICN* const pAddrInfo);
DESCNET_USDT_STATIC void                      DescICNSetRxDataListener(t_descUsdtNetInfoPoolPtr infoPool, const DescICNRxDataListener * const dataListener);
DESCNET_USDT_STATIC void                      DescICNSendRequest(t_descUsdtNetInfoPoolPtr infoPool);
#if defined (DESC_USDTNET_ENABLE_TX_LOCK_DESCICN)
DESCNET_USDT_STATIC void                      DescICNLockTxResource(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void                      DescICNUnlockTxResource(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void                      DescICNReleaseTxResource(t_descUsdtNetInfoPoolPtr infoPool);
#endif
/* API DescICN callbacks */
DESCNET_USDT_STATIC void                      DescICNRxMsgInd(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);

static void DescICNGetResponseData(DICN_CHANNEL_FORMAL_PARAM_DEF_ONLY);
static void DescICNDoExitRxProcess(DICN_CHANNEL_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult result);

#if defined(DESC_USDTNET_ENABLE_LONGSERVICE_SUPPORT)
DESCNET_USDT_STATIC void                DescUsdtNetLSFinishReception         (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC void                DescUsdtNetLSFinishTransmission      (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetLSStartReception          (t_descUsdtNetInfoPoolPtr infoPool);
/* Copy data from ringbuffer into network layer */
# if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetLSRingBufferCopyRoutine   (t_descUsdtNetInfoPoolPtr infoPool, DescUsdtNetMsg pDestination, vuint8 dataLength);
# endif
#endif
/* Call backs */
DESCNET_USDT_STATIC void                DescUsdtNetAbsFinishReception         (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC void                DescUsdtNetAbsFinishTransmission      (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsStartReception          (t_descUsdtNetInfoPoolPtr infoPool);
/* Copy data from ringbuffer into network layer */
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsRingBufferCopyRoutine   (t_descUsdtNetInfoPoolPtr infoPool, DescUsdtNetMsg pDestination, vuint8 dataLength);
#endif

/* Generic API  */
DESCNET_USDT_STATIC void                DescUsdtNetReleaseInfoPool         (t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void                DescUsdtNetInitPowerOn             (void);
DESCNET_USDT_STATIC void                DescUsdtNetInit                    (void);
DESCNET_USDT_STATIC void                DescUsdtNetStateTask               (void);
DESCNET_USDT_STATIC void                DescUsdtNetTimerTask               (void);
DESCNET_USDT_STATIC void                DescUsdtNetTransmitResponse        (t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void                DescUsdtNetPrepareResponse         (t_descUsdtNetInfoPoolPtr infoPool);

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC vuint16             DescUsdtNetGetRingBuffTxMinLen     (t_descUsdtNetInfoPoolPtr infoPool);
#endif

#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
#else
DESCNET_USDT_STATIC DescUsdtNetMsg      DescUsdtNetGetTransmissionPtr      (t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void                DescUsdtNetReleaseTransmissionObj  (t_descUsdtNetInfoPoolPtr infoPool);
#endif

DESCNET_UUDT_STATIC void                      DescUudtNetCANInitPowerOn(void);
DESCNET_UUDT_STATIC void                      DescUudtNetCANInit(void);
DESCNET_UUDT_STATIC void                      DescUudtNetCANTimerTask(void);
DESCNET_UUDT_STATIC void                      DescUudtNetCANStateTask(void);
DESCNET_UUDT_STATIC t_descUudtNetInfoPoolPtr  DescUudtNetCANTxReserveResource(t_descUudtNetBusInfoPtr busInfo);
DESCNET_UUDT_STATIC void                      DescUudtNetCANTransmitResponse(t_descUudtNetInfoPoolPtr infoPool);
DESCNET_UUDT_STATIC void                      DescUudtNetCANReleaseResource(t_descUudtNetInfoPoolPtr infoPool);
#if (kDescUudtNetQueueSize > 1)
DESCNET_UUDT_STATIC void                      DescUudtNetCANCancelAllResponses(void);
#endif

DESCNET_UUDT_STATIC void                     DescUudtNetFinishTransmission(t_descUudtNetInfoPoolPtr infoPool, t_descUudtNetResult status);

static void DescUudtNetTryToSendMsg (RESOURCE_FORMAL_PARAM_DEF_ONLY);
static void DescUudtNetCanTxMsgEnd(RESOURCE_FORMAL_PARAM_DEF_FIRST t_descUudtNetResult status);
static void DescUudtNetInitPowerOnResourceManager(RESOURCE_FORMAL_PARAM_DEF_ONLY);
static void DescUudtNetInitCanMsgManager(CAN_MSG_FORMAL_PARAM_DEF_ONLY);
static void DescUudtNetInitResourceManager(RESOURCE_FORMAL_PARAM_DEF_ONLY);

static void DescNetworkOnceInit(void);
static void DescNetworkIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescNetworkInitPowerOn(void);
static void DescNetworkInit(void);

static void DescTransmitRcrRp(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescReleaseContext(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescSetDiagActive(t_descUsdtNetInfoPoolPtr infoPool);
static void DescOemRxErrorInd(t_descUsdtNetResult status);

static void DescTimingOnceInit(void);
static void DescTimingIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescOemTimer(void);
static void DescOemS1Timeout(void);

#if defined (DESC_ENABLE_SERVICE_A9_SUPPORT) || \
    defined (DESC_ENABLE_SCHEDULED)
static void DescOemStateTask(void);
#endif

static void DescStateOnceInit(void);

/* ---- used by the timings subcomponent ---- */
static void  DescOemOnStopSession(void);
static void  DescSetDiagInactive(void);
/* ---- used by the processor subcomponent ---- */
static void  DescOnDisableNormalComm(void);

/* ---- Providing interface between subcomponents Dispatch and Network ---- */
static void DescDoPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult status);
/* Internal API for INIT */
static void DescDispatcherIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
static DescSvcInstIndex DescFindSvcInst(DescConstPtr reqHeadPtr, V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, vuint8_least* failedByteMask);
#endif
static DescSvcHeadIndex DescFindSvc(DescMsgItem reqSvcId);

static void DescDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
static vuint8_least DescGetSvcInstHeadExtEntrySize(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead);
# if defined(C_COMP_NEC_78K0_AFCAN)
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
# else
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
# endif
#endif

#if defined (DESC_ENABLE_PID_LIST_MODE)
static void DescFinalProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif

static void DescOemInvalidSubServiceEvent(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescOemInit(void);

static void DescContextStateTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DESC_API_CALLBACK_TYPE DescGenReadDidDID_9A_Diagnostic_Data_Identifier(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemStopDiagnosticSession(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescReadDataByIdentifier(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemDisableNormalCommunication(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescProcessDynamicallyDefineDpid(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescGenSendTesterPresent(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescGenRequestProgrammingMode(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemEnableProgrammingMode(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescReadStatusOfDTCByStatus(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescReadDpidStop(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescReadDpidOnce(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescReadDpidSlow(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescReadDpidMedium(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescReadDpidFast(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescPreReadStatusOfDTC(vuint8 iContext);
static void DESC_API_CALLBACK_TYPE DescOemPostStopDiagnosticSession(vuint8 iContext, vuint8 status);
static void DESC_API_CALLBACK_TYPE DescPostReadDataByIdentifier(vuint8 iContext, vuint8 status);
static void DESC_API_CALLBACK_TYPE DescPostProcessDynamicallyDefineDpid(vuint8 iContext, vuint8 status);
static void DESC_API_CALLBACK_TYPE DescOemPostSendTesterPresent(vuint8 iContext, vuint8 status);
static void DESC_API_CALLBACK_TYPE DescOemPostEnableProgrammingMode(vuint8 iContext, vuint8 status);
static void DESC_API_CALLBACK_TYPE DescPostReadDpidPeriodic(vuint8 iContext, vuint8 status);
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FA(DescMsg pMsg);
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FB(DescMsg pMsg);
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FC(DescMsg pMsg);
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FD(DescMsg pMsg);
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FE(DescMsg pMsg);
#if defined (DESC_ENABLE_ANY_PREHANDLER_USAGE)
static void DESC_API_CALL_TYPE DescDummyPreHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif
#if defined (DESC_ENABLE_ANY_POSTHANDLER_USAGE)
static void DESC_API_CALL_TYPE DescDummyPostHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status);
#endif

static void DescRdiPowerOnInit(void);
static void DescRdiInit(void);
static void DescRdiStateTask(void);
#if defined (DESC_ENABLE_SERVICE_A9_81_SUPPORT)
static void DescRdiUudtConfirmation(void);
#endif

static DescPidInstIndex DescPmGetPidPoolHandle   (vuint16 pid);
static DescPidInstIndex DescPmGetAvailablePidHandle(vuint16 pid);
#if defined(DESC_ENABLE_PERIODIC_MODE)
static DescPidInstIndex DescPmGetSupportedPidClientHandle(vuint16 pid, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable);
#endif
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || defined(DESC_ENABLE_PERIODIC_MODE)
static DescPidInstIndex DescPmGetPidClientHandle (DescPidInstIndex pidInfoHandle, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable);
#endif
static DescPidAnalyseFailureReason DescPmAnalysePid(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST V_MEMROM1 DescPidTinyInfo V_MEMROM2 V_MEMROM3 * pRefTinyInfo);
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || \
    defined(DESC_ENABLE_PID_LIST_MODE)        || \
    defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
static DescMsgLen       DescPmGetPidResponseLen  (DescPidInstIndex pidHandle);
#endif

static void     DescRdpiInit(void);
static void     DescRdpiStateTask(void);
static void     DescInitSingleScheduler(DESC_RDPI_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static vuint8_least DescRdpiGetDpidHandle(vuint8 dpid);
static DescBool     DescRdpiCheckDpid(vuint8 dpid);

#if (kDescNumOfPeriodicTimers > 0)
static void     DescRdpiTimerTask(void);
static void     DescUpdateScheduler(DESC_RDPI_TIMER_FORMAL_PARAM_DEF_FIRST DescMsgContext *pMsgContext);
static void     DescRdpiDeletePid(vuint8 dpid);
static void     DescInitScheduler(void);
static void     DescRdpiStopAll(void);
#else
# define DescRdpiTimerTask()                                         /* Not used */
# define DescInitScheduler()                                         /* Not used */
# define DescRdpiStopAll()                                           /* Not used */
#endif


static void DescIterInitPidListProcessor(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescPidProcessorTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescPidProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescPidDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescDynDpidTask(void);
static void DescOnceInitDynDefineDpid(void);
#if defined (DESC_ENABLE_DYN_DPID_DEFINED_CHECK)
static DescBool DescDynDpidIsDefined(vuint8 dpid);
#endif
static void DescDefDynDpidAppendPidDefinition(DescMsgContext* pMsgContext);
static void DescDynDpidClearTable(void);
static void DescDynDefinedDpidRxMsgInd(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
static void DescCommonReadDynDefinedDpid(DescMsg pMsg, vuint8_least dpidHandle);
static vuint8_least DescGetDynDpidHandle(vuint8_least globalDpidHandle);
#if defined (DESC_UUDTNET_ENABLE_DATALENGTH_USAGE)
static vuint8_least DescDynDpidGetResLength(vuint8_least dpidHandle);
#endif



/* -----------------------------------------------------------------------------
    &&&~ RAM definitions
 ----------------------------------------------------------------------------- */

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
static vuint8 g_descUsdtNetTpTxChannel[kDescTpNumContexts];
# endif
#endif
static t_descUsdtNetInfoPool  g_descUsdtNetInfoPoolIsoTp[kDescNumContexts];
#if defined (DESC_ENABLE_PARALLEL_OBD)
static t_descUsdtNetInfoPoolPtr g_busInfoPoolRxRef[kTpRxChannelCount + 1]; /* rx channels + one functional */
#endif
static t_descUsdtNetInfoPoolPtr g_busInfoPoolTxRef[kTpTxChannelCount];

DESC_USDTNET_PRVT_DEF_VAR_FAR(vuint8) g_descBuffer[kDescTpNumContexts][kDescPrimBufferLen];

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
/* Tp state controller  */
static DescTpCtrl g_descTpCtrl;
#endif
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
/* Parallel request responder state controller 
 use memory model specific define, since there are embedded Rx and Tx Buffers insider.
*/
DESC_USDTNET_PRVT_DEF_VAR_FAR(DescAddChannelCtrl) g_descAddChannelCtrl;
#endif

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
# if defined(C_COMP_COSMIC_MCS12X_MSCAN12) && \
     defined(V_ENABLE_USED_GLOBAL_VAR)
DESC_USDTNET_PRVT_DEF_VAR_FAR(vuint8) g_descCopyToCanData[7];
# endif
#endif

#if defined(TP_FUNC_ENABLE_RECEPTION) && \
    (kDescNumFuncReqContexts > 0)
/* second buffer for functional without response purpose only */
DESC_USDTNET_PRVT_DEF_VAR_FAR(vuint8) g_descSecBuffer[kDescSecBufferLen];
/* storage for infoPool reference for functional reception */
static t_descUsdtNetInfoPoolPtr g_busInfoPoolFuncRef;
#endif

static t_descUsdtNetInfoPool  g_descUsdtNetInfoPoolDescICN[kDescICNChannelCount];
#if defined (DESC_USDTNET_ENABLE_DESCICN_STATE)
static DescICNState           g_descIcnState[kDescICNChannelCount];
#endif
static DescICNRxDataListener  g_descListenerConfig[kDescICNChannelCount];
DESC_USDTNET_PRVT_DEF_VAR_FAR(vuint8) g_descIcnBuffer[kDescICNChannelCount][kDescICNBufferLen];

static t_descUudtNetInfoPool g_descUudtNetInfoPoolCAN[kDescUudtNetQueueSize];

#if defined(DESC_UUDTNET_ENABLE_DATA_BUFFERS)
/* Optional data queue */
static vuint8 g_descUudtNetDataQueueBuffers[kDescUudtNetQueueSize][kDescUudtNetFrameLen];
#endif

#if (kDescUudtNetQueueSize > 1)
static t_descUudtNetQueueIter  g_descUudtNetPrioQueueCount;
static t_descUudtNetQueueIter  g_descUudtNetPrioQueue[kDescUudtNetQueueSize];
#endif

static t_descUudtNetResourceManager  g_descUudtNetResourceManager[kDescUudtNetQueueSize];

/* CAN msg specific monitoring manager */
static t_descUudtNetCANTxManager  g_descUudtNetCanMsgManager[kDescUudtNetNumCanMsgs];
#if (kDescUudtNetNumCanMsgs > 1)
static t_descUudtNetCanMsgIter    g_descUudtNetCanMsgCounter;
#endif
#if defined (DESC_UUDTNET_ENABLE_TX_FAILED_SIM)
static DescBool                   g_descUudtNetDoSimFailed;
#endif

/* Extra buffer for the "response pending" negative response */
DESC_PRVT_DEF_VAR_FAR(DescMsgItem) g_descRcrrpBuffer[kDescNumContexts][3];

/* Global storage of the user response information */
#if defined (DESC_ENABLE_SPONTANEOUS_RES)
static t_descUsdtNetInfoPool  g_descUsdtNetSpontanResInfoPool;
#endif

/* State machine of each received request */
static DescContextCtrl          g_descContextCtrl[kDescNumContexts];
static DescInterruptContextCtrl g_descInterruptContextCtrl[kDescNumContexts];
#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
static vuint8                   g_descTesterAddress[kDescNumContexts];
#endif

/* The response for the S1 Timeout */
/* It must be declared as a memory data, because of the API requirement of the 
* DescTransmitSingleFrame function */
static vuint8  g_descResSidStopSession;

#if defined (DESC_ENABLE_UUDT_NET)
/* DescUudtNet info struct */
static t_descUudtNetBusInfo g_descUudtNetInfo;
#endif

/* Flag for activating/deactivating the S1 monitoring */
#if defined (DESC_ENABLE_S1_SINGLE_SVC_RELOAD)
static DescBool  g_descIsS1TimerActive;
#endif
#if defined (DESC_ENABLE_S1_ANY_SVC_RELOAD)
static DescBool  g_descDoReloadS1Timer;
#endif

#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT) || defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
/* Limitation timer/counter for maximal time window for "response pending" 
* negative responses that will be sent. */
static DescRcrrpLimitTimer g_descRcrrpLimitCounter[kDescNumContexts];
#endif

/* T2 timer for response pending support */
static DescT2Timer  g_descT2Timer[kDescNumContexts];
/* "Tester present" timer */
static DescS1Timer  g_descS1Timer;

/* GM-LAN VN timer */
static vuint16 g_vnTimer;

/* State machine of CANdesc described by CANdelaStudio */
static DescStateInfo g_descCurState;

/* ---- All generated states relevant for diagnostic management ---- */
static DescOemStateCtrl g_descOemStateCtrl;

/* Store the service entry index for the current request */
static DescSvcHeadIndex      g_descCurReqSvc[kDescNumContexts];

/* Store the instance entry index for the current request */
static DescMemSvcInstIndex   g_descCurReqSvcInst[kDescNumContexts];

/* Context information to accompany the complete request processing */
static DescMsgContext     g_descMsgContext[kDescNumContexts];

/* Store detected diagnostic error */
static DescNegResCode     g_descNegResCode[kDescNumContexts];

#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
/* Pointer of main handlers */
static DescMainHandler    g_descRecallHandler[kDescNumContexts];
#endif

#if defined(DESC_ENABLE_GENERIC_USER_POST_HANDLER_SUPPORT)
/* Store the SID byte for the application if the post-handler is used */
static DescMsgItem        g_descUserSIdBackup[kDescNumContexts];
#endif


#if defined (DESC_ENABLE_EXT_NEG_RES_CODE_HANDLING)
/* Additional 2 bytes for the negative response message */
static DescExtNegResCode g_descExtNegResCode[kDescNumContexts];
#endif

/* module state machine */
static DescRdiStateCtrl g_descRdiStateCtrl;
static vuint8           g_descRdiCurReqContext;
/* global check mask for request */
static vuint8           g_descNextMode;

#if defined (DESC_ENABLE_SERVICE_A9_80_SUPPORT) || \
    defined (DESC_ENABLE_SERVICE_A9_81_SUPPORT)
/* global buffer for the asynchronous application writing */
/* common buffer for mode $80 and $81 */
static vuint8           g_descUudtPrimBuffer[kDescBufferLen];
#endif

#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
static vuint8_least     g_descRdiCanChUsers;
static vuint8           g_descRdiCanChannel;
#endif

/* global storage of the searching masks */
static vuint8     g_descRdi81SearchStatusMask;
/* global current iterator value */
static vuint16    g_descNextIterPos;

static DescSchedulerState       g_descSchedulerState[kDescNumOfRdpiTimers];/* scheduler state machine  */
static DescSchedulerTimer       g_descSchedulerTimer[kDescNumOfRdpiTimers];/* timers for the scheduler - use the same count of timers to avoid usecase difference*/
static DescRdpiStateCtrl        g_descRdpiStateCtrl;/* The RDPI state machine */
static vuint8                   g_descRdpiCurReqContext;/* Current request's context */
static vuint8                   g_descSchedulerList[kDescNumOfRdpiTimers][kDescNumOfPeriodicPids];/* Dpid scheduler lists */
#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
static vuint8_least             g_descRdpiCanChUsers;
static vuint8                   g_descRdpiCanChannel;
#endif
static t_descUudtNetInfoPoolPtr g_descDpidUudtResource;/* InfoPool */

/* Local context information storing (for each DID) */
static DescMsgContext        g_descPidMsgContext[kDescNumContexts];
static DescPidProcessorState g_descPidProcessorState[kDescNumContexts];
/* The current list of PID references */
static DescMemPidInstIndex   g_descPidList[kDescNumContexts][kDescNumMaxPidList];
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
/* Bit-mapped post handler queue */
static vuint8                g_descPidPostHdlrQueue[kDescNumPostHdlrQueueBytes];
#endif

static DescDynDpidInfo            g_descDynDpidInfoTable[kDescNumDynDefinedDpids];
static DescDynDpidInfo            g_descDynDpidTempInfoTable;/* Used for temporary processing */
static DescDefDynDpidContextState g_descDefDynDpidContextState;



/* -----------------------------------------------------------------------------
    &&&~ ROM definitions
 ----------------------------------------------------------------------------- */

/* Version information */
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 g_descMainVersion     = (vuint8) DESC_MAIN_VERSION;
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 g_descSubVersion      = (vuint8) DESC_SUB_VERSION;
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 g_descBugFixVersion   = (vuint8) DESC_BUGFIX_VERSION;

#if defined(DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descCan2TpChannelMap[kDescNumCommChannels] =
{
# if (kDescNumCommChannels >= 1)
  kDescCan2TpChannel_0
# endif
# if (kDescNumCommChannels >= 2)
  ,kDescCan2TpChannel_1
# endif
# if (kDescNumCommChannels >= 3)
  ,kDescCan2TpChannel_2
# endif
# if (kDescNumCommChannels >= 4)
  ,kDescCan2TpChannel_3
# endif
# if (kDescNumCommChannels >= 5)
  ,kDescCan2TpChannel_4
# endif
# if (kDescNumCommChannels >= 6)
  ,kDescCan2TpChannel_5
# endif
# if (kDescNumCommChannels >= 7)
  ,kDescCan2TpChannel_6
# endif
# if (kDescNumCommChannels == 8)
  ,kDescCan2TpChannel_7
# endif
# if (kDescNumCommChannels > 8)
#  error "Too many CAN-channels!!!"
# endif
};
#endif

#if defined(DESC_ENABLE_PARALLEL_OBD)
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descDescConnections[kDescTpNumContexts] =
{
   kDescDiagConnection
  ,kDescDiagObdConnection
};
#endif

/* Table of all configured CAN messages used for UUDT transmissions. */
V_MEMROM0 static V_MEMROM1 t_descUudtNetMsgInfoStruct V_MEMROM2 g_descUudtNetCanMsgInfoTable[kDescUudtNetNumCanMsgs] = 
{
  { 4, (TxDataPtr)UUDT_Resp_From_EHPS_EPS_HS._c, 0 }, 
  { 9, (TxDataPtr)UUDT_Resp_From_EPS_EPS_JR_CE._c, 1 }
};
/* Table of all state transitions defined by CANdelaStudio. */
V_MEMROM0 static V_MEMROM1 DescStateInfo V_MEMROM2 g_descStateGroupTransition[kDescStateGroupNumTransition][2] = 
{
  { { 0x0F, 0x0B }, { 0x01, 0x01 } }, 
  { { 0x00, 0x01 }, { 0x00, 0x02 } }, 
  { { 0x00, 0x01 }, { 0x00, 0x08 } }, 
  { { 0x01, 0x00 }, { 0x02, 0x00 } }, 
  { { 0x06, 0x00 }, { 0x04, 0x00 } }, 
  { { 0x04, 0x00 }, { 0x08, 0x00 } }
};
/* &~MsgTables */
/* Table of reference indexes for fast SID look-up. */
V_MEMROM0 static V_MEMROM1 DescMsgItem V_MEMROM2 g_descSidMap[kDescSvcIdMapSize] = 
{
  0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x03, 0xFF, 0x04, 0x05, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0xFF, 0xFF, 0xFF, 0x08, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x09, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0x0C, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0x10, 0xFF, 0xFF, 0xFF, 0x11
};
/* Table of service ID relevant information. */
V_MEMROM0 static V_MEMROM1 DescSvcHead V_MEMROM2 g_descSvcHead[kDescSvcHeadNumItems] = 
{
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00,  0,  0 } /* $4 */, 
  { 0x01, 0, 0, 0x01, 0x01, 0, 1, 0, 0x00,  1,  0 } /* $12 */, 
  { 0x03, 1, 1, 0x03, 0x03, 0, 1, 0, 0x00,  2,  0 } /* $1A */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 34, 32 } /* $20 */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 35, 32 } /* $22 */, 
  { 0x01, 0, 0, 0x01, 0x01, 0, 1, 0, 0x00, 36, 32 } /* $23 */, 
  { 0x01, 1, 1, 0x03, 0x03, 0, 1, 1, 0x00, 37, 32 } /* $27 */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 41, 36 } /* $28 */, 

  { 0x01, 0, 0, 0x01, 0x01, 0, 1, 0, 0x00, 42, 36 } /* $2C */, 
  { 0x01, 0, 0, 0x01, 0x01, 0, 1, 0, 0x00, 43, 36 } /* $34 */, 
  { 0x01, 1, 0, 0x01, 0x01, 0, 0, 1, 0x00, 44, 36 } /* $36 */, 
  { 0x03, 1, 1, 0x01, 0x01, 0, 1, 0, 0x00, 45, 37 } /* $3B */, 
  { 0x01, 0, 0, 0x03, 0x01, 0, 1, 0, 0x00, 54, 46 } /* $3E */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0x00, 55, 46 } /* $A2 */, 
  { 0x01, 1, 0, 0x03, 0x03, 0, 0, 1, 0x00, 56, 46 } /* $A5 */, 
  { 0x01, 1, 0, 0x03, 0x03, 0, 0, 1, 0x00, 58, 48 } /* $A9 */, 

  { 0x01, 1, 0, 0x01, 0x01, 0, 0, 1, 0x00, 59, 49 } /* $AA */, 
  { 0x03, 1, 1, 0x01, 0x01, 0, 1, 0, 0x00, 64, 54 } /* $AE */, 
  { 0x00, 0, 0, 0x00, 0x00, 0, 1, 0, 0x00, 70, 60 } /* $FF */
};
/* Table of all configured (effectively used) pre-handlers. */
V_MEMROM0 static V_MEMROM1 DescPreHandler V_MEMROM2 g_descPreHandlerTable[kDescNumPreHandlers] = 
{
  DescDummyPreHandler, 
  ApplDescPreDisableNormalCommunication, 
  ApplDescPreRequestProgrammingMode, 
  DescPreReadStatusOfDTC, 
  ApplDescPreControlCPID_02_Steering_Assist_Control, 
  ApplDescPreControlCPID_03_Steering_Angle_Sensor_Calibration, 
  ApplDescPreControlCPID_04_Reset_Adaptive_Data, 
  ApplDescPreControlCPID_05_Feature_Control, 
  ApplDescPreControlCPID_FD_System_Basic_Functions
};
/* Table of all configured (effectively used) post-handlers. */
V_MEMROM0 static V_MEMROM1 DescPostHandler V_MEMROM2 g_descPostHandlerTable[kDescNumPostHandlers] = 
{
  DescDummyPostHandler, 
  DescOemPostStopDiagnosticSession, 
  DescOemPostSendTesterPresent, 
  DescOemPostEnableProgrammingMode, 
  DescPostReadDataByIdentifier, 
  DescPostProcessDynamicallyDefineDpid, 
  DescPostReadDpidPeriodic, 
  ApplDescPostApplDescGenericPostControlCPID
};
/* Table of service (instance) relevant information. */
V_MEMROM0 static V_MEMROM1 DescSvcInst V_MEMROM2 g_descSvcInst[kDescSvcInstNumItems] = 
{
  {   1, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescClearDiagnosticInformation } /* $4 */, 
  {   0, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadFailureRecordData } /* $12 */, 
  {   2, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_02_Calibration_Programmed_Status } /* $1A $2 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_90_Vehicle_Identification_Number } /* $1A $90 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_97_System_Name_Or_Engine_Type } /* $1A $97 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_98_Repair_Shop_Code_Or_Tester_Serial_Number } /* $1A $98 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_99_Programming_Date } /* $1A $99 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, DescGenReadDidDID_9A_Diagnostic_Data_Identifier } /* $1A $9A */, 

  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_9F_Previous_Stored_Repair_Shop_Code_Or_Tester_Serial_Number } /* $1A $9F */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_A0_Manufacturers_Enable_Counter } /* $1A $A0 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_A1_ECU_Configuration_Data } /* $1A $A1 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDid_DID_AB_Compressed_Vehicle_Partitioning_and_Product_Structure_CVPPS } /* $1A $AB */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_B0_ECU_Diagnostic_Address } /* $1A $B0 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_B3_Data_Universal_Numbering_System_Identification_DUNS } /* $1A $B3 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_B4_Manufacturing_Traceability_Characters } /* $1A $B4 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_C0_Boot_Software_Part_Number } /* $1A $C0 */, 

  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_C1_Software_Module_Identifier_1_Operational_Application_Soft } /* $1A $C1 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_C2_Software_Module_Identifier_2_Performance_Calibration } /* $1A $C2 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_C3_Software_Module_Identifier_3_Feature_Enable_Disable_Calib } /* $1A $C3 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_C4_Software_Module_Identifier_4_Non_Variant_Calibration } /* $1A $C4 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_CB_End_Model_Part_Number } /* $1A $CB */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_CC_Base_Model_Part_Number } /* $1A $CC */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_D0_Boot_Software_Part_Number_Alpha_Code } /* $1A $D0 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_D1_Software_Module_Identifier_1_Alpha_Code } /* $1A $D1 */, 

  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_D2_Software_Module_Identifier_2_Alpha_Code } /* $1A $D2 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_D3_Software_Module_Identifier_3_Alpha_Code } /* $1A $D3 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_D4_Software_Module_Identifier_4_Alpha_Code } /* $1A $D4 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_DB_End_Model_Part_Number_Alpha_Code } /* $1A $DB */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_DC_Base_Model_Part_Number_Alpha_Code } /* $1A $DC */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_DE_GMLAN_Identification_Data } /* $1A $DE */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_F0_Programmed_State_Indicator_PSI } /* $1A $F0 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_F3_ECU_ID } /* $1A $F3 */, 

  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_F4_Signature_Bypass_Authorization_Ticket } /* $1A $F4 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReadDidDID_F6_Boot_Info_Block_Subject_Name_and_ECU_Name } /* $1A $F6 */, 
  {   1, { 0x03, 0x03, 0 }, { 0x0F, 0x0F },                      0,    0,    1, DescOemStopDiagnosticSession } /* $20 */, 
  {   0, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    4, DescReadDataByIdentifier } /* $22 */, 
  {   7, { 0x01, 0x01, 0 }, { 0x0F, 0x0E }, kDescStateNoTransition,    0,    0, ApplDescReadMemory } /* $23 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescGetSeedSPS_Seed } /* $27 $1 */, 
  {   7, { 0x03, 0x03, 0 }, { 0x0F, 0x0D },                      1,    0,    0, ApplDescSendKeySPS_Key } /* $27 $2 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescGetSeedDevice_Control_Seed } /* $27 $3 */, 

  {   7, { 0x01, 0x01, 0 }, { 0x0F, 0x07 },                      2,    0,    0, ApplDescSendKeyDevice_Control_Key } /* $27 $4 */, 
  {   1, { 0x03, 0x03, 0 }, { 0x0F, 0x0F },                      3,    1,    0, DescOemDisableNormalCommunication } /* $28 */, 
  {   0, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    5, DescProcessDynamicallyDefineDpid } /* $2C */, 
  {   6, { 0x01, 0x01, 0 }, { 0x0F, 0x0E }, kDescStateNoTransition,    0,    0, ApplDescRequestDownload } /* $34 */, 
  {   0, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescTransferDataDownload } /* $36 $0 */, 
  {   3, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescWriteDidDID_02_Calibration_Programmed_Status } /* $3B $2 */, 
  {  19, { 0x01, 0x01, 0 }, { 0x0F, 0x0E }, kDescStateNoTransition,    0,    0, ApplDescWriteDidDID_90_Vehicle_Identification_Number } /* $3B $90 */, 
  {   0, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescWriteDidDID_97_System_Name_Or_Engine_Type } /* $3B $97 */, 

  {  12, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescWriteDidDID_98_Repair_Shop_Code_Or_Tester_Serial_Number } /* $3B $98 */, 
  {   6, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescWriteDidDID_99_Programming_Date } /* $3B $99 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x0F, 0x0E }, kDescStateNoTransition,    0,    0, ApplDescWriteDidDID_9A_Diagnostic_Data_Identifier } /* $3B $9A */, 
  {   3, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescWriteDidDID_A0_Manufacturers_Enable_Counter } /* $3B $A0 */, 
  { 824, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescWriteDidDID_F4_Signature_Bypass_Authorization_Ticket } /* $3B $F4 */, 
  {   3, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescWriteDidDID_F5_DVT_Access_KeyTable_Index_Change_KTIC } /* $3B $F5 */, 
  {   1, { 0x03, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    2, DescGenSendTesterPresent } /* $3E */, 
  {   1, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescReportProgrammedState } /* $A2 */, 

  {   2, { 0x03, 0x03, 0 }, { 0x06, 0x0F },                      4,    2,    0, DescGenRequestProgrammingMode } /* $A5 $1 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x04, 0x0F },                      5,    0,    3, DescOemEnableProgrammingMode } /* $A5 $3 */, 
  {   3, { 0x03, 0x03, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    3,    0, DescReadStatusOfDTCByStatus } /* $A9 $81 */, 
  {   0, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, DescReadDpidStop } /* $AA $0 */, 
  {   0, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, DescReadDpidOnce } /* $AA $1 */, 
  {   0, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    6, DescReadDpidSlow } /* $AA $2 */, 
  {   0, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    6, DescReadDpidMedium } /* $AA $3 */, 
  {   0, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    6, DescReadDpidFast } /* $AA $4 */, 

  {   2, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    0,    0, ApplDescControlCancelAll } /* $AE $0 */, 
  {   5, { 0x01, 0x01, 0 }, { 0x0F, 0x0B }, kDescStateNoTransition,    4,    7, ApplDescControlCPID_02_Steering_Assist_Control } /* $AE $2 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    5,    7, ApplDescControlCPID_03_Steering_Angle_Sensor_Calibration } /* $AE $3 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    6,    7, ApplDescControlCPID_04_Reset_Adaptive_Data } /* $AE $4 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    7,    7, ApplDescControlCPID_05_Feature_Control } /* $AE $5 */, 
  {   3, { 0x01, 0x01, 0 }, { 0x0F, 0x0F }, kDescStateNoTransition,    8,    7, ApplDescControlCPID_FD_System_Basic_Functions } /* $AE $FD */
};
/* Table of sub-service protocol information. */
V_MEMROM0 static V_MEMROM1 DescMsgItem V_MEMROM2 g_descSvcInstHeadExt[kDescSvcInstHeadExtNumItems] = 
{
  0x02, 0x90, 0x97, 0x98, 0x99, 0x9A, 0x9F, 0xA0, 0xA1, 0xAB, 0xB0, 0xB3, 0xB4, 0xC0, 0xC1, 0xC2 /* $1A */, 
  0xC3, 0xC4, 0xCB, 0xCC, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xDB, 0xDC, 0xDE, 0xF0, 0xF3, 0xF4, 0xF6 /* $1A */, 
  0x01, 0x02, 0x03, 0x04 /* $27 */, 
  0x00 /* $36 */, 
  0x02, 0x90, 0x97, 0x98, 0x99, 0x9A, 0xA0, 0xF4, 0xF5 /* $3B */, 
  0x01, 0x03 /* $A5 */, 
  0x81 /* $A9 */, 
  0x00, 0x01, 0x02, 0x03, 0x04 /* $AA */, 

  0x00, 0x02, 0x03, 0x04, 0x05, 0xFD /* $AE */
};
/* Table of all PIDs' instances which can be read using SIMD procedure. */
V_MEMROM0 static V_MEMROM1 DescPidInst V_MEMROM2 g_descPIDInfo[kDescNumPids] = 
{
  { 0x4016,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4016_Ignition_Cycle_Counter }, 
  { 0x401B,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_401B_ECU_Internal_Temperature }, 
  { 0x4074,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4074_Steering_Wheel_Angle }, 
  { 0x40AC,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_40AC_Steering_Input_Torque }, 
  { 0x40AD,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_40AD_Steering_Motor_Overload_Protection_Incidents }, 
  { 0x40AE,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_40AE_Calculated_System_Temperature }, 
  { 0x40AF,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_40AF_EPS_System_Status }, 
  { 0x40BC,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_40BC_Engine_Speed }, 

  { 0x40BD,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_40BD_Vehicle_Speed_Low_Resolution }, 
  { 0x41D1,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_41D1_Advanced_Park_Assist_Mode_Status }, 
  { 0x41D2,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_41D2_Electric_Power_Steering_Driver_Mode_Control_State }, 
  { 0x41D3,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_41D3_Electric_Power_Steering_Motor_Current_Commanded }, 
  { 0x41D4,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_41D4_Electric_Power_Steering_Motor_Current_Feedback }, 
  { 0x41D5,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_41D5_Electric_Power_Steering_Torque_Overlay_Status }, 
  { 0x41D6,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_41D6_Electric_Power_Steering_Angle_Overlay_Status }, 
  { 0x41D7,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_41D7_Electric_Power_Steering_Torque_Overlay_Requested }, 

  { 0x41D9,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_41D9_Steering_Ouput_Torque }, 
  { 0x4303,    4, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4303_Counterclockwise_Handwheel_Angle_Traveled_Maximum }, 
  { 0x4304,    4, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4304_Clockwise_Handwheel_Angle_Traveled_Maximum }, 
  { 0x43AD,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_43AD_Mechanical_Steering_Stops_Position_Learn_Status }, 
  { 0x43D0,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_43D0_Electric_Power_Steering_Stop_Start_Status }, 
  { 0x446F,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_446F_Electric_Power_Steering_APA_Angle_Overlay_Requested }, 
  { 0x44EA,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_44EA_Calculated_Rack_Travel }, 
  { 0x464D,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_464D_Steering_Friction_State_Of_Health }, 

  { 0x464E,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_464E_Smooth_Road_Shake_SRS_Maximum_Compensation_State_of_Hea }, 
  { 0x464F,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_464F_Controller_Temperature_State_of_Health }, 
  { 0x4650,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4650_Controller_Supply_Voltage_State_of_Health }, 
  { 0x4651,    3, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4651_Digital_Torque_Signal_State_of_Health }, 
  { 0x4652,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4652_EPS_Motor_Duty_Cycle_State_of_Health }, 
  { 0x4653,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4653_End_Of_Travel_Impact_State_of_Health }, 
  { 0x4654,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4654_Analog_Motor_Position_State_of_Health }, 
  { 0x4655,    3, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4655_EPS_Motor_Position_State_of_Health }, 

  { 0x4656,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4656_EPS_Motor_Current_State_of_Health }, 
  { 0x4657,    6, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4657_EPS_Motor_Phase_Voltage_State_of_Health }, 
  { 0x4658,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_4658_Random_Access_Memory_RAM_Error_Correction_Circuit_ECC_S }, 
  { 0x8002,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_8002_System_Power_Mode }, 
  { 0x8078,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_8078_Battery_Voltage_ECU_Monitored }, 
  { 0x819D,    2, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_819D_Vehicle_Speed_Medium_Resolution }, 
  { 0x82C1,    1, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_82C1_Engine_Running_Status }, 
  { 0xC000,    4, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_C000_Supplier_Internal_DTC_and_Failure_Type }, 

  { 0xC010,    6, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_C010_Time_Since_Ignition_On_1 }, 
  { 0xC050,    4, { { 0x0F, 0x0F }, { 0x03, 0x03, 0 } }, ApplDescReadPidPID_C050_Time_Since_Ignition_On }
};
/* The table for the corresponding rate timings */
V_MEMROM0 static V_MEMROM1 DescSchedulerTimer V_MEMROM2 g_descSchedulerTimerReload[kDescNumOfPeriodicTimers] = 
{
  kDescRdpiFastRateTicks, 
  kDescRdpiMediumRateTicks, 
  kDescRdpiSlowRateTicks
};
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descDpidSearchTable[kDescRdpiDpidSearchTableSize] = 
{
  0x7C
};
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descDpidSearchBitSumTable[kDescRdpiDpidSearchTableSize] = 
{
  0
};
V_MEMROM0 static V_MEMROM1 DescDpidHandler V_MEMROM2 g_descDpidHandlerTable[kDescRdpiDpidNumItems] = 
{
  DescReadPackDynamic_DPID_FA /* $FA */, 
  DescReadPackDynamic_DPID_FB /* $FB */, 
  DescReadPackDynamic_DPID_FC /* $FC */, 
  DescReadPackDynamic_DPID_FD /* $FD */, 
  DescReadPackDynamic_DPID_FE /* $FE */
};
/* Table of all dynamically defined DPID instances. */
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descDynDpid2GlobalDpidHandle[kDescNumDynDefinedDpids] = 
{
    0,   1,   2,   3,   4
};


/* -----------------------------------------------------------------------------
    &&&~ Macro definitions
 ----------------------------------------------------------------------------- */

#define DescGetTicksOfMs(timeMs)                                     (vuint16)((timeMs)/(kDescCallCycleUs/1000))
#define DescUtiGetBitFromIndex(bitsetBaseType, bitIdx)               ((bitsetBaseType)(((bitsetBaseType)0x01u)<<(bitIdx)))

#if (kDescNumContexts > 1)
# if defined (DESC_ENABLE_DEBUG_USER )
#  define DescAssertContext(p,e)                                     if (!(p)) {ApplDescFatalError(e, (vuint16)__LINE__);}
# else
#  define DescAssertContext(p,e)
# endif
#else
# define DescAssertContext(p,e)
#endif

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# define DescAssertCommon(p,e)                                       if (!(p)) {ApplDescFatalError(e, (vuint16)__LINE__);}
# define DescAssertCommonAlways(e)                                   (ApplDescFatalError((e), (vuint16)__LINE__))
#else
# define DescAssertCommon(p,e)
# define DescAssertCommonAlways(e)
#endif

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
# define DescAssertInternal(p,e)                                     if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescAssertInternalAlways(e)                                 (ApplDescFatalError((e), (vuint16)__LINE__))
#else
# define DescAssertInternal(p,e)
# define DescAssertInternalAlways(e)
#endif

#if defined (DESC_ENABLE_DEBUG_USER )
# define DescAssertUser(p,e)                                         if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescAssertUserAlways(e)                                     (ApplDescFatalError((e), (vuint16)__LINE__))
#else
# define DescAssertUser(p,e)
# define DescAssertUserAlways(e)
#endif

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
# define DescSubcompOnceInitPowerOnDebug()                           (CheckTableConsistency())
#endif

  /* Save too many else cases :) */
#if !defined (DescSubcompOnceInitPowerOnDebug)
# define DescSubcompOnceInitPowerOnDebug()                           /* Not used */
#endif

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# define DescSubcompOnceInitDebug()                                  /* Not used */
# define DescSubcompIterInitDebug(iContext)                          (DescDebugIterInit(DESC_CONTEXT_PARAM_ONLY))
#else
# define DescSubcompOnceInitDebug()                                  /* Not used */
# define DescSubcompIterInitDebug(iContext)                          /* Not used */
#endif

#if defined (DESC_ENABLE_DEBUG_USER )
# define DescUsdtNetIsoTpAssertUser(p,e)                             if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescUsdtNetIsoTpAssertUserAlways(e)                         do {ApplDescFatalError((e), (vuint16)__LINE__);}while(0)
#else
# define DescUsdtNetIsoTpAssertUser(p,e)                             /* Not used */
# define DescUsdtNetIsoTpAssertUserAlways(e)                         /* Not used */
#endif

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# define DescUsdtNetIsoTpAssertChannel(p,e)                          DescUsdtNetIsoTpAssertUser((p), (e))
#else
# define DescUsdtNetIsoTpAssertChannel(p,e)                          /* Not used */
#endif

#if defined(TP_FUNC_ENABLE_RECEPTION) && \
    (kDescNumFuncReqContexts > 0)
# define g_descSecondInfoPoolRef                                     (*g_busInfoPoolFuncRef)
#else
# define g_descSecondInfoPoolRef                                     (g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool])
#endif

#define DescOemCheckResponseRequiredOnFunc(reqData, dataLen)         (DescCheckResponseRequiredOnFunc((reqData),(dataLen)))

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
# define DescUsdtNetDescICNAssertInternal(p,e)                       if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
#else
# define DescUsdtNetDescICNAssertInternal(p,e)                       /* Not used */
#endif

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# define DescUsdtNetDescICNAssertChannel(p,e)                        DescUsdtNetDescICNAssertInternal((p), (e))
#else
# define DescUsdtNetDescICNAssertChannel(p,e)                        /* Not used */
#endif

#if defined(DESC_USDTNET_ENABLE_LONGSERVICE_SUPPORT)
# define DescUsdtNetFinishReception(infoPool, status)                (DescUsdtNetLSFinishReception((infoPool),(status)))
# define DescUsdtNetFinishTransmission(infoPool, status)             (DescUsdtNetLSFinishTransmission((infoPool),(status)))
# define DescUsdtNetStartReception(infoPool)                         (DescUsdtNetLSStartReception((infoPool)))
# define DescUsdtNetRingBufferCopyRoutine(infoPool, pDestination, dataLength) (DescUsdtNetLSRingBufferCopyRoutine((infoPool),(pDestination),(dataLength)))
#else
# define DescUsdtNetFinishReception(infoPool, status)                (DescUsdtNetAbsFinishReception((infoPool),(status)))
# define DescUsdtNetFinishTransmission(infoPool, status)             (DescUsdtNetAbsFinishTransmission((infoPool),(status)))
# define DescUsdtNetStartReception(infoPool)                         (DescUsdtNetAbsStartReception((infoPool)))
# define DescUsdtNetRingBufferCopyRoutine(infoPool, pDestination, dataLength) (DescUsdtNetAbsRingBufferCopyRoutine((infoPool),(pDestination),(dataLength)))
#endif

/* Static dispatch of the DescNet UUDT functions */
#define DescUudtNetInitPowerOn()                                     (DescUudtNetCANInitPowerOn())
#define DescUudtNetInit()                                            (DescUudtNetCANInit())
#define DescUudtNetStateTask()                                       (DescUudtNetCANStateTask())
#define DescUudtNetTimerTask()                                       (DescUudtNetCANTimerTask())
#define DescUudtNetTxReserveResource(infoPool)                       (DescUudtNetCANTxReserveResource(infoPool))
#define DescUudtNetTransmitResponse(infoPool)                        (DescUudtNetCANTransmitResponse(infoPool))
#define DescUudtNetReleaseResource(infoPool)                         (DescUudtNetCANReleaseResource(infoPool))

#if (kDescUudtNetQueueSize > 1)
# define DescUudtNetCancelAllResponses()                             (DescUudtNetCANCancelAllResponses())
#else
# define DescUudtNetCancelAllResponses()
#endif

#if (kDescUudtNetNumEcus > 1)
# define DescUudtMsgInfoAt(iter)                                     g_descUudtNetCanMsgInfoTable[comMultipleECUCurrent][iter]
#else
# define DescUudtMsgInfoAt(iter)                                     g_descUudtNetCanMsgInfoTable[iter]
#endif

#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
# define DescUudtNetMsgRef(iter)                                     g_descUudtNetResourceManager[iter].canMsgManagerRef
# define DescUudtNetResHandleRef(iter)                               g_descUudtNetCanMsgManager[iter].busHandle
#else
# define DescUudtNetMsgRef(iter)                                     iter
# define DescUudtNetResHandleRef(iter)                               iter
#endif

#if (kDescUudtNetQueueSize > 1)
# define DescUudtPrioQueueIter(iter)                                 g_descUudtNetPrioQueue[iter]
#else
# define DescUudtPrioQueueIter(iter)                                 iter
#endif

#if defined (DESC_UUDTNET_ENABLE_MSG_RETRANSMIT)
# define DESC_UUDT_TRANSMIT(msgRef)                                  (DescUudtNetLL_Transmit(msgRef))
#else
# define DESC_UUDT_TRANSMIT(msgRef)                                  ((void)DescUudtNetLL_Transmit(msgRef))
#endif
#if defined (DESC_ENABLE_DEBUG_USER ) || \
    defined (DESC_ENABLE_DEBUG_INTERNAL )
# define DescUudtNetCanAssertUser(p,e)                               if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescUudtNetCanAssertUserAlways(e)                           do {ApplDescFatalError((e), (vuint16)__LINE__);}while(0)
#else
# define DescUudtNetCanAssertUser(p,e)                               /* Not used */
# define DescUudtNetCanAssertUserAlways(e)                           /* Not used */
#endif


#if(kDescUudtNetNumCanMsgs > 1)
# define DescUudtNetMsgBuffer(iter)                                  DescUudtMsgInfoAt(iter).msgBuffer
# define DescUudtNetMsgHandle(iter)                                  DescUudtMsgInfoAt(iter).msgHandle
#else
# define DescUudtNetMsgBuffer(iter)                                  uudtResMsgBuffer
# define DescUudtNetMsgHandle(iter)                                  kUudtResMsgHandle
#endif
#define DescUudtNetLL_InitCanMsgManager(msgIter)                     /* Not used */
#define DescUudtNetLL_Transmit(msgRef)                               (CanTransmit(DescUudtNetMsgHandle(msgRef)))
#define DescUudtNetLL_CancelTransmit(msgHandle)                      (CanCancelTransmit(msgHandle))

/* Use CANdriver interrupt management */
#define DescUudtNetLL_InterruptRestore()                             (DescInterruptRestore())
#define DescUudtNetLL_InterruptDisable()                             (DescInterruptDisable())

/* Accept always the tester present */
#define DescIsTesterPresent(infoPool)                                kDescFalse
/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnNetwork()                          (DescNetworkInitPowerOn())

#define DescSubcompOnceInitNetwork()                                 (DescNetworkOnceInit())
#define DescSubcompIterInitNetwork(iContext)                         (DescNetworkIterInit(DESC_CONTEXT_PARAM_ONLY))

#if defined(DESC_USDTNET_ENABLE_LONGSERVICE_SUPPORT)
# define DescUsdtNetAbsReleaseInfoPool(infoPool)                     (DescUsdtNetLSReleaseInfoPool((infoPool)))
# define DescUsdtNetAbsInitPowerOn()                                 (DescUsdtNetLSInitPowerOn())
# define DescUsdtNetAbsInit()                                        (DescUsdtNetLSInit())
# define DescUsdtNetAbsStateTask()                                   (DescUsdtNetLSStateTask())
# define DescUsdtNetAbsTimerTask()                                   (DescUsdtNetLSTimerTask())
# define DescUsdtNetAbsTransmitResponse(infoPool)                    (DescUsdtNetLSTransmitResponse((infoPool)))
# define DescUsdtNetAbsPrepareResponse(infoPool)                     (DescUsdtNetLSPrepareResponse((infoPool)))
#else
# define DescUsdtNetAbsReleaseInfoPool(infoPool)                     (DescUsdtNetReleaseInfoPool((infoPool)))
# define DescUsdtNetAbsInitPowerOn()                                 (DescUsdtNetInitPowerOn())
# define DescUsdtNetAbsInit()                                        (DescUsdtNetInit())
/* This is an optional API - may be an empty macro!!! Do not enclose in paranthesis */
# define DescUsdtNetAbsStateTask()                                   DescUsdtNetStateTask()
/* This is an optional API - may be an empty macro!!! Do not enclose in paranthesis */
# define DescUsdtNetAbsTimerTask()                                   DescUsdtNetTimerTask()
# define DescUsdtNetAbsTransmitResponse(infoPool)                    (DescUsdtNetTransmitResponse((infoPool)))
/* This is an optional API - may be an empty macro!!! Do not enclose in paranthesis */
# define DescUsdtNetAbsPrepareResponse(infoPool)                     DescUsdtNetPrepareResponse((infoPool))
#endif

#if defined(ApplDescOnBeginOfProcExt)
/* ok - some one needs it */
#else
# define ApplDescOnBeginOfProcExt()                                  /* Not used */
#endif

#if defined(ApplDescOnEndOfProcExt)
/* ok - some one needs it */
#else
# define ApplDescOnEndOfProcExt()                                    /* Not used */
#endif
#if defined (DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
# define DescGetAvailBufferLenByMsgContext(pMsgContext)              ((pMsgContext)->busInfo.availBufferLength)
# define DescGetAvailBufferLenByInfoPool(infoPool)                   ((infoPool)->busInfo.availBufferLength)
#else
# define DescGetAvailBufferLenByMsgContext(iContext)                 kDescPrimBufferLen
# define DescGetAvailBufferLenByInfoPool(infoPool)                   kDescPrimBufferLen
#endif
#define DescNetGetAvailBufferLenByIContext(iContext)                 (DescGetAvailBufferLenByInfoPool(g_descInterruptContextCtrl[(iContext)].infoPoolPtr))

/* OEM specific behavior on these events */
#define DescOemOnTxFrame()                                           /* Not used */
#define DescOemOnRxErrorInd(status)                                  (DescOemRxErrorInd(status))
#define DescOemOnTxErrorInd(status)                                  /* Not used */
#define DescOemOnRxStart(infoPool)                                   (DescSetDiagActive(infoPool))
#define DescOemOnReqInd(iContext)                                    /* Not used */

/* Activate the VN timer */
#define DescOemOnConfirmation(iContext,status)                       (g_vnTimer = kDescVnDiagTimerTicks)
/* NM interactions */
#if defined (NM_TYPE_IVLAN)
/* No multi channel support */
# define DescNmActivateVN(channel)                                   (ApifRequestCan())
# define DescNmDeactivateVN(channel)                                 (ApifReleaseCan())
# define DescNmReturnToNormalMode(channel)                           (NmReturnToNormalMode())
# define DescNmSetCommHalted(channel)                                (NmNormalComHalted())
#endif

#if defined (NM_TYPE_GMLAN)
/* Channel dependent APIs */
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
#  define DescNmActivateVN(channel)                                  (IlNwmActivateVN((channel),VN_Diagnostics))
#  define DescNmDeactivateVN(channel)                                (IlNwmDeactivateVN((channel),VN_Diagnostics))
#  define DescNmReturnToNormalMode(channel)                          (IlNwmReturnToNormalMode(channel))
#  define DescNmSetCommHalted(channel)                               (IlNwmNormalCommHalted(channel))
# else
#  define DescNmActivateVN(channel)                                  (IlNwmActivateVN(VN_Diagnostics))
#  define DescNmDeactivateVN(channel)                                (IlNwmDeactivateVN(VN_Diagnostics))
#  define DescNmReturnToNormalMode(channel)                          (IlNwmReturnToNormalMode())
#  define DescNmSetCommHalted(channel)                               (IlNwmNormalCommHalted())
# endif
#endif

#if defined (VGEN_ENABLE_NM_BASIC)
/* Channel independent APIs */
# define DescNmActivateVN(channel)                                   /* Not used */
# define DescNmDeactivateVN(channel)                                 /* Not used */

/* Channel dependent APIs */
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
#  define DescNmReturnToNormalMode(channel)                          (CanPartOnline((channel), C_SEND_GRP_APPL))
#  define DescNmSetCommHalted(channel)                               (CanPartOffline((channel), C_SEND_GRP_APPL))
# else
#  define DescNmReturnToNormalMode(channel)                          (CanPartOnline(C_SEND_GRP_APPL))
#  define DescNmSetCommHalted(channel)                               (CanPartOffline(C_SEND_GRP_APPL))
# endif
#endif

/* T2 timer macros */
#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT) || defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
# define DescActivateLimiter(iContext)                               (g_descRcrrpLimitCounter[iContext] = kDescRcrrpMaxTicks)
# define DescDeactivateLimiter(iContext)                             (g_descRcrrpLimitCounter[iContext] = 0)
#else
# define DescActivateLimiter(iContext)                               /* Not used */
# define DescDeactivateLimiter(iContext)                             /* Not used */
#endif

#define DescActivateT2Timer(iContext)                                (g_descT2Timer[iContext] = kDescP2InitValue)
#define DescReloadT2TimerWithP3maxTime(iContext)                     (g_descT2Timer[iContext] = kDescP2ReloadValue)
#define DescDeactivateT2Timer(iContext)                              (g_descT2Timer[iContext] = 0)

/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnTiming()                           /* Not used */

#define DescSubcompOnceInitTiming()                                  (DescTimingOnceInit())
#define DescSubcompIterInitTiming(iContext)                          (DescTimingIterInit(DESC_CONTEXT_PARAM_ONLY))

#if defined (DESC_ENABLE_DYN_S1_TIMEOUT)
# define DescGetS1Value()                                            (DescOemGetS1Value())
#else
# define DescGetS1Value()                                            kDescS1TimerTicks
#endif

/* S1 timer macros */
#if defined (DESC_ENABLE_S1_ANY_SVC_RELOAD)
# define DescReloadS1Timer()                                         (g_descDoReloadS1Timer = kDescTrue)
# define DescStartS1Timer()                                          (g_descS1Timer = DescGetS1Value())
# define DescStopS1Timer()                                           (g_descS1Timer = 0)
  /* S1 timer decrementation mask */
# define DescSetConnectionActive(iContext)                           /* not used */
# define DescResetConnectionActive(iContext)                         (DescReloadS1Timer())
# define DescIsNoConnectionActive(iContext)                          (g_descInterruptContextCtrl[kDescPrimContext].activity == kDescContextIdle)
#endif

#if defined (DESC_ENABLE_S1_SINGLE_SVC_RELOAD)
# define DescReloadS1Timer()                                         (g_descS1Timer = DescGetS1Value())
# define DescStartS1Timer()                                          (g_descIsS1TimerActive = kDescTrue)
# define DescStopS1Timer()                                           (g_descIsS1TimerActive = kDescFalse, DescReloadS1Timer())
/* S1 timer decrementation mask */
# define DescSetConnectionActive(iContext)                           /* not used */
# define DescResetConnectionActive(iContext)                         /* not used */
# define DescIsNoConnectionActive(iContext)                          (1) /* decrement always the timer */
#endif

#define DescOemPreExtTimer()                                         (DescOemTimer())
#define DescOemPostExtTimer()                                        /* Not used */
#define DescOemOnS1TimeoutPre()                                      (DescOemS1Timeout())
#define DescOemOnS1TimeoutPost()                                     /* Not used */
#define DescOemOnT2Timeout(iContext)                                 /* Not used */
#define DescOemOnResPendingOvertime()                                (DescInit())
#define DescOemOnResPendingOverrun()                                 (DescInit())

/* Internal API for INIT */
#if !defined(DescStateCompInitOnceOem)
# define DescStateCompInitOnceOem()                                  /* Not used */
#endif

#if !defined(DescStateCompInitOnceGroup)
# define DescStateCompInitOnceGroup()                                /* Not used */
#endif

#if defined(DESC_ENABLE_AUTO_STATES)
# define DescStateCompInitOnceCore()                                 (DescStateOnceInit())
#else
# define DescStateCompInitOnceCore()                                 /* Not used */
#endif


#define DescSubcompOnceInitPowerOnState()                            /* Not used */
#define DescSubcompOnceInitState()                                   {DescStateCompInitOnceCore(); DescStateCompInitOnceGroup(); DescStateCompInitOnceOem()}
#define DescSubcompIterInitState(iContext)                           /* Not used */

#if defined (DESC_ENABLE_AUTO_STATES)
# if (kDescStateGroupNumTransition > 0)
static void DescSetState(DescSvcInstIndex svcInstHandle);
# else
#  define DescSetState(svcInstHandle)                                /* Not used */
# endif
static DescNegResCode DescCheckState (V_MEMROM1 DescStateInfo V_MEMROM2 V_MEMROM3 * refState);
#else
# define DescCheckState(a)                                           /* Not used */
# define DescSetState(svcInstHandle)                                 /* Not used */
#endif

#if defined(DescOemOnTransitionSecurity_Access)
#else
  #define DescOemOnTransitionSecurity_Access(newState, formerState)
#endif

#if defined(DescOemOnTransitionProgrammingMode)
#else
  #define DescOemOnTransitionProgrammingMode(newState, formerState)
#endif

#define DescSvcIsSupportedInStateSecurity_Access(refState)           (((refState)->stateSecurity_Access & g_descCurState.stateSecurity_Access) != 0)
#define DescSvcIsSupportedInStateProgrammingMode(refState)           (((refState)->stateProgrammingMode & g_descCurState.stateProgrammingMode) != 0)
#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
/* Prototype exists in desc.h */
# if (kDescNumContexts > 1)
#  define _DescStartRepeatedServiceCall(iContext,mainHandler)        (DescStartRepeatedServiceCall(iContext, mainHandler))
# else
#  define _DescStartRepeatedServiceCall(iContext,mainHandler)        (DescStartRepeatedServiceCall(mainHandler))
# endif
#else
  /* Preprocessor workaround */
# define _DescStartRepeatedServiceCall(iContext,mainHandler)         /* Not active */
#endif
#define DescSubcompOnceInitPowerOnDispatcher()                       /* Not used */

#define DescSubcompOnceInitDispatcher()                              /* Not used */
#define DescSubcompIterInitDispatcher(iContext)                      (DescDispatcherIterInit(DESC_CONTEXT_PARAM_ONLY))

/* Extract the bit position from the handle and shift with one position more 
 * (start from 0x02 instead of 0x01) since the Bit0 is for the SId.
 */
#define DescGetSvcInstFailurePosMask(svcInstHandle)                  ((vuint8)(0x02<<((vuint8)((svcInstHandle)>>13))))

#define DescOemOnProcessingDone(iContext)                            /* Not used */
#define DescOemOnSvcNotFound(iContext)                               /* Not used */
#define DescOemOnSvcInstNotFound(iContext)                           (DescOemInvalidSubServiceEvent(DESC_CONTEXT_PARAM_ONLY))
#define DescOemOnReqLengthNotMatched(iContext)                       /* Not used */
#define DescOemOnReqLengthTooSmall(iContext)                         /* Not used */
#define DescOemOnInvalidSidSession(iContext)                         /* Not used */
#define DescOemOnInvalidAddrMethod(iContext)                         /* Not used */
#define DescOemOnInvalidEcuState(iContext)                           /* Not used */
#define DescOemOnValidService(iContext)                              /* Not used */

/* API for inter sub-component initialization */
#define DescSubcompOnceInitPowerOnController()                       /* Not used */
#define DescSubcompOnceInitController()                              /* Not used */
#define DescSubcompIterInitController(iContext)                      /* Not used */

#if defined (DESC_ENABLE_SERVICE_A9_SUPPORT)
# define DescOemOnPowerOnInit(initParam)                             (DescRdiPowerOnInit())
#else
# define DescOemOnPowerOnInit(initParam)                             /* not used */
#endif
#define DescOemOnInit(initParam)                                     (DescOemInit())
#if defined (DESC_ENABLE_SERVICE_A9_SUPPORT) || \
    defined (DESC_ENABLE_SCHEDULED)
# define DescOemOnStateTask()                                        (DescOemStateTask())
#else
# define DescOemOnStateTask()                                        /* Not used */
#endif

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnProcessor()                        /* Not used */
#define DescSubcompOnceInitProcessor()                               /* Not used */
#define DescSubcompIterInitProcessor(iContext)                       /* Not used */

#define ApplDescGenericServiceConfirmation(status)
#if defined(DESC_ENABLE_RDI_UUDT_BUFFER_SWITCH)
# define g_descRdiCurrUudtBuffer                                     curUudtBuffer
#else
/* Only one buffer needed - which one? */
# if defined (DESC_ENABLE_SERVICE_A9_82_SUPPORT)
#  define g_descRdiCurrUudtBuffer                                    g_descUudtSecBuffer
# else
/* It is not possible that neither $82, nor one of $80 or $81 is not active */
#  define g_descRdiCurrUudtBuffer                                    g_descUudtPrimBuffer
# endif
#endif

#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
# define DescRdiRegisterCanChUser(user)                              (g_descRdiCanChUsers |= (user))
# define DescRdiUnRegisterCanChUser(user)                            (g_descRdiCanChUsers &= (vuint8_least)(~(user)))
#else
# define DescRdiRegisterCanChUser(user)                              /* Not used */
# define DescRdiUnRegisterCanChUser(user)                            /* Not used */
#endif

/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnFaultMemory()                      /* Not used */
#define DescSubcompOnceInitFaultMemory()                             (DescRdiInit())
#define DescSubcompIterInitFaultMemory(iContext)                     /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnSecurityAccess()                   /* Not used */
#define DescSubcompOnceInitSecurityAccess()                          /* Not used */
#define DescSubcompIterInitSecurityAccess(iContext)                  /* Not used */
#define DescOemOnInvalidRequest(iContext)                            /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnPidManager()                       /* Not used */
#define DescSubcompOnceInitPidManager()                              /* Not used */
#define DescSubcompIterInitPidManager(iContext)                      /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnRidManager()                       /* Not used */
#define DescSubcompOnceInitRidManager()                              /* Not used */
#define DescSubcompIterInitRidManager(iContext)                      /* Not used */

/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnScheduled()                        /* Not used */
#define DescSubcompOnceInitScheduled()                               (DescRdpiInit())
#define DescSubcompIterInitScheduled(iContext)                       /* Not used */

/* The offset will be zero for not efficient savings */
#define RdpiGetRow(dpid)                                             ((vuint8_least)(((dpid) >> 3) - kDescRdpiTableBottomOffset))
#define RdpiGetCol(dpid)                                             ((vuint8_least)((dpid) & 0x07))

#if defined (DESC_ENABLE_DYN_DEFINED_DPID_MODE)
# define DescDpidMgrGetDpidResLength(dpidHandle)                     (DescDynDpidGetResLength(dpidHandle))
#else
# define DescDpidMgrGetDpidResLength(dpidHandle)                     g_descDpidResLengthTable[dpidHandle]
#endif

#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
# define DescRdpiRegisterCanChUser(user)                             (g_descRdpiCanChUsers |= (user))
# define DescRdpiUnRegisterCanChUser(user)                           (g_descRdpiCanChUsers &= (vuint8_least)(~(user)))
#else
# define DescRdpiRegisterCanChUser(user)                             /* Not used */
# define DescRdpiUnRegisterCanChUser(user)                           /* Not used */
#endif

/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnPidListProcessor()                 /* Not used */
#define DescSubcompOnceInitPidListProcessor()                        /* Not used */
#define DescSubcompIterInitPidListProcessor(iContext)                (DescIterInitPidListProcessor(DESC_CONTEXT_PARAM_ONLY))

#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
# define DescPidMod8(value)                                          ((vuint8_least)((value) & (8-1)))
# if (kDescNumPostHdlrQueueBytes > 1)
#  define DescPidDiv8(value)                                         ((vuint8_least)((value) >> 3))
# else
#  define DescPidDiv8(value)                                         0
# endif
/* Queue the current reference of PID */
# define DescPidDoQueuePostHandlerAt(pidRef)                         (g_descPidPostHdlrQueue[DescPidDiv8(pidRef)] |= (vuint8)(0x01 << DescPidMod8(pidRef)))
# define DescPidIsPostHandlerQueuedAt(pidRef)                        ((g_descPidPostHdlrQueue[DescPidDiv8(pidRef)] & (0x01 << DescPidMod8(pidRef))) != 0)
#endif

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnDynDefinePid()                     /* Not used */
#define DescSubcompOnceInitDynDefinePid()                            /* Not used */
#define DescSubcompIterInitDynDefinePid(iContext)                    /* Not used */

/* Hook functions for PID manager */
#define DescPmClientCheckPid(result, pid)                            (result)
#define DescPmClientGetResLength(pidHandle)                          ((vuint8)0)


/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnDynDefineDpid()                    /* Not used */
#define DescSubcompOnceInitDynDefineDpid()                           (DescOnceInitDynDefineDpid())
#define DescSubcompIterInitDynDefineDpid(iContext)                   /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnRoeProcessor()                     /* Not used */
#define DescSubcompOnceInitRoeProcessor()                            /* Not used */
#define DescSubcompIterInitRoeProcessor(iContext)                    /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnVariantManager()                   /* Not used */
#define DescSubcompOnceInitVariantManager()                          /* Not used */
#define DescSubcompIterInitVariantManager(iContext)                  /* Not used */



/* -----------------------------------------------------------------------------
    &&&~ Implementation
 ----------------------------------------------------------------------------- */

/* Check if this feature is enabled */
#if defined (GEN_MAGIC_NUMBER_V_CFG) && \
    defined (kDescIntegrationMagicNumber)
/* begin Fileversion check */
# if (GEN_MAGIC_NUMBER_V_CFG != kDescIntegrationMagicNumber)
#  error "The magic number of the generated header v_cfg.h is different! Check time and date of generated files!"
# endif
#endif

/******************************************************************************
* All necessary preprocessor directives existence checks
******************************************************************************/
#if !defined(DESC_ENABLE_RES_PENDING_TIME_LIMIT) && \
    !defined(DESC_DISABLE_RES_PENDING_TIME_LIMIT)
# error "Missing switch DESC_XXXABLE_RES_PENDING_TIME_LIMIT!"
#endif

#if !defined(DESC_ENABLE_RES_PENDING_COUNT_LIMIT) && \
    !defined(DESC_DISABLE_RES_PENDING_COUNT_LIMIT)
# error "Missing switch DESC_XXXABLE_RES_PENDING_COUNT_LIMIT!"
#endif

#if defined (kDescNumContexts)
# if (kDescNumContexts == 0)
#  error "No diagnostic connection will be available!"
# endif
#else
# error "Missing kDescNumContexts define!"
#endif
/******************************************************************************
*  Conditional checks
******************************************************************************/
#if defined(DESC_ENABLE_MULTI_TP)
# if defined(DESC_ENABLE_SINGLE_TP_OPTIMIZED)
#  error "Could not be used both transport layers types!"
# endif
#elif defined(DESC_DISABLE_MULTI_TP)
# if defined(DESC_DISABLE_SINGLE_TP_OPTIMIZED)
#  error "At least one transport layer type must be selected!"
# endif
#else
# error "Missing switch DESC_XXXABLE_MULTI_TP!"
#endif

#if !defined(DESC_ENABLE_SINGLE_TP_OPTIMIZED) && \
    !defined(DESC_DISABLE_SINGLE_TP_OPTIMIZED)
# error "Missing switch DESC_XXXABLE_SINGLE_TP_OPTIMIZED!"
#endif

#if defined(DESC_ENABLE_RES_PENDING_TIME_LIMIT) && \
    defined(DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
# error "Both type of response pending limitations are not possible at the same time!"
#endif

#if defined (C_MULTIPLE_RECEIVE_CHANNEL) || defined (C_SINGLE_RECEIVE_CHANNEL)
/* config ok */
#else
/* code doubled system */
# if (kDescNumCommChannels > 1)
#  if defined (kDescCanChannel)
/* config ok */
#  else
#   error "Missing kDescCanChannel define!"
#  endif
# endif
#endif


#if defined (DESC_ENABLE_DEBUG_INTERNAL)
/*******************************************************************************
* NAME:              CheckIndexTableConsistency
*
* CALLED BY:         DescInitPowerOn
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs check if the table relations are consistent, and 
*                    if all main handler functions are not V_NULL.
*
*******************************************************************************/
static void CheckTableConsistency(void)
{
# if defined( C_COMP_IAR_M16C )
#  if defined ( _NEAR_ )
  static vuint8  sidCnt;
  static DescSvcInstIndex i;
#  else
  vuint8  sidCnt;
  DescSvcInstIndex i;
#  endif
# else
  vuint8  sidCnt;
  DescSvcInstIndex i;
# endif
  /*--------------------------*/
  /*   Check SID references   */
  /*--------------------------*/
  sidCnt = 0;
  for (i = 0; i < kDescSvcIdMapSize; i++)
  {
    if (g_descSidMap[i] != 0xff)
    {
       /* Will be used for checking if all sid are referenced */
       sidCnt++;
        /* unexisting reference (-1 due to the dummy entry */
       DescAssertInternal((g_descSidMap[i] < (kDescSvcHeadNumItems - 1)),
                         kDescAssertIndexTableInvalidReference
                       );
    }
  }
  DescAssertInternal((sidCnt == (kDescSvcHeadNumItems - 1)),
                    kDescAssertSvcTableUnreachableItem
                  );
  /*--------------------------------*/
  /*  Check SID To SINST references */
  /*--------------------------------*/
  for (i = 0; i < (kDescSvcHeadNumItems - 1); i++)
  {
    DescAssertInternal((g_descSvcHead[i].svcInstFirstItem < kDescSvcInstNumItems),
                      kDescAssertSvcTableInvalidReference
                    );
  }
# if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
  /* Check the last line content (must be exactly the last line number of the svcInst table) */
  DescAssertInternal((g_descSvcHead[i].svcInstFirstItem == (kDescSvcInstNumItems - 1)),
                    kDescAssertSvcTableInvalidReference
                  );
# else
  /* Check the dummy line content */
  DescAssertInternal((g_descSvcHead[i].svcInstFirstItem == kDescSvcInstNumItems),
                    kDescAssertSvcTableInvalidReference
                  );
# endif
  /*--------------------------------*/
  /*  Check Main handler existence  */
  /*--------------------------------*/
  for (i = 0; i < kDescSvcInstNumItems; i++)
  {
    DescAssertInternal((g_descSvcInst[i].mainHandler != V_NULL), kDescAssertMissingMainHandler);
  }
}
#endif

#if defined (DESC_ENABLE_DEBUG_INTERNAL) || \
    defined (DESC_ENABLE_DEBUG_USER)
/*******************************************************************************
* NAME:              DescDebugIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the debug subcomponent context specific data.
*
*******************************************************************************/
static void DescDebugIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;
}
#endif

/******************************************************************************
* All necessary preprocessor directives existence checks
******************************************************************************/
#if !defined(DESC_ENABLE_RES_ON_FUNC_REQUEST) && \
    !defined(DESC_DISABLE_RES_ON_FUNC_REQUEST)
# error "Missing switch DESC_XXXABLE_RES_ON_FUNC_REQ!"
#endif


#if !defined(DESC_ENABLE_FUNCREQ_TA_CHECK) && \
    !defined(DESC_DISABLE_FUNCREQ_TA_CHECK)
# error "Missing switch DESC_XXXABLE_FUNCREQ_TA_CHECK!"
#endif

#if !defined(DESC_ENABLE_NEGRES_ON_MSG_TOO_LONG) && \
    !defined(DESC_DISABLE_NEGRES_ON_MSG_TOO_LONG)
# error "Missing switch DESC_XXXABLE_NEGRES_ON_MSG_TOO_LONG!"
#endif

#if !defined(DESC_ENABLE_SPONTANEOUS_RES) && \
    !defined(DESC_DISABLE_SPONTANEOUS_RES)
# error "Missing switch DESC_XXXABLE_SPONTANEOUS_RES!"
#endif

#if !defined(DESC_ENABLE_EXT_NEG_RES_CODE_HANDLING) && \
    !defined(DESC_DISABLE_EXT_NEG_RES_CODE_HANDLING)
# error "Missing switch DESC_XXXABLE_EXT_NEG_RES_CODE_HANDLING!"
#endif

#if !defined(DESC_ENABLE_FORCE_DLC_8) && \
    !defined(DESC_DISABLE_FORCE_DLC_8)
# error "Missing switch DESC_XXXABLE_FORCE_DLC_8!"
#endif

/******************************************************************************
*  Conditional checks
******************************************************************************/

/******************************************************************************
* All OEM necessary preprocessor directives existence checks
******************************************************************************/
#if defined (NM_TYPE_IVLAN)
/*Ok IVLAN Nm type found */
#else
# if defined (NM_TYPE_GMLAN)
 /*Ok GMLAN Nm type found */
# else
#  if defined (VGEN_ENABLE_NM_BASIC)
  /*Ok NM basic type found */
#  else
#   error "None of the required NM types for GM was found!"
#  endif
# endif
#endif

/* GENy/CANgen NM configuration compatibility */
#if defined (VGEN_GENY)
# if defined(NM_ENABLE_HIGHSPEED_MODE)
#  define DESC_GENTOOL_NM_HISPEED_ENABLED
# endif
#else /* CANgen */
# if defined(NM_ENABLE_HISPEED_MODE)
#  define DESC_GENTOOL_NM_HISPEED_ENABLED
# endif
#endif

#if !defined (DESC_GENTOOL_NM_HISPEED_ENABLED)
# define DESC_GENTOOL_NM_HISPEED_DISABLED
#endif

/* Hi speed ability check */
#if defined (NM_TYPE_IVLAN) || defined (VGEN_ENABLE_NM_BASIC)
# if defined(DESC_ENABLE_HIGH_SPEED_SUPPORT)
#  error "There is no support of RequestProgrammingModeHiSpeed on high-speed communication buses!Please, check CANdelaStudio configuration."
# endif
#else /* GMLAN */
/* Check only for single channel configurations */
# if (kDescNumCommChannels == 1)
#  if (defined(DESC_GENTOOL_NM_HISPEED_ENABLED) && \
      defined(DESC_ENABLE_HIGH_SPEED_SUPPORT)) || \
      (defined(DESC_GENTOOL_NM_HISPEED_DISABLED) && \
      defined(DESC_DISABLE_HIGH_SPEED_SUPPORT))
/* OK: Configuration plausible */
#  else
#   if defined(DESC_GENTOOL_NM_HISPEED_ENABLED)
#    error "Check if your ECU supports $A5 $02 (CANdelaStudio)!"
#   else
#    error "Check if your ECU supports HiSpeedModeChange (GENtool GMLAN Options)!"
#   endif
#  endif
# endif
#endif

/* PartOffline availability check */
#if defined (VGEN_ENABLE_NM_BASIC)
# if defined(C_ENABLE_PART_OFFLINE)
 /* configuration match! */
# else
#  error "The communication control service needs the PART_OFFLINE functionality of the CANdriver!"
# endif
# if defined(C_SEND_GRP_APPL)
/* application group exists */
# else
#  error "The required C_SEND_GRP_APPL is not configured! Please define a part-offline group with name APPL."
# endif
#endif

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpInitPowerOn
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Power on initialization
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpInitPowerOn(void)
{
  DescUsdtNetIsoTpInit();
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpInitContext
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Re-initialization 
*                    
*                    
*******************************************************************************/
static void DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
  vuint8  descTmpTxChannel;

  /* Find a channel for TP */
  descTmpTxChannel = TpTxGetConnectionStatus(DescGetConnectionOfContext(DESC_TPCONTEXT_PARAM_VALUE));
  if(descTmpTxChannel == kTpNoChannel)
  {
    if( (g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE] = TpTxGetFreeChannel(DescGetConnectionOfContext(DESC_TPCONTEXT_PARAM_VALUE))) != kTpNoChannel )
    {
      TpTxLockChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
#  if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      /* Initialize the transmission type */
      g_descTpCtrl.txPath[g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]].type = kDescMainTransmission;
#  endif
    }
  }
#  if defined (DESC_ENABLE_DEBUG_INTERNAL)
  else
  { /* The TX channel is still locked but is it the same as before? */
    DescUsdtNetIsoTpAssertChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE] == descTmpTxChannel, kDescAssertWrongTpTxChannel);
  }
#  endif
  DescUsdtNetIsoTpAssertChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE] != kTpNoChannel, kDescAssertWrongTpTxChannel);
# endif
#endif

#if defined(DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.availBufferLength = kDescPrimBufferLen;
#endif
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext;
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resDataPtr = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resType = kDescUsdtResponseNone;
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpInit
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Re-initialization 
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpInit(void)
{
  { /* Init tx resources */
    vuint8_least resIter = kTpTxChannelCount;
    while(resIter != 0)
    {
      resIter--;
      g_busInfoPoolTxRef[resIter] = V_NULL;
    }
  }

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  {
    vuint8_least addIter = kDescNumAddRequestChannels;

    g_descAddChannelCtrl.count = 0;
    while(addIter != 0)
    {
      --addIter;
      g_descAddChannelCtrl.channel[addIter].status = kDescContextIdle;
    }
  }
#endif

  DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(kDescPrimContext));
#if defined (DESC_ENABLE_PARALLEL_OBD)
  DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(kDescObdContext));
#endif

#if defined(TP_FUNC_ENABLE_RECEPTION) && \
    (kDescNumFuncReqContexts > 0)
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].descHandle = kDescUsdtNetInvalidDescContext;
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].reqDataPtr = g_descSecBuffer;
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].resDataPtr = g_descSecBuffer;
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].resType = kDescUsdtResponseNone;
# if defined(DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].busInfo.availBufferLength = kDescSecBufferLen;
# endif
#endif
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpStateTask
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       State Task of the IsoTp driver
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpStateTask(void)
{
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  /* Process additional requests */
  DescBusyResponseHandler();
#endif
}

#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY) && \
     defined (DESC_DISABLE_EXTERNAL_CHECK_TA)
/*******************************************************************************
* NAME:              DescCheckTA
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Target address evaluation.
*                    
*******************************************************************************/
t_ta_type DescCheckTA (vuint8 targetAddress)
{
  t_ta_type returnValue = kTpNone;

  if (targetAddress == TP_ECU_NUMBER)
  {
    returnValue = kTpPhysical;
  }
  else
  {
    if (targetAddress == kDescOemExtAddrFuncTargetAddr)
    {
      returnValue = kTpFunctional;
    }
  }
  return returnValue;
}
# endif
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
/*******************************************************************************
* NAME:              DescDispatchServiceContext
*
* CALLED BY:         Desc start reception event
* PRECONDITIONS: 
*
* DESCRIPTION:       this function dispatches the parallel request reception target context
*******************************************************************************/
static vuint8 DescDispatchServiceContext(vuint8 sid)
{
  vuint8 result = kDescPrimContext; /* Main connection */

  /* OBD predispatching for request routing */
  if((sid > 0x00) && (sid < 0x10))
  {
    result = kDescObdContext;
  }
  return result;
}
#endif

/*******************************************************************************
* NAME:              DescGetBuffer
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       StartOfFrame reception function
*                    
*******************************************************************************/
TP_MEMORY_MODEL_DATA vuint8* DescGetBuffer(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint16 dataLength)
{
  DescUsdtNetMsg returnValue = V_NULL;

#if (defined (DESC_ENABLE_PHYSREQ_TA_CHECK) || defined (DESC_ENABLE_PHYSREQ_SA_CHECK))
  DescBool addressCheckResult;

# if defined (DESC_ENABLE_PHYSREQ_TA_CHECK)
  addressCheckResult = DescOemCheckPhysTargetAddress(TpGetTargetAddress(TP_CHANNEL_RX_PARAM_ONLY));
  if(addressCheckResult == kDescTrue)
# endif
  {
# if defined (DESC_ENABLE_PHYSREQ_SA_CHECK)
    addressCheckResult = DescOemCheckPhysSourceAddress(TpRxGetSourceAddress(TP_CHANNEL_RX_PARAM_ONLY));
# endif
  }

  if(addressCheckResult == kDescTrue)
#endif
  {
#if defined (DESC_ENABLE_PARALLEL_OBD)
    DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
    DESC_TPCONTEXT_PARAM_VALUE = DescDispatchServiceContext(TpRxGetCanBuffer(tpRxChannel)[0]);
#endif

    if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle == kDescUsdtNetInvalidDescContext)
    {
      if(dataLength > kDescPrimBufferLen)
#if defined (DESC_ENABLE_NEGRES_ON_MSG_TOO_LONG)
      {
        /* Force only one frame copy, length validation should fail later on causing NRC message */
        TpRxSetBufferOverrun(TP_CHANNEL_RX_PARAM_ONLY);
      } /* no else required in that case - a valid reception has to be simulated */
#else
      {
# if ((TP_ISO15765_VERSION >= 0x0273) && defined (TP_ENABLE_ISO_15765_2_2))
#  if (TP_ISO15765_VERSION >= 0x0277)
        TpRxSetFCStatus(TP_CHANNEL_RX_PARAM_FIRST kTpFCStatusOverflow);
#  else
#   error "Incompatible TPMC Version - please use version 2.77+"
#  endif
# else
        /* returnValue = V_NULL; it is already default */
# endif
      } /* discard reception */
      else
#endif
      {
        t_descUsdtNetResult result;
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
        t_ta_type ta_type;
# endif
#endif
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.busType   = kDescUsdtNetBusTypeIsoTp;
#if (TP_USE_EXTENDED_ADDRESSING           == kTpOn)      || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress = TpRxGetSourceAddress(TP_CHANNEL_RX_PARAM_ONLY);
        /* Make the tester ID visible to the above layer */
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.testerId = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress;

    /* g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpRxGetReceivedTargetAddress (TP_CHANNEL_RX_PARAM_VALUE); */
#endif

#if ( kCanNumberOfChannels > 1 ) /* more than one canChannel ? */
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel = TpRxGetCanChannel(TP_CHANNEL_RX_PARAM_ONLY);
# else
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel = TpRxGetCanChannel();
# endif
        /* Make the communication channel ID visible to the above layer */
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.comChannel = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel;
#endif
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle         = TP_CHANNEL_RX_PARAM_VALUE;
#endif

#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_ENABLE_MULTIPLE_ADDRESSING)
          /* This check should be used for all Multi Addressing Tps*/
        if(TpRxGetAddressingFormat(TP_CHANNEL_RX_PARAM_ONLY) == kTpExtendedAddressing)
# endif
        {
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY) /*It has to be actviated for Extended Addressing */
          ta_type = TpRxGetTaType(TP_CHANNEL_RX_PARAM_ONLY);
          if (ta_type == kTpPhysical)
# endif
#endif
          {
            g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType         = kDescUsdtNetReqTypePhysical;
          }
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
          else
          {
            g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType         = kDescUsdtNetReqTypeFunctional;
          }
# endif

        }
# if defined (TP_ENABLE_MULTIPLE_ADDRESSING)
        else
        {
          g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType   = (t_descUsdtNetReqType)((TpRxGetAssignedDestination(TP_CHANNEL_RX_PARAM_ONLY) == kTpRequestDiagPhysical) ? kDescUsdtNetReqTypePhysical: kDescUsdtNetReqTypeFunctional);
        }
# endif
#endif

        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].dataLength        = dataLength;
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle        = DESC_TPCONTEXT_PARAM_VALUE; /* Write used context */

        /* Check if Desc itself is free */
        result = DescUsdtNetStartReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE]);
        if(result == kDescUsdtNetworkOk)
        { /* it is */
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
          /* store the connection type */
          g_descTpCtrl.rxPath[tpRxChannel].type = kDescMainReception;
#endif
#if defined (DESC_ENABLE_PARALLEL_OBD)
          /* store the working context type */
          g_busInfoPoolRxRef[tpRxChannel] = &g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE];
#endif
          returnValue = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr;
        }
        else
        {
          g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext; /* Write used context */
        }
      }
    }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    else
    { /* check if an additional request channel is free */
      vuint8_least iter;
      iter = kDescNumAddRequestChannels;
      while( iter != 0 )
      {
        --iter;
        if(g_descAddChannelCtrl.channel[iter].status == kDescContextIdle)
        {
          g_descAddChannelCtrl.channel[iter].status = kDescContextActiveRx;
          /* Force only one frame copy */
          TpRxSetBufferOverrun(TP_CHANNEL_RX_PARAM_ONLY);
          g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_ONLY].type = kDescAddReception;
          g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_ONLY].info = (vuint8)iter;
          returnValue = g_descAddChannelCtrl.channel[iter].buffers.reqBuffer;
          /* Break */
          iter = 0;
        }
      }
    }
#endif
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              DescPhysReqInd
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Rx path for physical requests.
*                    Function name must be entered to the CANgen OSEK-TP Options 
*                    dialog in the fields "RxIndication".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescPhysReqInd(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint16 dataLen)
{
  DESC_IGNORE_UNREF_PARAM(dataLen);

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].type)
  {
  case kDescMainReception:
#endif
    {
#if defined (DESC_ENABLE_PARALLEL_OBD)
      DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
      DESC_TPCONTEXT_PARAM_VALUE = g_busInfoPoolRxRef[TP_CHANNEL_RX_PARAM_VALUE]->descHandle;
#endif
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
      DescUsdtNetIsoTpAssertChannel(g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle == TP_CHANNEL_RX_PARAM_VALUE, kDescNetAssertWrongIsoTpRxChannel);
#endif
      /*-----------------------------*/
      /*Transport protocol management*/
      /*-----------------------------*/
#if defined (TP_ENABLE_DYNAMIC_CHANNELS)
# if defined (TP_ENABLE_NORMAL_ADDRESSING)       || \
     defined (TP_ENABLE_MIXED_11_ADDRESSING)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.ReceiveID = TpRxGetChannelID(TP_CHANNEL_RX_PARAM_ONLY);
#  if defined (TP_FUNC_ENABLE_RECEPTION)
      if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType == kDescUsdtNetReqTypeFunctional)
      {
        TpFuncSetResponse(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
      }
      else
#  endif
      {
        TpTxSetResponse(g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle, g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
      }
# endif
#endif
#if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpRxGetEcuNumber(TP_CHANNEL_RX_PARAM_ONLY);
#else
# if (TP_USE_EXTENDED_ADDRESSING == kTpOn) || \
     defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
     defined (TP_ENABLE_MIXED_29_ADDRESSING)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = kDescEcuNumber;
# endif
#endif
#if (TP_USE_EXTENDED_ADDRESSING == kTpOn)
# if (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.BaseAddress = TpRxGetBaseAddress(TP_CHANNEL_RX_PARAM_ONLY);
# endif
#endif
      /* Reception has finished */
      DescUsdtNetFinishReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE], kDescUsdtNetworkOk);
      /* Reset the channel */
      TpRxResetChannel(TP_CHANNEL_RX_PARAM_ONLY);
    }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    break;
  case kDescAddReception:
    /* Increase succesfully received additionally requests */
    DescUsdtNetIsoTpAssertUser((g_descAddChannelCtrl.count < kDescNumAddRequestChannels), kDescAssertIllegalAddRequestCount);

# if defined(DESC_ENABLE_NEG_RES_ON_SID_WITH_SET_BIT6)
    /* Process any SID */
# else
    /* Check for invalid SID (if bit6 set -> SID from the response ID page received. */
    if((g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.reqBuffer[0] & 0x40) == 0)
# endif
    {
      if(g_descAddChannelCtrl.count < kDescNumAddRequestChannels)
      {
        g_descAddChannelCtrl.count++;
      }
      /* Store tpRxChannel in buffer*/
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.tpRxChannel = TP_CHANNEL_RX_PARAM_VALUE;
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].status = kDescContextActiveProcess;
      /* write the negative response code */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.resBuffer[2] = 0x21;
      /* copy SID onto the right place */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.resBuffer[1] = g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.reqBuffer[0];
      /* write the negative response identifier */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.resBuffer[0] = 0x7f;
    }
# if defined(DESC_ENABLE_NEG_RES_ON_SID_WITH_SET_BIT6)
    /* nothing to do */
# else
    else
    {
      /* Reset the additional channel state */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].status = kDescContextIdle;
      TpRxResetChannel(TP_CHANNEL_RX_PARAM_VALUE);
    }
# endif
    break;
  default:
    /* Unknown type */
    DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
    break;
  }
#endif
}


/*******************************************************************************
* NAME:              DescRxErrorIndication
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Release the lock mechanism for Rx on error by receiving.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpXXXErrorIndication".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescRxErrorIndication(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(status);
  TP_CHANNEL_RX_PARAM_IGNORE_UNREF;

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].type)
  {
    case kDescMainReception:
#endif
      {
#if defined (DESC_ENABLE_PARALLEL_OBD)
        DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
        DESC_TPCONTEXT_PARAM_VALUE = g_busInfoPoolRxRef[TP_CHANNEL_RX_PARAM_VALUE]->descHandle;
#endif
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        DescUsdtNetIsoTpAssertChannel(g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle == TP_CHANNEL_RX_PARAM_VALUE, kDescNetAssertWrongIsoTpRxChannel);
#endif
        /* reception error - notify CANdesc */
        DescUsdtNetFinishReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE], kDescUsdtNetworkAbort);
      }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      break;
    case kDescAddReception:
      /* reset the additional cahnnel status */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].status = kDescContextIdle;
      break;
    default:
      /* Unknown type */
      DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
      break;
  }
#endif
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpPrepareResponse
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS: 
*
* DESCRIPTION:       Prepare address info for response message
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpPrepareResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
#if (TP_USE_EXTENDED_ADDRESSING           == kTpOn)      || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
  vuint8 sourceAddress;

  DescUsdtNetIsoTpAssertUser(infoPool->busInfo.busType == kDescUsdtNetBusTypeIsoTp, kDescNetAssertWrongBusType);

  /* Swap Source- and TargetAddress */
  sourceAddress = infoPool->busInfo.addressingInfo.isoTp.SourceAddress;
  infoPool->busInfo.addressingInfo.isoTp.SourceAddress  = infoPool->busInfo.addressingInfo.isoTp.TargetAddress;
  infoPool->busInfo.addressingInfo.isoTp.TargetAddress = sourceAddress;
#else
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(infoPool);
#endif
}

/*******************************************************************************
* NAME:              DescTransmitResponse
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS: 
*
* DESCRIPTION:       Response transmission function
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpTransmitResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
  vuint8 result;
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if ( defined (TP_ENABLE_DYNAMIC_CHANNELS) || defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND) )
  vuint8 tpTxChannel;
# endif
#endif
#if defined (DESC_ENABLE_PARALLEL_OBD)
  DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
#endif
  volatile t_descUsdtNetInfoPoolPtr* lBusInfoPoolTxRef;

  DescUsdtNetIsoTpAssertUser(infoPool->busInfo.busType == kDescUsdtNetBusTypeIsoTp, kDescNetAssertWrongBusType);

#if defined (DESC_ENABLE_PARALLEL_OBD)
  DESC_TPCONTEXT_PARAM_VALUE = infoPool->descHandle;
#endif

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
  tpTxChannel = g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE];
  infoPool->busHandle = tpTxChannel;
# else
#  if defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
  tpTxChannel = g_descCan2TpChannelMap[DESC_COMM_CHANNEL_PARAM_WRAP_INDEX(infoPool->busInfo.comChannel)];
#  endif
# endif
#endif
  /* Avoid compiler optimization */
  lBusInfoPoolTxRef = &g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE];

  /* Busy ? */
  if(*lBusInfoPoolTxRef != V_NULL)
  {
    DescInterruptDisable();
    /* Still busy ? */
    if(*lBusInfoPoolTxRef != V_NULL)
    {
      t_descUsdtNetInfoPoolPtr lBusInfoPoolTxRefBackup;
      /* Push old content */
      lBusInfoPoolTxRefBackup = g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE];
      /* assign temporarly the new resource to be finalized */
      g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = infoPool;
      /* Cancel the transmission */
      DescConfirmation(TP_CHANNEL_TX_PARAM_FIRST kTpBusy);
      /* Pop old content */
      g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = lBusInfoPoolTxRefBackup;
      DescInterruptRestore();
      return;
    }
    DescInterruptRestore();
  }

  g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = infoPool;

#if defined (TP_ENABLE_EXTENDED_ADDRESSING)     || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
  TpTxSetTargetAddress (TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.testerId); /* use the abstract info for spontaneus responses */
#endif
#if ( kTpNumberOfCanChannels > 1 ) /* more than one canChannel ? */
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
  TpTxSetCanChannel(TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.comChannel);/* use the abstract info for spontaneus responses */
# endif
#endif
#if (TP_USE_EXTENDED_ADDRESSING           == kTpOn)      || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
# if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
  TpTxSetEcuNumber(TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.addressingInfo.isoTp.SourceAddress);
# endif
#endif
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
  TpTxSetBaseAddress(TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.addressingInfo.isoTp.BaseAddress);
# endif
#endif

#if (!defined (TP_ENABLE_DYNAMIC_CHANNELS) && !defined (TP_ENABLE_SINGLE_CHANNEL_TP))
# if defined (DESC_ENABLE_DESC_ON_MULTI_CAN) && \
     !defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
/* In order to use CANdesc on multiple CANchannels, define DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND 
 * in your user config file and define the CAN to TPconnection association e.g.:
  #define kDescCan2TpChannel_0    1 - if CAN 0 corresponds to TPconnection 1 */
#  error "CANdesc on multiple CANchannels needs DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND!"
# endif
#endif

#if (!defined (TP_ENABLE_DYNAMIC_CHANNELS) && !defined (TP_ENABLE_SINGLE_CHANNEL_TP))
  /* Overwrite the 0xFE value to avoid assertions to be miscalled. */
  infoPool->busHandle = TP_CHANNEL_TX_PARAM_VALUE;
  /* CAN-channel to TP-channel */
  DescUsdtNetIsoTpAssertUser((TP_CHANNEL_TX_PARAM_VALUE != kTpNoChannel), kDescNetAssertWrongIsoTpTxChannel);

# if defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
  result = DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_VALUE, infoPool->resDataPtr, infoPool->dataLength);
# else
#  if defined(DESC_ENABLE_DOBT_SUPPORT)
#   error "DOBT on static multi TPMC is not supported!"
#  endif
  result = TpTransmitDiag(infoPool->resDataPtr, infoPool->dataLength);
# endif
#else
  result = DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_VALUE, infoPool->resDataPtr, infoPool->dataLength);
#endif
  if (result != kTpSuccess)
  { /* Cancel the transmission */
    DescConfirmation(TP_CHANNEL_TX_PARAM_FIRST result);
  }
}

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
/*******************************************************************************
* NAME:              DescUsdtNetIsoTpGetRingBuffTxMinLen
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS:
*
* DESCRIPTION:       Get Minimum Length
*
*
*******************************************************************************/
DESCNET_USDT_STATIC vuint16 DescUsdtNetIsoTpGetRingBuffTxMinLen(t_descUsdtNetInfoPoolPtr infoPool)
{
  DESC_IGNORE_UNREF_PARAM(infoPool);
  return (vuint16) 0x06;
}
#endif

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpCopyToCan
*
* CALLED BY:         DescCopyToCAN
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides abstract copy functionality between CANdriver and DANIS.
*******************************************************************************/
static void DescUsdtNetIsoTpCopyToCan(TpCopyToCanInfoStructPtr infoStruct)
{
  vuint8_least i = infoStruct->Length;
  while(i--)
  {
    infoStruct->pDestination[i] = infoStruct->pSource[i];
  }
}

/*******************************************************************************
* NAME:              DescCopyToCAN
*
* CALLED BY:         Transport layer
* PRECONDITIONS:     
*
* DESCRIPTION:       Callback for filling the data into the Tx buffer.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpCopyToCan".
*******************************************************************************/
vuint8 TP_API_CALLBACK_TYPE DescCopyToCAN(TpCopyToCanInfoStructPtr infoStruct)
{
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
  vuint8 returnValue = kTpFailed;
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
#  if ( defined (TP_ENABLE_DYNAMIC_CHANNELS) || defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND) )
  vuint8 TP_CHANNEL_TX_PARAM_ONLY = infoStruct->Channel;
#  endif
# endif
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.txPath[infoStruct->Channel].type)
  {
    case kDescMainTransmission:
#endif
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
      DescUsdtNetIsoTpAssertChannel(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->busHandle == TP_CHANNEL_TX_PARAM_VALUE, kDescNetAssertWrongIsoTpTxChannel);
# endif
      if (g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->resType == kDescUsdtResponseRingBuffer)
      {
        t_descUsdtNetResult result;
# if defined(C_COMP_COSMIC_MCS12X_MSCAN12) && \
     defined(V_ENABLE_USED_GLOBAL_VAR)
        result = DescUsdtNetRingBufferCopyRoutine(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE], &g_descCopyToCanData[0], (vuint8)infoStruct->Length);
# else
        result = DescUsdtNetRingBufferCopyRoutine(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE], (DescUsdtNetMsg)infoStruct->pDestination, (vuint8)infoStruct->Length);
# endif
        if (result == kDescUsdtNetworkOk)
        {
# if defined(C_COMP_COSMIC_MCS12X_MSCAN12) && \
     defined(V_ENABLE_USED_GLOBAL_VAR)
          infoStruct->pSource = &g_descCopyToCanData[0];
          DescUsdtNetIsoTpCopyToCan(infoStruct);
# endif
          returnValue = kTpSuccess;
        }
      }
      else
      {
        DescUsdtNetIsoTpCopyToCan(infoStruct);
        returnValue = kTpSuccess;
      }
      return returnValue;
#else
      {
        DescUsdtNetIsoTpCopyToCan(infoStruct);
        return kTpSuccess;
      }
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    case kDescAddTransmission:
      DescUsdtNetIsoTpCopyToCan(infoStruct);
      return kTpSuccess;   /*Everythings ok now*/
    default:
      /* Unknown type */
      break;
    }
    DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
    return kTpSuccess;   /*Everythings ok now*/
#endif
}

/*******************************************************************************
* NAME:              DescConfirmation
*
* CALLED BY:         Transport layer
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides the post transmission processing.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpConfirmation".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescConfirmation(TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  t_descUsdtNetResult result;
  TP_CHANNEL_TX_PARAM_IGNORE_UNREF;

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.txPath[tpTxChannel].type)
  {
    case kDescMainTransmission:
#endif
      {
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        DescUsdtNetIsoTpAssertChannel(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->busHandle == TP_CHANNEL_TX_PARAM_VALUE, kDescNetAssertWrongIsoTpTxChannel);
#endif
        /* Translate the TP parameter to the DESC_NET type */
        result = (status != kTpSuccess) ? kDescUsdtNetworkAbort:kDescUsdtNetworkOk;

        DescUsdtNetFinishTransmission(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE], result);
      /* No response any more is reset by CANdesc (DescUsdtNetFinishTransmission) */
      /* g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->resType = kDescUsdtResponseNone;*/
      }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      break;
    case kDescAddTransmission:
      /* Decrease pending count of additionally requests */
      DescUsdtNetIsoTpAssertUser((g_descAddChannelCtrl.count != 0), kDescAssertIllegalAddRequestCount);
      if(g_descAddChannelCtrl.count != 0)
      {
        g_descAddChannelCtrl.count--;
      }

      g_descAddChannelCtrl.channel[g_descTpCtrl.txPath[tpTxChannel].info].status = kDescContextIdle;
      break;
    default:
      /* Unknown type */
      DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
      break;
  }
#endif

  g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = V_NULL;
}

/*******************************************************************************
* NAME:              DescTxErrorIndication
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Release the lock mechanism for Tx on error by sending.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpXXXErrorIndication".
*******************************************************************************/
vuint8 TP_API_CALLBACK_TYPE DescTxErrorIndication(TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(status);
  TP_CHANNEL_TX_PARAM_IGNORE_UNREF;

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
  if (g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->busHandle == TP_CHANNEL_TX_PARAM_VALUE)
#endif
  {
    /* Flush the response */
    DescConfirmation(TP_CHANNEL_TX_PARAM_FIRST status);
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    switch (g_descTpCtrl.txPath[tpTxChannel].type)
    {
      case kDescMainTransmission:
#endif
        return kTpHoldChannel;
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      case kDescAddTransmission:
        return kTpFreeChannel;
      default:
        /* Unknown type */
        DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
        return kTpFreeChannel;
    }
#endif
  }
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
  else
  {
    return kTpFreeChannel;
  }
#endif
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpReleaseInfoPool
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS: 
*
* DESCRIPTION:       Release of infopool
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpReleaseInfoPool(t_descUsdtNetInfoPoolPtr infoPool)
{
  DescUsdtNetIsoTpAssertUser(infoPool->busInfo.busType == kDescUsdtNetBusTypeIsoTp, kDescNetAssertWrongBusType);
  infoPool->descHandle = kDescUsdtNetInvalidDescContext;
}


#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
/******************************************************************************
* NAME:              DescBusyResponseHandler
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Busy response handler for additional received requests
*
*******************************************************************************/
static void DescBusyResponseHandler(void)
{
  vuint8_least addIter;
  vuint8       tpTxChannel;

  /* */
  if (g_descAddChannelCtrl.count != 0)
  {
    addIter = kDescNumAddRequestChannels;
    while(addIter != 0)
    {
      --addIter;
      if(g_descAddChannelCtrl.channel[addIter].status == kDescContextActiveProcess)
      {
        tpTxChannel = TpTxGetFreeChannel(kDescDiagAddConnection);
        if (tpTxChannel != kTpNoChannel)
        {
          g_descTpCtrl.txPath[tpTxChannel].type = kDescAddTransmission;
          /* store additional request channel number */
          g_descTpCtrl.txPath[tpTxChannel].info = (vuint8)addIter;
          /* copy the TP addressinformations from rx channel to tx channel */
          /* tpRxChannel is stored in 6.th byte of dummy buffer */
          TpTxSetResponse(g_descAddChannelCtrl.channel[addIter].buffers.res.tpRxChannel, tpTxChannel);

          g_descAddChannelCtrl.channel[addIter].status = kDescContextActiveTx;

          if (DanisIsoTpTransmit(tpTxChannel, g_descAddChannelCtrl.channel[addIter].buffers.res.resBuffer, 3) == kTpSuccess)
          {
            TpRxResetChannel(g_descAddChannelCtrl.channel[addIter].buffers.res.tpRxChannel);
          }
          else
          { /* If we can not send the data, we have to terminate this channel and try it at next cycle */
            g_descAddChannelCtrl.channel[addIter].status = kDescContextActiveProcess;
            TpTxResetChannel(tpTxChannel);
          }
        }
      }
    }
  }
}
#endif

#if defined (TP_FUNC_ENABLE_RECEPTION) && \
    defined (DESC_ENABLE_RES_ON_FUNC_REQUEST) && \
    (kDescNumFuncReqContexts > 0)
/*******************************************************************************
* NAME:              DescCheckResponseRequiredOnFunc
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescBool DescCheckResponseRequiredOnFunc(DescMsg reqData, DescMsgLen dataLength)
{
  vuint8 sid;
  DescBool returnValue = kDescFalse;
  DESC_IGNORE_UNREF_PARAM(dataLength);

  sid = reqData[0];
  /*---------------------------------------------*/
  /*              Search service ID              */
  /*---------------------------------------------*/
  /* If service is not supported */
  /* ----------------------------*/
  sid = DescFindSvc(sid);
  if(sid < kDescInvalidSvcHandle)
  {
    DescAssertInternal((sid < kDescSvcHeadNumItems),kDescAssertSvcTableIndexOutOfRange);
    /* check if this service needs response by default */
    if ((g_descSvcHead[sid].resOnReq & kDescFuncReq) != 0)
    {
      returnValue = kDescTrue;
    }
  }
  return returnValue;
}
#endif

#if defined (TP_FUNC_ENABLE_RECEPTION)     && \
    defined (DESC_ENABLE_FUNCREQ_TA_CHECK) && \
    defined (DESC_ENABLE_OBD_FUNC_REQUEST) && \
    defined (TP_FUNC_ENABLE_APPL_PRECOPY)
/*******************************************************************************
* NAME:              DescExtCheckTAAcceptance
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Checks if the incoming request is relevant for this ECU. 
*                    
*******************************************************************************/
vuint8 DescExtCheckTAAcceptance(vuint8 tgtAddr)
{
  DescBool resultBool = DescIsTAAcceptable(tgtAddr);
  return (vuint8)((resultBool == kDescTrue)?0x00:0xFF);
}
#endif

#if defined(TP_FUNC_ENABLE_RECEPTION)
/*******************************************************************************
* NAME:              DescGetFuncBuffer
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       StartOfFrame reception function
*                    
*******************************************************************************/
TP_MEMORY_MODEL_DATA vuint8* TP_API_CALLBACK_TYPE DescGetFuncBuffer(vuint16 dataLength)
{
  DescUsdtNetMsg returnValue = V_NULL;
# if defined (DESC_ENABLE_FUNCREQ_TA_CHECK) || \
     defined (DESC_ENABLE_FUNCREQ_SA_CHECK) || \
     (defined (DESC_ENABLE_RES_ON_FUNC_REQUEST) && (kDescNumFuncReqContexts > 0))
  DescBool resultBool = kDescTrue;
# endif
  t_descUsdtNetResult usdtNetResult = kDescUsdtNetworkFailed;

  if (g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].descHandle == kDescUsdtNetInvalidDescContext)
  {
# if defined (DESC_ENABLE_FUNCREQ_TA_CHECK)
#  if defined(DESC_ENABLE_OBD_FUNC_REQUEST)
#   if !defined (TP_FUNC_ENABLE_APPL_PRECOPY)
#    error "Please, enable the usage of the functional application precopy API."
    /* If CANgen is used, please create an user config file for the "OSEK TP" component in the GENtool with the following content
    * #if defined (TP_FUNC_DISABLE_APPL_PRECOPY)
    * # undef TP_FUNC_DISABLE_APPL_PRECOPY
    * #endif
    * #if !defined (TP_FUNC_ENABLE_APPL_PRECOPY)
    * # define TP_FUNC_ENABLE_APPL_PRECOPY
    * #endif
    * vuint8 DescExtCheckTAAcceptance(vuint8 tgtAddr);
    * #define __ApplFuncTpPrecopy(tgtAddr)  DescExtCheckTAAcceptance(tgtAddr)
    */
#   endif
#  else
    resultBool = DescIsTAAcceptable(TpFuncGetTargetAddress());
    if(resultBool == kDescTrue)
#  endif
# endif
    {
# if defined (DESC_ENABLE_FUNCREQ_SA_CHECK)
      resultBool = DescOemCheckFuncSourceAddress(TpFuncGetSourceAddress());
      if(resultBool == kDescTrue)
# endif
      {
        usdtNetResult = kDescUsdtNetworkOk;
      }
    }

    if(usdtNetResult == kDescUsdtNetworkOk)
    {
# if (kDescNumFuncReqContexts > 0)
#  if defined (DESC_ENABLE_RES_ON_FUNC_REQUEST)

      CanChipDataPtr canDataPtr = TpFuncGetCanBuffer();
      /* Must be a loop dependend on the dataLength, but use now only two byte copy until 
       * the CANdriver supports a FAR pointer define (enable/disable)*/
#   if (  defined  (C_COMP_TI_TMS320) && \
       !defined (DESC_ENABLE_GENTOOL_GENY) )
      g_descSecBuffer[0] = (vuint8)(canDataPtr[0] & 0x00ff);
      g_descSecBuffer[1] = (vuint8)((canDataPtr[0] & 0xff00) >> 8);
#   else
      g_descSecBuffer[0] = canDataPtr[0];
      g_descSecBuffer[1] = canDataPtr[1];
#   endif

      resultBool = DescOemCheckResponseRequiredOnFunc(g_descSecBuffer, dataLength);
      /* Decide which infoPool should be used */
      if (resultBool == kDescTrue)
      {
        if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle == kDescUsdtNetInvalidDescContext)
        {
          g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr        = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
          g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle        = kDescPrimContext;
          g_busInfoPoolFuncRef = &g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE];
        }
        else
        {
          /* Nothing to receive - skip further processing */
          return returnValue;
        }
      }
      else
#  endif
      {
        g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].descHandle         = kDescSecContext;
        g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].reqDataPtr         = g_descSecBuffer;
        g_busInfoPoolFuncRef = &g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool];
      }
# else
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr         = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle         = kDescPrimContext;
# endif

      /* Initialization of the context */
      g_descSecondInfoPoolRef.busInfo.busType   = kDescUsdtNetBusTypeIsoTp;
      g_descSecondInfoPoolRef.busHandle         = 0xfe;
      g_descSecondInfoPoolRef.reqType           = kDescUsdtNetReqTypeFunctional;
      g_descSecondInfoPoolRef.resType           = kDescUsdtResponseNone;
      g_descSecondInfoPoolRef.resDataPtr        = g_descSecondInfoPoolRef.reqDataPtr;
      g_descSecondInfoPoolRef.dataLength        = dataLength;
# if ( defined(TP_FUNC_ENABLE_EXTENDED_ADDRESSING) || \
     defined(TP_FUNC_ENABLE_NORMAL_FIXED_ADDRESSING) || \
     defined(TP_FUNC_ENABLE_MIXED_29_ADDRESSING) )
      g_descSecondInfoPoolRef.busInfo.addressingInfo.isoTp.TargetAddress = TpFuncGetTargetAddress();
#  if ( defined(TP_FUNC_ENABLE_EXTENDED_ADDRESSING) && !defined (TP_RX_BASE_ADDRESS))
   /* Not supported */
#  else
      g_descSecondInfoPoolRef.busInfo.addressingInfo.isoTp.SourceAddress = TpFuncGetSourceAddress();
      /* Make the tester ID visible to the above layer */
      g_descSecondInfoPoolRef.busInfo.testerId = g_descSecondInfoPoolRef.busInfo.addressingInfo.isoTp.SourceAddress;
#  endif
# endif
# if ( kCanNumberOfChannels > 1 ) /* more than one canChannel ? */
      g_descSecondInfoPoolRef.busInfo.addressingInfo.isoTp.CanChannel = TpFuncGetCanChannel();
      /* Make the communication channel ID visible to the above layer */
      g_descSecondInfoPoolRef.busInfo.comChannel = g_descSecondInfoPoolRef.busInfo.addressingInfo.isoTp.CanChannel;
# endif
      /* Check if Desc itself is free */
      usdtNetResult = DescUsdtNetStartReception(&g_descSecondInfoPoolRef);
      if(usdtNetResult == kDescUsdtNetworkOk)
      { /* it is */
        returnValue = g_descSecondInfoPoolRef.reqDataPtr;
      }
      else
      {
        DescUsdtNetIsoTpReleaseInfoPool(&g_descSecondInfoPoolRef);
      }
    }
  }
  /* discard reception */
  return returnValue;
}
#endif

#if defined(TP_FUNC_ENABLE_RECEPTION)
/*******************************************************************************
* NAME:              DescFuncReqInd
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Rx path for functional requests.
*
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescFuncReqInd(vuint16 dataLen)
{
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(dataLen);

  if (g_descSecondInfoPoolRef.busHandle == 0xfe)
  {
    /*-----------------------------*/
    /*Transport protocol management*/
    /*-----------------------------*/
    /* Reception has finished */
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)  && \
     defined (TP_ENABLE_NORMAL_ADDRESSING)
    TpFuncSetResponse(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
# endif
    DescUsdtNetFinishReception(&g_descSecondInfoPoolRef, kDescUsdtNetworkOk);
    /* Reset the channel */
    TpFuncResetChannel();
  }
}
#endif

/*******************************************************************************
* NAME:              DescIsTAAcceptable
*
* CALLED BY:         DescFuncReqInd
* PRECONDITIONS:     
*
* DESCRIPTION:       Checks if the incoming request is relevant for this ECU. 
*
*******************************************************************************/
static DescBool DescIsTAAcceptable(vuint8 targetAddress)
{
  DescBool returnValue = kDescFalse;

  if((targetAddress == 0xFE)
#if defined (DESC_ENABLE_GW_ECU_ADDR)
  || (targetAddress == 0xFD)
#endif
    )
  {
    returnValue = kDescTrue;
  }
  return returnValue;
}

/*******************************************************************************
 Desc ICN private functions
*******************************************************************************/
/*******************************************************************************
* NAME:              DescICNDoExitRxProcess
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
static void DescICNDoExitRxProcess(DICN_CHANNEL_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult result)
{
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
  /* Stop data monitoring */
  g_descIcnState[DICN_CHANNEL_PARAM_VALUE].timer = 0;
  g_descIcnState[DICN_CHANNEL_PARAM_VALUE].doRetryDataCopy = kDescFalse;
#endif
  /* First notify DESC about the response data availability */
  DescICNRxMsgInd(&g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE], result);
  /* Notify sender for the transmission end status */
  DescUsdtNetFinishTransmission(&g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE], result);
}


/*******************************************************************************
* NAME:              DescICNGetResponseData
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
static void DescICNGetResponseData(DICN_CHANNEL_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
  t_descUsdtNetResult       result;
  vuint8_least              copyLen;
  vuint8_least              preDataLen;
  vuint8_least              postDataLen;
  static vuint8 g_descIcnTempBuffer[kDescICNChannelCount][kDescICNTempBufferLen];
#endif

  DescUsdtNetDescICNAssertInternal(g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].pDestination != V_NULL, kDescAssertDescIcnIllegalTargetPointer);
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
  if(g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].resType == kDescUsdtResponseRingBuffer)
  {
    do
    {
      copyLen = ((((vuint16)(g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].dataLength - g_descIcnState[DICN_CHANNEL_PARAM_VALUE].rdIdx)) / kDescICNTempBufferLen) != 0)?
                 kDescICNTempBufferLen:
                 (g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].dataLength % kDescICNTempBufferLen);
      result = DescUsdtNetRingBufferCopyRoutine(&g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE], g_descIcnTempBuffer[DICN_CHANNEL_PARAM_VALUE], (vuint8)copyLen);

      if(result == kDescUsdtNetworkOk)
      {
        /* Restart data timeout monitoring each time a data has been copied */
        g_descIcnState[DICN_CHANNEL_PARAM_VALUE].timer = (DescICNConfTimer)kDescICNDataCopyTimeoutTicks;

        preDataLen = 0;
        postDataLen = 0;
        /* Skip ot side of the data window */
        if((g_descIcnState[DICN_CHANNEL_PARAM_VALUE].rdIdx < g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].endIdx)&&
          ((g_descIcnState[DICN_CHANNEL_PARAM_VALUE].rdIdx + kDescICNTempBufferLen) > g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].beginIdx))
        {
          /*Still any data to copy!*/
          /*-----------------------*/
          if(g_descIcnState[DICN_CHANNEL_PARAM_VALUE].rdIdx < g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].beginIdx)
          {
            preDataLen = (vuintx)(g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].beginIdx - g_descIcnState[DICN_CHANNEL_PARAM_VALUE].rdIdx);
          }
          /*Check for not full temp buffer with data*/
          if((g_descIcnState[DICN_CHANNEL_PARAM_VALUE].rdIdx + kDescICNTempBufferLen) > g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].endIdx)
          {
            postDataLen = (vuintx)(kDescICNTempBufferLen - (g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].endIdx - g_descIcnState[DICN_CHANNEL_PARAM_VALUE].rdIdx));
          }

          copyLen = (vuintx)(kDescICNTempBufferLen - (postDataLen + preDataLen));
          /* Copy the data */
          DescMsgCopyRamToFarRam(&g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].pDestination[g_descIcnState[DICN_CHANNEL_PARAM_VALUE].wrIdx],
                                 &g_descIcnTempBuffer[DICN_CHANNEL_PARAM_VALUE][preDataLen],
                                 (vuint16)copyLen);
          /* set next write position */
          g_descIcnState[DICN_CHANNEL_PARAM_VALUE].wrIdx+=(DescMsgLen)copyLen;
        }
        /*Take next data portion */
        g_descIcnState[DICN_CHANNEL_PARAM_VALUE].rdIdx+=(DescMsgLen)kDescICNTempBufferLen;
      }
    }
    while((result == kDescUsdtNetworkOk)&&
          (g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].dataLength > g_descIcnState[DICN_CHANNEL_PARAM_VALUE].rdIdx));
    /* Check exit condition */
    if(result != kDescUsdtNetworkOk)
    {
      g_descIcnState[DICN_CHANNEL_PARAM_VALUE].doRetryDataCopy = kDescTrue;
      return;
    }
  }
  else
#endif
  {
    /* copy the data */
    /* Simple linear copy */
    DescMsgCopyFarRamToFarRam(g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].pDestination,
                             &g_descIcnBuffer[DICN_CHANNEL_PARAM_VALUE][g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].beginIdx],
                             (vuint16)(g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].endIdx - g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].beginIdx));
  }
  /* That was - finish transmission */
  DescICNDoExitRxProcess(DICN_CHANNEL_PARAM_FIRST kDescUsdtNetworkOk);
}


/*******************************************************************************
 Desc ICN server side 
*******************************************************************************/

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
/*******************************************************************************
* NAME:              DescUsdtNetDescICNTimerTask
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetDescICNTimerTask(void)
{
  DICN_CHANNEL_PARAM_DEF_LOCAL

# if defined (DESC_USDTNET_ENABLE_MULTI_DESCICN)
  DICN_CHANNEL_PARAM_VALUE = kDescICNChannelCount;
  while(DICN_CHANNEL_PARAM_VALUE != 0)
# endif
  {
# if defined (DESC_USDTNET_ENABLE_MULTI_DESCICN)
    DICN_CHANNEL_PARAM_VALUE--;
# endif
    if(g_descIcnState[DICN_CHANNEL_PARAM_VALUE].timer != 0)
    {
      g_descIcnState[DICN_CHANNEL_PARAM_VALUE].timer--;
      if(g_descIcnState[DICN_CHANNEL_PARAM_VALUE].timer == 0)
      {
        /* That was - finish transmission */
        DescICNDoExitRxProcess(DICN_CHANNEL_PARAM_FIRST kDescUsdtNetworkAbort);
      }
    }
  }
}
#endif

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
/*******************************************************************************
* NAME:              DescUsdtNetDescICNStateTask
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetDescICNStateTask(void)
{
  DICN_CHANNEL_PARAM_DEF_LOCAL

# if defined (DESC_USDTNET_ENABLE_MULTI_DESCICN)
  DICN_CHANNEL_PARAM_VALUE = kDescICNChannelCount;
  while(DICN_CHANNEL_PARAM_VALUE != 0)
# endif
  {
# if defined (DESC_USDTNET_ENABLE_MULTI_DESCICN)
    DICN_CHANNEL_PARAM_VALUE--;
# endif
    if(g_descIcnState[DICN_CHANNEL_PARAM_VALUE].doRetryDataCopy != kDescFalse)
    {
      g_descIcnState[DICN_CHANNEL_PARAM_VALUE].doRetryDataCopy = kDescFalse;
      DescICNGetResponseData(DICN_CHANNEL_PARAM_ONLY);
    }
  }
}
#endif

/*******************************************************************************
* NAME:              DescUsdtNetDescICNInitPowerOn
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetDescICNInitPowerOn(void)
{
  DescUsdtNetDescICNInit();
}


/*******************************************************************************
* NAME:              DescUsdtNetDescICNInit
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetDescICNInit(void)
{
  DICN_CHANNEL_PARAM_DEF_LOCAL

#if defined (DESC_USDTNET_ENABLE_MULTI_DESCICN)
  DICN_CHANNEL_PARAM_VALUE = kDescICNChannelCount;
  while(DICN_CHANNEL_PARAM_VALUE != 0)
#endif
  {
#if defined (DESC_USDTNET_ENABLE_MULTI_DESCICN)
    DICN_CHANNEL_PARAM_VALUE--;
#endif
    g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].reqType = kDescUsdtNetReqTypeInternal;
    g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].resType = kDescUsdtResponseNone;
    g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].busHandle = DICN_CHANNEL_PARAM_VALUE;
    g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].reqDataPtr = g_descIcnBuffer[DICN_CHANNEL_PARAM_VALUE];
    g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].resDataPtr = g_descIcnBuffer[DICN_CHANNEL_PARAM_VALUE];
    g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext;
    g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].busInfo.busType = kDescUsdtNetBusTypeDescICN;
#if defined(DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
    g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].busInfo.availBufferLength = kDescICNBufferLen;
#endif
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
    g_descIcnState[DICN_CHANNEL_PARAM_VALUE].doRetryDataCopy = kDescFalse;
    g_descIcnState[DICN_CHANNEL_PARAM_VALUE].timer = 0;
#endif
#if defined (DESC_USDTNET_ENABLE_TX_LOCK_DESCICN)
    g_descIcnState[DICN_CHANNEL_PARAM_VALUE].isLocked = kDescFalse;
#endif
  }
}


/*******************************************************************************
* NAME:              DescUsdtNetDescICNPrepareResponse
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetDescICNPrepareResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
  vuint8 tempContext;
  /* Swap the source/target contexts */
  tempContext = infoPool->busInfo.addressingInfo.descICN.TargetContext;
  infoPool->busInfo.addressingInfo.descICN.TargetContext = infoPool->busInfo.addressingInfo.descICN.SourceContext;
  infoPool->busInfo.addressingInfo.descICN.SourceContext = tempContext;
}


/*******************************************************************************
* NAME:              DescUsdtNetDescICNTransmitResponse
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetDescICNTransmitResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
  /* Ignore RCR-RP responses */
  switch(infoPool->resType)
  {
      /* Negative responses have no data */
    case kDescUsdtResponseNegative:
      DescICNDoExitRxProcess(DICN_CHANNEL_INFOPOOL_PARAM_FIRST kDescUsdtNetworkOk);
      break;
    case kDescUsdtResponseNegativeRCR_RP:
    case kDescUsdtResponseNegativeApplRCR_RP:
      /* Ignore these responses (do not notify DESC) */
      DescUsdtNetFinishTransmission(infoPool, kDescUsdtNetworkOk);
      break;
      /* Any positive response */
    default:
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
      g_descIcnState[DICN_CHANNEL_INFOPOOL_PARAM_VALUE].rdIdx = 0;
      g_descIcnState[DICN_CHANNEL_INFOPOOL_PARAM_VALUE].wrIdx = 0;
      /* Start data timeout monitoring */
      g_descIcnState[DICN_CHANNEL_INFOPOOL_PARAM_VALUE].timer = (DescICNConfTimer)kDescICNDataCopyTimeoutTicks;
#endif
      /* Try get some data */
      DescICNGetResponseData(DICN_CHANNEL_INFOPOOL_PARAM_ONLY);
      break;
  }
}

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
/*******************************************************************************
* NAME:              DescUsdtNetDescICNGetRingBuffTxMinLen
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS:
*
* DESCRIPTION:       Get Minimum Length
*
*
*******************************************************************************/
DESCNET_USDT_STATIC vuint16 DescUsdtNetDescICNGetRingBuffTxMinLen(t_descUsdtNetInfoPoolPtr infoPool)
{
  DESC_IGNORE_UNREF_PARAM(infoPool);
  return (vuint16) 0x06;
}
#endif

/*******************************************************************************
* NAME:              DescUsdtNetDescICNReleaseInfoPool
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetDescICNReleaseInfoPool(t_descUsdtNetInfoPoolPtr infoPool)
{
  /* Avoid warnings */
  DESC_IGNORE_UNREF_PARAM(infoPool);
#if defined (DESC_USDTNET_ENABLE_TX_LOCK_DESCICN)
  if(g_descIcnState[DICN_CHANNEL_INFOPOOL_PARAM_VALUE].isLocked == kDescFalse)
#endif
  {
    g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_INFOPOOL_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext;
  }
}

/*******************************************************************************
 Desc ICN client side 
*******************************************************************************/
/*******************************************************************************
* NAME:              DescICNAllocateTxResource
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC t_descUsdtNetInfoPoolPtr DescICNAllocateTxResource(const t_AddrInfoDescICN* const pAddrInfo)
{
  DICN_CHANNEL_PARAM_DEF_LOCAL
  t_descUsdtNetResult  result;
#if defined (DESC_USDTNET_ENABLE_MULTI_DESCICN)
  DICN_CHANNEL_PARAM_VALUE = kDescICNChannelCount;
  while(DICN_CHANNEL_PARAM_VALUE != 0)
#endif
  {
#if defined (DESC_USDTNET_ENABLE_MULTI_DESCICN)
    DICN_CHANNEL_PARAM_VALUE--;
#endif
    /* Is any ICN channel free? */
    if(g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].descHandle == kDescUsdtNetInvalidDescContext)
    {
      /* First store the paramater (source context) */
      g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].busInfo.addressingInfo.descICN = *pAddrInfo;
      /* Set the first possible target context now */
      g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].descHandle = pAddrInfo->TargetContext;
      /* Check if this context is free */
      result = DescUsdtNetStartReception(&g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE]);
      if(result == kDescUsdtNetworkOk)
      {
        /* Default listener configuration - no target pointer - listener must be set!!! */
        g_descListenerConfig[DICN_CHANNEL_PARAM_VALUE].pDestination = V_NULL;

        return &g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE];
      }
      /* Reset the descHandle */
      g_descUsdtNetInfoPoolDescICN[DICN_CHANNEL_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext;
    }
  }
  return V_NULL;
}

/*******************************************************************************
* NAME:              DescICNSetRxDataListener
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescICNSetRxDataListener(t_descUsdtNetInfoPoolPtr infoPool, const DescICNRxDataListener * const dataListener)
{
  /* Avoid warnings */
  DESC_IGNORE_UNREF_PARAM(infoPool);
  /* Copy the data block configuration */
  g_descListenerConfig[DICN_CHANNEL_INFOPOOL_PARAM_VALUE] = *dataListener;
}

/*******************************************************************************
* NAME:              DescICNSendRequest
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescICNSendRequest(t_descUsdtNetInfoPoolPtr infoPool)
{
  /* Avoid warnings */
  DescUsdtNetFinishReception(infoPool, kDescUsdtNetworkOk);
}

#if defined (DESC_USDTNET_ENABLE_TX_LOCK_DESCICN)
/*******************************************************************************
* NAME:              DescICNLockTxResource
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Reserve Tx Resource to be available even after IcnRxMsgInd
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescICNLockTxResource(t_descUsdtNetInfoPoolPtr infoPool)
{
  /* Avoid warnings */
  DESC_IGNORE_UNREF_PARAM(infoPool);
  g_descIcnState[DICN_CHANNEL_INFOPOOL_PARAM_VALUE].isLocked = kDescTrue;
}
#endif

#if defined (DESC_USDTNET_ENABLE_TX_LOCK_DESCICN)
/*******************************************************************************
* NAME:              DescICNUnlockTxResource
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Unlock Tx Resource to allow cleanup after IcnRxMsgInd
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescICNUnlockTxResource(t_descUsdtNetInfoPoolPtr infoPool)
{
  /* Avoid warnings */
  DESC_IGNORE_UNREF_PARAM(infoPool);
  g_descIcnState[DICN_CHANNEL_INFOPOOL_PARAM_VALUE].isLocked = kDescFalse;
}
#endif

#if defined (DESC_USDTNET_ENABLE_TX_LOCK_DESCICN)
/*******************************************************************************
* NAME:              DescICNReleaseTxResource
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Unlock and free resource
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescICNReleaseTxResource(t_descUsdtNetInfoPoolPtr infoPool)
{
  g_descIcnState[DICN_CHANNEL_INFOPOOL_PARAM_VALUE].isLocked = kDescFalse;
  /* Explicitely release the info pool */
  DescUsdtNetDescICNReleaseInfoPool(infoPool);
}
#endif

/*  ********************************************************************************
 * Function name:DescUsdtNetInitPowerOn
 * Description:Reroutes the API to the corresponding network layer.
 * Returns: none
 * Parameter(s):
 *   - infoPool:
 *       - Network layer specific information.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DescUsdtNetInitPowerOn(void)
{
  DescUsdtNetIsoTpInitPowerOn();
  DescUsdtNetDescICNInitPowerOn();
}


/*  ********************************************************************************
 * Function name:DescUsdtNetInit
 * Description:Reroutes the API to the corresponding network layer.
 * Returns: none
 * Parameter(s):
 *   - infoPool:
 *       - Network layer specific information.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DescUsdtNetInit(void)
{
  DescUsdtNetIsoTpInit();
  DescUsdtNetDescICNInit();
}


/*  ********************************************************************************
 * Function name:DescUsdtNetStateTask
 * Description:Reroutes the API to the corresponding network layer.
 * Returns: none
 * Parameter(s):
 *   - infoPool:
 *       - Network layer specific information.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DescUsdtNetStateTask(void)
{
  DescUsdtNetIsoTpStateTask();
}


/*  ********************************************************************************
 * Function name:DescUsdtNetTimerTask
 * Description:Reroutes the API to the corresponding network layer.
 * Returns: none
 * Parameter(s):
 *   - infoPool:
 *       - Network layer specific information.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DescUsdtNetTimerTask(void)
{
}


/*  ********************************************************************************
 * Function name:DescUsdtNetPrepareResponse
 * Description:Reroutes the API to the corresponding network layer.
 * Returns: none
 * Parameter(s):
 *   - infoPool:
 *       - Network layer specific information.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DescUsdtNetPrepareResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
  switch(infoPool->busInfo.busType)
  {
    case kDescUsdtNetBusTypeIsoTp:
    {
      DescUsdtNetIsoTpPrepareResponse(infoPool);
    }
    break;
    case kDescUsdtNetBusTypeDescICN:
    {
      DescUsdtNetDescICNPrepareResponse(infoPool);
    }
    break;
    default:
    {
      /* Unknown bus type. */
    }
    break;
  }
}


/*  ********************************************************************************
 * Function name:DescUsdtNetTransmitResponse
 * Description:Reroutes the API to the corresponding network layer.
 * Returns: none
 * Parameter(s):
 *   - infoPool:
 *       - Network layer specific information.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DescUsdtNetTransmitResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
  switch(infoPool->busInfo.busType)
  {
    case kDescUsdtNetBusTypeIsoTp:
    {
      DescUsdtNetIsoTpTransmitResponse(infoPool);
    }
    break;
    case kDescUsdtNetBusTypeDescICN:
    {
      DescUsdtNetDescICNTransmitResponse(infoPool);
    }
    break;
    default:
    {
      /* Unknown bus type. */
    }
    break;
  }
}


/*  ********************************************************************************
 * Function name:DescUsdtNetReleaseInfoPool
 * Description:Reroutes the API to the corresponding network layer.
 * Returns: none
 * Parameter(s):
 *   - infoPool:
 *       - Network layer specific information.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DescUsdtNetReleaseInfoPool(t_descUsdtNetInfoPoolPtr infoPool)
{
  switch(infoPool->busInfo.busType)
  {
    case kDescUsdtNetBusTypeIsoTp:
    {
      DescUsdtNetIsoTpReleaseInfoPool(infoPool);
    }
    break;
    case kDescUsdtNetBusTypeDescICN:
    {
      DescUsdtNetDescICNReleaseInfoPool(infoPool);
    }
    break;
    default:
    {
      /* Unknown bus type. */
    }
    break;
  }
}


#if defined (DESC_UUDTNET_ENABLE_TX_FAILED_SIM)
/*******************************************************************************
* NAME:              DescUudtNetCanDoSimTxFailed
*
* CALLED BY:         TestApplication
* PRECONDITIONS: 
*
* DESCRIPTION:       Enables/disables the TX Failed simulation
*                    
*                    
*******************************************************************************/
void DescUudtNetCanDoSimTxFailed(DescBool doSim)
{
  g_descUudtNetDoSimFailed = doSim;
}
#endif

/*******************************************************************************
* NAME:              DescUudtNetInitPowerOn
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Power on initialization
*                    
*                    
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetCANInitPowerOn(void)
{
  RESOURCE_ITER_DEF_LOCAL

#if (kDescUudtNetQueueSize > 1)
  RESOURCE_ITER_VALUE = kDescUudtNetQueueSize;
  while(RESOURCE_ITER_VALUE != 0)
#endif
  {
    RESOURCE_ITER_VALUE_DECREMENT;
    DescUudtNetInitPowerOnResourceManager(RESOURCE_ITER_ONLY);
  }

  DescUudtNetCANInit();
}

/*******************************************************************************
* NAME:              DescUudtNetInit
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Re-initialization 
*                    
*                    
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetCANInit(void)
{
  RESOURCE_ITER_DEF_LOCAL
  CAN_MSG_ITER_DEF_LOCAL

#if defined (DESC_UUDTNET_ENABLE_TX_FAILED_SIM)
  g_descUudtNetDoSimFailed = kDescFalse;
#endif

#if (kDescUudtNetNumCanMsgs > 1)
  g_descUudtNetCanMsgCounter = 0;
  CAN_MSG_ITER_VALUE = kDescUudtNetNumCanMsgs;
  while(CAN_MSG_ITER_VALUE != 0)
#endif
  {
    CAN_MSG_ITER_VALUE_DECREMENT;
    DescUudtNetInitCanMsgManager(CAN_MSG_ITER_ONLY);
  }

#if (kDescUudtNetQueueSize > 1)
  /* Queue is empty */
  g_descUudtNetPrioQueueCount = 0;
  RESOURCE_ITER_VALUE = kDescUudtNetQueueSize;
  while(RESOURCE_ITER_VALUE != 0)
#endif
  {
    RESOURCE_ITER_VALUE_DECREMENT;
    DescUudtNetInitResourceManager(RESOURCE_ITER_ONLY);
  }
}

/*******************************************************************************
* NAME:              DescUudtNetInitCanMsgManager
*
* CALLED BY:         DescUudtNetCAN
* PRECONDITIONS: 
*
* DESCRIPTION:       Power on initialization
*                    
*                    
*******************************************************************************/
static void DescUudtNetInitCanMsgManager(CAN_MSG_FORMAL_PARAM_DEF_ONLY)
{
  g_descUudtNetCanMsgManager[CAN_MSG_PARAM_VALUE].timer      = 0;
#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
  g_descUudtNetCanMsgManager[CAN_MSG_PARAM_VALUE].busHandle  = kDescUudtNetBusHandleInvalid;
#endif

  DescUudtNetLL_InitCanMsgManager(CAN_MSG_PARAM_VALUE);
}

/*******************************************************************************
* NAME:              DescUudtNetInitPowerOnResourceManager
*
* CALLED BY:         DescUudtNetCAN
* PRECONDITIONS: 
*
* DESCRIPTION:       Power on initialization
*                    
*                    
*******************************************************************************/
static void DescUudtNetInitPowerOnResourceManager(RESOURCE_FORMAL_PARAM_DEF_ONLY)
{
  g_descUudtNetInfoPoolCAN[RESOURCE_PARAM_VALUE].busHandle        = (vuint8)RESOURCE_PARAM_VALUE;
  /* Initialize the pointers */
#if defined(DESC_UUDTNET_ENABLE_DATA_BUFFERS)
  g_descUudtNetInfoPoolCAN[RESOURCE_PARAM_VALUE].resDataPtr       = g_descUudtNetDataQueueBuffers[RESOURCE_PARAM_VALUE];
#else
  g_descUudtNetInfoPoolCAN[RESOURCE_PARAM_VALUE].resDataPtr       = DescUudtNetMsgBuffer(RESOURCE_PARAM_VALUE);
#endif
#if defined(DESC_UUDTNET_ENABLE_MULTI_BUS_SUPPORT)
  g_descUudtNetInfoPoolCAN[RESOURCE_PARAM_VALUE].busInfo.busType  = kDescUudtNetBusTypeCAN;
#endif
}

/*******************************************************************************
* NAME:              DescUudtNetInitResourceManager
*
* CALLED BY:         DescUudtNetCAN
* PRECONDITIONS: 
*
* DESCRIPTION:       Power on initialization
*                    
*                    
*******************************************************************************/
static void DescUudtNetInitResourceManager(RESOURCE_FORMAL_PARAM_DEF_ONLY)
{
#if defined(DESC_UUDTNET_ENABLE_DYN_LIFETIME_SUPPORT)
  g_descUudtNetInfoPoolCAN[RESOURCE_PARAM_VALUE].busInfo.lifeTime   = kDescLifeTimeTemporary;
#endif
#if defined (DESC_UUDTNET_ENABLE_MULTI_CLIENT)
  g_descUudtNetInfoPoolCAN[RESOURCE_PARAM_VALUE].busInfo.client     = kDescClientNone;
#endif

#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
  g_descUudtNetResourceManager[RESOURCE_PARAM_VALUE].canMsgManagerRef  = kDescUudtNetMsgRefInvalid;
#endif
  g_descUudtNetResourceManager[RESOURCE_PARAM_VALUE].engine            = kDescUudtNetCanResEngineIdle;
}

/*******************************************************************************
* NAME:              DescUudtNetCANTimerTask
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetCANTimerTask(void)
{
  CAN_MSG_ITER_DEF_LOCAL

#if (kDescUudtNetNumCanMsgs > 1)
  /* No CAN message used */
  if(g_descUudtNetCanMsgCounter != 0)
#endif
  {
#if (kDescUudtNetNumCanMsgs > 1)
    CAN_MSG_ITER_VALUE = kDescUudtNetNumCanMsgs;
    while(CAN_MSG_ITER_VALUE != 0)
#endif
    {
      CAN_MSG_ITER_VALUE_DECREMENT;
      /* Check timeout monitoring */
      if(g_descUudtNetCanMsgManager[CAN_MSG_ITER_VALUE].timer != 0)
      {
        g_descUudtNetCanMsgManager[CAN_MSG_ITER_VALUE].timer--;
        if(g_descUudtNetCanMsgManager[CAN_MSG_ITER_VALUE].timer == 0)
        {
          /* Check if the message is just sent? */
          DescUudtNetLL_InterruptDisable();
          if(g_descUudtNetResourceManager[DescUudtNetResHandleRef(CAN_MSG_ITER_VALUE)].engine != kDescUudtNetCanResEngineSent)
          {
            /* Message obsolete */
            DescUudtNetLL_CancelTransmit(DescUudtNetMsgHandle(CAN_MSG_ITER_VALUE));
            DescUudtNetLL_InterruptRestore();
            /* Message not sent - error */
            DescUudtNetCanTxMsgEnd(RESOURCE_ITER_USAGE_FIRST(DescUudtNetResHandleRef(CAN_MSG_ITER_VALUE))
                                   kDescUudtNetworkFailed);
          }
          else
          {
            /* Just restore interrupts, and let the StateTask to handle the message end */
            DescUudtNetLL_InterruptRestore();
          }
        }
      }
    }
  }
}


/*******************************************************************************
* NAME:              DescUudtNetCANStateTask
*
* CALLED BY:         DescUudtNetCAN
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetCANStateTask(void)
{
#if (kDescUudtNetQueueSize > 1)
  if(g_descUudtNetPrioQueueCount != 0)
#endif
  {
    RESOURCE_ITER_DEF_LOCAL
#if (kDescUudtNetQueueSize > 1)
    /* At least one element is there */
    RESOURCE_ITER_VALUE = 0;
    do
#endif
    {
      if(g_descUudtNetResourceManager[DescUudtPrioQueueIter(RESOURCE_ITER_VALUE)].engine == kDescUudtNetCanResEngineSent)
      {
        DescUudtNetCanTxMsgEnd(RESOURCE_ITER_USAGE_FIRST(DescUudtPrioQueueIter(RESOURCE_ITER_VALUE)) kDescUudtNetworkOk);
      }
      else
      {
        RESOURCE_ITER_VALUE_INCREMENT;
      }
    }
#if (kDescUudtNetQueueSize > 1)
    while(RESOURCE_ITER_VALUE < g_descUudtNetPrioQueueCount);
    /* Something in the queue */
    RESOURCE_ITER_VALUE = 0;
    while(RESOURCE_ITER_VALUE < g_descUudtNetPrioQueueCount)
#endif
    {
      /* Signal cleared by the retry function if transmission successful */
      if((g_descUudtNetResourceManager[DescUudtPrioQueueIter(RESOURCE_ITER_VALUE)].engine & (kDescUudtNetCanResEngineDoSend | kDescUudtNetCanResEngineResend)) != 0)
      {
        /* Remove the retry state (made in the function below too. */
        /* g_descUudtNetResourceManager[DescUudtPrioQueueIter(RESOURCE_PARAM_VALUE)].engine = kDescUudtNetCanResEngineLocked;*/
        DescUudtNetTryToSendMsg(RESOURCE_ITER_USAGE_ONLY(DescUudtPrioQueueIter(RESOURCE_ITER_VALUE)));
      }
      RESOURCE_ITER_VALUE_INCREMENT;
    }
  }
}

/*******************************************************************************
* NAME:              DescUudtNetCANTxReserveResource
*
* CALLED BY:         DescUudtNetDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
DESCNET_UUDT_STATIC t_descUudtNetInfoPoolPtr  DescUudtNetCANTxReserveResource(t_descUudtNetBusInfoPtr busInfo)
{
  RESOURCE_ITER_DEF_LOCAL

  /* Disable interrupts */
  t_descUudtNetInfoPoolPtr pResultInfoPoolRef = V_NULL;

  /* Try releasing resources */
  DescUudtNetCANStateTask();
#if (kDescUudtNetQueueSize > 1)
  RESOURCE_ITER_VALUE = kDescUudtNetQueueSize;
  while(RESOURCE_ITER_VALUE != 0)
#endif
  {
    RESOURCE_ITER_VALUE_DECREMENT;
    /* Check if free */
    if(g_descUudtNetResourceManager[RESOURCE_ITER_VALUE].engine == kDescUudtNetCanResEngineIdle)
    {
#if defined (DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT) && \
    defined (DESC_DISABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
      /* Check for matching CAN channel (only if the buffers are CAN message buffers)*/
      if(DescUudtMsgInfoAt(RESOURCE_ITER_VALUE).commChannel == busInfo->busProperty.can.canChannel)
#endif
      {
        /* Reserve the resource */
        g_descUudtNetResourceManager[RESOURCE_ITER_VALUE].engine = kDescUudtNetCanResEngineLocked;
        /* Copy the requested info (reserve the resource for this client) */
        g_descUudtNetInfoPoolCAN[RESOURCE_ITER_VALUE].busInfo = *busInfo;
        pResultInfoPoolRef = &g_descUudtNetInfoPoolCAN[RESOURCE_ITER_VALUE];
#if defined (DESC_UUDTNET_ENABLE_MSG_PADDING)
        VStdMemSet(g_descUudtNetInfoPoolCAN[RESOURCE_ITER_VALUE].resDataPtr,
                   kDescUudtNetPaddingByte,
                   kDescUudtNetFrameLen);
#endif
#if (kDescUudtNetQueueSize > 1)
        /* Its freee yepiii :) */
        RESOURCE_ITER_VALUE = 0;
#endif
      }
    }
  }
  return pResultInfoPoolRef;
}

/*******************************************************************************
* NAME:              DescUudtNetCANTransmitResponse
*
* CALLED BY:         DescUudtNetDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetCANTransmitResponse (t_descUudtNetInfoPoolPtr infoPool)
{
  RESOURCE_ITER_DEF_LOCAL

  /* Avoid warnings */
  DESCNET_CAN_IGNORE_UNREF_PARAM(infoPool);

#if (kDescUudtNetQueueSize > 1)
  RESOURCE_ITER_VALUE = infoPool->busHandle;
  /* Store TX request */
  g_descUudtNetPrioQueue[g_descUudtNetPrioQueueCount] = RESOURCE_ITER_VALUE;
  g_descUudtNetPrioQueueCount++;
#endif

  /* Force transmission (consider queue) */
  g_descUudtNetResourceManager[RESOURCE_ITER_VALUE].engine = kDescUudtNetCanResEngineDoSend;
  DescUudtNetCANStateTask();
}

/*******************************************************************************
* NAME:              DescUudtNetTryToSendMsg
*
* CALLED BY:         DescUudtNetCAN
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static void DescUudtNetTryToSendMsg (RESOURCE_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_UUDTNET_ENABLE_MSG_RETRANSMIT)
  DescUudtNetLL_TxStatusType result = kDescUudtNetLL_TxFailed;
#endif

  /* If first try (no resend) */
#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
  /* Is there any message assigned ? */
  if(g_descUudtNetResourceManager[RESOURCE_PARAM_VALUE].canMsgManagerRef == kDescUudtNetMsgRefInvalid)
#else
  if(g_descUudtNetResourceManager[RESOURCE_PARAM_VALUE].engine == kDescUudtNetCanResEngineDoSend)
#endif
  {

#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
    CAN_MSG_ITER_DEF_LOCAL
# if (kDescUudtNetNumCanMsgs > 1)
    CAN_MSG_ITER_VALUE = kDescUudtNetNumCanMsgs;
    while(CAN_MSG_ITER_VALUE != 0)
# endif
#endif
    {
#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
      CAN_MSG_ITER_VALUE_DECREMENT;
# if defined (DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
      if(DescUudtMsgInfoAt(CAN_MSG_ITER_RESOURCE_VALUE).commChannel == g_descUudtNetInfoPoolCAN[RESOURCE_PARAM_VALUE].busInfo.busProperty.can.canChannel)
# endif
#endif
      {
#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
        /* Check if free */
        if(g_descUudtNetCanMsgManager[CAN_MSG_ITER_RESOURCE_VALUE].timer == 0)
#endif
        {
          g_descUudtNetCanMsgManager[CAN_MSG_ITER_RESOURCE_VALUE].timer     = kDescUudtNetConfTimeoutTicks;   /* Set timeout value: the count down is running by now */
#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
          g_descUudtNetCanMsgManager[CAN_MSG_ITER_RESOURCE_VALUE].busHandle = (vuint8)RESOURCE_PARAM_VALUE;       /* Set the handle */

          g_descUudtNetResourceManager[RESOURCE_PARAM_VALUE].canMsgManagerRef = CAN_MSG_ITER_RESOURCE_VALUE; /* Set reference */
#endif
#if (kDescUudtNetNumCanMsgs > 1)
          /* Increment count of reserved messages */
          g_descUudtNetCanMsgCounter++;
#endif
#if defined(DESC_UUDTNET_ENABLE_DATA_BUFFERS)
# if defined(DESC_UUDTNET_ENABLE_PACKED_DATA)
          /* Copy the queued data and pack the bytes for TMS CANdriver */
          VStdMemCpyExWordToByte(DescUudtNetMsgBuffer(CAN_MSG_ITER_RESOURCE_VALUE),
                                 0,
                                 &(g_descUudtNetDataQueueBuffers[RESOURCE_PARAM_VALUE][kDescUudtCanDataOffset]),
                                 kDescUudtNetFrameLen);
# else
          /* Copy the data */
          DescMsgCopyRamToRam( DescUudtNetMsgBuffer(CAN_MSG_ITER_RESOURCE_VALUE),
                              &(g_descUudtNetDataQueueBuffers[RESOURCE_PARAM_VALUE][kDescUudtCanDataOffset]),
                              kDescUudtNetFrameLen);

# endif
#endif
#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
# if (kDescUudtNetNumCanMsgs > 1)
          CAN_MSG_ITER_VALUE = 0;/* Its freee yepiii :) */
# endif
#endif
        }
      }
    }
  }

  /* Assume success */
  g_descUudtNetResourceManager[RESOURCE_PARAM_VALUE].engine = kDescUudtNetCanResEngineWaitForConf;

#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
  /* Is there any message assigned ? */
  if(g_descUudtNetResourceManager[RESOURCE_PARAM_VALUE].canMsgManagerRef != kDescUudtNetMsgRefInvalid)
#endif
  {
#if defined (DESC_UUDTNET_ENABLE_TX_FAILED_SIM)
    if(g_descUudtNetDoSimFailed == kDescFalse)
#endif
    {
      /* Msg object reserved, try resend only */
#if defined (DESC_UUDTNET_ENABLE_MSG_RETRANSMIT)
      result =
#endif
      DESC_UUDT_TRANSMIT(DescUudtNetMsgRef(RESOURCE_PARAM_VALUE));
    }
  }

#if defined (DESC_UUDTNET_ENABLE_MSG_RETRANSMIT)
  if(result != kDescUudtNetLL_TxOk)
  {
    g_descUudtNetResourceManager[RESOURCE_PARAM_VALUE].engine = kDescUudtNetCanResEngineResend;
  }
#endif
}

/*******************************************************************************
* NAME:              DescUudtNetCanTxMsgEnd
*
* CALLED BY:         DescUudtNetCAN
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static void DescUudtNetCanTxMsgEnd(RESOURCE_FORMAL_PARAM_DEF_FIRST t_descUudtNetResult status)
{
  RESOURCE_ITER_DEF_LOCAL


  /* Notify application */
  DescUudtNetFinishTransmission(&g_descUudtNetInfoPoolCAN[RESOURCE_PARAM_VALUE], status);

#if defined(DESC_UUDTNET_ENABLE_DYN_LIFETIME_SUPPORT)
  if(infoPool->busInfo.lifeTime == kDescLifeTimeTemporary)
#endif
  {
    /* Release resources */
#if defined (DESC_ENABLE_DYN_RESOURCE_TO_CAN_MSG_REF)
    /* Is there any message assigned ? */
    if(g_descUudtNetResourceManager[RESOURCE_PARAM_VALUE].canMsgManagerRef != kDescUudtNetMsgRefInvalid)
#endif
    {
      DescUudtNetInitCanMsgManager(CAN_MSG_ITER_USAGE(DescUudtNetMsgRef(RESOURCE_PARAM_VALUE)));
    }
    DescUudtNetInitResourceManager(RESOURCE_PARAM_ONLY);

#if (kDescUudtNetQueueSize > 1)
    RESOURCE_ITER_VALUE = g_descUudtNetPrioQueueCount;
    /* Find the position */
    while(RESOURCE_ITER_VALUE != 0)
    {
      RESOURCE_ITER_VALUE_DECREMENT;
      if(RESOURCE_PARAM_VALUE == g_descUudtNetPrioQueue[RESOURCE_ITER_VALUE])
      {
        /* handle found */
        break;
      }
    }
    /* Stretch the priority queue */
    g_descUudtNetPrioQueueCount--;
    while(RESOURCE_ITER_VALUE < g_descUudtNetPrioQueueCount)
    {
      g_descUudtNetPrioQueue[RESOURCE_ITER_VALUE] = g_descUudtNetPrioQueue[RESOURCE_ITER_VALUE + 1];
      RESOURCE_ITER_VALUE_INCREMENT;
    }
#endif
#if (kDescUudtNetNumCanMsgs > 1)
      /* Decrement count of reserved messages */
      g_descUudtNetCanMsgCounter--;
#endif
  }
}

/*******************************************************************************
* NAME:              DescUudtNetCANReleaseResource
*
* CALLED BY:         Internal
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetCANReleaseResource(t_descUudtNetInfoPoolPtr infoPool)
{
  DESC_IGNORE_UNREF_PARAM(infoPool->busHandle);
  DescUudtNetInitResourceManager(RESOURCE_PARAM_USAGE(infoPool->busHandle));
}


#if (kDescUudtNetQueueSize > 1)
/*******************************************************************************
* NAME:              DescUudtNetCANCancelAllResponses
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       Cancels all queued responses.
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetCANCancelAllResponses(void)
{
  DescUudtNetLL_InterruptDisable();
  while(g_descUudtNetPrioQueueCount != 0)
  {
    /* Only the first element will be processed until all are gone */

    /* Is currently at transmission ? */
    if(g_descUudtNetResourceManager[DescUudtPrioQueueIter(0)].engine == kDescUudtNetCanResEngineWaitForConf)
    {
      /* Message obsolete */
      DescUudtNetLL_CancelTransmit(DescUudtNetMsgHandle(DescUudtNetMsgRef(DescUudtPrioQueueIter(0))));
    }

    /* Clear the queue (modifies the g_descUudtNetPrioQueueCount) */
    /* Notify by success, since the tester wanted no more messages to be sent (or timeout)*/
    DescUudtNetCanTxMsgEnd(RESOURCE_ITER_USAGE_FIRST(DescUudtPrioQueueIter(0)) kDescUudtNetworkOk);
  }
  DescUudtNetLL_InterruptRestore();
}
#endif

/*******************************************************************************
* NAME:              DescUudtConfirmation
*
* CALLED BY:         Communication driver
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides the post transmission processing.
*******************************************************************************/
void DescUudtConfirmation(DescUudtNetLL_MsgHandleType txObject)
{
  CAN_MSG_ITER_DEF_LOCAL

  /* Avoid warnings */
  DESCNET_CAN_IGNORE_UNREF_PARAM(txObject);
#if (kDescUudtNetNumCanMsgs > 1)
  CAN_MSG_ITER_VALUE = kDescUudtNetNumCanMsgs;
  while(CAN_MSG_ITER_VALUE != 0)
#endif
  {
    CAN_MSG_ITER_VALUE_DECREMENT;
#if (kDescUudtNetNumCanMsgs > 1)
    if(DescUudtNetMsgHandle(CAN_MSG_ITER_VALUE) == txObject)
#endif
    {
      g_descUudtNetResourceManager[DescUudtNetResHandleRef(CAN_MSG_ITER_VALUE)].engine = kDescUudtNetCanResEngineSent;
#if (kDescUudtNetNumCanMsgs > 1)
      /* Break loop */
      CAN_MSG_ITER_VALUE = 0;
#endif
    }
  }
}

/*******************************************************************************
* NAME:              DescNetworkOnceInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the network subcomponent.
*
*******************************************************************************/
static void DescNetworkOnceInit(void)
{
#if defined (DESC_ENABLE_SPONTANEOUS_RES)
  /* Initialization of the spontaneous pool */
  g_descUsdtNetSpontanResInfoPool.resType = kDescUsdtResponseNone;
  /* will be done at transmission time:
  g_descUsdtNetSpontanResInfoPool.descHandle = kDescPrimContext;
  g_descUsdtNetSpontanResInfoPool.reqDataPtr = V_NULL; 
  g_descUsdtNetSpontanResInfoPool.busInfo.busType = kDescUsdtNetBusTypeIsoTp;
  */
#endif
  /* Don't forget the USDT NET */
  DescNetworkInit();
}

/*******************************************************************************
* NAME:              DescNetworkIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the network subcomponent context specific data.
*
*******************************************************************************/
static void DescNetworkIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Init the buffer state mashine */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].txState = kDescUsdtNetworkOk;
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError = 0;
#if defined (DESC_ENABLE_SPONTANEOUS_RES)
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isTransmitSingleFrameReady = 0;
#endif
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;

  /* Interrupt context controller */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextIdle;
#if defined (DESC_ENABLE_FORCE_RCR_RP)
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpIdle;
#endif
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].isContextLocked = 0;

  /* Prepare for RCR-RP negative response - the SID will be filled 
  when the T2 timer expires */
  g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE][0] = kDescNegResSId;
  g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE][2] = kDescNrcResponsePending;

#if defined (DESC_ENABLE_RES_RINGBUFFER)
  DescRingBufferIterInit(DESC_CONTEXT_PARAM_ONLY);
#endif
}

#if defined (DESC_ENABLE_SPONTANEOUS_RES)
/*******************************************************************************
* NAME:              DescTransmitSingleFrame
*
* CALLED BY:         any application function
* PRECONDITIONS: 
*
* DESCRIPTION:       Any time can make the application a single frame response.
*******************************************************************************/
void DescTransmitSingleFrame(DescMsg resData, vuint8 resLen)
{
  DescAssertCommon((resLen <= kDescSingleFrameDataLength), kDescAssertTooLongSingleFrameResponse);

  /* Store into the global variables */
  g_descUsdtNetSpontanResInfoPool.descHandle = kDescPrimContext;
  g_descUsdtNetSpontanResInfoPool.reqDataPtr = V_NULL;
  g_descUsdtNetSpontanResInfoPool.resDataPtr = resData;
  g_descUsdtNetSpontanResInfoPool.busInfo.busType = kDescUsdtNetBusTypeIsoTp;
  g_descUsdtNetSpontanResInfoPool.dataLength = (vuint16)resLen;
  g_descUsdtNetSpontanResInfoPool.resType = kDescUsdtResponseSpontaneous;

  if((g_descInterruptContextCtrl[kDescPrimContext].activity & (kDescContextActiveRx|kDescContextActiveTx)) == 0)
  {
    DescUsdtNetAbsTransmitResponse(&g_descUsdtNetSpontanResInfoPool);
  }
  else
  {
    /* Make a queue request for TpTransmit */
    DescInterruptDisable();
    g_descContextCtrl[kDescPrimContext].isTransmitSingleFrameReady = 1;
    DescInterruptRestore();
  }
}
#endif


/*******************************************************************************
* NAME:              DescReleaseContext
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       releases the RX path and manages the S1 timer
*******************************************************************************/
static void DescReleaseContext(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_ENABLE_DESCICN_SUPPORT)
  /* Check if this instance is a internal request */
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqType != kDescUsdtNetReqTypeInternal)
#endif
  {
    /* Deactivate the connection */
    DescResetConnectionActive(DESC_CONTEXT_PARAM_VALUE);
    /* Notify the application */
    ApplDescOnEndOfProcExt();
  }
  /* Release context */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].isContextLocked = 0;
  /* Release the network resource */
  DescUsdtNetAbsReleaseInfoPool(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
}

/*******************************************************************************
* NAME:              DescNetworkInitPowerOn
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the current state of the CANdesc component
*
*******************************************************************************/
static void DescNetworkInitPowerOn(void)
{
  DescUsdtNetAbsInitPowerOn();
  DescUudtNetInitPowerOn();
}


/*******************************************************************************
* NAME:              DescNetworkInit
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the current state of the CANdesc component
*
*******************************************************************************/
static void DescNetworkInit(void)
{
  DescUsdtNetAbsInit();
  DescUudtNetInit();
}

/*******************************************************************************
* NAME:              DescGetActivityState
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the current state of the CANdesc component
*
*******************************************************************************/
vuint8 DESC_API_CALL_TYPE DescGetActivityState(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity;
}

#if defined(DESC_ENABLE_DESCICN_SUPPORT)
/*******************************************************************************
* NAME:              DescICNRxMsgInd
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescICNRxMsgInd(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  switch(infoPool->busInfo.addressingInfo.descICN.Client)
  {
# if defined(DESC_ENABLE_DYN_DEFINED_DID_CLIENT)
    case kDescIcnClientDynDefDid:
      DescDynDefinedDidRxMsgInd(infoPool, status);
      break;
# endif
# if defined(DESC_ENABLE_DYN_DEFINED_DPID_CLIENT)
    case kDescIcnClientDynDefDpid:
      DescDynDefinedDpidRxMsgInd(infoPool, status);
      break;
# endif
# if defined(DESC_ENABLE_ROE_CLIENT)
    case kDescIcnClientRoe:
      DescRoeRxMsgInd(infoPool, status);
      break;
# endif
    default:
      DescAssertInternalAlways(kDescAssertInvalidDescICNClient);
      break;
  }
}
#endif


/*******************************************************************************
* NAME:              DescUsdtNetAbsStartReception
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       StartOfFrame reception function
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsStartReception(t_descUsdtNetInfoPoolPtr infoPool)
{
  t_descUsdtNetResult returnValue = kDescUsdtNetworkFailed;

  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].isContextLocked == 0)
  {
#if defined (DESC_ENABLE_CHECK_MSG_RX_ACCEPTANCE)
    if(DescOemCheckAcceptance(infoPool) != kDescFalse)
#endif
    {
      /* Lock the buffer */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].isContextLocked = 1;
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].activity |= kDescContextActiveRxBegin;

      /* Store infoPool reference */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].infoPoolPtr = infoPool;

      /* Set connection active for S1 timer check */
      DescSetConnectionActive(infoPool->descHandle);

#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
      DescSetNpmOnCanChannelActive(infoPool->busInfo.comChannel, g_descCanChannelMapQueue);
#endif
#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
      /* Store the ISO TP Source Address */
      g_descTesterAddress[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)] = infoPool->busInfo.testerId;
#endif
      /* Notify the application */
#if defined (DESC_ENABLE_DESCICN_SUPPORT)
      /* Check if this instance is a internal request */
      if(infoPool->reqType != kDescUsdtNetReqTypeInternal)
#endif
      {
        ApplDescOnBeginOfProcExt();
      }
      /* Notify the implementation */
      DescOemOnRxStart(infoPool);
      returnValue = kDescUsdtNetworkOk;
    }
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              DescUsdtNetAbsFinishReception
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       reception has finished
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetAbsFinishReception(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  /* Clear this state always!!! (in error case lefts ContextIdle then) */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].activity &= (DescContextActivity)(~kDescContextActiveRxBegin);
  if ((status == kDescUsdtNetworkOk) &&
      (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].infoPoolPtr == infoPool))
  {
    /* Check if a TesterPresent is requested with SuppresPosBit set to not lock Desc */
    DescBool result = DescIsTesterPresent(infoPool);
    if (result == kDescFalse)
    {
      /* On physical requested message actions (for S1 timer normally)*/
      DescOemOnReqInd(infoPool->descHandle);

      g_descMsgContext[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].busInfo = infoPool->busInfo;

      DescUsdtNetAbsPrepareResponse(infoPool);

      /* Sets indication flag for cyclic task */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].activity |= kDescContextActiveRxEnd;
      /*TBD: DescSetEvent(DescDSDTask, descRequestReceived)*/
      return;
    }
  }
  else
  { /* Reception error had happened */
    DescOemOnRxErrorInd(status);
  }
  DescReleaseContext(DESC_CONTEXT_PARAM_WRAPPER_ONLY(infoPool->descHandle));
}

/*******************************************************************************
* NAME:              DescUsdtNetAbsFinishTransmission
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       transmission has finished
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetAbsFinishTransmission(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL

#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_ONLY = infoPool->descHandle;
#endif

  if (status == kDescUsdtNetworkOk)
  {
    /* nothing to do */
  }
  else
  {
    DescOemOnTxErrorInd(status);
  }

  switch (infoPool->resType)
  {
  case kDescUsdtResponsePositive:
    /* fall through */
  case kDescUsdtResponseNegative:
    /* fall through */
  case kDescUsdtResponseRingBuffer:
    /* Make post processing not always success (if called from the error indication)*/
    DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST status);
#if defined(DESC_ENABLE_SPONTANEOUS_RES)
    /* fall through */
  case kDescUsdtResponseRoe:
    /* fall through */
  case kDescUsdtResponseSpontaneous:
    /* fall through */
  case kDescUsdtResponseSpontaneousAppl:
# if defined (DESC_ENABLE_PROTOCOL_UDS) || defined (DESC_ENABLE_PROTOCOL_UDS2012)
    if(infoPool->resType == kDescUsdtResponseSpontaneousAppl)
    {
       vuint8 result;
      /* Interpret the status */
      result = (vuint8)((status == kDescUsdtNetworkOk)?kDescOk:kDescFailed);
      /* Confirm the forced RCR-RP response transmission */
      ApplDescSpontaneousResponseConfirmation(DESC_CONTEXT_PARAM_FIRST result);
      /* no break - fall through */

    }
#  if defined (DESC_ENABLE_ROE_SUPPORT)
    else
    {
      if(infoPool->resType == kDescUsdtResponseRoe)
      {
        /* Notify the ROE handler */
        DescRoeResponseConfirmation();
      }
    }
#  endif
    /* Release context here */
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].isContextLocked = 0;
# endif
#endif
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
    if (infoPool->resDataPtr != infoPool->reqDataPtr )
    {
      DescUsdtNetReleaseTransmissionObj(infoPool);
    }
#endif
    break;
#if defined (DESC_ENABLE_FORCE_RCR_RP)
  case kDescUsdtResponseNegativeApplRCR_RP:
    {
      vuint8 result;
      /* Interpret the status */
      result = (vuint8)((status == kDescUsdtNetworkOk)?kDescOk:kDescFailed);
      /* Confirm the forced RCR-RP resposne transmission */
      ApplDescRcrRpConfirmation(DESC_CONTEXT_PARAM_FIRST result);
      /* no break - fall through */
    }
#endif
    /* fall through */
  case kDescUsdtResponseNegativeRCR_RP:
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
    if (infoPool->resDataPtr != g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE])
    {
      infoPool->resDataPtr = V_NULL;
      DescUsdtNetReleaseTransmissionObj(infoPool);
    }
#endif
    break;
#if defined (DESC_ENABLE_SCHEDULER_USDT_TRANSMITTER)
  case kDescUsdtResponsePeriodic:
    DescDoSchedulePostProcessing();
    break;
#endif
  default:
    break;
  }
  /* Reset response type */
  infoPool->resType = kDescUsdtResponseNone;
}

/*******************************************************************************
* NAME:              DescTransmitRcrRp
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       Transmission of RCR-RP
*
*******************************************************************************/
static void DescTransmitRcrRp(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
  /* The response message is already filled with the necessary information */
  if (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr == V_NULL)
  {
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = DescUsdtNetGetTransmissionPtr(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
    memcpy(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr,g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE],3);
  }
  else
#endif
  {
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE];
  }
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength = kDescNegResLen;

  DescUsdtNetAbsTransmitResponse(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
  DescReloadT2TimerWithP3maxTime(DESC_CONTEXT_PARAM_VALUE);
  /* Custom management in case of timeout of T2 */
  DescOemOnT2Timeout(DESC_CONTEXT_PARAM_VALUE);
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
  g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE]--;
#endif
#if defined (DESC_ENABLE_ALL_RES_AFTER_RCRRP)
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].rcrRpSent = 1;
#endif
}

#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
/*******************************************************************************
* NAME:              DescGetTesterAddress
*
* CALLED BY:         Application
* PRECONDITIONS: 
*
* DESCRIPTION:       Returns the tester address of the last request.
*******************************************************************************/
vuint8 DESC_API_CALL_TYPE DescGetTesterAddress(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return g_descTesterAddress[DESC_CONTEXT_PARAM_VALUE];
}
#endif

/*******************************************************************************
* NAME:              DescGetCurrentBusInfo
*
* CALLED BY:         Application
* PRECONDITIONS: 
*
* DESCRIPTION:       Returns the current communication parameters.
*******************************************************************************/
t_descUsdtNetBus* DESC_API_CALL_TYPE DescGetCurrentBusInfo (DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return &(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].busInfo);
}

#if defined (DESC_ENABLE_UUDT_NET)
/*******************************************************************************
* NAME:              DescUudtNetFinishTransmission
*
* CALLED BY:         CANdriver
* PRECONDITIONS:     
*
* DESCRIPTION:       Unlocks the buffer for next UUDT to be sent. 
*
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetFinishTransmission(t_descUudtNetInfoPoolPtr infoPool, t_descUudtNetResult status)
{
  /* Dummy assignment to avoid compiler warnings */
  DESC_IGNORE_UNREF_PARAM(status);
  DESC_IGNORE_UNREF_PARAM(infoPool);

# if defined (DESC_ENABLE_SERVICE_A9_81_SUPPORT)
#  if defined(DESC_UUDTNET_ENABLE_MULTI_CLIENT)
  if(infoPool->busInfo.client == kDescClientRdi)
#  endif
  {
    DescRdiUudtConfirmation();
  }
#  if defined (DESC_ENABLE_DEBUG_INTERNAL) && \
      defined (DESC_UUDTNET_ENABLE_MULTI_CLIENT)
  else
  {
    /* the other possible value is RDPI module, no other value is allowed */
    DescAssertInternal((infoPool->busInfo.client == kDescClientScheduler), kDescAssertWrongUudtTransmitterHandle);
  }
#  endif
# endif
}
#endif

/*******************************************************************************
* NAME:              DescOemRxErrorInd
*
* CALLED BY:         DescRxErrorInd
* PRECONDITIONS:     
*
* DESCRIPTION:       Predefined action on RX transmission error. 
*
*******************************************************************************/
static void DescOemRxErrorInd(t_descUsdtNetResult status)
{
  if(status == kDescUsdtNetworkAbort)
  {
    /* Start the VN timer */
    /* To be done */
    g_vnTimer = kDescVnDiagTimerTicks;
  }
}

/*******************************************************************************
* NAME:              DescTimingOnceInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the network subcomponent common data.
*
*******************************************************************************/
static void DescTimingOnceInit(void)
{
  /* Deactivate and reinit the timers */
  /* Clear the flag to avoid one DescTask callcycle time S1 timeout jitter */
#if defined (DESC_ENABLE_S1_ANY_SVC_RELOAD)
  g_descDoReloadS1Timer = kDescFalse;
#endif
  DescStopS1Timer();
}

/*******************************************************************************
* NAME:              DescTimingIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the timing subcomponent context data.
*
*******************************************************************************/
static void DescTimingIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
  DescDeactivateLimiter(DESC_CONTEXT_PARAM_VALUE);
}

#if defined (DESC_ENABLE_FORCE_RCR_RP)
/*******************************************************************************
* NAME:              DescForceRcrRpResponse
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Forces the CANdesc to send immediately a RCR-RP response.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescForceRcrRpResponse(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* Check if allowed such force RCR-RP to be used) 
   * To be able to send RCR-RP teh requested service must be a service which will send a response. */
  DescAssertUser(((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq & g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0), kDescAssertInvalidUsageOfForceRcrRpApi);
  /* Mark that a RCR-RP shall be sent immediately */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpCharged;
}
#endif

/*******************************************************************************
* NAME:              DescActivateS1Timer
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       External activation of the S1 timer. 
*
*******************************************************************************/
void DescActivateS1Timer(void)
{
  DescStartS1Timer();
}

/*******************************************************************************
* NAME:              DescOemS1Timeout
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       In case of S1 timeout specific actions to be done. 
*
*******************************************************************************/
static void DescOemS1Timeout(void)
{
  /* Check if already in programming mode 
   * if so - don't send any response 
   */
#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
  if(0 == (g_descCurState.stateProgrammingMode & kDescStateProgrammingModeActive))
#endif
  {/* Send the DiagResponse with ResID $60 */
    DescTransmitSingleFrame(&g_descResSidStopSession,1);
  }
  DescOemOnStopSession();
}

#if defined (DESC_ENABLE_SERVICE_A9_SUPPORT) || \
    defined (DESC_ENABLE_SCHEDULED)
/*******************************************************************************
* NAME:              DescOemStateTask
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Additional timers could be added here.
*
*******************************************************************************/
static void DescOemStateTask(void)
{
# if defined (DESC_ENABLE_SERVICE_A9_SUPPORT)
  /* call the AA and A9 service managers */
  /* First must be the RDI task to be able to send a message during scheduled DPIDs */
  DescRdiStateTask();
# endif
# if defined (DESC_ENABLE_SCHEDULED)
  DescRdpiStateTask();
# endif
}
#endif

/*******************************************************************************
* NAME:              DescOemTimer
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Additional timers could be added here.
*
*******************************************************************************/
static void DescOemTimer(void)
{
  /* --------------------------------------------------------*/
  /* VN Timeout ---------------------------------------------*/
  /* --------------------------------------------------------*/
  DescInterruptDisable();
  if(g_vnTimer != 0)
  {
    g_vnTimer--;
    if(g_vnTimer == 0)
    {
      /* deactivate the Diagnostic VN for GM when the VN timeout occurs */
      DescSetDiagInactive();
    }
  }
  DescInterruptRestore();

#if defined (DESC_ENABLE_SCHEDULED)
  DescRdpiTimerTask();
#endif
}

/*******************************************************************************
* NAME:              DescStateOnceInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the state subcomponent common data.
*
*******************************************************************************/
static void DescStateOnceInit(void)
{
  DescStateInit();
}

void DESC_API_CALL_TYPE DescStateInit(void)
{
  g_descCurState.stateSecurity_Access = kDescStateSecurity_AccessLock_SPS;
  g_descCurState.stateProgrammingMode = kDescStateProgrammingModeNormal;
}


DescStateGroup DESC_API_CALL_TYPE DescGetStateSecurity_Access(void)
{
  return g_descCurState.stateSecurity_Access;
}


void DESC_API_CALL_TYPE DescSetStateSecurity_Access(DescStateGroup descState)
{
  /* The new state shall not be zero */
  DescAssertCommon((descState != 0), kDescAssertZeroStateValue);
  DescOemOnTransitionSecurity_Access(descState, g_descCurState.stateSecurity_Access);
  ApplDescOnTransitionSecurity_Access(descState, g_descCurState.stateSecurity_Access);
  g_descCurState.stateSecurity_Access = CANBITTYPE_CAST descState;
}


DescStateGroup DESC_API_CALL_TYPE DescGetStateProgrammingMode(void)
{
  return g_descCurState.stateProgrammingMode;
}


void DESC_API_CALL_TYPE DescSetStateProgrammingMode(DescStateGroup descState)
{
  /* The new state shall not be zero */
  DescAssertCommon((descState != 0), kDescAssertZeroStateValue);
  DescOemOnTransitionProgrammingMode(descState, g_descCurState.stateProgrammingMode);
  ApplDescOnTransitionProgrammingMode(descState, g_descCurState.stateProgrammingMode);
  g_descCurState.stateProgrammingMode = CANBITTYPE_CAST descState;
}


static DescNegResCode DescCheckState(V_MEMROM1 DescStateInfo V_MEMROM2 V_MEMROM3* refState)
{
  if((refState->stateSecurity_Access & g_descCurState.stateSecurity_Access) == 0)
  {
    return kDescNrcRejectStateSecurity_Access;
  }
  if((refState->stateProgrammingMode & g_descCurState.stateProgrammingMode) == 0)
  {
    return kDescNrcRejectStateProgrammingMode;
  }
  return kDescNrcNone;
}


static void DescSetState(DescSvcInstIndex svcInstHandle)
{
  V_MEMROM1 DescStateInfo V_MEMROM2 V_MEMROM3* curRefState;
  if(g_descSvcInst[svcInstHandle].setStateIndex != kDescStateNoTransition)
  {
    curRefState = &g_descStateGroupTransition[g_descSvcInst[svcInstHandle].setStateIndex][0];
    DescInterruptDisable();
    if((g_descCurState.stateSecurity_Access & curRefState->stateSecurity_Access) != 0)
    {
      DescSetStateSecurity_Access((curRefState+1)->stateSecurity_Access);
    }
    if((g_descCurState.stateProgrammingMode & curRefState->stateProgrammingMode) != 0)
    {
      DescSetStateProgrammingMode((curRefState+1)->stateProgrammingMode);
    }
    DescInterruptRestore();
  }
}


/*******************************************************************************
* NAME:              DescOnDisableNormalComm
*
* CALLED BY:         DESC
* PRECONDITIONS:     
*
* DESCRIPTION:       Central communication disable handling
*
*******************************************************************************/
static void  DescOnDisableNormalComm(void)
{
  /* Notify the application */
  ApplDescOnDisableNormalComm();
  /* activate timer monitoring */
  DescStartS1Timer();
}

#if defined(DESC_ENABLE_QNX_CONTEXT_SWITCH)
/*******************************************************************************
* NAME:              DescSetCommState
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Sets the new communication state. 
*
*******************************************************************************/
void DescSetCommState(DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_FIRST vuint8 state)
{
# if (TP_USE_DYN_ID == kTpOn)
#  if (TP_USE_NORMAL_ADDRESSING == kTpOn)
  TpTxSetChannelID(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE], DIAG_TRANSMIT_ID, DIAG_RECEIVE_ID);
#   if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
#    if (kTpNumberOfCanChannels > 1)
#     if defined(DESC_ENABLE_MULTI_TP)
  TpTxSetCanChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE], DESC_COMM_CHANNEL_PARAM_VALUE);
#     else
  TpTxSetCanChannel(DESC_COMM_CHANNEL_PARAM_VALUE);
#     endif
#    endif
#   endif
#  endif
# endif
# if defined (DESC_ENABLE_MULTI_TP)
#  if defined (TP_ENABLE_MULTIPLE_ADDRESSING)
  TpTxSetAddressingFormat(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE], kTpNormalAddressing);
#  endif
# endif

# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
  g_descOemStateCtrl.canChannel = DESC_COMM_CHANNEL_PARAM_VALUE;
# endif

  if((state & kDescCommDisabled) != 0)
  {
# if defined (NM_TYPE_GMLAN)
    Nm_Status result = DescNmSetCommHalted(g_descOemStateCtrl.canChannel);
    if(result == NM_OK)
# else /* IVLAN or NM_BASIC */
    DescNmSetCommHalted(g_descOemStateCtrl.canChannel);
# endif
    {
      DescOnDisableNormalComm();
    }

    /* Do only initialize desc state, do not re-create the transitions to get there.
     * Therefore the state variable is set explicitely instead of calling SetStateProgrammingMode()
     */
    if ((g_descCurState.stateProgrammingMode & kDescStateProgrammingModeNormal) != 0)
    { /* Just make sure not to overwrite the state, in case the Set-APIs are not called in sequence */
      g_descCurState.stateProgrammingMode = kDescStateProgrammingModeCommHalted;
    }
  }
}
#endif

#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
# if defined(DESC_ENABLE_QNX_CONTEXT_SWITCH)
/*******************************************************************************
* NAME:              DescSetProgMode
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Sets the new programming state. 
*
*******************************************************************************/
void DescSetProgMode(vuint8 state)
{
  /* If not idle - start S1 timer */
  if((state & kDescProgModeIdle) == 0)
  {
    /* activate timer monitoring */
    DescStartS1Timer();

    /* Do only initialize desc state, do not re-create the transitions to get there.
     * Therefore the state variable is set explicitely instead of calling SetStateProgrammingMode()
     */

    /* calculate the current state of the programming sequence */
    if ((state & kDescProgModeActive) != 0)
    {
      g_descCurState.stateProgrammingMode = kDescStateProgrammingModeActive;
    }
    else if ( ((state & kDescProgModeAccepted) != 0)
#  if defined (DESC_ENABLE_REQ_HISPEED_PROG)
           && ((g_descCurState.stateProgrammingMode & kDescStateProgrammingModeRequested_HiSpeed) == 0)
#  endif
            )
    { /* HiSpeed is evaluated separately, so assume low speed if not already set */
      g_descCurState.stateProgrammingMode = kDescStateProgrammingModeRequested;
    }
    else
    { /* satisfy MISRA */
    }
  }
}
# endif
#endif

#if defined(DESC_ENABLE_QNX_CONTEXT_SWITCH)
# if defined (DESC_ENABLE_REQ_HISPEED_PROG)
/*******************************************************************************
* NAME:              DescSetHiSpeedMode
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Sets the new hi-speed programming state. 
*
*******************************************************************************/
void DescSetHiSpeedMode(vuint8 state)
{
  /* If not idle - start S1 timer */
  if((state & kDescHiSpeedModeIdle) != 0)
  {
    /* activate timer monitoring */
    DescStartS1Timer();

    /* Do only initialize desc state, do not re-create the transitions to get there.
     * Therefore the state variable is set explicitely instead of calling SetStateProgrammingMode()
     */

    if ((state & kDescHiSpeedModeActive) != 0)
    { /* if hispeed is activated, the programming sequence was completed */
      g_descCurState.stateProgrammingMode = kDescStateProgrammingModeActive;
    }
    else if ( ((state & kDescHiSpeedModeAccepted) != 0)
           && ((g_descCurState.stateProgrammingMode & kDescStateProgrammingModeRequested) == 0) )
    { /* Probably SetHiSpeedMode will not set up to 'accepted' in case A5 03 was already done,
         but we make sure anyways since it is an external API. */
      g_descCurState.stateProgrammingMode = kDescStateProgrammingModeRequested_HiSpeed;
    }
    else
    { /* satisfy MISRA */
    }
  }
}
# endif
#endif

/*******************************************************************************
* NAME:              DescGetCommState
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns the current communication state. 
*
*******************************************************************************/
vuint8 DescGetCommState(void)
{
  return (vuint8)(((g_descCurState.stateProgrammingMode & kDescStateProgrammingModeNormal) != 0)?kDescCommEnabled:kDescCommDisabled);
}

#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
/*******************************************************************************
* NAME:              DescGetProgMode
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns the current programming mode state. 
*
*******************************************************************************/
vuint8 DescGetProgMode(void)
{
  vuint8 result = kDescProgModeAccepted;
  if ((g_descCurState.stateProgrammingMode & kDescStateProgrammingModeActive) != 0)
  {
    result = kDescProgModeActive;
  }
  else if ((g_descCurState.stateProgrammingMode & ((DescStateGroup)(kDescStateProgrammingModeNormal|kDescStateProgrammingModeCommHalted))) != 0)
  {
    result = kDescProgModeIdle;
  }
  else
  {
    /* satisfy MISRA */
  }
  return result;
}
#endif

#if defined (DESC_ENABLE_REQ_HISPEED_PROG)
/*******************************************************************************
* NAME:              DescGetHiSpeedMode
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns the current hi-speed mode state. 
*
*******************************************************************************/
vuint8 DescGetHiSpeedMode(DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_ONLY)
{
  vuint8 result = kDescHiSpeedModeIdle;
  if ( (0 != (g_descCurState.stateProgrammingMode & kDescStateProgrammingModeActive))
    && (0 != IlNwmStateHispeedMode(IlNwmGetStatus(DESC_COMM_CHANNEL_PARAM_ONLY))) )
  {
    result = kDescHiSpeedModeActive;
  }
  else if ((g_descCurState.stateProgrammingMode & kDescStateProgrammingModeRequested_HiSpeed) != 0)
  {
    result = kDescHiSpeedModeAccepted;
  }
  else
  {
    /* satisfy MISRA */
  }
  return result;
}
#endif

/*******************************************************************************
* NAME:              DescOemOnStopSession
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Common action when the diagnostic session is stopped.
*
*******************************************************************************/
static void DescOemOnStopSession(void)
{
  /* Stop and prepare for next usage of Tester present timer */
  DescStopS1Timer();
  /* Start the VN timer */
  g_vnTimer = kDescVnDiagTimerTicks;

  DescNmReturnToNormalMode(g_descOemStateCtrl.canChannel);

  /* Notify the application */
  ApplDescOnEnableNormalComm();
#if defined (DESC_ENABLE_SCHEDULED)
  /* initialize the RDPI service ($AA) */
  DescRdpiStopAll();
#endif

#if defined (DESC_ENABLE_SERVICE_A9_82_SUPPORT)
  /* deactivate the $A9 $82 service */
  DescRdiDeactivateOnChangeDtcCount();
#endif
  ApplDescOnReturnToNormalMode();

#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
  /* If return to normal mode from Programming stat - make ECU reset */
  if((g_descCurState.stateProgrammingMode & kDescStateProgrammingModeActive) != 0)
  {
    /* make it as last in case of application delay (up to 150ms) 
     * Shall be used as a immediate RESET or event if the application 
     * has something to save 
     */
    ApplDescForceEcuReset();
  }
#endif
}

/*******************************************************************************
* NAME:              DescSetDiagInactive
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Common action when the diagnostic session is stopped.
*
*******************************************************************************/
static void DescSetDiagInactive(void)
{
  /* protected from incomming request inconsistent reading/writing 
  * before the call (refer DescOemTimer and DescOemOnStopSession)*/
  if(g_descOemStateCtrl.isCanActive == 1)
  {
    /* reset the flag because the CAN comm is inactive */
    g_descOemStateCtrl.isCanActive = 0;

    DescNmDeactivateVN(g_descOemStateCtrl.canChannel);

    /* Notify the application */
    ApplDescOnDiagInactive();
  }
}
/*******************************************************************************
* NAME:              DescSetDiagActive
*
* CALLED BY:         Network Layer
* PRECONDITIONS:     
*
* DESCRIPTION:       Common action when the diagnostic request comes.
*
*******************************************************************************/
static void DescSetDiagActive(t_descUsdtNetInfoPoolPtr infoPool)
{
  DESC_IGNORE_UNREF_PARAM(infoPool);

  /* Stop the VN timer */
  g_vnTimer = 0;
  if(g_descOemStateCtrl.isCanActive == 0)
  {
    /* set the flag that the CAN comm is active */
    g_descOemStateCtrl.isCanActive = 1;
#if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
    /* Use only the first activated VN on the CAN */
    g_descOemStateCtrl.canChannel = infoPool->busInfo.comChannel;
#endif
    DescNmActivateVN(g_descOemStateCtrl.canChannel);

    ApplDescOnDiagActive();
  }
}

#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
/*******************************************************************************
* NAME:              DescStartRepeatedServiceCall
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Enables the multicall feature for the current service.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescStartRepeatedServiceCall(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescMainHandler mainHandler)
{
  /* Initialize the required function handler */
  g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE] = mainHandler;
}
#endif

/*******************************************************************************
* NAME:              DescSetNegResponse
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Sets the error.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescSetNegResponse(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescNegResCode errorCode)
{
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* Ignore setting an error if already set */
  if (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
  {
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = errorCode;
  }
}

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
/******************************************************************************
* NAME:              DescGetSvcInstHeadExtEntrySize
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
static vuint8_least DescGetSvcInstHeadExtEntrySize(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead)
{
  return (vuint8_least)((pSvcHead->isReqHeadExtEchoed != 0)?
                  (pSvcHead->reqHeadExLen):(pSvcHead->reqHeadExLen + pSvcHead->resHeadExLen));
}
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
/******************************************************************************
* NAME:              DescGetSvcInstResHeadExt
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
# if defined(C_COMP_NEC_78K0_AFCAN)
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# else
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# endif
{
  vuint8_least offset = 0;
  if(pSvcHead->isReqHeadExtEchoed == 0)
  {
    offset = pSvcHead->reqHeadExLen;
  }
  return (DescGetSvcInstReqHeadExt(pSvcHead, svcInstAbsRef) + offset);
}
#endif

#if defined (DESC_ENABLE_SUB_SVC_USAGE)
/******************************************************************************
* NAME:              DescGetSvcInstReqHeadExt
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
# if defined(C_COMP_NEC_78K0_AFCAN)
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# else
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# endif
{
  vuint16_least offset = DescGetSvcInstHeadExtEntrySize(pSvcHead);
  offset *= (vuint16)(svcInstAbsRef - pSvcHead->svcInstFirstItem);

  return &g_descSvcInstHeadExt[pSvcHead->svcInstHeadExtFirstItem + offset];
}
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# if defined(DESC_ENABLE_BINARY_SVCINST_SEARCH)
/******************************************************************************
* NAME:              DescFindSvcInst
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
static DescSvcInstIndex DescFindSvcInst(DescConstPtr reqHeadPtr, V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, vuint8_least* failedByteMask)
{
  V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * headEx;
  DescSvcInstIndex        loIdx;
  DescSvcInstIndex        hiIdx;
  DescSvcInstIndex        idx;
  DescSvcInstIndex        reqSvcInstHandle;
  vuint8_least            currColFound;
  DescBool                isEqual;

  loIdx = pSvcHead->svcInstFirstItem;
  /* Calculate search elements */
  hiIdx = (DescSvcInstIndex)((pSvcHead + 1)->svcInstFirstItem - 1);

  /* Mark subserviceInstance handle as invalid */
  reqSvcInstHandle = kDescInvalidSvcInstHandle;

  /* No error still found */
  *failedByteMask = 0;
  do
  {
    /* Examine one concrete serviceInstanceHeader */
    /* ------------------------------------------ */
    idx = (DescSvcInstIndex)(((vuint16)((vuint16)hiIdx + (vuint16)loIdx)) >> 1);

    headEx = DescGetSvcInstReqHeadExt(pSvcHead, idx);
    currColFound = 0;

    do
    {
      isEqual = V_BOOL_EXPR(reqHeadPtr[currColFound] == headEx[currColFound]);
      currColFound++;
    }
    while((currColFound < pSvcHead->reqHeadExLen)&&(isEqual != kDescFalse));

    if(isEqual != kDescFalse)
    {
#  if defined (DESC_ENABLE_MULTI_VARIANT)
      /*Check if it is allowed in the actual configuration*/
      if(DescPermittedInConfig(g_descSvcInst[idx].variantMask) != 0)
#  endif
      {
        reqSvcInstHandle = idx;
      }
      break;
    }
    else
    {
      /* Compensate post increment */
      currColFound--;
      /* Check for deepest error column */
      if(currColFound > *failedByteMask)
      {
        *failedByteMask = currColFound;
      }
      /* Determine which half shall be taken */
      if (reqHeadPtr[currColFound] < headEx[currColFound])
      {
        /* Avoid signed types */
        if(idx == 0)
        {
          break;
        }
        hiIdx = (DescSvcInstIndex)(idx - 1);
      }
      else
      {
        /* Message 'greater' than service instance: Use upper half of interval... */
        loIdx = (DescSvcInstIndex)(idx + 1);
      }
    }
  }
  while (loIdx <= hiIdx);
  /* Use 0x02, to skip the SID bit */
  *failedByteMask = (vuint8)(0x02 << *failedByteMask);
  /* return the search result 
   * place the error column number in the last 3 bits */
  return reqSvcInstHandle;
}
# endif
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# if defined(DESC_ENABLE_LINEAR_SVCINST_SEARCH)
/******************************************************************************
* NAME:              DescFindSvcInst
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Linear search for service instance.
*
*******************************************************************************/
static DescSvcInstIndex DescFindSvcInst(DescConstPtr reqHeadPtr, V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, vuint8_least* failedByteMask)
{
  DescSvcInstHeadExtIndex iter;
  DescSvcInstIndex        reqSvcInstHandle;
  DescSvcInstIndex        offset;
  vuint8_least            currColFound;
  vuint8_least            incStep;
  DescBool                isEqual;


  incStep = DescGetSvcInstHeadExtEntrySize(pSvcHead);

  /* Mark subserviceInstance handle as invalid */
  reqSvcInstHandle = kDescInvalidSvcInstHandle;
  /* No error still found */
  *failedByteMask = 0;
  offset = 0;

  for(iter = pSvcHead->svcInstHeadExtFirstItem;
      iter < (pSvcHead + 1)->svcInstHeadExtFirstItem;
      iter+= incStep)
  {
    currColFound = 0;
    do
    {
      isEqual = V_BOOL_EXPR(reqHeadPtr[currColFound] == g_descSvcInstHeadExt[iter + currColFound]);
      currColFound++;
    }
    while ((currColFound < pSvcHead->reqHeadExLen)&&(isEqual != kDescFalse));


    if(isEqual != kDescFalse)
    {
      reqSvcInstHandle = (DescSvcInstIndex)(offset + pSvcHead->svcInstFirstItem);
#  if defined (DESC_ENABLE_MULTI_VARIANT)
       /*Check if it is allowed in the actual configuration*/
      if(DescPermittedInConfig(g_descSvcInst[reqSvcInstHandle].variantMask) == 0)
      {
        reqSvcInstHandle = kDescInvalidSvcInstHandle;
      }
#  endif
      break;
    }
    else
    {
      /* Compensate post increment */
      currColFound--;
      /* Check for deepest error column */
      if(currColFound > *failedByteMask)
      {
        /* Use 0x02, to skip the SID bit */
        *failedByteMask = currColFound;
      }
      /* Check if it makes sense to continue the search */
      if(reqHeadPtr[currColFound] < g_descSvcInstHeadExt[iter + currColFound])
      {
        /* That was it */
        break;
      }
    }
    /* Increment the reference */
    offset++;
  }

  /* Use 0x02, to skip the SID bit */
  *failedByteMask = (vuint8)(0x02 << *failedByteMask);
  return reqSvcInstHandle;
}
# endif
#endif

/******************************************************************************
* NAME:              DescFindSvc
*
* CALLED BY:         Dispatcher,FuncReception
* PRECONDITIONS:     
*
* DESCRIPTION:       Search a service ID.
*
*******************************************************************************/
static DescSvcHeadIndex DescFindSvc(DescMsgItem reqSvcId)
{
  DescSvcHeadIndex result  = kDescInvalidSvcHandle;
  vuint8_least     byteVar = 0;

  /* check if it is in the correct range (0x00-0x3f or 0x80-bf => bit2 must be 0) */
  /* check if it is not bigger that the maximum defined SID */
  if (((reqSvcId & kDescPosResIdOffset) == 0)&&
       (reqSvcId <= kDescMaxReqSid))
  {
    /* find in which response range is the request. */
    if ((reqSvcId & 0x80) != 0)
    {
      byteVar = kDescPosResIdOffset;
    }
    result = g_descSidMap[reqSvcId - byteVar];
  }


#if defined (DESC_ENABLE_MULTI_VARIANT) || \
    defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
  if(result < kDescInvalidSvcHandle)
  {
# if defined (DESC_ENABLE_MULTI_VARIANT)
    /*Check if it is allowed in the actual configuration*/
    if(DescPermittedInConfig(g_descSvcHead[result].variantMask) == 0)
    {
      result = kDescInvalidSvcHandle;
    }
# endif
  }
  else
  {
# if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
    /* Check if the application can recognize the SID */
    if(ApplDescCheckUserService(reqSvcId) == kDescOk)
    {
      /* The last service is the generic user one */
      result = (DescSvcHeadIndex)(kDescSvcHeadNumItems - 1);
    }
# endif
  }
#endif
  return result;
}

#if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
/******************************************************************************
* NAME:              DescGetServiceId
*
* CALLED BY:         Application user service
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns the current request's SId.
*
*******************************************************************************/
DescMsgItem DESC_API_CALL_TYPE DescGetServiceId(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
# if defined(DESC_ENABLE_GENERIC_USER_POST_HANDLER_SUPPORT)
  /* Service Id can be reported only if not receive was active (post-handler are called in Idle mode) 
   * Removed since the condition is incomplete - if between the call of DescProcessingDOne and the PosHandler excution a new service will be requested,
   * it is still possible to evaluate the SID but the activity is set to ActiveRx.
   */
  /* DescAssertUser((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity != kDescContextActiveRx), kDescAssertNoSidCanBeReportedInIdleMode);*/
  /* Take from the backup */
  return g_descUserSIdBackup[DESC_CONTEXT_PARAM_VALUE];
# else
  /* Service Id can be reported only during request processing */
  DescAssertUser((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveProcess), kDescAssertNoSidCanBeReportedInIdleMode);
  /* Take from the current buffer */
  return g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr[0];
# endif
}
#endif

/*******************************************************************************
* NAME:              DescDispatcherIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the dispatcher subcomponent context specific data.
*
*******************************************************************************/
static void DescDispatcherIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
  /* Clear the multicall function pointer */
  g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE] = V_NULL;
#endif
#if (kDescNumContexts > 1)
  /* Init the context reference */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].iContext = DESC_CONTEXT_PARAM_VALUE;
#endif
  /* init unused parameter */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes = 0;
  /* Delete the error registers */
  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcNone;
#if defined (DESC_ENABLE_EXT_NEG_RES_CODE_HANDLING)
  g_descExtNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescExtNrcNone;
#endif
}

#if defined (DESC_ENABLE_EXT_NEG_RES_CODE_HANDLING)
/*******************************************************************************
* NAME:              DescSetExtNegResponse
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Sets the additional error codes (GM).
*
*******************************************************************************/
void DescSetExtNegResponse(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescNegResCode errorCode, DescExtNegResCode  extErrorCode)
{
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* Ignore setting an error if already set 
   * this check is for both normal and extended double setting */
  if (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
  {
    g_descExtNegResCode[DESC_CONTEXT_PARAM_VALUE] = extErrorCode;
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = errorCode;
  }
}
#endif


/*******************************************************************************
* NAME:              DescDispatcher
*
* CALLED BY:         DescTask
* PRECONDITIONS:     If there is at least one received request.
*
* DESCRIPTION:       Provides the kernel of the diagnostic
*
*******************************************************************************/
static void DescDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Code optimization */
  DescMsg msg;

  msg = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;
#if defined(DESC_ENABLE_GENERIC_USER_POST_HANDLER_SUPPORT)
  /* Store the SId for the case it is user SId */
  g_descUserSIdBackup[DESC_CONTEXT_PARAM_VALUE] = msg[0];
#endif
  /* Encapsulate the error handling for distinguishing if the PostHAndler has to
   * be called in error cases, handled by CANdesc 
   */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError = 0;
  /* Set default response on request type (phys - yes, func - no) */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = kDescDefaultResOnReq;

  /*---------------------------------------------*/
  /*      The length of the request must be at   */
  /*    least enought to contain the SID         */
  /*---------------------------------------------*/
  if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen != 0)
  {
    /*---------------------------------------------*/
    /*              Search service ID              */
    /*---------------------------------------------*/
    /* If service not supported */
    /* -------------------------*/
    g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE] = DescFindSvc(msg[0]);
    if(g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE] < kDescInvalidSvcHandle)
    {
      V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * refDescSvcHead;

      refDescSvcHead = &g_descSvcHead[g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE]];

      /* -------------------------------------*/
      /* Set the Svc default addressing type  */
      /* -------------------------------------*/
      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = refDescSvcHead->resOnReq;

      /*---------------------------------------------*/
      /*             Service related checks          */
      /*---------------------------------------------*/
      /*---------------------------------------------*/
      /*              Acceptable request type        */
      /*---------------------------------------------*/
      /* If service is not supported in the requested type - exit */
      if ((refDescSvcHead->reqType &
         g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType ) != 0)
      {
#if defined (DESC_ENABLE_SESSION_CHECK_ON_SID_LEVEL) && (kDescNumStateSession > 0)
        /*------------------------------------*/
        /*     Service ID session check       */
        /*------------------------------------*/
        if ((refDescSvcHead->checkSessionState & g_descCurState.stateSession) != 0)
#endif
        {
          /*---------------------------------------------*/
          /*      The length of the request must be at   */
          /*    least the length of the requests header  */
          /*---------------------------------------------*/
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          /* increment by 1 to include the SID byte also in the length of the header */
          if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen >= (refDescSvcHead->reqHeadExLen + 1))
#endif
          {
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
            vuint8_least svcInstFailedBytePosMask = 0;
#endif
            /*The SID is not more from relevance */
            msg++;
            /*---------------------------------------------*/
            /*              Search service instance        */
            /*---------------------------------------------*/
            /* if at least one instance is defined - check if it is valid */
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
            if(refDescSvcHead->reqHeadExLen != 0)
            {
              g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE] = (DescMemSvcInstIndex)DescFindSvcInst(msg, refDescSvcHead, &svcInstFailedBytePosMask);
            }
            else
#endif
            {
              g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE] = refDescSvcHead->svcInstFirstItem;
            }
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
            if(g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE] < kDescInvalidSvcInstHandle)
#endif
            {
              V_MEMROM1 DescSvcInst V_MEMROM2 V_MEMROM3 * refDescSvcInst;

              refDescSvcInst = &g_descSvcInst[g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]];

              /* -------------------------------------------------------*/
              /* Set the SvcInst default state for the response sending */
              /* -------------------------------------------------------*/
              g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = refDescSvcInst->msgAddInfo.resOnReq;

              /*---------------------------------------------*/
              /*  Service instance addressing method check   */
              /*---------------------------------------------*/
              if ((refDescSvcInst->msgAddInfo.reqType &
                   g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
              {
                /*---------------------------------------------*/
                /*      Service instance related checks        */
                /*---------------------------------------------*/
                /* Request length (top limit) check */

                /* If the table stored length is not zero - 
                check it for matching with the request length */
                if((refDescSvcInst->reqLen == 0) ||
                   (refDescSvcInst->reqLen == g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen))
                {
#if defined (DESC_ENABLE_AUTO_STATES)
                  /* Generated state checks */
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = DescCheckState(&(refDescSvcInst->checkState));

                  /* If any error was detected - go out */
                  if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
                  {
                    /* Release the PostHandler call feature */
                    g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError = 1;

#if defined (DESC_ENABLE_PREHANDLER_USAGE)
                    /*---------------------------------------------*/
                    /*    Application specific condition check     */
                    /*---------------------------------------------*/
                    /* Call the pre handler */
                    g_descPreHandlerTable[refDescSvcInst->preHandlerRef](DESC_CONTEXT_PARAM_ONLY);
                    /* If any error was detected - go out */
                    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
                    {
                      /* Prepare the application information */
                      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData    = (DescMsg)(msg + DescExtractReqExtHeadLen(refDescSvcHead->reqHeadExLen));
                      /* This is the extension of the response header (the header without the resposne SID), so for the complete length - add 1 */
                      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resData    = (DescMsg)(msg + DescExtractResExtHeadLen(refDescSvcHead->resHeadExLen));
                      /* The length contains up to now the whole request length, so just substract the header length */
                      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen -= (DescMsgLen)(DescExtractReqExtHeadLen(refDescSvcHead->reqHeadExLen) + 1);
                      /* Zero the response length - optimization for no data responses */
                      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = 0;

                      /*-------------------------*/
                      /*  P2 timer management    */
                      /*-------------------------*/
                      if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq &
                          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
                      {
                        /* Start the timer for the response only if the request 
                         * by default was configured to sent response 
                         * (the tester will await any response by default)
                         */
                        DescActivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
                        DescActivateLimiter(DESC_CONTEXT_PARAM_VALUE);
                      }
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
                      /* Activate the multicall mechanism */
                      _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, refDescSvcInst->mainHandler);
#endif

                      /*---------------------------------------------*/
                      /*      Call the main handler function         */
                      /*---------------------------------------------*/
                      refDescSvcInst->mainHandler(&g_descMsgContext[DESC_CONTEXT_PARAM_VALUE]);

                      DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts), kDescAssertInvalidContextId);
                      /* The iContext field exists only in multi context configuration */
                      DescAssertContext((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].iContext == DESC_CONTEXT_PARAM_VALUE), kDescAssertContextIdWasModified);
                      /* Skip the processing done call - let the application decide when */
                      return;
                    }
                  }
#if defined (DESC_ENABLE_AUTO_STATES)
                  else
                  {
# if defined (DESC_ENABLE_NRC_SUBFUNCTION_WRONG_SESSION)
                    /* Correct the negative response code dependent on the sub-function instantiation */
                    if((g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcServiceNotSupportedInActiveMode)
                      &&(refDescSvcHead->hasSubFunction != 0))
                    {
                      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcSubfunctionNotSupportedInActiveSession;
                    }
# endif
                    /* EXAMPLE: Additional activities may be necessary */
                    DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
                    DescOemOnInvalidEcuState(DESC_CONTEXT_PARAM_VALUE);
                  }
#endif
                }
                else
                {
                  /* EXAMPLE(not used): Additional activities may be necessary */
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcReqLengthNotMatched;
                  DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
                  DescOemOnReqLengthNotMatched(DESC_CONTEXT_PARAM_VALUE);
                }
              }
              else
              {
                g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
                /* EXAMPLE: Additional activities may be necessary */
                DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
                DescOemOnInvalidAddrMethod(DESC_CONTEXT_PARAM_VALUE);
              }
            }
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
            else
            {
              /* Check which negative response shall be send (UnexpectedId/UnexpectedSubFunction)*/
              /*lint -e{644} (PClint can not know that this code will be reached only if the service is not found, and the variable is always initialized with 0)*/
              if((vuintx)(refDescSvcHead->reqHeadByteSpec & svcInstFailedBytePosMask) != (vuintx)0)
              {
                g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcUnexpectedId;
              }
              else
              {
                g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcUnexpectedSubFunction;
              }

              /* Could be used in case when the instance is not found special init to be done*/
              DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
              DescOemOnSvcInstNotFound(DESC_CONTEXT_PARAM_VALUE);
            }
#endif
          }
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          else
          {
            g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcReqLengthNotMatched;
            /* EXAMPLE: Additional activities my be necessary */
            DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
            DescOemOnReqLengthTooSmall(DESC_CONTEXT_PARAM_VALUE);
          }
#endif
        }
#if defined (DESC_ENABLE_SESSION_CHECK_ON_SID_LEVEL) && (kDescNumStateSession > 0)
        else
        {
          g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcSessionNotMatched;
          /* EXAMPLE: Additional activities may be necessary */
          DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
          DescOemOnInvalidSidSession(DESC_CONTEXT_PARAM_VALUE);
        }
#endif
      }
      else
      {
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
        /* EXAMPLE: Additional activities my be necessary */
        DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
        DescOemOnInvalidAddrMethod(DESC_CONTEXT_PARAM_VALUE);
      }
    }
    else
    {
      /* Could be used in case when the service is not found special init to be done*/
      DescOemOnSvcNotFound(DESC_CONTEXT_PARAM_VALUE);
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcSvcNotFound;
    }
  }
  else
  {
    /* Set any error type (no real response will be sent so never mind what error it is) */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = (DescNegResCode)(~kDescNrcNone);
    /* no response must be sent */
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = 0;
  }

  /* flush the current request */
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}

#if defined (DESC_ENABLE_PID_LIST_MODE)
/*******************************************************************************
* NAME:              DescProcessingDone
*
* CALLED BY:         Dispatch,  any application function
* PRECONDITIONS: 
*
* DESCRIPTION:       Depending on the current situation, provides the right 
*                    action. 
*******************************************************************************/
void DESC_API_CALL_TYPE DescProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  switch(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode)
  {
    case kDescContextModeNormal:
      /* Finalize the request processing */
      DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
    case kDescContextModePidList:
      /* Current Pid list process finalization */
      DescPidProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
    default:
      /* Unknown context mode */
      DescAssertCommonAlways(kDescAssertInvalidContextMode);
      break;
  }
}
#endif

/*******************************************************************************
* NAME:              DescProcessingDone
*
* CALLED BY:         Dispatch,  any application function
* PRECONDITIONS: 
*
* DESCRIPTION:       Depending on the current situation, provides the right 
*                    action. 
*******************************************************************************/
#if defined (DESC_ENABLE_PID_LIST_MODE)
static void DescFinalProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
#else
void DescProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
#endif
{
  DescMsg       msg;
  /* temporary variable to avoid multiple calculations of the FOR's end condition*/
  vuint8_least  resHeadLen;

  /* check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* check for correct time point of function call */
  DescAssertCommon((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveProcess),
                   kDescAssertProcessingDoneCallAfterResFlushing);
  /* Make processing done safe */
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveProcess)
  {
#if defined (DESC_ENABLE_PID_LIST_MODE)
    /* Set the CANdesc in a normal mode */
    g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;
#endif

    /* Specific actions which will be performed each time processing done with real response is called (timer management) */
    DescOemOnProcessingDone(DESC_CONTEXT_PARAM_VALUE);

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL) && \
    defined (DESC_ENABLE_RES_RINGBUFFER)
    /* If no ring buffer currently in use - stop multiple calls */
    if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0)
#endif
    {
      /* Deactivate the multicall mechanism */
      _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
    }

    /* Check if there will be a real response onto the bus */
    if ((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq &
         g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) !=0 )
    {
      /* Init with the current buffer location */
      msg = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;
      /* if there was an error detection - make negative response */
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
      {
        if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType & kDescFuncReq) != 0)
        {

           /* In case of secured transmission - it is not possible to enter here!!! */
          switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
          {
            case 0x11:/* fall through */
            DESC_OEM_SUPPRESSED_FUNC_NRC
              /* fall through */
              /* Simulate success confirmation */
              DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
              return;/* Leave the function */
            default:break;/* Send negative response onto the comm bus */
          }

#if defined (DESC_ENABLE_OBDII_NR_CONFORMANCE)
          /* Functional OBD requests (Sid =[0x00,...,0x0F]) */
          if(msg[0] < 0x10)
          {
            /* ...may support only NRCs: $21, $22 and $78 */
            switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
            {
              case 0x21:/* Fall through */
              case 0x22:/* Fall through */
              case 0x78:/* Fall through */
                /* These are allowed - continue processing */
                break;
              default:
                /* Simulate success confirmation */
                DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
                return;
            }
          }
#endif
        }

        msg[1] = msg[0]; /* Copy the SID */
        msg[0] = kDescNegResSId;/* Place 0x7F ...*/
        msg[2] = g_descNegResCode[DESC_CONTEXT_PARAM_VALUE];/*... and the current error code*/
#if defined (DESC_ENABLE_EXT_NEG_RES_CODE_HANDLING)
        if (g_descExtNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescExtNrcNone)
        {
          msg[3] = DescGetHiByte(g_descExtNegResCode[DESC_CONTEXT_PARAM_VALUE]);/* Place the HI byte of the error data */
          msg[4] = DescGetLoByte(g_descExtNegResCode[DESC_CONTEXT_PARAM_VALUE]);/* Place the LO byte of the error data */
          /* Clear the ext error for the next time */
          g_descExtNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescExtNrcNone;
          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = (DescMsgLen)(kDescNegResLen + 2);
        }
        else
#endif
        {
          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = kDescNegResLen;
        }
      }
      else
      {
        /* Create response SID */
        msg[0] += kDescPosResIdOffset;

        /* Skip SID */
        msg++;

        /* Fill header of response */
        DescAssertCommon((g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE] < kDescSvcHeadNumItems),kDescAssertSvcTableIndexOutOfRange);
        /* optimize the loop - casting because it is sure that the header length is far below 254 bytes */
        /* This is the extension of the response header (the header without the resposne SID), so for the complete length - add 1 */
        resHeadLen = DescExtractResExtHeadLen((vuint8)g_descSvcHead[g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE]].resHeadExLen);
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
        DescMsgCopyRomToFarRam(msg,
                               DescGetSvcInstResHeadExt(&g_descSvcHead[g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE]],
                                                        g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]),
                               (vuint16)resHeadLen);
#endif
        /* Now consider the SID too */
        resHeadLen++;
        /* Making the total length of the response message 
        * (header + data) This macro is an optimization for adding a value: (X+=Y)*/
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += (DescMsgLen)resHeadLen;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
        /*Set the write pointer for the ring buffer manager (resHeadLen + SIdByte) */
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex =    (DescMsgLen)resHeadLen;
        /* Protocol data are the response head data */
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen = (DescBitType)resHeadLen;
#endif
      }
#if defined (DESC_ENABLE_RES_RINGBUFFER)
      /* Set it for the copyToCan function */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex = 0;
      /* Init RingBuffer controller */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten =0;
      /* Mark that from now on a single response will be sent */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveProcessEnd;

      /* Set the write pointer in case of RingBuffer usage and leave this function */
      if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0)
#endif
      {
#if (kDescNumFuncReqContexts > 0)
        /* No response for the parallel thread */
        DescAssertCommon((DESC_CONTEXT_PARAM_VALUE != kDescSecContext),kDescAssertUnExpectedContextWithResponse);
#endif
        /* Set ready for transmit */
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTxReady;
      }
    }
    else
    {
      /* Simulate success confirmation */
      DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
    }
  }/* ProcessingDone not allowed */
}


/*******************************************************************************
* NAME:              DescDoPostProcessing
*
* CALLED BY:         DescConfirmation, DescProcessingDone
* PRECONDITIONS: 
*
* DESCRIPTION:       Provides finalizing actions
*******************************************************************************/
static void DescDoPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult status)
{
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* Predefined function - must be here, because after that the diag error will be deleted */
  DescOemOnConfirmation(DESC_CONTEXT_PARAM_VALUE, status);

  /* Deactivate the RCR-RP timer (for no response requests) */
  DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
  DescDeactivateLimiter(DESC_CONTEXT_PARAM_VALUE);

  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].txState = status;
  /* Activate the post processing */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActivePostProcess;


  /* Stop calling the application if set (TX error cases) */
  _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);

  /* Release context for next requests */
  DescReleaseContext(DESC_CONTEXT_PARAM_ONLY);
}

/*******************************************************************************
* NAME:              DescOemInvalidSubServiceEvent
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Global error handler.
*
*******************************************************************************/
static void DescOemInvalidSubServiceEvent(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
 if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr[0] == 0xA5)
 {
#if defined (DESC_ENABLE_REQ_HISPEED_PROG)
  if ( (g_descCurState.stateProgrammingMode &
          ((DescStateGroup)(kDescStateProgrammingModeRequested | kDescStateProgrammingModeRequested_HiSpeed))) != 0)
#else
  if ( (g_descCurState.stateProgrammingMode & kDescStateProgrammingModeRequested) != 0)
#endif
  { /* Abort ongoing ProgrammingSequence and fall back to the start */
    DescSetStateProgrammingMode(kDescStateProgrammingModeCommHalted);
  }
  else if ( (g_descCurState.stateProgrammingMode & kDescStateProgrammingModeActive) != 0)
  {
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcConditionsNotCorrect;
  }
 }
}

/*******************************************************************************
* NAME:              DescInitPowerOn
*
* CALLED BY:         Application
* PRECONDITIONS:     On system boot.
*
* DESCRIPTION:       Performs time consuming init/checks of the diag module.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescInitPowerOn(DescInitParam initParam)
{
  /******************************
  Subcomponent once InitPowerOn
  *******************************/
  DescSubcompOnceInitPowerOnDebug();
  DescSubcompOnceInitPowerOnNetwork();
  DescSubcompOnceInitPowerOnTiming();
  DescSubcompOnceInitPowerOnState();
  DescSubcompOnceInitPowerOnDispatcher();
  DescSubcompOnceInitPowerOnController();
  DescSubcompOnceInitPowerOnProcessor();
  DescSubcompOnceInitPowerOnFaultMemory();
  DescSubcompOnceInitPowerOnScheduled();
  DescSubcompOnceInitPowerOnSecurityAccess();
  DescSubcompOnceInitPowerOnPidManager();
  DescSubcompOnceInitPowerOnRidManager();
  DescSubcompOnceInitPowerOnPidListProcessor();
  DescSubcompOnceInitPowerOnDynDefinePid();
  DescSubcompOnceInitPowerOnDynDefineDpid();
  DescSubcompOnceInitPowerOnRoeProcessor();
  DescSubcompOnceInitPowerOnVariantManager();


  /* Generated function - DescInit must be here called because of init parameters */
  DescOemOnPowerOnInit(initParam);
  DescInit(initParam);
}

/*******************************************************************************
* NAME:              DescInit
*
* CALLED BY:         any application function, DescInitPowerOn
* PRECONDITIONS:
*
* DESCRIPTION:       Performs init of the diag module.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescInit(DescInitParam initParam)
{

  DESC_CONTEXT_PARAM_DEF_LOCAL

  /* Parameter may not be used - use dummy assignemt if necessary */
  DESC_IGNORE_UNREF_PARAM(initParam);

  /************************
  Subcomponent once init
  ************************/
  DescSubcompOnceInitDebug();
  DescSubcompOnceInitNetwork();
  DescSubcompOnceInitTiming();
  DescSubcompOnceInitState();
  DescSubcompOnceInitDispatcher();
  DescSubcompOnceInitController();
  DescSubcompOnceInitProcessor();
  DescSubcompOnceInitFaultMemory();
  DescSubcompOnceInitScheduled();
  DescSubcompOnceInitSecurityAccess();
  DescSubcompOnceInitPidManager();
  DescSubcompOnceInitRidManager();
  DescSubcompOnceInitPidListProcessor();
  DescSubcompOnceInitDynDefinePid();
  DescSubcompOnceInitDynDefineDpid();
  DescSubcompOnceInitRoeProcessor();
  DescSubcompOnceInitVariantManager();

#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_VALUE = kDescNumContexts;
  while(DESC_CONTEXT_PARAM_VALUE != 0)
  {
    DESC_CONTEXT_PARAM_ONLY--;
#endif
    /************************
    Subcomponent context init
    ************************/
    DescSubcompIterInitDebug(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitNetwork(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitTiming(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitState(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitDispatcher(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitController(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitProcessor(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitFaultMemory(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitScheduled(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitSecurityAccess(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitPidManager(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitRidManager(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitPidListProcessor(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitDynDefinePid(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitDynDefineDpid(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitRoeProcessor(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitVariantManager(DESC_CONTEXT_PARAM_VALUE);
#if(kDescNumContexts > 1)
  }
#endif
  /* Customized function */
  DescOemOnInit(initParam);
}

/*******************************************************************************
* NAME:              DescTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescTask(void)
{
  DescStateTask();
  DescTimerTask();
}

/*******************************************************************************
* NAME:              DescTimerTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescTimerTask(void)
{
  /*----------------------------------------*/
  /*      Pre-request process timers        */
  /*----------------------------------------*/
  /* Timer before a request will be processed */
  DescOemPreExtTimer();

  /* --------------------------------------------------------*/
  /* Tester Timeout -----------------------------------------*/
  /* --------------------------------------------------------*/
  /* Attention: Reenable interrupt after comparision against zero to avoid test-and-set problem. */
  /* ----------------*/
  /* Tester Timeout  */
  /* ----------------*/
#if defined (DESC_ENABLE_S1_SINGLE_SVC_RELOAD)
  if(g_descIsS1TimerActive == kDescTrue)
#else
  if(g_descS1Timer != 0)
#endif
  {
#if defined (DESC_ENABLE_S1_ANY_SVC_RELOAD)
    if(g_descDoReloadS1Timer == kDescTrue)
    {
      /* This will clear the flag. No data loss possible, since the flag can be only set 
       * in interrupt, and only here will be cleared.
       */
      g_descDoReloadS1Timer = kDescFalse;
      DescStartS1Timer();
    }
#endif

    /*lint -e{506} (in some cases the expression is always true)*/
    /* Check for currently active requests to decide to decrement or not the counter */
    if(DescIsNoConnectionActive(iContext))
    {
      g_descS1Timer--;
      if(g_descS1Timer == 0)
      {
        /* Deactivate the timer */
        DescStopS1Timer();
        /* Special handling in case of S1 timeout before resetting the state */
        DescOemOnS1TimeoutPre();
        /* Simulate the same behavior as it would be done by requesting
         * default session 
         */
#if defined (DESC_ENABLE_AUTO_STATES)
# if (kDescStateGroupNumTransition > 0)
        /* Patch the setstate function to simulate real request */
        DescSetState(kDescDefaultSessionSvcInstEntry);
# endif
#endif
        /* Special handling in case of S1 timeout after resetting the state*/
        DescOemOnS1TimeoutPost();
      }

    }
  }

  /*----------------------------------------*/
  /*      Post-request process timers       */
  /*----------------------------------------*/
  /* Timer before a request will be processed */
  DescOemPostExtTimer();

  /* Only during request processing */
  /* RCR-RP only during processing (pprocessingEnd but not during transmission) */
  if((g_descInterruptContextCtrl[kDescPrimContext].activity & (kDescContextActiveProcess|kDescContextActiveProcessEnd)) != 0)
  {
#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT)
    /* --------------------------------------------------------*/
    /* Response pending time limitation -----------------      */
    /* --------------------------------------------------------*/
    /* Attention: Reenable interrupt after comparision against zero to avoid test-and-set problem. */
    if(g_descRcrrpLimitCounter[kDescPrimContext] != 0)
    {
      g_descRcrrpLimitCounter[kDescPrimContext]--;
      if(g_descRcrrpLimitCounter[kDescPrimContext] == 0)
      {
        /* Stop sending of further $78 error codes */
        DescDeactivateT2Timer(kDescPrimContext);
        /* Guarantee no application interrupts with "processing done" 
         * (sorry too late for the application)
         */
# if defined (DESC_ENABLE_FORCE_RCR_RP)
        /* Reset this flag if set */
        g_descInterruptContextCtrl[kDescPrimContext].forcedRcrRpState = kDescForcedRcrRpIdle;
# endif
# if defined(DESC_ENABLE_RES_RINGBUFFER)
        if(g_descRingBufferCtrl[kDescPrimContext].isRingBufferActive != 0)
        {
          DescRingBufferCancel(DESC_CONTEXT_PARAM_WRAPPER_ONLY(kDescPrimContext));
        }
        else
# endif
        {
# if defined(DESC_ENABLE_OEM_HANDLING_ON_RCRRP_LIMIT_EXPIRATION)
          /* Custom action */
          DescOemOnResPendingOvertime();
# else
          /* Set no response - just finalize the request */
          g_descMsgContext[kDescPrimContext].msgAddInfo.resOnReq = 0;
          /* Set an error so no complicatet checks to be performed and no PostHandler to be called */
          g_descNegResCode[kDescPrimContext] = (DescNegResCode)(~kDescNrcNone);

          DescInterruptDisable();
          /* Close the case :) */
          DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(kDescPrimContext));
          DescInterruptRestore();
# endif
        }
        /* Notify the application about timeout */
        ApplDescResponsePendingOvertimed();
        return;
      }
    }
#endif

    /* --------------------------------------------------------*/
    /* Response Timeout ---------------------------------------*/
    /* --------------------------------------------------------*/
    /* TimeoutT2 unequal to 0 means running */
    if(g_descT2Timer[kDescPrimContext] != 0)
    {
#if defined (DESC_ENABLE_FORCE_RCR_RP)
      /* Check if the application needs RCR-RP right now */
      if(g_descInterruptContextCtrl[kDescPrimContext].forcedRcrRpState == kDescForcedRcrRpCharged)
      {
        /* Check if the TX channel is free */
        if(g_descInterruptContextCtrl[kDescPrimContext].infoPoolPtr->resType == kDescUsdtResponseNone)
        { /* reserve the TX channel for single frame */
          g_descInterruptContextCtrl[kDescPrimContext].infoPoolPtr->resType = kDescUsdtResponseNegativeApplRCR_RP;
          /* reset RCR-RP state */
          g_descInterruptContextCtrl[kDescPrimContext].forcedRcrRpState = kDescForcedRcrRpIdle;

          DescTransmitRcrRp(DESC_CONTEXT_PARAM_WRAPPER_ONLY(kDescPrimContext));
        }
        else
        { /* Force timeout */
          g_descT2Timer[kDescPrimContext] = 1;
        }
      }
      else
#endif
      {
        g_descT2Timer[kDescPrimContext]--;
        /*Timeout reached?*/
        if(g_descT2Timer[kDescPrimContext] == 0)
        {
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
          if(g_descRcrrpLimitCounter[kDescPrimContext] != 0)
          {
#endif
            /* Check if the TX channel is free */
            if(g_descInterruptContextCtrl[kDescPrimContext].infoPoolPtr->resType == kDescUsdtResponseNone)
            {
              /* reserve the TX channel for single frame */
              g_descInterruptContextCtrl[kDescPrimContext].infoPoolPtr->resType = kDescUsdtResponseNegativeRCR_RP;

              DescTransmitRcrRp(DESC_CONTEXT_PARAM_WRAPPER_ONLY(kDescPrimContext));
            }
            else
            {
              g_descT2Timer[kDescPrimContext] = 1;
            }
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
          }
          else
          {
            /* Guarantee no application interrupts with "processing done" 
             * (sorry too late for the application)
             */
# if defined (DESC_ENABLE_FORCE_RCR_RP)
            /* Reset this flag if set */
            g_descInterruptContextCtrl[kDescPrimContext].forcedRcrRpState = kDescForcedRcrRpIdle;
# endif
# if defined(DESC_ENABLE_RES_RINGBUFFER)
            if(g_descRingBufferCtrl[kDescPrimContext].isRingBufferActive != 0)
            {
              DescRingBufferCancel(DESC_CONTEXT_PARAM_WRAPPER_ONLY(kDescPrimContext));
            }
            else
# endif
            {
# if defined(DESC_ENABLE_OEM_HANDLING_ON_RCRRP_LIMIT_EXPIRATION)
              /* Custom action */
              DescOemOnResPendingOverrun();
# else
              /* Set no response - just finalize the request */
              g_descMsgContext[kDescPrimContext].msgAddInfo.resOnReq = 0;
              /* Set an error so no complicatet checks to be performed and no PostHandler to be called */
              g_descNegResCode[kDescPrimContext] = (DescNegResCode)(~kDescNrcNone);

              DescInterruptDisable();
              /* Close the case :) */
              DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(kDescPrimContext));
              DescInterruptRestore();
# endif
            }
            /* Notify the application about timeout */
            ApplDescResponsePendingOverrun();
          }
#endif
        }
      }
    }
  }
#if defined(kDescSecureTimer) && defined(DESC_ENABLE_SECURITY_ACCESS)
# if (kDescSecureTimer != 0)
  DescSecurityAccessTimer();
# endif
#endif

  /* Call the DescNet timer tasks */
  DescUudtNetTimerTask();
  DescUsdtNetAbsTimerTask();
}

/*******************************************************************************
* NAME:              DescStateTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescStateTask(void)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL

  /*Postprocess UUDT confirmation*/
  DescUudtNetStateTask();

  /*-------------------------*/
  /* Global tasks processing */
  /*-------------------------*/
  DescOemOnStateTask();

  /*--------------------------*/
  /* Context tasks processing */
  /*--------------------------*/
#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_VALUE = kDescNumContexts;
  while(DESC_CONTEXT_PARAM_VALUE != 0)
  {
    DESC_CONTEXT_PARAM_ONLY--;
#endif
    /* Check pending post-processing */
    if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity != kDescContextIdle)
#if defined (DESC_ENABLE_SPONTANEOUS_RES)
      ||(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isTransmitSingleFrameReady != 0)
#endif
      )
    {
      DescContextStateTask(DESC_CONTEXT_PARAM_ONLY);
    }
#if(kDescNumContexts > 1)
  }
#endif

#if defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
  DescDynDpidTask();
#endif
  /* Call the DescNet  tasks */
  DescUudtNetStateTask();
  DescUsdtNetAbsStateTask();
}

/*******************************************************************************
* NAME:              DescContextStateTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
static void DescContextStateTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /*------------------------*/
  /*  Post processing task  */
  /*------------------------*/
  if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & kDescContextActivePostProcess) != 0)
  {
    vuint8  postProcessState;

    DescInterruptDisable();
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity &= (DescContextActivity)(~kDescContextActivePostProcess);
    DescInterruptRestore();


#if defined (DESC_ENABLE_RES_RINGBUFFER)
    /**********************
    * RingBuffer handling
    **********************/
    /* Ring buffer relevant states reset */
    DescRingBufferStateReset(DESC_CONTEXT_PARAM_ONLY);
#endif

    /* By default - ok */
    postProcessState = kDescPostHandlerStateOk;

    /* Check the status of the response */
    if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].txState != kDescUsdtNetworkOk)
    {
      /* Clear ok, set error type */
      postProcessState = kDescPostHandlerStateTxFailed;
    }

    /* Add type of the response */
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
    {
      /* Clear ok, set error type */
      postProcessState &= (vuint8)(~kDescPostHandlerStateOk);
      postProcessState |= kDescPostHandlerStateNegResSent;
    }

    ApplDescGenericServiceConfirmation(postProcessState);

#if defined (DESC_ENABLE_POSTHANDLER_USAGE)
    /* Call the post handler only if application error was active */
    if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError != 0)
    {
      /* Call the post handler */
      g_descPostHandlerTable[g_descSvcInst[g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]].postHandlerRef](DESC_CONTEXT_PARAM_FIRST postProcessState);
    }
#endif
#if defined (DESC_ENABLE_AUTO_STATES)
# if (kDescStateGroupNumTransition > 0)
    /*----------------------------*/
    /*        Modify state        */
    /*----------------------------*/
    /* Called only in successfully finished 
     * request processing */
    if((postProcessState & kDescPostHandlerStateOk) != 0)
    {
      DescSetState(g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]);
    }
# endif
#endif
  }

  /*-------------------------*/
  /*    Rx processing task   */
  /*-------------------------*/
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveRxEnd)
  {
    /* Switch to process state */
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveProcess;

#if defined (DESC_ENABLE_DESCICN_SUPPORT)
    /* Check if this instance is a internal request */
    if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqType != kDescUsdtNetReqTypeInternal)
#endif
    {
      /* transfer addressing information from infoPool into MsgContext */
      if (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqType == kDescUsdtNetReqTypeFunctional)
      {
        /* Specify that the current request was actually a functional one */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType = kDescFuncReq;
      }
      else
      {
        /* Set request addressing method */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType = kDescPhysReq;
      }
      /* Copy the SID for RCR-RP response. 
       * necessary for multi session diag to know which one will be sent
       */
      g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE][1] = *g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;
    }
#if defined (DESC_ENABLE_DESCICN_SUPPORT)
    else
    {
      /* Set request addressing method always to simulate physical reception */
      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType = kDescPhysReq;
    }
#endif
    /* Stores the length */
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength;

    /* Clear the error code */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcNone;
    /* Process the dispatcher */
    DescDispatcher(DESC_CONTEXT_PARAM_ONLY);
  }

  /*------------------------------*/
  /*    Process processing task   */
  /*------------------------------*/
#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL) || defined (DESC_ENABLE_PID_LIST_MODE)
  /*--------------------------------------*/
  /*    Repeated Main-Handler Call task   */
  /*--------------------------------------*/
  if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & (kDescContextActiveProcess |
                                                                       kDescContextActiveTxReady |
                                                                       kDescContextActiveTx |
                                                                       kDescContextActiveProcessEnd)) != 0)
  {
    /*--------------------------------------*/
    /*    Repeated Main-Handler Call task   */
    /*--------------------------------------*/
# if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
    if(g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE] != V_NULL)
    {
#  if defined(DESC_ENABLE_PID_LIST_MODE)
      /* If list mode service - process using its context */
      if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode == kDescContextModePidList)
      {
        g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE](&g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE]);
      }
      else
#  endif
      {
        g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE](&g_descMsgContext[DESC_CONTEXT_PARAM_VALUE]);
      }
    }
# endif
# if defined (DESC_ENABLE_PID_LIST_MODE)
    DescPidProcessorTask(DESC_CONTEXT_PARAM_ONLY);
# endif
  }
#endif

#if defined (DESC_ENABLE_SPONTANEOUS_RES)
  if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isTransmitSingleFrameReady != 0)
  {
    if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & (kDescContextActiveRx|kDescContextActiveTx)) == 0)
    {
      DescUsdtNetAbsTransmitResponse(&g_descUsdtNetSpontanResInfoPool);

      /* No further tries for transmit */
      DescInterruptDisable();
      g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isTransmitSingleFrameReady = 0;
      DescInterruptRestore();
    }
  }
#endif

  /*-------------------------*/
  /*    Tx processing task   */
  /*-------------------------*/
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveTxReady)
  {
    /* Check if the TX channel is free */
    if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType == kDescUsdtResponseNone)
#if defined (DESC_ENABLE_SPONTANEOUS_RES)
        &&(g_descUsdtNetSpontanResInfoPool.resType == kDescUsdtResponseNone)
#endif
        )
    {
      /* Deactivate the RCR-RP timer here:
       * - equivalent to stopping it into ProcessingDone
       * - reduces code complexity to distinguish the different use cases 
       */
      DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
      DescDeactivateLimiter(DESC_CONTEXT_PARAM_VALUE);

      /* Set the new state of CANdesc */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTx;

      /* reserve the TX channel and set the confirmation type to be expected */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength = g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
      if (g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0)
      {
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType    = kDescUsdtResponseRingBuffer;
      }
      else
#endif
      {
        /* Check if the negative response code is set */
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType    = (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)?kDescUsdtResponsePositive:kDescUsdtResponseNegative;
      }
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
      if (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr == V_NULL)
      {
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = DescUsdtNetGetTransmissionPtr(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
        memcpy(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr,g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr,g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength);
      }
      else
#endif
      {
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;
      }
      DescUsdtNetAbsTransmitResponse(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
    }
  }
}

/*******************************************************************************
* NAME:              DescOemInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Custom initialization
*
*******************************************************************************/
static void DescOemInit(void)
{
  /* Init the variable for the unsolicited positive response */
  g_descResSidStopSession = 0x60;
  /* By default allow UUDT transmission */
  g_descOemStateCtrl.isUudtProcessSuspended = 0;
  /* Init in inactive state to assure each time CAN online to be set */
  g_descOemStateCtrl.isCanActive = 0;
  /* Stop the VN timer */
  g_vnTimer = 0;
#if defined (DESC_ENABLE_SCHEDULED)
  /* UUDT resource is free */
  g_descDpidUudtResource = V_NULL;
#endif
#if defined(DESC_UUDTNET_ENABLE_MULTI_BUS_SUPPORT)
  /* Send only on CAN */
  g_descUudtNetInfo.busType = kDescUudtNetBusTypeCAN;
#endif

}

/*  ********************************************************************************
 * Function name:DescGenReadDidDID_9A_Diagnostic_Data_Identifier
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescReqTypePhys or kDescReqTypeFunc).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->iContext:
 *       - Use this request handle to all API which requiers it.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescGenReadDidDID_9A_Diagnostic_Data_Identifier(DescMsgContext* pMsgContext)
{
  DescMsg pMsg;
  pMsg = pMsgContext->resData;
  {
    pMsg[0] = ApplDescReadDidDATADID_9A_Diagnostic_Data_Identifier();
  }
  {
    pMsg[1] = ApplDescReadDidVersion_CodeDID_9A_Diagnostic_Data_Identifier();
  }
  pMsgContext->resDataLen = 2;
  DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:DescGenSendTesterPresent
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescReqTypePhys or kDescReqTypeFunc).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->iContext:
 *       - Use this request handle to all API which requiers it.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescGenSendTesterPresent(DescMsgContext* pMsgContext)
{
  DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:DescGenRequestProgrammingMode
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescReqTypePhys or kDescReqTypeFunc).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->iContext:
 *       - Use this request handle to all API which requiers it.
 *       - Access type: read
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescGenRequestProgrammingMode(DescMsgContext* pMsgContext)
{
  DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:DescReadStatusOfDTCByStatus (Service request header:$A9 $81 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescReadStatusOfDTCByStatus(DescMsgContext* pMsgContext)
{
  
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  /* if still not active mode $81 to prevent multi call if the application needs more time */
  if((g_descRdiStateCtrl.isFirstAnswer & kDescRdiMode81) == 0)
#endif
  {
#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
    /* Accept stop requests only if no scheduler is running or 
     * the scheduler was started from the same CAN channel */
    if((g_descRdiCanChannel != kDescUudtNetNoCanChannel)&&
       (g_descRdiCanChannel != pMsgContext->busInfo.comChannel))
    {
      g_descNegResCode[pMsgContext->iContext] = kDescNrcGeneralReject;
      DescProcessingDone(pMsgContext->iContext);
      /* Skip further processing */
      return;
    }
    DescRdiRegisterCanChUser(kDescRdiUser_81);
    /* Store the new channel - if already stored - this is the same value again */
    g_descRdiCanChannel = pMsgContext->busInfo.comChannel;
#endif

    g_descRdiCurReqContext = pMsgContext->iContext;/* store the context for the later response acknowledgement */

    g_descRdiStateCtrl.is81ModeActive  = 1;/* Set the current mode that is 81 */
    g_descRdiStateCtrl.isLastDtcFound  = 0;/* reset flag that the so the search could start */
    g_descRdiStateCtrl.reqMode        |= kDescRdiMode81;/* set request is received */
    g_descRdiStateCtrl.isFirstAnswer  |= kDescRdiMode81;/* set that this was the first request */

    g_descRdi81SearchStatusMask = pMsgContext->reqData[0];/* set the mask to be asked for */

    g_descNextIterPos = 0;/* Start scanning from the beginning */

    g_descUudtPrimBuffer[0] = 0x81;/* prepare the response */
  }
;
}


/*  ********************************************************************************
 * Function name:DescReadDpidSlow (Service request header:$AA $2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescReadDpidSlow(DescMsgContext* pMsgContext)
{
  DescUpdateScheduler(kDescRdpiDpidSchedulingSlow, pMsgContext);
}


/*  ********************************************************************************
 * Function name:DescReadDpidMedium (Service request header:$AA $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescReadDpidMedium(DescMsgContext* pMsgContext)
{
  DescUpdateScheduler(kDescRdpiDpidSchedulingMedium, pMsgContext);
}


/*  ********************************************************************************
 * Function name:DescReadDpidFast (Service request header:$AA $4 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescReadDpidFast(DescMsgContext* pMsgContext)
{
  DescUpdateScheduler(kDescRdpiDpidSchedulingFast, pMsgContext);
}


/*  ********************************************************************************
 * Function name:DescPreReadStatusOfDTC (Service request header:$A9 $81 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescPreReadStatusOfDTC(vuint8 iContext)
{
  
  if(g_descRdiStateCtrl.is81ModeActive == 1)
  {
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcRdiAlreadyActive;
  }
;
}


/*  ********************************************************************************
 * Function name:DescReadPackDynamic_DPID_FA
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsg:
 *       - Write the data into this buffer.
 *       - Access type: write
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FA(DescMsg pMsg)
{
  DescCommonReadDynDefinedDpid(pMsg, 0);
}


/*  ********************************************************************************
 * Function name:DescReadPackDynamic_DPID_FB
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsg:
 *       - Write the data into this buffer.
 *       - Access type: write
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FB(DescMsg pMsg)
{
  DescCommonReadDynDefinedDpid(pMsg, 1);
}


/*  ********************************************************************************
 * Function name:DescReadPackDynamic_DPID_FC
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsg:
 *       - Write the data into this buffer.
 *       - Access type: write
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FC(DescMsg pMsg)
{
  DescCommonReadDynDefinedDpid(pMsg, 2);
}


/*  ********************************************************************************
 * Function name:DescReadPackDynamic_DPID_FD
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsg:
 *       - Write the data into this buffer.
 *       - Access type: write
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FD(DescMsg pMsg)
{
  DescCommonReadDynDefinedDpid(pMsg, 3);
}


/*  ********************************************************************************
 * Function name:DescReadPackDynamic_DPID_FE
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsg:
 *       - Write the data into this buffer.
 *       - Access type: write
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescReadPackDynamic_DPID_FE(DescMsg pMsg)
{
  DescCommonReadDynDefinedDpid(pMsg, 4);
}


#if defined (DESC_ENABLE_ANY_PREHANDLER_USAGE)
/*******************************************************************************
* NAME:              DescDummyPreHandler
*
* CALLED BY:         DESCDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Used instead of V_NULL pointer
*
*******************************************************************************/
static void DESC_API_CALL_TYPE DescDummyPreHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;
}
#endif

#if defined (DESC_ENABLE_ANY_POSTHANDLER_USAGE)
/*******************************************************************************
* NAME:              DescDummyPostHandler
*
* CALLED BY:         DESCDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Used instead of V_NULL pointer
*
*******************************************************************************/
static void DESC_API_CALL_TYPE DescDummyPostHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;
  DESC_IGNORE_UNREF_PARAM(status);
}
#endif

/*******************************************************************************
* NAME:              DescOemPostSendTesterPresent
*
* CALLED BY:         DescDispatcher/DescTask (in case of real answer is sent)
* PRECONDITIONS:     
*
* DESCRIPTION:       Keeping the tester present timer and in this way 
*                    all activated services alive. 
*
*******************************************************************************/
static void DescOemPostSendTesterPresent(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  if((status & kDescPostHandlerStateOk) != 0)
  {
    DescReloadS1Timer();
  }
}

#if defined (DESC_ENABLE_SERVICE_10_02)
/*******************************************************************************
* NAME:              DescOemPostDisableAllDTCs
*
* CALLED BY:         DescDispatcher/DescTask (in case of real answer is sent)
* PRECONDITIONS:     
*
* DESCRIPTION:       Diag service. 
*
*******************************************************************************/
static void DescOemPostDisableAllDTCs(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  if((status & kDescPostHandlerStateOk) != 0)
  {
    /* Stop the VN timer */
    g_vnTimer = 0;
    DescStartS1Timer();
    ApplDescOnDisableAllDtc();
  }
}
#endif

#if defined (DESC_ENABLE_SERVICE_10_03)
/*******************************************************************************
* NAME:              DescOemPostEnableDTCsDuringDevCntrl
*
* CALLED BY:         DescDispatcher/DescTask (in case of real answer is sent)
* PRECONDITIONS:     
*
* DESCRIPTION:       Diag service. 
*
*******************************************************************************/
static void DescOemPostEnableDTCsDuringDevCntrl(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  if((status & kDescPostHandlerStateOk) != 0)
  {
    /* Stop the VN timer */
    g_vnTimer = 0;
    DescStartS1Timer();
    ApplDescOnEnableDtcsDuringDevCntrl();
  }
}
#endif

/*******************************************************************************
* NAME:              DescOemStopDiagnosticSession
*
* CALLED BY:         DescDispatcher/DescTask (in case of real answer is sent)
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns into the default/BOOT ECU state . 
*
*******************************************************************************/
static void DescOemStopDiagnosticSession(DescMsgContext *pMsgContext)
{
#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
  /* Check the current programming mode */
  if(g_descCurState.stateProgrammingMode == kDescStateProgrammingModeActive)
  {
    pMsgContext->msgAddInfo.resOnReq = 0;
  }
#endif
  /* UUDT transmission is temporarely NOT allowed */
  g_descOemStateCtrl.isUudtProcessSuspended = 1;

  /* No data to be sent */
  pMsgContext->resDataLen = 0;
  /* Finish the processing */
  DescProcessingDone(pMsgContext->iContext);
}


/*******************************************************************************
* NAME:              DescOemPostStopDiagnosticSession
*
* CALLED BY:         DescDispatcher/DescTask (in case of real answer is sent)
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns into the default/BOOT ECU state . 
*
*******************************************************************************/
static void DescOemPostStopDiagnosticSession(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  /* UUDT transmission is allowed (in any case - also in error case)
   * !!! Clear this flag prior initializing the scheduler */
  g_descOemStateCtrl.isUudtProcessSuspended = 0;

  if((status & kDescPostHandlerStateOk) != 0)
  {
    DescOemOnStopSession();
  }
}

/*******************************************************************************
* NAME:              DescOemDisableNormalCommunication
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Disables the normal communication mode. 
*
*******************************************************************************/
static void DescOemDisableNormalCommunication(DescMsgContext *pMsgContext)
{
#if defined (NM_TYPE_GMLAN)
  Nm_Status result = DescNmSetCommHalted(g_descOemStateCtrl.canChannel);
  if(result != NM_OK)
  {
    DescSetNegResponse(pMsgContext->iContext, kDescNrcConditionsNotCorrect);
  }
  else
#else /* IVLAN or NM_BASIC */
  DescNmSetCommHalted(g_descOemStateCtrl.canChannel);
#endif
  {
    DescOnDisableNormalComm();
  }

  DescProcessingDone(pMsgContext->iContext);
}

#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
/*******************************************************************************
* NAME:              DescOemEnableProgrammingMode
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Disables the normal communication mode. 
*
*******************************************************************************/
static void DescOemEnableProgrammingMode(DescMsgContext *pMsgContext)
{
/*positive response should not be sent*/
  pMsgContext->msgAddInfo.resOnReq = 0;

  DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
}
#endif



#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
/*******************************************************************************
* NAME:              DescOemPostEnableProgrammingMode
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Process entering Programming mode
*
*******************************************************************************/
static void DescOemPostEnableProgrammingMode(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  if((status & kDescPostHandlerStateOk) != 0)
  {
# if defined (DESC_ENABLE_FLASHABLE_ECU)
    /* Notify the application to jump into FBL */
    ApplDescOnEnterProgMode();
# else
#  if defined (DESC_ENABLE_REQ_HISPEED_PROG)
    /* The return value is not checked, because there are 2 cases that can 
     * cause error setting this mode and which are excluded here:
     * 1. NormalComm is active - impossible because of the checks in $A5 $01/$02
     * 2. EnterSleepMode - impossible - VN_Diagnostics is active still. 
     */
    if((g_descCurState.stateProgrammingMode & kDescStateProgrammingModeRequested_HiSpeed) != 0)
    {
#   if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
      (void)IlNwmSetHispeedMode(g_descOemStateCtrl.canChannel);
#   else
      (void)IlNwmSetHispeedMode();
#   endif
    }
#  endif
# endif
  }
}
#endif

/*******************************************************************************
* NAME:              DescRdiPowerOnInit
*
* CALLED BY:         DescOemInitPowerOn
* PRECONDITIONS:     
*
* DESCRIPTION:       Init the A9 manager
*
*******************************************************************************/
static void DescRdiPowerOnInit(void)
{
  /* init the state machine here to have startup
   * definite state */
  g_descRdiStateCtrl.is81ModeActive = 0;
  g_descRdiStateCtrl.isFirstAnswer = 0;
  g_descRdiStateCtrl.reqMode = 0;
  g_descRdiStateCtrl.answerMode = 0;
  g_descRdiStateCtrl.isLastDtcFound = 0;
  g_descRdiStateCtrl.is82ModeActive = 0;
}

/*******************************************************************************
* NAME:              DescRdiInit
*
* CALLED BY:         DescOemInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Init the A9 manager
*
*******************************************************************************/
static void DescRdiInit(void)
{
#if defined (DESC_ENABLE_SERVICE_A9_82_SUPPORT)
  /* make it before initializing the state machine */
  /* deactivate the $A9 $82 service */
  DescRdiDeactivateOnChangeDtcCount();
  /* prepare the response - here will be always 0x82 */
  g_descUudtSecBuffer[0] = 0x82;
#endif

#if defined (DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
  /* Set to NoChannel value to allow activation of the scheduler */
  g_descRdiCanChannel = kDescUudtNetNoCanChannel;
  g_descRdiCanChUsers = 0;
#endif

  /* init the state machine */
  DescRdiPowerOnInit();
  g_descNextMode = kDescRdiMode80;
}

/*******************************************************************************
* NAME:              DescRdiStateTask
*
* CALLED BY:         DescOemState
* PRECONDITIONS:     
*
* DESCRIPTION:       Dynamical management fro DPID scheduling
*
*******************************************************************************/
static void DescRdiStateTask(void)
{
#if defined(DESC_ENABLE_RDI_UUDT_BUFFER_SWITCH)
  /* temporary buffer for parallel transmission of UUDTs */
  DescMsg curUudtBuffer;
#endif

#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
  if((g_descRdiCanChUsers & kDescRdiUserMask) == 0)
  {
    /* Free the channel on no usage*/
    g_descRdiCanChannel = kDescUudtNetNoCanChannel;
  }
#endif
  /*--------------------------*/
  /*            Rx            */
  /*--------------------------*/
  /* safe Idle task time */
  if((g_descRdiStateCtrl.reqMode & kDescRdiModeMask) != 0)
  {
    switch(g_descRdiStateCtrl.reqMode)
    {
#if defined (DESC_ENABLE_SERVICE_A9_81_SUPPORT)
      case (vuint8)kDescRdiMode81:
        /* Send the response buffer, and the searched mask */
        ApplDescGetDtcStatusByMask(g_descNextIterPos,
                                   g_descRdi81SearchStatusMask);
        /* delete the requested mode */
        g_descRdiStateCtrl.reqMode &= (DescBitType) (kDescRdiModeMask & ~kDescRdiMode81);
        break;
#endif
#if defined (DESC_ENABLE_SERVICE_A9_80_SUPPORT)
# if defined (DESC_ENABLE_SERVICE_A9_82_SUPPORT)
      case (vuint8)(kDescRdiMode80 | kDescRdiMode82):
# endif
      /* fall through */
      case (vuint8)kDescRdiMode80:
        /* send the DTC number and the FTB */
        ApplDescGetDtcStatusByNumber(DescMake16Bit(g_descUudtPrimBuffer[1], g_descUudtPrimBuffer[2]), g_descUudtPrimBuffer[3]);
        /* delete the requested mode */
        g_descRdiStateCtrl.reqMode &= (DescBitType) (kDescRdiModeMask & ~kDescRdiMode80);
        break;
#endif
#if defined (DESC_ENABLE_SERVICE_A9_82_SUPPORT)
# if defined (DESC_ENABLE_SERVICE_A9_81_SUPPORT)
        /* In this case give the priority to the $82 and skip the $81 with one task */
      case (vuint8)(kDescRdiMode81 | kDescRdiMode82):
# endif
      /* fall through */
      case (vuint8)kDescRdiMode82:

        /* start the DTC on count change algorithm */
        ApplDescEnableOnChangeDtcCount(g_descRdi82SearchStatusMask);
        /* set tha OnDTCCountChange is active so in case of timeout only the application
         *  to be called to cancel the change monitoring algo */
        g_descRdiStateCtrl.is82ModeActive = 1;
        /* delete the requested mode */
        g_descRdiStateCtrl.reqMode &= (DescBitType) (kDescRdiModeMask & ~kDescRdiMode82);
        break;
#endif
      default:break;/* idle mode */
    }
  }
  /*--------------------------*/
  /*            Tx            */
  /*--------------------------*/
  /* there is any ready confirmation from the application */
  if((g_descRdiStateCtrl.answerMode & kDescRdiModeMask) != 0)
  {
    /* Is access to the com bus allowed */
    if(g_descOemStateCtrl.isUudtProcessSuspended == 0)
    {
      t_descUudtNetInfoPoolPtr pUudtResource;

#if defined(DESC_UUDTNET_ENABLE_MULTI_CLIENT)
      /* Prepare the resource init info */
      g_descUudtNetInfo.client = kDescClientRdi;
#endif
#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
      /* set the correct CAN channel */
      g_descUudtNetInfo.busProperty.can.canChannel = g_descRdiCanChannel;
#endif
      /* if the UUDT msg is free */
      pUudtResource = DescUudtNetTxReserveResource(&g_descUudtNetInfo);
      /* Check for success */
      if(pUudtResource != V_NULL)
      {
        /* find the next - in this way the parallel confirmations are solved */
        while ((g_descRdiStateCtrl.answerMode & g_descNextMode) == 0)
        {
          /* find the next confirmed mode with wrap around */
          if((g_descNextMode & kDescRdiMode82) != 0)
          {
            g_descNextMode = kDescRdiMode80;
          }
          else
          {
            g_descNextMode <<=1;
          }
        }

#if defined(DESC_ENABLE_RDI_UUDT_BUFFER_SWITCH)
        /* set the buffer and send just the response */
        curUudtBuffer = &g_descUudtPrimBuffer[0];
#endif
        /* $A9 mode specific processing */
        switch(g_descNextMode)
        {
#if defined (DESC_ENABLE_SERVICE_A9_80_SUPPORT)
          /*---------------------*/
          case kDescRdiMode80:
          /*---------------------*/
            DescRdiUnRegisterCanChUser(kDescRdiUser_80);
            break;
#endif /* DESC_ENABLE_SERVICE_A9_80_SUPPORT */
#if defined (DESC_ENABLE_SERVICE_A9_81_SUPPORT)
          /*---------------------*/
          case kDescRdiMode81:
          /*---------------------*/
            /* check if no more macthing DTCs or never found */
            if(g_descRdiStateCtrl.isLastDtcFound != 0)
            {
              DescRdiUnRegisterCanChUser(kDescRdiUser_81);
            }
            break;
#endif /* DESC_ENABLE_SERVICE_A9_81_SUPPORT */
#if defined (DESC_ENABLE_SERVICE_A9_82_SUPPORT)
          /*---------------------*/
          case kDescRdiMode82:
          /*---------------------*/
# if defined(DESC_ENABLE_RDI_UUDT_BUFFER_SWITCH)
            /* set the buffer and send just the response */
            curUudtBuffer = &g_descUudtSecBuffer[0];
# endif
            break;
#endif /* DESC_ENABLE_SERVICE_A9_82_SUPPORT */
          default:
            DescAssertInternalAlways(kDescAssertInvalidA9Mode);
            break;
        }

        /* clear the corresponding confirmation flag */
        g_descRdiStateCtrl.answerMode &= (DescBitType)~g_descNextMode;

        /* if that was the first UUDT response for the current 
        *  type of response - free the diagnostic layer */
        if((g_descRdiStateCtrl.isFirstAnswer & g_descNextMode) != 0)
        {
          g_descRdiStateCtrl.isFirstAnswer &= (DescBitType)~g_descNextMode;
          /* send no response by default */
          g_descMsgContext[g_descRdiCurReqContext].msgAddInfo.resOnReq = 0;
          DescProcessingDone(g_descRdiCurReqContext);
        }

        /* shift with wrap around (make it before the CanTransmit so the confirmation each time
         * to have the next awaiting mode)*/
        if((g_descNextMode & kDescRdiMode82) != 0)
        {
          g_descNextMode = kDescRdiMode80;
        }
        else
        {
          g_descNextMode <<=1;
        }

        /*---------------------------------*/
        /*        send the response        */
        /*---------------------------------*/
        /* copy the data on the response buffer */
        DescMsgCopyRamToRam(pUudtResource->resDataPtr, g_descRdiCurrUudtBuffer, kDescBufferLen);
#if defined (DESC_UUDTNET_ENABLE_DATALENGTH_USAGE)
        /* Use always 8 Byte response length */
        pUudtResource->dataLength = 8;
#endif
        DescUudtNetTransmitResponse(pUudtResource);
      }
    }
  }
}

#if defined (DESC_ENABLE_SERVICE_A9_81_SUPPORT)
/*******************************************************************************
* NAME:              DescRdiUudtConfirmation
*
* CALLED BY:         DescUudtConfirmation
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides synchronization of the API calls. 
*
*******************************************************************************/
static void DescRdiUudtConfirmation(void)
{
  /* perform this only for the $81 request (at this time the value will be already shifted) 
   * that is why should be compared with $82 constant. Only in the $81 the variable g_descNextMode 
   * mode will have this value at this time point. */
  if((g_descNextMode & kDescRdiMode82) != 0)
  {
    /* check if that was the last confirmation - no more macthing DTCs or never found */
    if(g_descRdiStateCtrl.isLastDtcFound == 0)
    {
      /* request again the application to find a mask */
      g_descRdiStateCtrl.reqMode |= kDescRdiMode81;
      /* restart the VN timer to keep the bus online */
      g_vnTimer = kDescVnDiagTimerTicks;
    }
    else
    {
      /* free the module from this mode 
       * make it in the confirmation so not the next $80 or again
       * $81 to overwrite the buffer before it will be sent */
      g_descRdiStateCtrl.is81ModeActive = 0;
    }
  }
}
#endif

/*******************************************************************************
* NAME:              DescRdiDtcStatusByMaskFound
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Confirmation that the response is written and ready for 
*                    transmission. 
*
*******************************************************************************/
void DescRdiDtcStatusByMaskFound(DescRdiDtcRecord *pDtcReport)
{
  /* store the next starting position here */
  g_descNextIterPos = pDtcReport->nextIterPos;
  /* compose th response */
  g_descUudtPrimBuffer[1] = DescGetHiByte(pDtcReport->dtcNum);
  g_descUudtPrimBuffer[2] = DescGetLoByte(pDtcReport->dtcNum);
  g_descUudtPrimBuffer[3] = pDtcReport->failureTypeByte;
  g_descUudtPrimBuffer[4] = pDtcReport->statusByte;

  /* set the confirmation flag */
  g_descRdiStateCtrl.answerMode |= kDescRdiMode81;
}

/*******************************************************************************
* NAME:              DescRdiDtcStatusByMaskNotFound
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Confirmation that no more or at all DTC with the given mask 
*                    were found.
*
*******************************************************************************/
void DescRdiDtcStatusByMaskNotFound(vuint8 dtcSam)
{
  /* compose EndOfDTCReportMess */
  g_descUudtPrimBuffer[1] =
  g_descUudtPrimBuffer[2] =
  g_descUudtPrimBuffer[3] = 0;
  g_descUudtPrimBuffer[4] = dtcSam;
  /* set the confirmation flag */
  g_descRdiStateCtrl.answerMode |= kDescRdiMode81;
  /* set flag that the last that no more DTC there are */
  g_descRdiStateCtrl.isLastDtcFound = 1;
}

#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || \
    defined(DESC_ENABLE_PID_LIST_MODE)        || \
    defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
/*******************************************************************************
* NAME:              DescPmGetPidResponseLen
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescMsgLen DescPmGetPidResponseLen(DescPidInstIndex pidHandle)
{
  DescMsgLen result;

  result = DescPmClientGetResLength(pidHandle);

  /* If client didn't recognize it as own DID */
  if(result == 0)
  {
    result = g_descPIDInfo[pidHandle].resDataLen;
  }

  return result;
}
#endif

/*******************************************************************************
* NAME:              DescAnalysePid
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescPidAnalyseFailureReason DescPmAnalysePid(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST V_MEMROM1 DescPidTinyInfo V_MEMROM2 V_MEMROM3 * pRefTinyInfo)
{
  DescPidAnalyseFailureReason reason = pmAnalyseReasonOther;
  /*---------------------------------------------*/
  /*     Service ID addressing method check      */
  /*---------------------------------------------*/
#if defined (DESC_ENABLE_ADDR_METHOD_CHECK)
  if ((pRefTinyInfo->msgAddInfo.reqType &
       g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) == 0)
  {
    /* EXAMPLE: Additional activities may be necessary */
    /*DescOemOnInvalidAddrMethod(DESC_CONTEXT_PARAM_ONLY);*/
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
  }
  else
#endif
  {
#if defined (DESC_ENABLE_AUTO_STATES)
    /* Generated state checks */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = DescCheckState(&(pRefTinyInfo->checkState));
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
    {
#if defined (DESC_ENABLE_PID_PREHANDLER_USAGE)
      /*---------------------------------------------*/
      /*    Application specific condition check     */
      /*---------------------------------------------*/
      /* Call the pre handler */
      g_descPreHandlerTable[pRefTinyInfo->preHandlerRef](DESC_CONTEXT_PARAM_ONLY);
#endif
    }
#if defined (DESC_ENABLE_AUTO_STATES)
    else
    {
      /* Correct the negative response code dependent on the sub-function availability */
# if defined (DESC_ENABLE_PROTOCOL_KWP)
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcServiceNotSupportedInActiveMode)
# else
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcSubfunctionNotSupportedInActiveSession)
# endif
      {
        reason = pmAnalyseReasonSession;
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcParamIdNotSupportedInSession;
      }

      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] ==  kDescOemNrcParamIdNotSupportedInSecurityState)
      {
        reason = pmAnalyseReasonSecurityState;
      }
    }
#endif
  }

  return reason;
}

#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || defined(DESC_ENABLE_PERIODIC_MODE)
/******************************************************************************
* NAME:              DescPmGetPidClientHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static DescPidInstIndex DescPmGetPidClientHandle(DescPidInstIndex pidInfoHandle, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable)
{
  DescPidInstIndex result;
  DescPidInstIndex iter;

  result = kDescInvalidPidHandle;
  iter = topOfTable;
  while(iter != 0)
  {
    iter--;
    if(pClientInfoTbl[iter].pidHandle == pidInfoHandle)
    {
# if defined (DESC_ENABLE_MULTI_VARIANT)
      /*Check if it is allowed in the actual configuration*/
      if(DescPermittedInConfig(pClientInfoTbl[iter].tinyInfo.variantMask) != 0)
# endif
      {
        result = iter;
      }
      /* Break */
      iter = 0;
    }
  }
  return result;
}
#endif

/******************************************************************************
* NAME:              DescPmGetAvailablePidHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static DescPidInstIndex DescPmGetAvailablePidHandle(vuint16 pid)
{
  DescPidInstIndex result;

  result = DescPmGetPidPoolHandle(pid);
  result = DescPmClientCheckPid(result, pid);

  return result;
}

#if defined(DESC_ENABLE_PERIODIC_MODE)
/******************************************************************************
* NAME:              DescPmGetSupportedPidClientHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:    Returns a reference of the DID in the client specific info table
*
*******************************************************************************/
static DescPidInstIndex DescPmGetSupportedPidClientHandle(vuint16 pid, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable)
{
  DescPidInstIndex result;
  result = DescPmGetAvailablePidHandle(pid);
  /* No check needed for invalidity since all the functions are protected by such checks */
  result = DescPmGetPidClientHandle(result, pClientInfoTbl, topOfTable);
  return result;
}
#endif

/******************************************************************************
* NAME:              DescPmGetPidPoolHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static DescPidInstIndex DescPmGetPidPoolHandle(vuint16 pid)
{
  DescPidInstIndex  loIdx;
  DescPidInstIndex  hiIdx;
  DescPidInstIndex  idx;

  /* Init look-up */
  loIdx= 0;
  hiIdx= (DescPidInstIndex)(kDescNumPids - 1);

  do
  {
    /* Examine one concrete serviceInstanceHeader */
    /* ------------------------------------------ */
    idx = (DescPidInstIndex)(((vuint16)((vuint16)hiIdx + (vuint16)loIdx)) >> 1);

    /* Check for matching element */
    if(g_descPIDInfo[idx].reqPid == pid)
    {
#if defined (DESC_ENABLE_MULTI_CFG_SUPPORT)
      DescBool isSupported = ApplDescIsDataIdSupported(pid);
      if(isSupported == kDescFalse)
      {
        /* Nothing more to look for */
        break;
      }
      else
#endif
      {
#if defined (DESC_ENABLE_PID_SECURITY_FILTER)
        DescBool isAllowed = DescPmCheckPidSecurityAccess(&(g_descPIDInfo[idx].tinyInfo.checkState));
        if(isAllowed == kDescFalse)
        {
          /* Nothing more to look for */
          break;
        }
        else
#endif
        {
          /* Bingoooo :) */
#if defined (DESC_ENABLE_MULTI_VARIANT)
          /*Check if it is allowed in the actual configuration*/
          if(DescPermittedInConfig(g_descPIDInfo[idx].tinyInfo.variantMask) == 0)
          {
            return kDescInvalidPidHandle;
          }
          else
#endif
          {
            return idx;
          }
        }
      }
    }
    /* Determine which half shall be taken */
    if (pid < g_descPIDInfo[idx].reqPid)
    {
      /* Avoid use of signed types */
      if(idx == 0)
      {
        break;
      }
      hiIdx = (DescPidInstIndex)(idx - 1);
    }
    else
    {
      /* Message 'greater' than service instance: Use upper half of interval... */
      loIdx = (DescPidInstIndex)(idx + 1);
    }
  }
  while (loIdx <= hiIdx);
  /* return the search result */
  return kDescInvalidPidHandle;
}

/*******************************************************************************
* NAME:              DescInitSingleScheduler
*
* CALLED BY:         DescRdpiInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Clears the scheduler table.
*
*******************************************************************************/
static void DescInitSingleScheduler(DESC_RDPI_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* reinit the scanner  */
  g_descSchedulerState[DESC_RDPI_CONTEXT_PARAM_VALUE].count = 0;
  g_descSchedulerState[DESC_RDPI_CONTEXT_PARAM_VALUE].currentListPos = 0;
  g_descSchedulerState[DESC_RDPI_CONTEXT_PARAM_VALUE].newItems1stPos = kDescRdpiInvalidNewDpidPos;
  /* clear the amount of used cells */
  g_descSchedulerState[DESC_RDPI_CONTEXT_PARAM_VALUE].isTimeExpired = 0;
  /* no overtime */
  g_descSchedulerState[DESC_RDPI_CONTEXT_PARAM_VALUE].isTimeOverrun = 0;
  /* stop the timer */
  g_descSchedulerTimer[DESC_RDPI_CONTEXT_PARAM_VALUE] = 0;
}

#if (kDescNumOfPeriodicTimers > 0)
/*******************************************************************************
* NAME:              DescInitScheduler
*
* CALLED BY:         DescRdpiTask, DescRdpiInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Clears the scheduler table.
*
*******************************************************************************/
static void DescInitScheduler(void)
{
  DESC_RDPI_TIMER_ITER_DEF_LOCAL

  /* Clear all scheduled DPIDs */
# if (kDescNumOfPeriodicTimers > 1)
  DESC_RDPI_TIMER_ITER_VALUE = kDescNumOfPeriodicTimers;
  while(DESC_RDPI_TIMER_ITER_VALUE != 0)
# endif
  {
    DESC_RDPI_TIMER_ITER_VALUE_DEC
    if(g_descSchedulerState[DESC_RDPI_TIMER_ITER_VALUE].count != 0)
    {
      /* One timer less */
      g_descRdpiStateCtrl.activeTimers--;
      /* init the state machine of all schedulers */
      DescInitSingleScheduler(DESC_RDPI_TIMER_ITER_VALUE);
    }
  }
  /* Clear all pending transmissions */
  /* Network layer must be first initialized !!! */
  DescUudtNetCancelAllResponses();
}
#endif

#if (kDescNumOfPeriodicTimers > 0)
/******************************************************************************
* NAME:              DescRdpiDeletePid
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static void DescRdpiDeletePid(vuint8 dpid)
{
  vuint8_least index;
  vuint8_least listIter;
  DESC_RDPI_TIMER_PARAM_DEF_LOCAL
  DESC_RDPI_TIMER_ITER_DEF_LOCAL

  /* Mark invalid position */
  index = (vuint8_least)0xFF;
# if (kDescNumOfPeriodicTimers > 1)
  DESC_RDPI_TIMER_ITER_VALUE = kDescNumOfPeriodicTimers; /* Search only in the scheduled timer (not SOR)*/
  while(DESC_RDPI_TIMER_ITER_VALUE != 0)
# endif
  {
    DESC_RDPI_TIMER_ITER_VALUE_DEC

    listIter = g_descSchedulerState[DESC_RDPI_TIMER_ITER_VALUE].count;
    /* check if current timer has active elements */
    while(listIter != 0)
    {
      listIter--;
      if (g_descSchedulerList[DESC_RDPI_TIMER_ITER_VALUE][listIter] == dpid)
      {
        /* Found - break all loops !!! */
        index = listIter;
        listIter = 0;
# if (kDescNumOfPeriodicTimers > 1)
        DESC_RDPI_TIMER_PARAM_VALUE = DESC_RDPI_TIMER_ITER_VALUE;
        DESC_RDPI_TIMER_ITER_VALUE = 0;
# endif
      }
    }
  }

  /* Anything found?*/
  if (index != 0xFF)
  {
    /*lint -e{644} (PClint can not know that this code will be reached only if timer is not found (initialized))*/
    g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].count--;
    if(g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].count == 0)
    {
      /* Deactivated timer */
      g_descRdpiStateCtrl.activeTimers--;
      DescInitSingleScheduler(DESC_RDPI_TIMER_PARAM_VALUE);
    }
    else
    {
      /* Adjust the currently running index */
      if(g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].currentListPos != 0)
      {
        /* Need index update? */
        if(g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].currentListPos > index)
        {
          g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].currentListPos--;
        }
        else
        {
          /* The deleted DID is the currently referenced one */
          if(g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].currentListPos == index)
          {
            /* Last element (count already decremented and points to it!)? */
            if(g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].currentListPos ==
               g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].count)
            {
              /* Same rate ? */
              if (DESC_RDPI_TIMER_PARAM_VALUE == DESC_RDPI_LAST_TIMER)
              {
                /* If the application is still not ready, let the ProcessingDone do this job */
                if(g_descDpidUudtResource == V_NULL)
                {
                  /* Index is out of boundary */
                  g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].currentListPos = 0;
                  DESC_RDPI_LAST_TIMER_INC;
                }
                /*
                else
                { nothing to change - the application will do that via ProcessingDone call. }
                */
              }
              else
              {
                /* Index is out of boundary - reset */
                g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].currentListPos = 0;
              }
            }
            /*
            else
            { nothing to change  }
            */
          }
          /*
          else
          { nothing to change  }
          */
        }
      }

      /* Move the tail (compress the list) */
      for(;index < g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].count; index++ )
      {
        g_descSchedulerList[DESC_RDPI_TIMER_PARAM_VALUE][index] = g_descSchedulerList[DESC_RDPI_TIMER_PARAM_VALUE][index + 1];
      }
    }
  }
}
#endif

#if (kDescNumOfPeriodicTimers > 0)
/*******************************************************************************
* NAME:              DescRdpiStopAll
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       Stops processing of scheduler. 
*
*******************************************************************************/
static void DescRdpiStopAll(void)
{
  /* Guarantee higher prio task processing */
  DescInterruptDisable();

  /* Check if on processing of a periodic DPID */
  if(g_descRdpiStateCtrl.lastTimer != kDescRdpiDpidSchedulingOnce)
  {
    /* Try finish data packet processing */
    DescDataPacketProcessingDone(kDescDataPacketFailedDoNotSend);
  }

  /* Check for still pending jobs */
  if(0 != (g_descRdpiStateCtrl.isPending1stAck & (~(DescUtiGetBitFromIndex(DescBitType, kDescRdpiDpidSchedulingOnce)))))
  {
    g_descRdpiStateCtrl.isPending1stAck = 0;
    /* disable the diag response */
    g_descMsgContext[g_descRdpiCurReqContext].msgAddInfo.resOnReq = 0;
    DescProcessingDone(g_descRdpiCurReqContext);
  }

  /* Init scheduler */
  DescInitScheduler();

  DescRdpiUnRegisterCanChUser(kDescRdpiUserSendPeriodic);
  DescInterruptRestore();
}
#endif

#if (kDescNumOfPeriodicTimers > 0)
/*******************************************************************************
* NAME:              DescUpdateScheduler
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Diag service. 
*
*******************************************************************************/
static void DescUpdateScheduler(DESC_RDPI_TIMER_FORMAL_PARAM_DEF_FIRST DescMsgContext *pMsgContext)
{
  vuint8_least   i;
  vuint8_least   j;
  vuint8_least   newCount;
  vuint8_least   newItem1stPos;
  DescMsg  reqData;
  DescBool result;

# if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
  /* Accept stop requests only if no scheduler is running or 
   * the scheduler was started from the same CAN channel */
  if((g_descRdpiCanChannel != kDescUudtNetNoCanChannel)&&
     (g_descRdpiCanChannel != pMsgContext->busInfo.comChannel))
  {
    g_descNegResCode[pMsgContext->iContext] = kDescNrcGeneralReject;
    DescProcessingDone(pMsgContext->iContext);
    /* Skip further processing */
    return;
  }
  DescRdpiRegisterCanChUser(kDescRdpiUserSendPeriodic);
  /* Store the new channel - if already stored - this is the same value again */
  g_descRdpiCanChannel = pMsgContext->busInfo.comChannel;
# endif

  /* Check if the length is enough */
  if(pMsgContext->reqDataLen != 0)
  {
    /* Check if the requested data will fit into the queue */
    if(pMsgContext->reqDataLen <= kDescNumOfPeriodicPids)
    {
      /* Everything fine */
      reqData = pMsgContext->reqData;

      i = pMsgContext->reqDataLen;
      newCount = g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].count;
      newItem1stPos = kDescRdpiInvalidNewDpidPos;

      /* search for supported, new DPIDs (i is at least 1)*/
      while(i != 0)
      {
        i--;
        result = DescRdpiCheckDpid(*reqData);
# if defined (DESC_ENABLE_DYN_DPID_DEFINED_CHECK)
        /* Consider DynDPIDs definition */
        if(result == kDescTrue)
        {
          result = DescDynDpidIsDefined(*reqData);
        }
# endif
        if(result == kDescTrue)
        {
          /* Find duplicates */
          j = 0;
          while(j < newCount)
          {
            if(*reqData == g_descSchedulerList[DESC_RDPI_TIMER_PARAM_VALUE][j])
            {
              /* Duplicate found */
              break;
            }
            j++;
          }

          /* Mark first new item position (also for already existing DPIDs in the scheduler list) */
          if(newItem1stPos == kDescRdpiInvalidNewDpidPos)
          {
            newItem1stPos = j;
          }

          /* Really a new one? */
          if(j == newCount)
          {
            if(newCount < kDescNumOfPeriodicPids)
            {
              /* Append new one */
              g_descSchedulerList[DESC_RDPI_TIMER_PARAM_VALUE][newCount] = *reqData;
              newCount++;
            }
            else
            {
              /* Prepare for overflow */
              g_descNegResCode[pMsgContext->iContext] = kDescOemNrcSchedulerFull;
            }
          }
          /* Next DPID */
          reqData++;
        }
        else
        {
          /* Break */
          i = 0;
          /* Overwrite possible overflow with hi prio NRC $31 */
          g_descNegResCode[pMsgContext->iContext] = kDescOemNrcDpidNotSupported;
        }
      }

      /* Everything ok ?*/
      if(g_descNegResCode[pMsgContext->iContext] == kDescNrcNone)
      {
        /* Clean up the new DPIDs from the other schedulers */

        /* Cache the offset */
        j = g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].count;
        i = (vuint8_least)(newCount - j);
        while(i != 0)
        {
          i--;
          /* This will delete the DPID from the other schedulers only 
           * since the new one did't update the new count.
           */
          DescRdpiDeletePid(g_descSchedulerList[DESC_RDPI_TIMER_PARAM_VALUE][j + i]);
        }

        /* init the timer so imediately to be ready to send if this is the first activation */
        if(g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].count == 0)
        {
          /* Force scheduler activation */
          g_descSchedulerTimer[DESC_RDPI_TIMER_PARAM_VALUE] = 1;
          g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].currentListPos = 0;

          g_descRdpiStateCtrl.activeTimers++;
        }

        /* Store the context for the response */
        g_descRdpiCurReqContext = pMsgContext->iContext;

# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
        /* In case of multicall feature on - deactivate it */
        _DescStartRepeatedServiceCall(g_descRdpiCurReqContext, V_NULL);
# endif

        /* Await acknowledge */
        g_descRdpiStateCtrl.isPending1stAck = DescUtiGetBitFromIndex(DescBitType, DESC_RDPI_TIMER_PARAM_VALUE);
        /* Update the new scheduler length and first new item scaner */
        g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].count = (vuint8)newCount;
        g_descSchedulerState[DESC_RDPI_TIMER_PARAM_VALUE].newItems1stPos = (vuint8)newItem1stPos;

      }
      /* else NRC already set */
    }
    else
    {
      g_descNegResCode[pMsgContext->iContext] = kDescOemNrcReqTooLongForScheduled;
    }
  }
  else
  {
    g_descNegResCode[pMsgContext->iContext] = kDescOemNrcZeroLength;
  }

  /* Only negative responses will be sent as USDT messages */
  if(g_descNegResCode[pMsgContext->iContext] != kDescNrcNone)
  {
    DescProcessingDone(pMsgContext->iContext);
  }
}
#endif

/*******************************************************************************
* NAME:              DescRdpiInit
*
* CALLED BY:         DescOemInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Init the AA manager
*
*******************************************************************************/
static void DescRdpiInit(void)
{
  DESC_RDPI_CONTEXT_PARAM_DEF_LOCAL

#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
  g_descRdpiCanChUsers = 0;
  /* Set to NoChannel value to allow activation of the scheduler */
  g_descRdpiCanChannel = kDescUudtNetNoCanChannel;
#endif

  /* No pending processing */
  g_descRdpiStateCtrl.isPending1stAck = 0;

#if (kDescNumOfPeriodicTimers > 0)
  /* start scanning for ready UUDT to be send */
  g_descRdpiStateCtrl.lastTimer = 0;
  /* init the module state machine - clear all flags */
  g_descRdpiStateCtrl.isWaitingResUudt = 0;
  g_descRdpiStateCtrl.activeTimers = 0;

  /* init the scheduler tables and the scheduler state machine */
  DESC_RDPI_CONTEXT_PARAM_VALUE = kDescNumOfRdpiTimers;
  while(DESC_RDPI_CONTEXT_PARAM_VALUE != 0)
#endif
  {
    DESC_RDPI_CONTEXT_PARAM_VALUE_DEC
    /* init the state machine of all schedulers */
    DescInitSingleScheduler(DESC_RDPI_CONTEXT_PARAM_ONLY);
  }
}

#if (kDescNumOfPeriodicTimers > 0)
/*******************************************************************************
* NAME:              DescRdpiTimerTask
*
* CALLED BY:         DescOemTimer
* PRECONDITIONS:     
*
* DESCRIPTION:       Dynamical management for DPID scheduling
*
*******************************************************************************/
static void DescRdpiTimerTask(void)
{
  DESC_RDPI_TIMER_ITER_DEF_LOCAL

  /* if at least one scheduled/single shot service active */
  if(g_descRdpiStateCtrl.activeTimers != 0)
  {
# if (kDescNumOfPeriodicTimers > 1)
    DESC_RDPI_TIMER_ITER_VALUE = kDescNumOfPeriodicTimers;
    while(DESC_RDPI_TIMER_ITER_VALUE != 0)
# endif
    {
      DESC_RDPI_TIMER_ITER_VALUE_DEC
      if(g_descSchedulerTimer[DESC_RDPI_TIMER_ITER_VALUE] != 0)
      {
        g_descSchedulerTimer[DESC_RDPI_TIMER_ITER_VALUE]--;
        if(g_descSchedulerTimer[DESC_RDPI_TIMER_ITER_VALUE] == 0)
        {
          if(g_descSchedulerState[DESC_RDPI_TIMER_ITER_VALUE].isTimeExpired != 0)
          {
            /* set that while the DPID list was still in sending process,
            the timer has timed out */
            g_descSchedulerState[DESC_RDPI_TIMER_ITER_VALUE].isTimeOverrun = 1;
          }
          else
          {
            g_descSchedulerState[DESC_RDPI_TIMER_ITER_VALUE].isTimeExpired = 1;
          }

          g_descSchedulerTimer[DESC_RDPI_TIMER_ITER_VALUE] = g_descSchedulerTimerReload[DESC_RDPI_TIMER_ITER_VALUE];
        }
      }
    }
  }
}
#endif

/*******************************************************************************
* NAME:              DescRdpiStateTask
*
* CALLED BY:         DescOemState
* PRECONDITIONS:     
*
* DESCRIPTION:       Dynamical management for DPID scheduling
*
*******************************************************************************/
static void DescRdpiStateTask(void)
{
  DESC_RDPI_CONTEXT_PARAM_DEF_LOCAL
  DescBool mayContinue;

#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
  if((g_descRdpiCanChUsers & kDescRdpiUserMask) == 0)
  {
    /* Free the channel on no usage*/
    g_descRdpiCanChannel = kDescUudtNetNoCanChannel;
  }
#endif

#if (kDescNumOfPeriodicTimers > 0)
  /* if awaiting response is queued */
  if(g_descRdpiStateCtrl.isWaitingResUudt != 0)
  {
    /* Shared resource with asynch API */
    if(g_descDpidUudtResource == V_NULL)
    {
# if defined(DESC_UUDTNET_ENABLE_MULTI_CLIENT)
      /* Prepare the resource init info */
      g_descUudtNetInfo.client = kDescClientScheduler;
# endif
# if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
      /* set the correct CAN channel */
      g_descUudtNetInfo.busProperty.can.canChannel = g_descRdpiCanChannel;
# endif
      /* if the UUDT msg is free */
      g_descDpidUudtResource = DescUudtNetTxReserveResource(&g_descUudtNetInfo);

      if(g_descDpidUudtResource != V_NULL)
      {
        /* no more retries */
        g_descRdpiStateCtrl.isWaitingResUudt = 0;
        DescRdpiUnRegisterCanChUser(kDescRdpiUserStopPeriodic);

        g_descDpidUudtResource->resDataPtr[0] = 0;
# if defined(DESC_UUDTNET_ENABLE_DATALENGTH_USAGE)
        g_descDpidUudtResource->dataLength = 1;
# endif
        /* send the stop scheduling response message */
        DescUudtNetTransmitResponse(g_descDpidUudtResource);
        /* Release resource */
        g_descDpidUudtResource = V_NULL;

        /* disable the diag response */
        g_descMsgContext[g_descRdpiCurReqContext].msgAddInfo.resOnReq = 0;
        DescProcessingDone(g_descRdpiCurReqContext);
      }
    }
  }
#endif

#if (kDescNumOfPeriodicTimers > 0)
  /* if at least one scheduled/single shot service active */
  if(g_descRdpiStateCtrl.activeTimers != 0)
#else
  /* Run-time optimization for idle task */
  if(g_descSchedulerState[DESC_RDPI_LAST_TIMER].isTimeExpired != 0)
#endif
  {
    /* Is access to the com bus allowed and resource is free */
    if((g_descOemStateCtrl.isUudtProcessSuspended == 0)&&
       (g_descDpidUudtResource == V_NULL))
    {
#if (kDescNumOfPeriodicTimers > 0)
      DESC_RDPI_CONTEXT_PARAM_VALUE = kDescNumOfRdpiTimers;
      do
      {
        DESC_RDPI_CONTEXT_PARAM_VALUE_DEC
        if(g_descSchedulerState[DESC_RDPI_LAST_TIMER].isTimeExpired != 0)
#endif
        {
          DescAssertInternal((g_descSchedulerState[DESC_RDPI_LAST_TIMER].count != 0), kDescAssertNoScheduledDpidsButSchedulingActive);
          do
          {
#if (kDescNumOfPeriodicTimers > 0)
            /* Cache current timer for the case application has responded immediatelly */
            vuint8_least lastTimer = g_descRdpiStateCtrl.lastTimer;
#else
            const vuint8_least lastTimer = 0;/* enforce compiler optimization */
#endif
            /* Try to get resources */
            mayContinue = kDescTrue;

            DescAssertInternal((g_descSchedulerState[lastTimer].currentListPos < kDescNumOfPeriodicPids), kDescAssertDpidListInvalidReference);
#if defined(DESC_UUDTNET_ENABLE_MULTI_CLIENT)
            /* Prepare the resource init info */
            g_descUudtNetInfo.client = kDescClientScheduler;
#endif
#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
            /* set the correct CAN channel */
            g_descUudtNetInfo.busProperty.can.canChannel = g_descRdpiCanChannel;
#endif
            /* if the UUDT msg is free */
            g_descDpidUudtResource = DescUudtNetTxReserveResource(&g_descUudtNetInfo);
            if(g_descDpidUudtResource != V_NULL)
            {
              vuint8_least dpidHandle;

              /* write into the buffer the DPID byte */
              g_descDpidUudtResource->resDataPtr[0] = g_descSchedulerList[lastTimer][g_descSchedulerState[lastTimer].currentListPos];
              dpidHandle = DescRdpiGetDpidHandle(g_descDpidUudtResource->resDataPtr[0]);
#if defined(DESC_UUDTNET_ENABLE_DATALENGTH_USAGE)
              /* Set to current byte length */
              g_descDpidUudtResource->dataLength = DescDpidMgrGetDpidResLength(dpidHandle);
              /* Don't forget the DPID byte !!! */
              g_descDpidUudtResource->dataLength++;
#endif
             /* prepare next with wrap around */
              g_descSchedulerState[lastTimer].currentListPos++;

              /* send the corresponding UUDT message */
              /* get the corresponding application handler */
              g_descDpidHandlerTable[dpidHandle](&(g_descDpidUudtResource->resDataPtr[1]));

              /* If listPos == 0 -> this timer has been processed. */
              if(g_descSchedulerState[lastTimer].currentListPos == 0)
              {
                /* Leave current scheduler list */
                mayContinue = kDescFalse;
                /* Let other timer to be evaluated */
                /* DESC_RDPI_CONTEXT_PARAM_VALUE_SET(0)*/
              }

              /* If asynch (res != 0) - check later */
              if(g_descDpidUudtResource != V_NULL)
              {
                /* Skip this task */
                mayContinue = kDescFalse;
                DESC_RDPI_CONTEXT_PARAM_VALUE_SET(0)
              }
            }
            else
            {
              /* Skip this task */
              mayContinue = kDescFalse;
              DESC_RDPI_CONTEXT_PARAM_VALUE_SET(0)
            }
          }
          while(mayContinue == kDescTrue);
        }
#if (kDescNumOfPeriodicTimers > 0)
        else
        {
          DESC_RDPI_LAST_TIMER_INC;
        }
      }
      while(DESC_RDPI_CONTEXT_PARAM_VALUE != 0);
#endif
    }
  }
}

#if (kDescNumOfPeriodicTimers > 0)
/*******************************************************************************
* NAME:              DescReadDpidStop
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Diag service. 
*
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescReadDpidStop(DescMsgContext *pMsgContext)
{
  vuint8_least i;
  DescMsg reqData;


# if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
  /* Accept stop requests only if no scheduler is running or 
   * the scheduler was started from the same CAN channel */
  if((g_descRdpiCanChannel != kDescUudtNetNoCanChannel)&&
     (g_descRdpiCanChannel != pMsgContext->busInfo.comChannel))
  {
    g_descNegResCode[pMsgContext->iContext] = kDescNrcGeneralReject;
    DescProcessingDone(pMsgContext->iContext);
    /* Skip further processing */
    return;
  }

  DescRdpiRegisterCanChUser(kDescRdpiUserStopPeriodic);
  /* Store the new channel - if already stored - this is the same value again */
  g_descRdpiCanChannel = pMsgContext->busInfo.comChannel;
# endif

  reqData = &pMsgContext->reqData[0];
  i = pMsgContext->reqDataLen;
  if(i == 0)
  {
    /* Stop the all schedulled DPIDs */
    DescRdpiStopAll();
  }
  else
  {
    /* check for matching length */
    if(i > kDescNumOfPeriodicPids)
    {
      g_descNegResCode[pMsgContext->iContext] = kDescOemNrcReqTooLongForScheduled;
      DescProcessingDone(pMsgContext->iContext);
      /* Skip further processing */
      return;
    }
    while (i != 0)
    {
      i--;
      DescRdpiDeletePid(reqData[i]);
    }

    /* If no timer active - flush the current responses */
    if(g_descRdpiStateCtrl.activeTimers == 0)
    {
      /* Clear all pending transmissions */
      DescUudtNetCancelAllResponses();
      DescRdpiUnRegisterCanChUser(kDescRdpiUserSendPeriodic);
    }
  }
# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  /* In case of multicall feature on - deactivate it */
  _DescStartRepeatedServiceCall(pMsgContext->iContext, V_NULL);
# endif

  /* store the context index for the later response processing done acknowledge */
  g_descRdpiCurReqContext = pMsgContext->iContext;
  /* set queued answer */
  g_descRdpiStateCtrl.isWaitingResUudt = 1;
}
#endif

/*******************************************************************************
* NAME:              DescReadDpidOnce
*
* CALLED BY:         DescDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Diag service. 
*
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescReadDpidOnce(DescMsgContext *pMsgContext)
{
  vuint8_least i;
  DescMsg      reqData;
  DescBool     found;


#if defined(DESC_UUDTNET_ENABLE_DYN_MULTICAN_SUPPORT)
  /* Accept stop requests only if no scheduler is running or 
   * the scheduler was started from the same CAN channel */
  if((g_descRdpiCanChannel != kDescUudtNetNoCanChannel)&&
     (g_descRdpiCanChannel != pMsgContext->busInfo.comChannel))
  {
    g_descNegResCode[pMsgContext->iContext] = kDescNrcGeneralReject;
    DescProcessingDone(pMsgContext->iContext);
    /* Skip further processing */
    return;
  }
  DescRdpiRegisterCanChUser(kDescRdpiUserSendOnce);
  /* Store the new channel - if already stored - this is the same value again */
  g_descRdpiCanChannel = pMsgContext->busInfo.comChannel;
#endif

  g_descRdpiCurReqContext = pMsgContext->iContext;
  i = pMsgContext->reqDataLen;

  /* check for non zero length */
  if (i != 0)
  {
    /* check for matching length */
    if(i <= kDescNumOfPeriodicPids)
    {
      reqData = pMsgContext->reqData;
      found = kDescTrue;
      /* Check for all valid DPIDs */
      while((i != 0)&&(found == kDescTrue))
      {
        i--;
        /* Check if all DPIDs are supported - else reject the request */
        found = DescRdpiCheckDpid(reqData[i]);
#if defined (DESC_ENABLE_DYN_DPID_DEFINED_CHECK)
        /* Consider DynDPIDs definition */
        if(found == kDescTrue)
        {
          found = DescDynDpidIsDefined(*reqData);
        }
#endif
      }
      /* is everything fine? */
      if(found == kDescTrue)
      {
        /* Check if already running */
        if(g_descSchedulerState[kDescRdpiDpidSchedulingOnce].count == 0)
        {
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
          /* In case of multicall feature on - deactivate it */
          _DescStartRepeatedServiceCall(pMsgContext->iContext, V_NULL);
#endif
          /* store the length of the list for SOR */
          g_descSchedulerState[kDescRdpiDpidSchedulingOnce].count = (vuint8)pMsgContext->reqDataLen;
          /* The list is valid - refresh the single shot scheduler */
          DescMsgCopyFarRamToRam(
                              g_descSchedulerList[kDescRdpiDpidSchedulingOnce],
                              &reqData[0],
                              (vuint16)g_descSchedulerState[kDescRdpiDpidSchedulingOnce].count);

#if (kDescNumOfPeriodicTimers > 0)
          /* set the flag for isActive single shot */
          g_descRdpiStateCtrl.activeTimers++;
#endif
          /* Await acknowledge */
          g_descRdpiStateCtrl.isPending1stAck = DescUtiGetBitFromIndex(DescBitType, kDescRdpiDpidSchedulingOnce);
          /* Done at scheduler init (timer specific) */
          g_descSchedulerState[kDescRdpiDpidSchedulingOnce].isTimeExpired = 1;
          g_descSchedulerState[kDescRdpiDpidSchedulingOnce].currentListPos = 0;  /* Start from the begining */
          g_descSchedulerState[kDescRdpiDpidSchedulingOnce].newItems1stPos = 0;  /* Always the first element is the new one */
          /* Jump out */
          return;
        }
        else
        {
          g_descNegResCode[g_descRdpiCurReqContext] = kDescNrcBusyRepeatRequest;
        }
      }
      else
      {
        g_descNegResCode[g_descRdpiCurReqContext] = kDescOemNrcDpidNotSupported;
      }
    }
    else
    {
      g_descNegResCode[g_descRdpiCurReqContext] = kDescOemNrcReqTooLongForScheduled;
    }
  }
  else
  {
    g_descNegResCode[g_descRdpiCurReqContext] = kDescOemNrcZeroLength;
  }

  DescProcessingDone(g_descRdpiCurReqContext);
}

#if (kDescNumOfPeriodicTimers > 0)
/*******************************************************************************
* NAME:              DescPostReadDpidPeriodic
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Activate S1 timer as timed service. 
*
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescPostReadDpidPeriodic(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  if((status & kDescPostHandlerStateOk) != 0)
  {
    /* Reload timer only if at least one periodic timer is still active */
    if((g_descSchedulerState[0].count != 0)
# if (kDescNumOfPeriodicTimers > 1)
       || (g_descSchedulerState[1].count != 0)
# endif
# if (kDescNumOfPeriodicTimers > 2)
       || (g_descSchedulerState[2].count != 0)
# endif
       )
    {
      DescStartS1Timer();
    } /* else - no periodic scheduler active (-> do not reload timer */
  }
}
#endif


/*******************************************************************************
* NAME:              DescRdpiGetDpidHandle
*
* CALLED BY:         DescRdpiExecutePid
* PRECONDITIONS:     
*
* DESCRIPTION:       Convert DPID to its linear index(handle). 
*
*******************************************************************************/
static vuint8_least DescRdpiGetDpidHandle(vuint8 dpid)
{
  vuint8_least i;
  vuint8_least bitMask;
  vuint8_least bits;
  vuint8_least dpidRow;
  /* bit counter mask */
  bitMask = 1;
  /* reset the counter */
  bits = 0;
  dpidRow = RdpiGetRow(dpid);
  for(i = RdpiGetCol(dpid);i != 0 ;i--)
  {
    if((g_descDpidSearchTable[dpidRow] & bitMask) != 0)
    {
      bits++;
    }
    bitMask <<=1;
  }

  DescAssertInternal(((g_descDpidSearchBitSumTable[dpidRow] + bits) < kDescRdpiDpidNumItems), kDescAssertInvalidDpidHandle);

  return (vuint8_least)(g_descDpidSearchBitSumTable[dpidRow] + bits);
}

/*******************************************************************************
* NAME:              DescRdpiCheckDpid
*
* CALLED BY:         DescUpdateScheduler, DescOemReadDpidStopSending, DescOemReadDpidSendOneRes
* PRECONDITIONS:     
*
* DESCRIPTION:       Checks if the requested DPID is supported by the configuration. 
*
*******************************************************************************/
static DescBool DescRdpiCheckDpid(vuint8 dpid)
{
  DescBool result = kDescFalse;
  vsint8_least dpidRow;

  dpidRow = (vsint8_least)((dpid >> 3) - kDescRdpiTableBottomOffset);

#if (kDescRdpiTableBottomOffset > 0)
  if(dpidRow >= 0)
#endif
  {
/* Only if there is a top offset difference */
#if (kDescRdpiTableTopOffset > 0)
    if(dpidRow < kDescRdpiDpidSearchTableSize)
#endif
    {
#if (kDescRdpiTableBottomOffset > 0)
      if((dpidRow + kDescRdpiTableBottomOffset) >= kDescRdpiTableBottomOffset)
#endif
      {
        if((g_descDpidSearchTable[dpidRow] & (vuint8)(0x01<<RdpiGetCol(dpid))) != 0)
        {
          result = kDescTrue;
        }
      }
    }
  }
  return result;
}

/*******************************************************************************
* NAME:              DescDataPacketProcessingDone
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Acknowledged DataPacket
*
*******************************************************************************/
void DescDataPacketProcessingDone(DescDataPacketProcessStatus status)
{
  /* Should be asserted but in release mode - ignore application */
  if(g_descDpidUudtResource != V_NULL)
  {
    /* Scheduler still running? */
    if (g_descSchedulerState[DESC_RDPI_LAST_TIMER].count != 0)
    {
#if (kDescNumOfPeriodicTimers > 0)
      /* Drop any pending UUDTs during susspend mode */
      if((g_descOemStateCtrl.isUudtProcessSuspended != 0) &&
         (g_descRdpiStateCtrl.lastTimer != kDescRdpiDpidSchedulingOnce))
      {
        status = kDescDataPacketFailedDoNotSend;
      }
#endif
      switch(status)
      {
        case kDescDataPacketFailedSendDummy:
          /* Fill the data with zeroes */
#if defined(DESC_UUDTNET_ENABLE_DATALENGTH_USAGE)
          VStdMemSet(&g_descDpidUudtResource->resDataPtr[1],
                     kDescUudtNetPaddingByte,
                     g_descDpidUudtResource->dataLength);
#else
          VStdMemSet(&g_descDpidUudtResource->resDataPtr[1],
                     kDescUudtNetPaddingByte,
                     (vuint8)(kDescUudtNetFrameLen - 1));
#endif
          /* Fall through */
        case kDescDataPacketOk:
          /* send the message */
          DescUudtNetTransmitResponse(g_descDpidUudtResource);
          break;
        case kDescDataPacketFailedDoNotSend:
          /* Something went wrong - release the UUDT resource */
          DescUudtNetReleaseResource(g_descDpidUudtResource);
          break;
        default:/* nothing to do: the enum type is check by the compiler */break;
      }

      /* Use ">" since pre-increment is used -> once > then this was the first new DPID.*/
      if(g_descSchedulerState[DESC_RDPI_LAST_TIMER].currentListPos >
         g_descSchedulerState[DESC_RDPI_LAST_TIMER].newItems1stPos)
      {
        /* No more pending jobs */
        g_descRdpiStateCtrl.isPending1stAck = 0;
        /* Prevent from further checks */
        g_descSchedulerState[DESC_RDPI_LAST_TIMER].newItems1stPos = kDescRdpiInvalidNewDpidPos;

        /* disable the diag response */
        g_descMsgContext[g_descRdpiCurReqContext].msgAddInfo.resOnReq = 0;
        DescProcessingDone(g_descRdpiCurReqContext);
      }

      /* Was that the last element? */
      if(g_descSchedulerState[DESC_RDPI_LAST_TIMER].currentListPos >= g_descSchedulerState[DESC_RDPI_LAST_TIMER].count)
      {
        /* Wrap around */
        g_descSchedulerState[DESC_RDPI_LAST_TIMER].currentListPos = 0;

        /* Check if send once or cycled one */
#if (kDescNumOfPeriodicTimers > 0)
        if(g_descRdpiStateCtrl.lastTimer == kDescRdpiDpidSchedulingOnce)
        {
          g_descRdpiStateCtrl.activeTimers--;
#endif
          DescRdpiUnRegisterCanChUser(kDescRdpiUserSendOnce);
          /*--------------------------------------------------*/
          DescInitSingleScheduler(DESC_RDPI_CONTEXT_PARAM_USAGE(kDescRdpiDpidSchedulingOnce));
          /*--------------------------------------------------*/
#if (kDescNumOfPeriodicTimers > 0)
        }
        else
        {
          /* Check if the timer has again expired while this sending was in progress:
          if so - start immediate the next transmission sequence,
          otherwise - there is free time - lets have a break */
          if(g_descSchedulerState[DESC_RDPI_LAST_TIMER].isTimeOverrun == 1)
          {
             g_descSchedulerState[DESC_RDPI_LAST_TIMER].isTimeOverrun = 0;
          }
          else
          {
            /* the time is ok - skip further checks */
            g_descSchedulerState[DESC_RDPI_LAST_TIMER].isTimeExpired = 0;
          }
        }
        DESC_RDPI_LAST_TIMER_INC;
#endif
      }
    }
    else
    {
      /* Stop session issued - release UUDT transmitter resources */
      DescUudtNetReleaseResource(g_descDpidUudtResource);
    }
    /* Release resource */
    g_descDpidUudtResource = V_NULL;
  }
}

/*******************************************************************************
* NAME:              DescIterInitPidListProcessor
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       Subcomponent initialization
*******************************************************************************/
static void DescIterInitPidListProcessor(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* These are initilized each time a request has been received */
  /*g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount = 0;
   *g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid = 0;
    g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidProcessed = 0;*/
  /* No PID to be processed */
  g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady = 0;

}

/*******************************************************************************
* NAME:              DescPidProcessingDone
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Subcomponent processing done for a single PID 
* iContext for the main response is also the same for the DID 
*******************************************************************************/
static void DescPidProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);

#if defined (DESC_ENABLE_RES_RINGBUFFER)
  /********************************************************/
  /*        Mixed mode (Ring buffer || Linear)            */
  /********************************************************/
  /* The length will be composed in the PidDispatcher */
# if defined (DESC_ENABLE_DEBUG_USER )
  {
    DescMsgLen expectedPidLen;
#  if defined(DESC_ENABLE_UNIFIED_PID_MGR)
    /* Check for dynamic response length and multiple PID request */
    expectedPidLen = ApplDescGetPidDataLength(pidTypeReadOnce, g_descPidList[DESC_CONTEXT_PARAM_VALUE][g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid]);
    /* Add the PID itself */
    expectedPidLen+=2;
#  else
    expectedPidLen = DescPmGetPidResponseLen(g_descPidList[DESC_CONTEXT_PARAM_VALUE][g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid]);
#  endif

#  if defined (DESC_ENABLE_DYN_DID_RES_LENGTH)
    /* Check for non-dynamic length */
    if(expectedPidLen != 0)
#  endif
    {
      DescAssertUser(((g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen == expectedPidLen)||
                      (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)), kDescAssertPidResLenToCddDefNotMatched);
    }/* else: for dynamic length - no validation */
  }
# endif
  /* PID processing finished */
  g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidProcessed = 1;

# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  /* If no ring buffer currently in use 
   * OR
   * the transmission has been started AND current PID does not support ring-buffer
   * -> stop multiple calls 
   */
  if((g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0) ||
    ((g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferTxActive != 0) &&
     (g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferReactivated == 0)))
# endif
  {
    /* Deactivate the multicall mechanism */
    _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
  }

  /* Check if a response transmission has been started */
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveProcess)
  {
    /* if there was an error detection - make negative response */
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
    {
      /* Go on with the response */
      DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
    }
    else
    {
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr[0] += kDescPosResIdOffset;
# if defined (DESC_ENABLE_DYN_DID_RES_LENGTH)
      /* Handling of DID with dynamic data length */
      if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen == 2)
      {
        /* If no response length set - the only PID is with dynamic length - use the application length */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
      }
# endif
      /* Set response length (add the Sid byte length) */
      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += 1;
      /* No transmission started yet and RingBuffer active means: first RingBuffer PID */
      if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0)
      {
        DescLinearResponseProcessing(DESC_CONTEXT_PARAM_ONLY);
      }
      /* Set ring buffer is under transmission */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferTxActive = 1;
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive = 1;

      /* Mark that from now on a single response will be sent */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTxReady;
    }
  }
  else
  {
    /* Check if there is still a positive response */
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
    {
      /* Force buffer underrun in the RingBufferCopy function */
      g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;
    }
    else
    {
      /* Check if this is a linear response */
      if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferReactivated == 0)
      {
        /* -- Linear -- */
        DescLinearResponseProcessing(DESC_CONTEXT_PARAM_ONLY);
      }
    }
  }
#else
  /********************************************************/
  /*                  Pure linear mode                    */
  /********************************************************/
    /* Stop always the current main-handler cyclic call */
  _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);

  /* Check positive or negative responses */
  if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
  {
    /* Calculate the common length up to now (including the PID previosely placed) */
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen + kDescReservedBytesForPid;

    /* Check BUS's buffer overflow */
    if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen > (DescMsgLen)(4095 - 1))
    {
      /* Accept only bus specific length */
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcResponseTooLong;
    }
    else
    {
      g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData += g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
      /* Process next PID */
      g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid++;

      if(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid <
         g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount)
      {
        /* No transmission up to now initiated, no ring buffer used - only linear buffer usage - take immediatelly the next PID */
        g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady = 1;
        /* Skip the final response activation */
        return;
      }
    }
  }
  /* Go on with the response */
  DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
#endif
}

/*******************************************************************************
* NAME:              DescPidProcessorTask
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Subcomponent task functionality. Polling mode.
* 
*******************************************************************************/
static void DescPidProcessorTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  DescPidInstIndex pidHandle;

  /* Active task only if PID list mode active */
  if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode == kDescContextModePidList)
  {
    /* Process next PID? */
    if(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady !=0)
    {
      g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady = 0;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
      /* Reset the temporary state (may be the next PID will use linear buffer who knows :o) ) */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferReactivated = 0;
#endif
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
      /* Set post handler to be called */
      DescPidDoQueuePostHandlerAt(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid);
#endif
      /*---------------------*/
      /* Execute main handler*/
      /*---------------------*/
      /* Cache the reference */
      pidHandle = g_descPidList[DESC_CONTEXT_PARAM_VALUE][g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid];
      {
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
        /* Use the global service id $22 preferences */

        /* Copy the PID again */
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData = g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData;
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData[0] = DescGetHiByte(pidHandle);
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData[1] = DescGetLoByte(pidHandle);
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen = 2;
#else
        /* Copy the response information */
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = g_descPIDInfo[pidHandle].tinyInfo.msgAddInfo.resOnReq;
        /* Put the PID inside */
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData[0] = DescGetHiByte(g_descPIDInfo[pidHandle].reqPid);
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData[1] = DescGetLoByte(g_descPIDInfo[pidHandle].reqPid);
#endif
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData += kDescReservedBytesForPid;

        /* Copy this location into the original context to be able to use the free linear space calculation function */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resData = g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData;

        /* Zero the response length */
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = 0;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex += kDescReservedBytesForPid;
        /* Once started transmission - there are no data rather than the PID inside */
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten = 0;
        /* Initiate the none application data length - PID is 2 Byte or the first time 3Byte*/
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen += kDescReservedBytesForPid;
#endif

#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
        /* If each service needs it - start always here to save ROM for the application */
        _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, ApplDescReadDataByIdentifier);
# endif
        /* Call the only available main-handler for PID read: Sid $22's one.*/
        ApplDescReadDataByIdentifier(&g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE]);
#else
# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
        /* If each service needs it - start always here to save ROM for the application */
        _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, g_descPIDInfo[pidHandle].mainHandler);
# endif
        /* Give the control to the application */
        g_descPIDInfo[pidHandle].mainHandler(&g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE]);
#endif
      }
    }
  }
}

/*******************************************************************************
* NAME:              DescPidDispatcher
*
* CALLED BY:         PidTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Processes a single PID with dispatcher functionality.
* 
*******************************************************************************/
static void DescPidDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  vuint8_least     iter;
  DescPidInstIndex pidHandle;

#if defined(DESC_ENABLE_PID_NRC_ALL_ON_WRONG_SESSION)
  vuint8_least     numPidsNotSuppInSession = 0;
#endif

  /* No data to be send to the application */
  g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen = 0;
  /* Init the counter */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen >>= 1; /* (length div 2), since the PID are 2 Byte */
  /* Already initialized in DescDispatcher */
  /* g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = 0; */

#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
  /* Clear the post-handler queue */
  iter = (vuint8_least)kDescNumPostHdlrQueueBytes;
  while(iter > 0)
  {
    iter--;
    g_descPidPostHdlrQueue[iter] = 0;
  }
#endif
  g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount = 0;
  /* Initialize the current PID ref to be processed */
  g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid = 0;

  /* Req data len contains still the count of the PIDs */
  /* Process all PIDs until an error has been detected */
  iter = g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen;
  while((iter != 0)&&
        (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone))
  {
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
    DescBool isSupported;
    pidHandle = DescMake16Bit(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[0],
                              g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[1]);
    isSupported = ApplDescIsPidSupported(pidTypeReadOnce, pidHandle);
#else
    /* Find PID (use main pool since each read-able PID is accessible by $22)*/
    pidHandle = DescPmGetAvailablePidHandle(DescMake16Bit(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[0],
                                                          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[1]));
#endif
    /* Decrement counter (already divided by 2) */
    iter--;
    /* Next PID prepare */
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData +=2;

    /* If found */
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
    if(isSupported != kDescFalse)
#else
    if(pidHandle < kDescInvalidPidHandle)
#endif
    {
      /* Found - Jepiiii */
      DescMsgLen pidResLen;
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
      /* Check for dynamic response length and multiple PID request */
      pidResLen = ApplDescGetPidDataLength(pidTypeReadOnce, pidHandle);
#else
      /* Check for dynamic response length and multiple PID request */
      pidResLen = DescPmGetPidResponseLen(pidHandle);
#endif

#if defined (DESC_ENABLE_DYN_DID_RES_LENGTH)
      /* Only in single PID mode and if last PID in the list, a PID with dynamic length will be accepted */
      if((pidResLen != 0)||
# if defined (DESC_ENABLE_RES_RINGBUFFER)
        /* Ringbuffer: with dynamic length may be only single PID request */
        (g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen == 1)
# else
        /* Linear: with dynamic length may be only the last PID or single PID request */
        (iter == 0)
# endif
        )/* end if expr */
#endif
      {
#if !defined(DESC_ENABLE_UNIFIED_PID_MGR) &&  defined(DESC_ENABLE_SKIP_PID)
        DescPidAnalyseFailureReason analyseReason;
#endif
        g_descPidList[DESC_CONTEXT_PARAM_VALUE][g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount] = (DescMemPidInstIndex)pidHandle;
        /* Do dispatch the PID */
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = ApplDescVerifyPidAccessConditions(pidTypeReadOnce, pidHandle);
#else
# if defined(DESC_ENABLE_SKIP_PID)
        analyseReason = DescPmAnalysePid(DESC_CONTEXT_PARAM_FIRST &g_descPIDInfo[pidHandle].tinyInfo);
# else
        (void)DescPmAnalysePid(DESC_CONTEXT_PARAM_FIRST &g_descPIDInfo[pidHandle].tinyInfo);
# endif
#endif
        {
          /* if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone) -> PostHandler has to be called in any case */
#if defined(DESC_ENABLE_SKIP_PID)
# if defined(DESC_ENABLE_UNIFIED_PID_MGR)
          switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
# else
          switch(analyseReason)
# endif
#endif
          {
#if defined(DESC_ENABLE_SKIP_PID)
# if defined(DESC_ENABLE_UNIFIED_PID_MGR)
#  if defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION)
          case kDescOemNrcParamIdNotSupportedInSession:
          /*Fall Through*/
#  endif
#  if defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SECURITY_STATE)
          case kDescOemNrcParamIdNotSupportedInSecurityState:
          /*Fall Through*/
#  endif
# else
#  if defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION)
          case pmAnalyseReasonSession:
          /*Fall Through*/
#  endif
#  if defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SECURITY_STATE)
          case pmAnalyseReasonSecurityState:
#  endif
# endif
              /* Just treat it as "not supported" - undo the registered NRC */
            g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcNone;
# if defined(DESC_ENABLE_PID_NRC_ALL_ON_WRONG_SESSION)
            ++numPidsNotSuppInSession;
# endif
            break;
         default:
#endif /*DESC_ENABLE_SKIP_PID*/
#if defined (DESC_ENABLE_PID_PREHANDLER_USAGE) && \
    defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
            /* Check for non-dummy pre-handler */
            if(g_descPIDInfo[pidHandle].tinyInfo.preHandlerRef != 0)
            {
              /* Set post handler to be called */
              DescPidDoQueuePostHandlerAt(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount);
            }
#endif
            /* One PID found - set it here because it will be used also for the post handler call */
            g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount++;
            /* Add the current PID response dataLen to the total response */
            g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += (DescMsgLen)(pidResLen + 2);

          } /*switch*/
        }
      }
#if defined (DESC_ENABLE_DYN_DID_RES_LENGTH)
      else
      {
        /* A PID with non constant length is illegally used */
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
      }
#endif
    }
  }
  /* If not found - no more elements */
  if(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount == 0)
  {
#if defined(DESC_ENABLE_PID_NRC_ALL_ON_WRONG_SESSION)
    if(numPidsNotSuppInSession != 0)
    {
      /* Set the session NRC only if the supported PIDs were not supported in the session */
      DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescOemNrcParamIdNotSupportedInSession);
    }
    else
#endif
    {
      /* May be no PID found - negative response */
      /* Important : use the function call to avoid overwriting of the NRC if previously set */
      DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescNrcRequestOutOfRange);
    }
  }

  /* Check bus's buffer overflow */
  if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen > (DescMsgLen)(4095 - 1)
#if !defined (DESC_ENABLE_RES_RINGBUFFER)
    /* If linear buffer - check for overflow */
     || g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen > (DescMsgLen)(DescGetAvailBufferLenByMsgContext(&g_descMsgContext[DESC_CONTEXT_PARAM_VALUE]) - 1)
#endif
    )
  {
    /* Accept only bus specific length */
    /* Important : use the function call to avoid overwriting of the NRC if previously set */
    DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescOemNrcResponseTooLong);
  }
#if !defined (DESC_ENABLE_RES_RINGBUFFER)
  /* If linear buffer - build the total length iteractively (assume dynamic length signals) */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = 0;
#endif
}

/*******************************************************************************
* NAME:              DescPostReadDataByIdentifier
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Post handler for PID list handling.
* 
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescPostReadDataByIdentifier(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
  DescPidInstIndex localPidInfoRef;


  localPidInfoRef = 0;
  /* Merge the main response status with the applications */
  while(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount != 0)
  {
    /* Check if the post handler may be called */
    if(DescPidIsPostHandlerQueuedAt(localPidInfoRef))
    {
      /* Call the post handler */
      g_descPostHandlerTable[g_descPIDInfo[g_descPidList[DESC_CONTEXT_PARAM_VALUE][localPidInfoRef]].postHandlerRef](DESC_CONTEXT_PARAM_FIRST status);
    }
    /* Decrement queued count */
    g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount--;
    /* Take the next post handler */
    localPidInfoRef++;
  }
#endif
#if defined (DESC_ENABLE_RES_RINGBUFFER)
  /* If no ring buffer active -> the transmission will start through DescFinalProcessingDone() which sets the context back to normal */
  /* Set the CANdesc in a normal mode */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;
#endif
  DESC_IGNORE_UNREF_PARAM(status);
#if (kDescNumContexts > 1)
  DESC_IGNORE_UNREF_PARAM(DESC_CONTEXT_PARAM_VALUE);
#endif
}

/*******************************************************************************
* NAME:              DescReadDataByIdentifier
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Main handler for PID list handling.
* 
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescReadDataByIdentifier(DescMsgContext *pMsgContext)
{
  /* Use iContext when necessary */
  DESC_CONTEXT_PARAM_DEF_LOCAL

#if (kDescNumContexts > 1)
  /* Use iContext as name to be able to use the DESC_CONTEXT_PARAM_VALUE macro */
  DESC_CONTEXT_PARAM_VALUE = pMsgContext->iContext;
#endif

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  /* Disable this multiple service call */
  _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
#endif
  /* The length for this service shall be ZERO to allow the application (CANdesc) 
   * to check it */
  /* Check if at least one PID is available (at least 2 Byte) */
  /* Check if the length is multiple of 2, since each PID is 2 Byte.*/
  if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen > 1)&&
    ((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen & 0x01) == 0))
  {
    /* Also the capacity of the ECU shall not be exceeded */
    if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen >> 1) <= kDescNumMaxPidList)
    {
      /* Set the CANdesc in a PID List mode */
      g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModePidList;
      /* Copy the original structure */
      g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE] = *pMsgContext;
      /* Dispatch all PID */
      DescPidDispatcher(DESC_CONTEXT_PARAM_ONLY);
      /* Check if any error was found */
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
      {
        /* Prepare for datat processing */
#if defined (DESC_ENABLE_RES_RINGBUFFER)
        /* Start from the begining */
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex = 0;
        /* Write after the SID */
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex = 1;
        /* Once started transmission - there are no data rather than the PID inside (will be written later) */
        /* g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten = 0;*/
        /* Initiate the none application data length - 1Byte SID*/
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen = 1;
        g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidProcessed = 0;
#endif
        /* Process the first PID 
        * stack utilization optimization */
        g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady = 1;
        return;
      }
    }
    else
    {
      /* Too many PIDs */
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcTooManyPIDs;
    }
  }
  else
  {
    /* Invalid length */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
  }
#if defined (DESC_ENABLE_PROTOCOL_KWP)
  /* KWP shall not respond on failed functionally requested service $22 with NR $31 ($33 is mapped to $31)*/
  if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType == kDescFuncReq)
  {
    switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
    {
      case kDescNrcRequestOutOfRange:
        /* Fall through */
      case kDescNrcAccessDenied:
        /* Suppress response */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = 0;
        break;
      default:/* Normal processing */ break;
    }
  }
#endif
  /* Reaching this point means diagnostic error was found */
  DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}

#if defined (DESC_ENABLE_DYN_DPID_DEFINED_CHECK)
/*******************************************************************************
* NAME:              DescDynDpidIsDefined
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescBool DescDynDpidIsDefined(vuint8 dpid)
{
  DescBool result = kDescTrue;
  vuint8_least dpidHandle = DescRdpiGetDpidHandle(dpid);
  dpidHandle = DescGetDynDpidHandle(dpidHandle);

  if(dpidHandle < kDescNumDynDefinedDpids)
  {
    if(g_descDynDpidInfoTable[dpidHandle].numOfItems == 0)
    {
      /* DynDpid defined */
      result = kDescFalse;
    }
  }
  return result;
}
#endif

#if defined (DESC_UUDTNET_ENABLE_DATALENGTH_USAGE)
/*******************************************************************************
* NAME:              DescDynDpidGetResLength
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static vuint8_least DescDynDpidGetResLength(vuint8_least globalDpidHandle)
{
  vuint8_least result = g_descDpidResLengthTable[globalDpidHandle];
  /* Is it a dyn defined DPID */
  if(result == 0)
  {
    /* Convert to dyn defined */
    globalDpidHandle = DescGetDynDpidHandle(globalDpidHandle);
    result = g_descDynDpidInfoTable[globalDpidHandle].resDataLength;
  }
  return result;
}
#endif

/*******************************************************************************
* NAME:              DescGetDynDpidHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static vuint8_least DescGetDynDpidHandle(vuint8_least globalDpidHandle)
{
  vuint8_least iter = kDescNumDynDefinedDpids;
  do
  {
    iter--;
  }
  while((iter != 0)&&(g_descDynDpid2GlobalDpidHandle[iter] != globalDpidHandle));

  return (g_descDynDpid2GlobalDpidHandle[iter] != globalDpidHandle)?
          kDescNumDynDefinedDpids:iter;
}

#if defined (DESC_ENABLE_HIPERFORMANCE_DYNDID_MODE)
/*******************************************************************************
* NAME:              DescMayCallStateTaskAgain
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns true if the StateTask may be called again in the same context.
*
*******************************************************************************/
DescBool DESC_API_CALL_TYPE DescMayCallStateTaskAgain(void)
{
  DescBool result = kDescFalse;

  /* check if the nested context is ready with the service processing */
  if((g_descInterruptContextCtrl[kDescReadDynDpidContext].activity & kDescContextActivePostProcess) != 0)
  {
    if(g_descDefDynDpidContextState.isDataExtractActive != 0)
    {
      /* If no data awaiting try again */
      result = kDescTrue;
    }
  }
  return result;
}
#endif

/*******************************************************************************
* NAME:              DescOnceInitDynDefineDpid
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static void DescOnceInitDynDefineDpid(void)
{
  DescDynDpidClearTable();

  g_descDefDynDpidContextState.doProcessNextItem = 0;
  g_descDefDynDpidContextState.isDataExtractActive = 0;

  /**
   *Not needed to be init since the at request run-time will be done.
  g_descDefDynDpidContextState.currentItem = 0;
  g_descDefDynDpidContextState.lastUsedDpidHandle = 0;
  g_descDefDynDpidContextState.definedDpidHandle = 0;
  g_descDefDynDpidContextState.currentDpidLen = 0;
   */

}


/*******************************************************************************
* NAME:             DescDynDpidTask 
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static void DescDynDpidTask(void)
{
  if(g_descDefDynDpidContextState.doProcessNextItem != 0)
  {
    g_descDefDynDpidContextState.doProcessNextItem = 0;
    /* Process next PID */
    DescCommonReadDynDefinedDpid(g_descDefDynDpidContextState.uudtResPtr, g_descDefDynDpidContextState.lastUsedDpidHandle);
  }
}


/*******************************************************************************
* NAME:              DescDynDefinedDpidRxMsgInd
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static void DescDynDefinedDpidRxMsgInd(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  DescDataPacketProcessStatus dataPacketStatus = kDescDataPacketFailedSendDummy;

  if(status == kDescUsdtNetworkOk)
  {
    /* Check response type */
    if(infoPool->resType != kDescUsdtResponseNegative)
    {
      /* Are there any other items for the response ? */
      g_descDefDynDpidContextState.currentItem++;
      if(g_descDefDynDpidContextState.currentItem < g_descDynDpidInfoTable[g_descDefDynDpidContextState.lastUsedDpidHandle].numOfItems)
      {
        /* Position after the currently received data */
        g_descDefDynDpidContextState.uudtResPtr += g_descDefDynDpidContextState.currentItemLen;
        g_descDefDynDpidContextState.currentDpidLen += g_descDefDynDpidContextState.currentItemLen;

        /* Await response from the ICN */
        g_descDefDynDpidContextState.doProcessNextItem = 1;
        return;
      }
      /* Send response */
      dataPacketStatus = kDescDataPacketOk;
    }
  }
  /* Reset the state machine */
  g_descDefDynDpidContextState.isDataExtractActive = 0;
  /* Finalize DataPacket processing*/
  DescDataPacketProcessingDone(dataPacketStatus);
}

/*******************************************************************************
* NAME:              DescCommonReadDynDefinedDpid
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       PacketHandler
* 
*******************************************************************************/
static void DescCommonReadDynDefinedDpid(DescMsg tgtPtr, vuint8_least dpidHandle)
{
  t_descUsdtNetInfoPoolPtr  pUsdtResource;
  DescICNRxDataListener     dataListener;
  t_AddrInfoDescICN         addrInfo;

  /* Check if already defined*/
  if(g_descDynDpidInfoTable[dpidHandle].numOfItems != 0)
  {
    DescPidInstIndex srcPidHandle;
    if(g_descDefDynDpidContextState.isDataExtractActive == 0)
    {
      g_descDefDynDpidContextState.isDataExtractActive = 1;
      /* Start from the begining */
      g_descDefDynDpidContextState.currentItem = 0;
      g_descDefDynDpidContextState.currentDpidLen = 0;
      g_descDefDynDpidContextState.currentItemLen = 0;
      /* Store the working pid reference */
      g_descDefDynDpidContextState.lastUsedDpidHandle = (vuint8)dpidHandle;
      g_descDefDynDpidContextState.uudtResPtr = tgtPtr;
    }

    /* Create inter-context request (use same context (mirror)) */
    addrInfo.SourceContext = kDescReadDynDpidContext;
    addrInfo.TargetContext = kDescReadDynDpidContext;
    addrInfo.Client = kDescIcnClientDynDefDpid;

    srcPidHandle = g_descDynDpidInfoTable[dpidHandle].pids[g_descDefDynDpidContextState.currentItem];

    /* Configure the read data by ID listener */
    dataListener.beginIdx = 3; /* Skip the Sid and the PID */
    dataListener.endIdx = DescPmGetPidResponseLen(srcPidHandle);

    /* Check if the total length still fits into the buffer */
    if((g_descDefDynDpidContextState.currentDpidLen + dataListener.endIdx)  <= 7)
    {

      pUsdtResource = DescICNAllocateTxResource(&addrInfo);
      /* Any free ICN channel ? */
      if(pUsdtResource != V_NULL)
      {

        /* Compose request read data by DID ($22)*/
        pUsdtResource->reqDataPtr[0] = (DescMsgItem)0x22;
        pUsdtResource->reqDataPtr[1] = DescGetHiByte(g_descPIDInfo[srcPidHandle].reqPid);
        pUsdtResource->reqDataPtr[2] = DescGetLoByte(g_descPIDInfo[srcPidHandle].reqPid);
        pUsdtResource->dataLength = (vuint16)3;


#if defined (DESC_ENABLE_DEF_DYN_ID_BY_MEM)
        /* Precaution for too long responses (modified PID) */
        if(dataListener.endIdx > 7)
        {
          dataListener.endIdx = (vuint8)7;
        }
#endif

        /* Store the data block size */
        g_descDefDynDpidContextState.currentItemLen = (vuint8)dataListener.endIdx;

        /* Correct the endIndex */
        dataListener.endIdx += dataListener.beginIdx;
        /* Set target location */
        dataListener.pDestination = tgtPtr;
        /* Set the corresponding listener */
        DescICNSetRxDataListener(pUsdtResource, &dataListener);
        /* Send the request */
        DescICNSendRequest(pUsdtResource);

      }
      else
      {
        /* Retry with this item */
        g_descDefDynDpidContextState.doProcessNextItem = 1;
      }
    }
    else
    {
      g_descDefDynDpidContextState.isDataExtractActive = 0; /* Reset the state machine */
      /* Write zero data */
      /* Finalize DataPacket processing with send dummy data */
      DescDataPacketProcessingDone(kDescDataPacketOk);
    }
  }
  else
  {
    /* Write zero data */
    /* Finalize DataPacket processing with send dummy data */
    DescDataPacketProcessingDone(kDescDataPacketOk);
  }
}

/*******************************************************************************
* NAME:              DescDynDpidClearTable
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static void DescDynDpidClearTable(void)
{
  vuint8_least iter;
  iter = kDescNumDynDefinedDpids;
  while(iter != 0)
  {
    iter--;
    g_descDynDpidInfoTable[iter].numOfItems = 0;
    g_descDynDpidInfoTable[iter].resDataLength = 0;
  }
}

/*******************************************************************************
* NAME:              DescPostProcessDynamicallyDefineDpid
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static void DESC_API_CALL_TYPE DescPostProcessDynamicallyDefineDpid(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  DESC_CONTEXT_PARAM_DUMMY_USE;
  if((status & kDescPostHandlerStateOk) != 0)
  {
    /* Allow the new PID information access */
    g_descDynDpidInfoTable[g_descDefDynDpidContextState.definedDpidHandle] = g_descDynDpidTempInfoTable;
  }
}

/*******************************************************************************
* NAME:             DescDefDynDpidAppendPidDefinition
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static void DescDefDynDpidAppendPidDefinition(DescMsgContext* pMsgContext)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL
  DescMsg          reqData;
  vuint8_least     numOfElements;

#if (kDescNumContexts > 1)
  /* Use iContext as name to be able to use the DESC_CONTEXT_PARAM_VALUE macro */
  DESC_CONTEXT_PARAM_VALUE = pMsgContext->iContext;
#endif

  /* skip the dyn dpid */
  reqData = (DescMsg)(pMsgContext->reqData + 1);
  numOfElements = (vuint8_least)(pMsgContext->reqDataLen >> 1);

  g_descDynDpidTempInfoTable.numOfItems = 0;
  g_descDynDpidTempInfoTable.resDataLength = 0;

  for (; numOfElements != 0; --numOfElements)
  {
    DescPidInstIndex srcPidHandle;
    /* Is the PID available (also dynamic PIDs can be asked) */
    srcPidHandle = DescPmGetAvailablePidHandle(DescMake16Bit(reqData[0],reqData[1]));
    reqData+=2;

    if(srcPidHandle < kDescInvalidPidHandle)
    {
      /* Analyze for state access */
      DescPidAnalyseFailureReason reason;
      reason = DescPmAnalysePid(DESC_CONTEXT_PARAM_FIRST &g_descPIDInfo[srcPidHandle].tinyInfo);

      if(kDescNrcNone != g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
      {
        if (pmAnalyseReasonOther != reason)
        { /* abort everything if the error is application defined */
          g_descDynDpidTempInfoTable.numOfItems = 0;
          g_descDynDpidTempInfoTable.resDataLength = 0;
          break;
        }
        else
        { /* Just skip this PID, and prepare the NRC register for the next PID */
          g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcNone;
        }
      }
      else
      {
        /* Add to the (temporary) DPID definition */
        g_descDynDpidTempInfoTable.pids[g_descDynDpidTempInfoTable.numOfItems] = (DescMemPidInstIndex)srcPidHandle;
        g_descDynDpidTempInfoTable.numOfItems++;
        g_descDynDpidTempInfoTable.resDataLength += DescPmGetPidResponseLen(srcPidHandle);
      }
    }
    else
    {
      /* abort everything if at least one PID is not supported by the ECU */
      g_descDynDpidTempInfoTable.numOfItems = 0;
      g_descDynDpidTempInfoTable.resDataLength = 0;
      break;
    }
  }
}

/*******************************************************************************
* NAME:              DescProcessDynamicallyDefineDpid
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static void DescProcessDynamicallyDefineDpid(DescMsgContext* pMsgContext)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL
  DescBool  dpidFound;

#if (kDescNumContexts > 1)
  /* Use iContext as name to be able to use the DESC_CONTEXT_PARAM_VALUE macro */
  DESC_CONTEXT_PARAM_VALUE = pMsgContext->iContext;
#endif

  /* Echoe the requested sub-function */
  pMsgContext->resDataLen = 1;
  /* Skip the DPID */
  pMsgContext->reqDataLen--;

  /* At least one PID must be there. If more check the length to be an even number and to fit the list */
  if((pMsgContext->reqDataLen < 2) ||
    ((pMsgContext->reqDataLen & 0x01) != 0) ||
     (pMsgContext->reqDataLen > (kDescDynDpidMaxNumElements * 2)))
  {
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
  }
  else
  {
    /* Find out if the DID exists and... */
    dpidFound = DescRdpiCheckDpid(pMsgContext->reqData[0]);
    if(dpidFound == kDescTrue)
    {
      /* get global handle */
      g_descDefDynDpidContextState.definedDpidHandle = (vuint8)DescRdpiGetDpidHandle(pMsgContext->reqData[0]);
      /* Get corresponding dyn DPID handle*/
      g_descDefDynDpidContextState.definedDpidHandle = (vuint8)DescGetDynDpidHandle(g_descDefDynDpidContextState.definedDpidHandle);

      /* if it is a dynamically define-able one. */
      /* Store for the post-procesing */
      if(g_descDefDynDpidContextState.definedDpidHandle < kDescNumDynDefinedDpids)
      {
        /* Append the PIDs */
        DescDefDynDpidAppendPidDefinition(pMsgContext);

        if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
        { /* No error while analyzing the PIDs, perform additional sanity checks */
          if (0 == g_descDynDpidTempInfoTable.numOfItems)
          { /* All PIDs were skipped (1st priority error) */
            g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
          }
          else if(g_descDynDpidTempInfoTable.resDataLength > 0x07)
          { /* Total DPID length must not exceed 7Byte (2nd priority error)*/
            g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
          }
          else
          { /* No error at all, DPID successfully defined */
          }
        }
        /* else keep the application defined error code */
      }
      else
      {
        /* The DPID is supported but not dynamically define-able*/
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
      }
    }
    else
    {
      /* Out of range */
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
    }
  }

  /* Close the service, the post handler takes care to allow the new defined structure to be access or not */
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}



