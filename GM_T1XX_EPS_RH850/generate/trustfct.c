/* file: C:/Hari/Work/SynergyProjects/T1xx_Synergy/BuildPrep/07.01.05_Work/Z_Work_1_8917_ShortTerm/GM_T1XX_EPS_RH850/generate/trustfct.c */
/* automatically generated by genRH850.exe, Version: 1.06 */
/* Configuration file: C:/Users/nz2654/AppData/Local/Temp/DaVinci/Cfg-1345187/Generation/Cfg_Gen-1484071352018-0/OsProxyFiles-1484072167553-0/Os_ActiveEcuC.arxml */
/* Generation time: Tue Jan 10 13:16:13 2017 */
/* Unlimited license CBD1400351 for Nxtr Automotive, Project License, EPS */
/* Implementation: RH850_P1M */
/* Version of general code: 9.01.06 */
#if defined USE_QUOTE_INCLUDES
 #include "vrm.h"
#else
 #include <vrm.h>
#endif

#define osdVrmGenMajRelNum 1
#define osdVrmGenMinRelNum 6
#if defined USE_QUOTE_INCLUDES
 #include "vrm.h"
#else
 #include <vrm.h>
#endif

#if defined USE_QUOTE_INCLUDES
 #include "Os.h"
#else
 #include <Os.h>
#endif

#pragma ghs section bss=".os_bss"
#pragma ghs section data=".os_data"
#pragma ghs section sbss=".os_sbss"
#pragma ghs section sdata=".os_sdata"
#pragma ghs section text=".os_text"
#pragma ghs section rodata=".os_rodata"
#pragma ghs section rosdata=".os_rosdata"

void Call_Adc0OutpInin(void)
{
   (void) CallTrustedFunction(osd_TFCT_Adc0OutpInin, (TrustedFunctionParameterRefType)0);
}

void Call_ApplXcpWrCmn(MTABYTEPTR os_arg_addr, vuint8 os_arg_size, const BYTEPTR os_arg_data)
{
   TrustedFunctionParameterType myargs;

   myargs.ApplXcpWrCmn_args.os_arg_addr = os_arg_addr;
   myargs.ApplXcpWrCmn_args.os_arg_size = os_arg_size;
   myargs.ApplXcpWrCmn_args.os_arg_data = os_arg_data;
   (void) CallTrustedFunction(osd_TFCT_ApplXcpWrCmn, &myargs);
}

uint8 Call_CritRegInitChk(void)
{
   TrustedFunctionParameterType myargs;

   (void) CallTrustedFunction(osd_TFCT_CritRegInitChk, &myargs);
   return myargs.CritRegInitChk_args.os_result;
}

uint8 Call_CritRegPerChk(void)
{
   TrustedFunctionParameterType myargs;

   (void) CallTrustedFunction(osd_TFCT_CritRegPerChk, &myargs);
   return myargs.CritRegPerChk_args.os_result;
}

void Call_DmaRegInin(void)
{
   (void) CallTrustedFunction(osd_TFCT_DmaRegInin, (TrustedFunctionParameterRefType)0);
}

void Call_DtsClnUp(void)
{
   (void) CallTrustedFunction(osd_TFCT_DtsClnUp, (TrustedFunctionParameterRefType)0);
}

void Call_DtsInin(uint32 os_arg_CrcHwIdxInReg, uint32 os_arg_CrcHwIdxOutReg)
{
   TrustedFunctionParameterType myargs;

   myargs.DtsInin_args.os_arg_CrcHwIdxInReg = os_arg_CrcHwIdxInReg;
   myargs.DtsInin_args.os_arg_CrcHwIdxOutReg = os_arg_CrcHwIdxOutReg;
   (void) CallTrustedFunction(osd_TFCT_DtsInin, &myargs);
}

void Call_Fls_MainFunction(void)
{
   (void) CallTrustedFunction(osd_TFCT_Fls_MainFunction, (TrustedFunctionParameterRefType)0);
}

void Call_GetResource(ResourceType os_arg_ResId)
{
   TrustedFunctionParameterType myargs;

   myargs.GetResource_args.os_arg_ResId = os_arg_ResId;
   (void) CallTrustedFunction(osd_TFCT_GetResource, &myargs);
}

void Call_IpgInin(void)
{
   (void) CallTrustedFunction(osd_TFCT_IpgInin, (TrustedFunctionParameterRefType)0);
}

void Call_NvM_MainFunction(void)
{
   (void) CallTrustedFunction(osd_TFCT_NvM_MainFunction, (TrustedFunctionParameterRefType)0);
}

void Call_NxtrWdgM_Init(void)
{
   (void) CallTrustedFunction(osd_TFCT_NxtrWdgM_Init, (TrustedFunctionParameterRefType)0);
}

void Call_ReleaseResource(ResourceType os_arg_ResId)
{
   TrustedFunctionParameterType myargs;

   myargs.ReleaseResource_args.os_arg_ResId = os_arg_ResId;
   (void) CallTrustedFunction(osd_TFCT_ReleaseResource, &myargs);
}

Std_ReturnType Call_Spi_AsyncTransmit(Spi_SequenceType os_arg_Sequence)
{
   TrustedFunctionParameterType myargs;

   myargs.Spi_AsyncTransmit_args.os_arg_Sequence = os_arg_Sequence;
   (void) CallTrustedFunction(osd_TFCT_Spi_AsyncTransmit, &myargs);
   return myargs.Spi_AsyncTransmit_args.os_result;
}

#ifndef OS_SUPPRESS_CALLEESTUB
/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_Adc0OutpInin(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionParams)   /* PRQA S 3199 */
   Adc0OutpInin();
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_ApplXcpWrCmn(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   ApplXcpWrCmn(((TrustedFunctionParameterType*)FunctionParams)->ApplXcpWrCmn_args.os_arg_addr,
                ((TrustedFunctionParameterType*)FunctionParams)->ApplXcpWrCmn_args.os_arg_size,
                ((TrustedFunctionParameterType*)FunctionParams)->ApplXcpWrCmn_args.os_arg_data);
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_CritRegInitChk(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   ((TrustedFunctionParameterType*)FunctionParams)->CritRegInitChk_args.os_result = CritRegInitChk();
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_CritRegPerChk(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   ((TrustedFunctionParameterType*)FunctionParams)->CritRegPerChk_args.os_result = CritRegPerChk();
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_DmaRegInin(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionParams)   /* PRQA S 3199 */
   DmaRegInin();
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_DtsClnUp(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionParams)   /* PRQA S 3199 */
   DtsClnUp();
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_DtsInin(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   DtsInin(((TrustedFunctionParameterType*)FunctionParams)->DtsInin_args.os_arg_CrcHwIdxInReg,
           ((TrustedFunctionParameterType*)FunctionParams)->DtsInin_args.os_arg_CrcHwIdxOutReg);
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_Fls_MainFunction(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionParams)   /* PRQA S 3199 */
   Fls_MainFunction();
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_GetResource(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   GetResource(((TrustedFunctionParameterType*)FunctionParams)->GetResource_args.os_arg_ResId);
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_IpgInin(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionParams)   /* PRQA S 3199 */
   IpgInin();
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_NvM_MainFunction(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionParams)   /* PRQA S 3199 */
   NvM_MainFunction();
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_NxtrWdgM_Init(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionParams)   /* PRQA S 3199 */
   NxtrWdgM_Init();
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_ReleaseResource(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   ReleaseResource(((TrustedFunctionParameterType*)FunctionParams)->ReleaseResource_args.os_arg_ResId);
}

/* MISRA RULE 8.10 VIOLATION: This function is only referenced directly in this
 * unit but via a function table also external. To avoid warnings from
 * some compilers it can't be static
 * MISRA RULE 16.7 VIOLATION: The pointer argument might be const, but
 * this prototype is required by the AUTOSAR specification.
 */
void TRUSTED_Spi_AsyncTransmit(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
   /* osdDummyRead might intentionally assign a value to an unused variable on
    * some platforms to avoid compiler warnings. This is no MISRA error. (3199) */
   osdDummyRead(FunctionIndex)   /* PRQA S 3199 */
   ((TrustedFunctionParameterType*)FunctionParams)->Spi_AsyncTransmit_args.os_result = Spi_AsyncTransmit(((TrustedFunctionParameterType*)FunctionParams)->Spi_AsyncTransmit_args.os_arg_Sequence);
}

#endif /* OS_SUPPRESS_CALLEESTUB */
#pragma ghs section bss=default
#pragma ghs section data=default
#pragma ghs section sbss=default
#pragma ghs section sdata=default
#pragma ghs section text=default
#pragma ghs section rodata=default
#pragma ghs section rosdata=default

